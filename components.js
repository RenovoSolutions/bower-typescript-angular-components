this["rl_components"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	__webpack_require__(2);
	__webpack_require__(4);
	__webpack_require__(6);
	__webpack_require__(13);
	var behaviors = __webpack_require__(14);
	exports.behaviors = behaviors;
	var components = __webpack_require__(17);
	exports.components = components;
	var services = __webpack_require__(121);
	exports.services = services;
	exports.moduleName = 'rl.ui';
	angular.module(exports.moduleName, [
	    'ui.bootstrap',
	    'ui.bootstrap-slider',
	    'ngSanitize',
	    behaviors.moduleName,
	    components.moduleName,
	    services.moduleName,
	]);


/***/ },
/* 1 */
/***/ function(module, exports) {

	(function() { module.exports = this["angular"]; }());

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(3);
	module.exports = 'ui.bootstrap';


/***/ },
/* 3 */
/***/ function(module, exports) {

	/*
	 * angular-ui-bootstrap
	 * http://angular-ui.github.io/bootstrap/
	
	 * Version: 0.13.4 - 2015-09-03
	 * License: MIT
	 */
	angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.bindHtml","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.dropdown","ui.bootstrap.modal","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.transition","ui.bootstrap.typeahead"]);
	angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html","template/accordion/accordion.html","template/alert/alert.html","template/carousel/carousel.html","template/carousel/slide.html","template/datepicker/datepicker.html","template/datepicker/day.html","template/datepicker/month.html","template/datepicker/popup.html","template/datepicker/year.html","template/modal/backdrop.html","template/modal/window.html","template/pagination/pager.html","template/pagination/pagination.html","template/tooltip/tooltip-html-popup.html","template/tooltip/tooltip-html-unsafe-popup.html","template/tooltip/tooltip-popup.html","template/tooltip/tooltip-template-popup.html","template/popover/popover-html.html","template/popover/popover-template.html","template/popover/popover.html","template/progressbar/bar.html","template/progressbar/progress.html","template/progressbar/progressbar.html","template/rating/rating.html","template/tabs/tab.html","template/tabs/tabset.html","template/timepicker/timepicker.html","template/typeahead/typeahead-match.html","template/typeahead/typeahead-popup.html"]);
	angular.module('ui.bootstrap.collapse', [])
	
	  .directive('collapse', ['$animate', function($animate) {
	    return {
	      link: function(scope, element, attrs) {
	        function expand() {
	          element.removeClass('collapse')
	            .addClass('collapsing')
	            .attr('aria-expanded', true)
	            .attr('aria-hidden', false);
	
	          $animate.addClass(element, 'in', {
	            to: { height: element[0].scrollHeight + 'px' }
	          }).then(expandDone);
	        }
	
	        function expandDone() {
	          element.removeClass('collapsing');
	          element.css({height: 'auto'});
	        }
	
	        function collapse() {
	          if (!element.hasClass('collapse') && !element.hasClass('in')) {
	            return collapseDone();
	          }
	
	          element
	            // IMPORTANT: The height must be set before adding "collapsing" class.
	            // Otherwise, the browser attempts to animate from height 0 (in
	            // collapsing class) to the given height here.
	            .css({height: element[0].scrollHeight + 'px'})
	            // initially all panel collapse have the collapse class, this removal
	            // prevents the animation from jumping to collapsed state
	            .removeClass('collapse')
	            .addClass('collapsing')
	            .attr('aria-expanded', false)
	            .attr('aria-hidden', true);
	
	          $animate.removeClass(element, 'in', {
	            to: {height: '0'}
	          }).then(collapseDone);
	        }
	
	        function collapseDone() {
	          element.css({height: '0'}); // Required so that collapse works when animation is disabled
	          element.removeClass('collapsing');
	          element.addClass('collapse');
	        }
	
	        scope.$watch(attrs.collapse, function(shouldCollapse) {
	          if (shouldCollapse) {
	            collapse();
	          } else {
	            expand();
	          }
	        });
	      }
	    };
	  }]);
	
	angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])
	
	.constant('accordionConfig', {
	  closeOthers: true
	})
	
	.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function($scope, $attrs, accordionConfig) {
	  // This array keeps track of the accordion groups
	  this.groups = [];
	
	  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
	  this.closeOthers = function(openGroup) {
	    var closeOthers = angular.isDefined($attrs.closeOthers) ?
	      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
	    if (closeOthers) {
	      angular.forEach(this.groups, function(group) {
	        if (group !== openGroup) {
	          group.isOpen = false;
	        }
	      });
	    }
	  };
	
	  // This is called from the accordion-group directive to add itself to the accordion
	  this.addGroup = function(groupScope) {
	    var that = this;
	    this.groups.push(groupScope);
	
	    groupScope.$on('$destroy', function(event) {
	      that.removeGroup(groupScope);
	    });
	  };
	
	  // This is called from the accordion-group directive when to remove itself
	  this.removeGroup = function(group) {
	    var index = this.groups.indexOf(group);
	    if (index !== -1) {
	      this.groups.splice(index, 1);
	    }
	  };
	
	}])
	
	// The accordion directive simply sets up the directive controller
	// and adds an accordion CSS class to itself element.
	.directive('accordion', function() {
	  return {
	    restrict: 'EA',
	    controller: 'AccordionController',
	    controllerAs: 'accordion',
	    transclude: true,
	    replace: false,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/accordion/accordion.html';
	    }
	  };
	})
	
	// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
	.directive('accordionGroup', function() {
	  return {
	    require: '^accordion',         // We need this directive to be inside an accordion
	    restrict: 'EA',
	    transclude: true,              // It transcludes the contents of the directive into the template
	    replace: true,                // The element containing the directive will be replaced with the template
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/accordion/accordion-group.html';
	    },
	    scope: {
	      heading: '@',               // Interpolate the heading attribute onto this scope
	      isOpen: '=?',
	      isDisabled: '=?'
	    },
	    controller: function() {
	      this.setHeading = function(element) {
	        this.heading = element;
	      };
	    },
	    link: function(scope, element, attrs, accordionCtrl) {
	      accordionCtrl.addGroup(scope);
	
	      scope.openClass = attrs.openClass || 'panel-open';
	      scope.panelClass = attrs.panelClass;
	      scope.$watch('isOpen', function(value) {
	        element.toggleClass(scope.openClass, value);
	        if (value) {
	          accordionCtrl.closeOthers(scope);
	        }
	      });
	
	      scope.toggleOpen = function($event) {
	        if (!scope.isDisabled) {
	          if (!$event || $event.which === 32) {
	            scope.isOpen = !scope.isOpen;
	          }
	        }
	      };
	    }
	  };
	})
	
	// Use accordion-heading below an accordion-group to provide a heading containing HTML
	// <accordion-group>
	//   <accordion-heading>Heading containing HTML - <img src="..."></accordion-heading>
	// </accordion-group>
	.directive('accordionHeading', function() {
	  return {
	    restrict: 'EA',
	    transclude: true,   // Grab the contents to be used as the heading
	    template: '',       // In effect remove this element!
	    replace: true,
	    require: '^accordionGroup',
	    link: function(scope, element, attr, accordionGroupCtrl, transclude) {
	      // Pass the heading to the accordion-group controller
	      // so that it can be transcluded into the right place in the template
	      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
	      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
	    }
	  };
	})
	
	// Use in the accordion-group template to indicate where you want the heading to be transcluded
	// You must provide the property on the accordion-group controller that will hold the transcluded element
	// <div class="accordion-group">
	//   <div class="accordion-heading" ><a ... accordion-transclude="heading">...</a></div>
	//   ...
	// </div>
	.directive('accordionTransclude', function() {
	  return {
	    require: '^accordionGroup',
	    link: function(scope, element, attr, controller) {
	      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {
	        if (heading) {
	          element.find('span').html('');
	          element.find('span').append(heading);
	        }
	      });
	    }
	  };
	})
	
	;
	
	angular.module('ui.bootstrap.alert', [])
	
	.controller('AlertController', ['$scope', '$attrs', function($scope, $attrs) {
	  $scope.closeable = !!$attrs.close;
	  this.close = $scope.close;
	}])
	
	.directive('alert', function() {
	  return {
	    controller: 'AlertController',
	    controllerAs: 'alert',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/alert/alert.html';
	    },
	    transclude: true,
	    replace: true,
	    scope: {
	      type: '@',
	      close: '&'
	    }
	  };
	})
	
	.directive('dismissOnTimeout', ['$timeout', function($timeout) {
	  return {
	    require: 'alert',
	    link: function(scope, element, attrs, alertCtrl) {
	      $timeout(function() {
	        alertCtrl.close();
	      }, parseInt(attrs.dismissOnTimeout, 10));
	    }
	  };
	}]);
	
	angular.module('ui.bootstrap.bindHtml', [])
	
	  .value('$bindHtmlUnsafeSuppressDeprecated', false)
	
	  .directive('bindHtmlUnsafe', ['$log', '$bindHtmlUnsafeSuppressDeprecated', function ($log, $bindHtmlUnsafeSuppressDeprecated) {
	    return function (scope, element, attr) {
	      if (!$bindHtmlUnsafeSuppressDeprecated) {
	        $log.warn('bindHtmlUnsafe is now deprecated. Use ngBindHtml instead');
	      }
	      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
	      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
	        element.html(value || '');
	      });
	    };
	  }]);
	angular.module('ui.bootstrap.buttons', [])
	
	.constant('buttonConfig', {
	  activeClass: 'active',
	  toggleEvent: 'click'
	})
	
	.controller('ButtonsController', ['buttonConfig', function(buttonConfig) {
	  this.activeClass = buttonConfig.activeClass || 'active';
	  this.toggleEvent = buttonConfig.toggleEvent || 'click';
	}])
	
	.directive('btnRadio', function() {
	  return {
	    require: ['btnRadio', 'ngModel'],
	    controller: 'ButtonsController',
	    controllerAs: 'buttons',
	    link: function(scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      element.find('input').css({display: 'none'});
	
	      //model -> UI
	      ngModelCtrl.$render = function() {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
	      };
	
	      //ui->model
	      element.bind(buttonsCtrl.toggleEvent, function() {
	        if (attrs.disabled) {
	          return;
	        }
	
	        var isActive = element.hasClass(buttonsCtrl.activeClass);
	
	        if (!isActive || angular.isDefined(attrs.uncheckable)) {
	          scope.$apply(function() {
	            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
	            ngModelCtrl.$render();
	          });
	        }
	      });
	    }
	  };
	})
	
	.directive('btnCheckbox', ['$document', function($document) {
	  return {
	    require: ['btnCheckbox', 'ngModel'],
	    controller: 'ButtonsController',
	    controllerAs: 'button',
	    link: function(scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      element.find('input').css({display: 'none'});
	
	      function getTrueValue() {
	        return getCheckboxValue(attrs.btnCheckboxTrue, true);
	      }
	
	      function getFalseValue() {
	        return getCheckboxValue(attrs.btnCheckboxFalse, false);
	      }
	
	      function getCheckboxValue(attributeValue, defaultValue) {
	        var val = scope.$eval(attributeValue);
	        return angular.isDefined(val) ? val : defaultValue;
	      }
	
	      //model -> UI
	      ngModelCtrl.$render = function() {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
	      };
	
	      //ui->model
	      element.bind(buttonsCtrl.toggleEvent, function() {
	        if (attrs.disabled) {
	          return;
	        }
	
	        scope.$apply(function() {
	          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
	          ngModelCtrl.$render();
	        });
	      });
	
	      //accessibility
	      element.on('keypress', function(e) {
	        if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {
	          return;
	        }
	
	        scope.$apply(function() {
	          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
	          ngModelCtrl.$render();
	        });
	      });
	    }
	  };
	}]);
	
	/**
	* @ngdoc overview
	* @name ui.bootstrap.carousel
	*
	* @description
	* AngularJS version of an image carousel.
	*
	*/
	angular.module('ui.bootstrap.carousel', [])
	.controller('CarouselController', ['$scope', '$element', '$interval', '$animate', function ($scope, $element, $interval, $animate) {
	  var self = this,
	    slides = self.slides = $scope.slides = [],
	    NEW_ANIMATE = angular.version.minor >= 4,
	    NO_TRANSITION = 'uib-noTransition',
	    SLIDE_DIRECTION = 'uib-slideDirection',
	    currentIndex = -1,
	    currentInterval, isPlaying;
	  self.currentSlide = null;
	
	  var destroyed = false;
	  /* direction: "prev" or "next" */
	  self.select = $scope.select = function(nextSlide, direction) {
	    var nextIndex = $scope.indexOfSlide(nextSlide);
	    //Decide direction if it's not given
	    if (direction === undefined) {
	      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
	    }
	    //Prevent this user-triggered transition from occurring if there is already one in progress
	    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {
	      goNext(nextSlide, nextIndex, direction);
	    }
	  };
	
	  function goNext(slide, index, direction) {
	    // Scope has been destroyed, stop here.
	    if (destroyed) { return; }
	
	    angular.extend(slide, {direction: direction, active: true});
	    angular.extend(self.currentSlide || {}, {direction: direction, active: false});
	    if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition &&
	      slide.$element && self.slides.length > 1) {
	      slide.$element.data(SLIDE_DIRECTION, slide.direction);
	      if (self.currentSlide && self.currentSlide.$element) {
	        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);
	      }
	
	      $scope.$currentTransition = true;
	      if (NEW_ANIMATE) {
	        $animate.on('addClass', slide.$element, function (element, phase) {
	          if (phase === 'close') {
	            $scope.$currentTransition = null;
	            $animate.off('addClass', element);
	          }
	        });
	      } else {
	        slide.$element.one('$animate:close', function closeFn() {
	          $scope.$currentTransition = null;
	        });
	      }
	    }
	
	    self.currentSlide = slide;
	    currentIndex = index;
	
	    //every time you change slides, reset the timer
	    restartTimer();
	  }
	
	  $scope.$on('$destroy', function () {
	    destroyed = true;
	  });
	
	  function getSlideByIndex(index) {
	    if (angular.isUndefined(slides[index].index)) {
	      return slides[index];
	    }
	    var i, len = slides.length;
	    for (i = 0; i < slides.length; ++i) {
	      if (slides[i].index == index) {
	        return slides[i];
	      }
	    }
	  }
	
	  self.getCurrentIndex = function() {
	    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {
	      return +self.currentSlide.index;
	    }
	    return currentIndex;
	  };
	
	  /* Allow outside people to call indexOf on slides array */
	  $scope.indexOfSlide = function(slide) {
	    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
	  };
	
	  $scope.next = function() {
	    var newIndex = (self.getCurrentIndex() + 1) % slides.length;
	
	    if (newIndex === 0 && $scope.noWrap()) {
	      $scope.pause();
	      return;
	    }
	
	    return self.select(getSlideByIndex(newIndex), 'next');
	  };
	
	  $scope.prev = function() {
	    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
	
	    if ($scope.noWrap() && newIndex === slides.length - 1){
	      $scope.pause();
	      return;
	    }
	
	    return self.select(getSlideByIndex(newIndex), 'prev');
	  };
	
	  $scope.isActive = function(slide) {
	     return self.currentSlide === slide;
	  };
	
	  $scope.$watch('interval', restartTimer);
	  $scope.$on('$destroy', resetTimer);
	
	  function restartTimer() {
	    resetTimer();
	    var interval = +$scope.interval;
	    if (!isNaN(interval) && interval > 0) {
	      currentInterval = $interval(timerFn, interval);
	    }
	  }
	
	  function resetTimer() {
	    if (currentInterval) {
	      $interval.cancel(currentInterval);
	      currentInterval = null;
	    }
	  }
	
	  function timerFn() {
	    var interval = +$scope.interval;
	    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
	      $scope.next();
	    } else {
	      $scope.pause();
	    }
	  }
	
	  $scope.play = function() {
	    if (!isPlaying) {
	      isPlaying = true;
	      restartTimer();
	    }
	  };
	  $scope.pause = function() {
	    if (!$scope.noPause) {
	      isPlaying = false;
	      resetTimer();
	    }
	  };
	
	  self.addSlide = function(slide, element) {
	    slide.$element = element;
	    slides.push(slide);
	    //if this is the first slide or the slide is set to active, select it
	    if(slides.length === 1 || slide.active) {
	      self.select(slides[slides.length-1]);
	      if (slides.length == 1) {
	        $scope.play();
	      }
	    } else {
	      slide.active = false;
	    }
	  };
	
	  self.removeSlide = function(slide) {
	    if (angular.isDefined(slide.index)) {
	      slides.sort(function(a, b) {
	        return +a.index > +b.index;
	      });
	    }
	    //get the index of the slide inside the carousel
	    var index = slides.indexOf(slide);
	    slides.splice(index, 1);
	    if (slides.length > 0 && slide.active) {
	      if (index >= slides.length) {
	        self.select(slides[index-1]);
	      } else {
	        self.select(slides[index]);
	      }
	    } else if (currentIndex > index) {
	      currentIndex--;
	    }
	    
	    //clean the currentSlide when no more slide
	    if (slides.length === 0) {
	      self.currentSlide = null;
	    }
	  };
	
	  $scope.$watch('noTransition', function(noTransition) {
	    $element.data(NO_TRANSITION, noTransition);
	  });
	
	}])
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.carousel.directive:carousel
	 * @restrict EA
	 *
	 * @description
	 * Carousel is the outer container for a set of image 'slides' to showcase.
	 *
	 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
	 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
	 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <carousel>
	      <slide>
	        <img src="http://placekitten.com/150/150" style="margin:auto;">
	        <div class="carousel-caption">
	          <p>Beautiful!</p>
	        </div>
	      </slide>
	      <slide>
	        <img src="http://placekitten.com/100/150" style="margin:auto;">
	        <div class="carousel-caption">
	          <p>D'aww!</p>
	        </div>
	      </slide>
	    </carousel>
	  </file>
	  <file name="demo.css">
	    .carousel-indicators {
	      top: auto;
	      bottom: 15px;
	    }
	  </file>
	</example>
	 */
	.directive('carousel', [function() {
	  return {
	    restrict: 'EA',
	    transclude: true,
	    replace: true,
	    controller: 'CarouselController',
	    controllerAs: 'carousel',
	    require: 'carousel',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/carousel/carousel.html';
	    },
	    scope: {
	      interval: '=',
	      noTransition: '=',
	      noPause: '=',
	      noWrap: '&'
	    }
	  };
	}])
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.carousel.directive:slide
	 * @restrict EA
	 *
	 * @description
	 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
	 *
	 * @param {boolean=} active Model binding, whether or not this slide is currently active.
	 * @param {number=} index The index of the slide. The slides will be sorted by this parameter.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	<div ng-controller="CarouselDemoCtrl">
	  <carousel>
	    <slide ng-repeat="slide in slides" active="slide.active" index="$index">
	      <img ng-src="{{slide.image}}" style="margin:auto;">
	      <div class="carousel-caption">
	        <h4>Slide {{$index}}</h4>
	        <p>{{slide.text}}</p>
	      </div>
	    </slide>
	  </carousel>
	  Interval, in milliseconds: <input type="number" ng-model="myInterval">
	  <br />Enter a negative number to stop the interval.
	</div>
	  </file>
	  <file name="script.js">
	function CarouselDemoCtrl($scope) {
	  $scope.myInterval = 5000;
	}
	  </file>
	  <file name="demo.css">
	    .carousel-indicators {
	      top: auto;
	      bottom: 15px;
	    }
	  </file>
	</example>
	*/
	
	.directive('slide', function() {
	  return {
	    require: '^carousel',
	    restrict: 'EA',
	    transclude: true,
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/carousel/slide.html';
	    },
	    scope: {
	      active: '=?',
	      actual: '=?',
	      index: '=?'
	    },
	    link: function (scope, element, attrs, carouselCtrl) {
	      carouselCtrl.addSlide(scope, element);
	      //when the scope is destroyed then remove the slide from the current slides array
	      scope.$on('$destroy', function() {
	        carouselCtrl.removeSlide(scope);
	      });
	
	      scope.$watch('active', function(active) {
	        if (active) {
	          carouselCtrl.select(scope);
	        }
	      });
	    }
	  };
	})
	
	.animation('.item', [
	         '$injector', '$animate',
	function ($injector, $animate) {
	  var NO_TRANSITION = 'uib-noTransition',
	    SLIDE_DIRECTION = 'uib-slideDirection',
	    $animateCss = null;
	
	  if ($injector.has('$animateCss')) {
	    $animateCss = $injector.get('$animateCss');
	  }
	
	  function removeClass(element, className, callback) {
	    element.removeClass(className);
	    if (callback) {
	      callback();
	    }
	  }
	
	  return {
	    beforeAddClass: function (element, className, done) {
	      // Due to transclusion, noTransition property is on parent's scope
	      if (className == 'active' && element.parent() &&
	          !element.parent().data(NO_TRANSITION)) {
	        var stopped = false;
	        var direction = element.data(SLIDE_DIRECTION);
	        var directionClass = direction == 'next' ? 'left' : 'right';
	        var removeClassFn = removeClass.bind(this, element,
	          directionClass + ' ' + direction, done);
	        element.addClass(direction);
	
	        if ($animateCss) {
	          $animateCss(element, {addClass: directionClass})
	            .start()
	            .done(removeClassFn);
	        } else {
	          $animate.addClass(element, directionClass).then(function () {
	            if (!stopped) {
	              removeClassFn();
	            }
	            done();
	          });
	        }
	
	        return function () {
	          stopped = true;
	        };
	      }
	      done();
	    },
	    beforeRemoveClass: function (element, className, done) {
	      // Due to transclusion, noTransition property is on parent's scope
	      if (className === 'active' && element.parent() &&
	          !element.parent().data(NO_TRANSITION)) {
	        var stopped = false;
	        var direction = element.data(SLIDE_DIRECTION);
	        var directionClass = direction == 'next' ? 'left' : 'right';
	        var removeClassFn = removeClass.bind(this, element, directionClass, done);
	
	        if ($animateCss) {
	          $animateCss(element, {addClass: directionClass})
	            .start()
	            .done(removeClassFn);
	        } else {
	          $animate.addClass(element, directionClass).then(function () {
	            if (!stopped) {
	              removeClassFn();
	            }
	            done();
	          });
	        }
	        return function () {
	          stopped = true;
	        };
	      }
	      done();
	    }
	  };
	
	}])
	
	
	;
	
	angular.module('ui.bootstrap.dateparser', [])
	
	.service('dateParser', ['$log', '$locale', 'orderByFilter', function($log, $locale, orderByFilter) {
	  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
	  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	
	  this.parsers = {};
	
	  var formatCodeToRegex = {
	    'yyyy': {
	      regex: '\\d{4}',
	      apply: function(value) { this.year = +value; }
	    },
	    'yy': {
	      regex: '\\d{2}',
	      apply: function(value) { this.year = +value + 2000; }
	    },
	    'y': {
	      regex: '\\d{1,4}',
	      apply: function(value) { this.year = +value; }
	    },
	    'MMMM': {
	      regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
	      apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }
	    },
	    'MMM': {
	      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
	      apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }
	    },
	    'MM': {
	      regex: '0[1-9]|1[0-2]',
	      apply: function(value) { this.month = value - 1; }
	    },
	    'M': {
	      regex: '[1-9]|1[0-2]',
	      apply: function(value) { this.month = value - 1; }
	    },
	    'dd': {
	      regex: '[0-2][0-9]{1}|3[0-1]{1}',
	      apply: function(value) { this.date = +value; }
	    },
	    'd': {
	      regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
	      apply: function(value) { this.date = +value; }
	    },
	    'EEEE': {
	      regex: $locale.DATETIME_FORMATS.DAY.join('|')
	    },
	    'EEE': {
	      regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')
	    },
	    'HH': {
	      regex: '(?:0|1)[0-9]|2[0-3]',
	      apply: function(value) { this.hours = +value; }
	    },
	    'hh': {
	      regex: '0[0-9]|1[0-2]',
	      apply: function(value) { this.hours = +value; }
	    },
	    'H': {
	      regex: '1?[0-9]|2[0-3]',
	      apply: function(value) { this.hours = +value; }
	    },
	    'h': {
	      regex: '[0-9]|1[0-2]',
	      apply: function(value) { this.hours = +value; }
	    },
	    'mm': {
	      regex: '[0-5][0-9]',
	      apply: function(value) { this.minutes = +value; }
	    },
	    'm': {
	      regex: '[0-9]|[1-5][0-9]',
	      apply: function(value) { this.minutes = +value; }
	    },
	    'sss': {
	      regex: '[0-9][0-9][0-9]',
	      apply: function(value) { this.milliseconds = +value; }
	    },
	    'ss': {
	      regex: '[0-5][0-9]',
	      apply: function(value) { this.seconds = +value; }
	    },
	    's': {
	      regex: '[0-9]|[1-5][0-9]',
	      apply: function(value) { this.seconds = +value; }
	    },
	    'a': {
	      regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
	      apply: function(value) {
	        if (this.hours === 12) {
	          this.hours = 0;
	        }
	
	        if (value === 'PM') {
	          this.hours += 12;
	        }
	      }
	    }
	  };
	
	  function createParser(format) {
	    var map = [], regex = format.split('');
	
	    angular.forEach(formatCodeToRegex, function(data, code) {
	      var index = format.indexOf(code);
	
	      if (index > -1) {
	        format = format.split('');
	
	        regex[index] = '(' + data.regex + ')';
	        format[index] = '$'; // Custom symbol to define consumed part of format
	        for (var i = index + 1, n = index + code.length; i < n; i++) {
	          regex[i] = '';
	          format[i] = '$';
	        }
	        format = format.join('');
	
	        map.push({ index: index, apply: data.apply });
	      }
	    });
	
	    return {
	      regex: new RegExp('^' + regex.join('') + '$'),
	      map: orderByFilter(map, 'index')
	    };
	  }
	
	  this.parse = function(input, format, baseDate) {
	    if (!angular.isString(input) || !format) {
	      return input;
	    }
	
	    format = $locale.DATETIME_FORMATS[format] || format;
	    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');
	
	    if (!this.parsers[format]) {
	      this.parsers[format] = createParser(format);
	    }
	
	    var parser = this.parsers[format],
	        regex = parser.regex,
	        map = parser.map,
	        results = input.match(regex);
	
	    if (results && results.length) {
	      var fields, dt;
	      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
	        fields = {
	          year: baseDate.getFullYear(),
	          month: baseDate.getMonth(),
	          date: baseDate.getDate(),
	          hours: baseDate.getHours(),
	          minutes: baseDate.getMinutes(),
	          seconds: baseDate.getSeconds(),
	          milliseconds: baseDate.getMilliseconds()
	        };
	      } else {
	        if (baseDate) {
	          $log.warn('dateparser:', 'baseDate is not a valid date');
	        }
	        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
	      }
	
	      for (var i = 1, n = results.length; i < n; i++) {
	        var mapper = map[i-1];
	        if (mapper.apply) {
	          mapper.apply.call(fields, results[i]);
	        }
	      }
	
	      if (isValid(fields.year, fields.month, fields.date)) {
	        dt = new Date(fields.year, fields.month, fields.date,
	          fields.hours, fields.minutes, fields.seconds,
	          fields.milliseconds || 0);
	      }
	
	      return dt;
	    }
	  };
	
	  // Check if date is valid for specific month (and year for February).
	  // Month: 0 = Jan, 1 = Feb, etc
	  function isValid(year, month, date) {
	    if (date < 1) {
	      return false;
	    }
	
	    if (month === 1 && date > 28) {
	      return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
	    }
	
	    if (month === 3 || month === 5 || month === 8 || month === 10) {
	      return date < 31;
	    }
	
	    return true;
	  }
	}]);
	
	angular.module('ui.bootstrap.position', [])
	
	/**
	 * A set of utility methods that can be use to retrieve position of DOM elements.
	 * It is meant to be used where we need to absolute-position DOM elements in
	 * relation to other, existing elements (this is the case for tooltips, popovers,
	 * typeahead suggestions etc.).
	 */
	  .factory('$position', ['$document', '$window', function($document, $window) {
	    function getStyle(el, cssprop) {
	      if (el.currentStyle) { //IE
	        return el.currentStyle[cssprop];
	      } else if ($window.getComputedStyle) {
	        return $window.getComputedStyle(el)[cssprop];
	      }
	      // finally try and get inline style
	      return el.style[cssprop];
	    }
	
	    /**
	     * Checks if a given element is statically positioned
	     * @param element - raw DOM element
	     */
	    function isStaticPositioned(element) {
	      return (getStyle(element, 'position') || 'static' ) === 'static';
	    }
	
	    /**
	     * returns the closest, non-statically positioned parentOffset of a given element
	     * @param element
	     */
	    var parentOffsetEl = function(element) {
	      var docDomEl = $document[0];
	      var offsetParent = element.offsetParent || docDomEl;
	      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {
	        offsetParent = offsetParent.offsetParent;
	      }
	      return offsetParent || docDomEl;
	    };
	
	    return {
	      /**
	       * Provides read-only equivalent of jQuery's position function:
	       * http://api.jquery.com/position/
	       */
	      position: function(element) {
	        var elBCR = this.offset(element);
	        var offsetParentBCR = { top: 0, left: 0 };
	        var offsetParentEl = parentOffsetEl(element[0]);
	        if (offsetParentEl != $document[0]) {
	          offsetParentBCR = this.offset(angular.element(offsetParentEl));
	          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
	          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
	        }
	
	        var boundingClientRect = element[0].getBoundingClientRect();
	        return {
	          width: boundingClientRect.width || element.prop('offsetWidth'),
	          height: boundingClientRect.height || element.prop('offsetHeight'),
	          top: elBCR.top - offsetParentBCR.top,
	          left: elBCR.left - offsetParentBCR.left
	        };
	      },
	
	      /**
	       * Provides read-only equivalent of jQuery's offset function:
	       * http://api.jquery.com/offset/
	       */
	      offset: function(element) {
	        var boundingClientRect = element[0].getBoundingClientRect();
	        return {
	          width: boundingClientRect.width || element.prop('offsetWidth'),
	          height: boundingClientRect.height || element.prop('offsetHeight'),
	          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
	          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
	        };
	      },
	
	      /**
	       * Provides coordinates for the targetEl in relation to hostEl
	       */
	      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
	        var positionStrParts = positionStr.split('-');
	        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';
	
	        var hostElPos,
	          targetElWidth,
	          targetElHeight,
	          targetElPos;
	
	        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);
	
	        targetElWidth = targetEl.prop('offsetWidth');
	        targetElHeight = targetEl.prop('offsetHeight');
	
	        var shiftWidth = {
	          center: function() {
	            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
	          },
	          left: function() {
	            return hostElPos.left;
	          },
	          right: function() {
	            return hostElPos.left + hostElPos.width;
	          }
	        };
	
	        var shiftHeight = {
	          center: function() {
	            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
	          },
	          top: function() {
	            return hostElPos.top;
	          },
	          bottom: function() {
	            return hostElPos.top + hostElPos.height;
	          }
	        };
	
	        switch (pos0) {
	          case 'right':
	            targetElPos = {
	              top: shiftHeight[pos1](),
	              left: shiftWidth[pos0]()
	            };
	            break;
	          case 'left':
	            targetElPos = {
	              top: shiftHeight[pos1](),
	              left: hostElPos.left - targetElWidth
	            };
	            break;
	          case 'bottom':
	            targetElPos = {
	              top: shiftHeight[pos0](),
	              left: shiftWidth[pos1]()
	            };
	            break;
	          default:
	            targetElPos = {
	              top: hostElPos.top - targetElHeight,
	              left: shiftWidth[pos1]()
	            };
	            break;
	        }
	
	        return targetElPos;
	      }
	    };
	  }]);
	
	angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])
	
	.value('$datepickerSuppressError', false)
	
	.constant('datepickerConfig', {
	  formatDay: 'dd',
	  formatMonth: 'MMMM',
	  formatYear: 'yyyy',
	  formatDayHeader: 'EEE',
	  formatDayTitle: 'MMMM yyyy',
	  formatMonthTitle: 'yyyy',
	  datepickerMode: 'day',
	  minMode: 'day',
	  maxMode: 'year',
	  showWeeks: true,
	  startingDay: 0,
	  yearRange: 20,
	  minDate: null,
	  maxDate: null,
	  shortcutPropagation: false
	})
	
	.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'datepickerConfig', '$datepickerSuppressError', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {
	  var self = this,
	      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;
	
	  // Modes chain
	  this.modes = ['day', 'month', 'year'];
	
	  // Configuration attributes
	  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',
	                   'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {
	    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
	  });
	
	  // Watchable date attributes
	  angular.forEach(['minDate', 'maxDate'], function(key) {
	    if ($attrs[key]) {
	      $scope.$parent.$watch($parse($attrs[key]), function(value) {
	        self[key] = value ? new Date(value) : null;
	        self.refreshView();
	      });
	    } else {
	      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
	    }
	  });
	
	  angular.forEach(['minMode', 'maxMode'], function(key) {
	    if ($attrs[key]) {
	      $scope.$parent.$watch($parse($attrs[key]), function(value) {
	        self[key] = angular.isDefined(value) ? value : $attrs[key];
	        $scope[key] = self[key];
	        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {
	          $scope.datepickerMode = self[key];
	        }
	      });
	    } else {
	      self[key] = datepickerConfig[key] || null;
	      $scope[key] = self[key];
	    }
	  });
	
	  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
	  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
	
	  if (angular.isDefined($attrs.initDate)) {
	    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
	    $scope.$parent.$watch($attrs.initDate, function(initDate) {
	      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
	        self.activeDate = initDate;
	        self.refreshView();
	      }
	    });
	  } else {
	    this.activeDate = new Date();
	  }
	
	  $scope.isActive = function(dateObject) {
	    if (self.compare(dateObject.date, self.activeDate) === 0) {
	      $scope.activeDateId = dateObject.uid;
	      return true;
	    }
	    return false;
	  };
	
	  this.init = function(ngModelCtrl_) {
	    ngModelCtrl = ngModelCtrl_;
	
	    ngModelCtrl.$render = function() {
	      self.render();
	    };
	  };
	
	  this.render = function() {
	    if (ngModelCtrl.$viewValue) {
	      var date = new Date(ngModelCtrl.$viewValue),
	          isValid = !isNaN(date);
	
	      if (isValid) {
	        this.activeDate = date;
	      } else if (!$datepickerSuppressError) {
	        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	      }
	    }
	    this.refreshView();
	  };
	
	  this.refreshView = function() {
	    if (this.element) {
	      this._refreshView();
	
	      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));
	    }
	  };
	
	  this.createDateObject = function(date, format) {
	    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	    return {
	      date: date,
	      label: dateFilter(date, format),
	      selected: model && this.compare(date, model) === 0,
	      disabled: this.isDisabled(date),
	      current: this.compare(date, new Date()) === 0,
	      customClass: this.customClass(date)
	    };
	  };
	
	  this.isDisabled = function(date) {
	    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));
	  };
	
	  this.customClass = function(date) {
	    return $scope.customClass({date: date, mode: $scope.datepickerMode});
	  };
	
	  // Split array into smaller arrays
	  this.split = function(arr, size) {
	    var arrays = [];
	    while (arr.length > 0) {
	      arrays.push(arr.splice(0, size));
	    }
	    return arrays;
	  };
	
	  // Fix a hard-reprodusible bug with timezones
	  // The bug depends on OS, browser, current timezone and current date
	  // i.e.
	  // var date = new Date(2014, 0, 1);
	  // console.log(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours());
	  // can result in "2013 11 31 23" because of the bug.
	  this.fixTimeZone = function(date) {
	    var hours = date.getHours();
	    date.setHours(hours === 23 ? hours + 2 : 0);
	  };
	
	  $scope.select = function(date) {
	    if ($scope.datepickerMode === self.minMode) {
	      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
	      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	      ngModelCtrl.$setViewValue(dt);
	      ngModelCtrl.$render();
	    } else {
	      self.activeDate = date;
	      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
	    }
	  };
	
	  $scope.move = function(direction) {
	    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
	        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
	    self.activeDate.setFullYear(year, month, 1);
	    self.refreshView();
	  };
	
	  $scope.toggleMode = function(direction) {
	    direction = direction || 1;
	
	    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
	      return;
	    }
	
	    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
	  };
	
	  // Key event mapper
	  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };
	
	  var focusElement = function() {
	    self.element[0].focus();
	  };
	
	  // Listen for focus requests from popup directive
	  $scope.$on('datepicker.focus', focusElement);
	
	  $scope.keydown = function(evt) {
	    var key = $scope.keys[evt.which];
	
	    if (!key || evt.shiftKey || evt.altKey) {
	      return;
	    }
	
	    evt.preventDefault();
	    if (!self.shortcutPropagation) {
	      evt.stopPropagation();
	    }
	
	    if (key === 'enter' || key === 'space') {
	      if (self.isDisabled(self.activeDate)) {
	        return; // do nothing
	      }
	      $scope.select(self.activeDate);
	      focusElement();
	    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
	      $scope.toggleMode(key === 'up' ? 1 : -1);
	      focusElement();
	    } else {
	      self.handleKeyDown(key, evt);
	      self.refreshView();
	    }
	  };
	}])
	
	.directive('datepicker', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/datepicker/datepicker.html';
	    },
	    scope: {
	      datepickerMode: '=?',
	      dateDisabled: '&',
	      customClass: '&',
	      shortcutPropagation: '&?'
	    },
	    require: ['datepicker', '^ngModel'],
	    controller: 'DatepickerController',
	    controllerAs: 'datepicker',
	    link: function(scope, element, attrs, ctrls) {
	      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      datepickerCtrl.init(ngModelCtrl);
	    }
	  };
	})
	
	.directive('daypicker', ['dateFilter', function(dateFilter) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/datepicker/day.html',
	    require: '^datepicker',
	    link: function(scope, element, attrs, ctrl) {
	      scope.showWeeks = ctrl.showWeeks;
	
	      ctrl.step = { months: 1 };
	      ctrl.element = element;
	
	      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	      function getDaysInMonth(year, month) {
	        return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];
	      }
	
	      function getDates(startDate, n) {
	        var dates = new Array(n), current = new Date(startDate), i = 0, date;
	        while (i < n) {
	          date = new Date(current);
	          ctrl.fixTimeZone(date);
	          dates[i++] = date;
	          current.setDate(current.getDate() + 1);
	        }
	        return dates;
	      }
	
	      ctrl._refreshView = function() {
	        var year = ctrl.activeDate.getFullYear(),
	          month = ctrl.activeDate.getMonth(),
	          firstDayOfMonth = new Date(year, month, 1),
	          difference = ctrl.startingDay - firstDayOfMonth.getDay(),
	          numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,
	          firstDate = new Date(firstDayOfMonth);
	
	        if (numDisplayedFromPreviousMonth > 0) {
	          firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
	        }
	
	        // 42 is the number of days on a six-month calendar
	        var days = getDates(firstDate, 42);
	        for (var i = 0; i < 42; i ++) {
	          days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
	            secondary: days[i].getMonth() !== month,
	            uid: scope.uniqueId + '-' + i
	          });
	        }
	
	        scope.labels = new Array(7);
	        for (var j = 0; j < 7; j++) {
	          scope.labels[j] = {
	            abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
	            full: dateFilter(days[j].date, 'EEEE')
	          };
	        }
	
	        scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);
	        scope.rows = ctrl.split(days, 7);
	
	        if (scope.showWeeks) {
	          scope.weekNumbers = [];
	          var thursdayIndex = (4 + 7 - ctrl.startingDay) % 7,
	              numWeeks = scope.rows.length;
	          for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
	            scope.weekNumbers.push(
	              getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
	          }
	        }
	      };
	
	      ctrl.compare = function(date1, date2) {
	        return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
	      };
	
	      function getISO8601WeekNumber(date) {
	        var checkDate = new Date(date);
	        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
	        var time = checkDate.getTime();
	        checkDate.setMonth(0); // Compare with Jan 1
	        checkDate.setDate(1);
	        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	      }
	
	      ctrl.handleKeyDown = function(key, evt) {
	        var date = ctrl.activeDate.getDate();
	
	        if (key === 'left') {
	          date = date - 1;   // up
	        } else if (key === 'up') {
	          date = date - 7;   // down
	        } else if (key === 'right') {
	          date = date + 1;   // down
	        } else if (key === 'down') {
	          date = date + 7;
	        } else if (key === 'pageup' || key === 'pagedown') {
	          var month = ctrl.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
	          ctrl.activeDate.setMonth(month, 1);
	          date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);
	        } else if (key === 'home') {
	          date = 1;
	        } else if (key === 'end') {
	          date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());
	        }
	        ctrl.activeDate.setDate(date);
	      };
	
	      ctrl.refreshView();
	    }
	  };
	}])
	
	.directive('monthpicker', ['dateFilter', function(dateFilter) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/datepicker/month.html',
	    require: '^datepicker',
	    link: function(scope, element, attrs, ctrl) {
	      ctrl.step = { years: 1 };
	      ctrl.element = element;
	
	      ctrl._refreshView = function() {
	        var months = new Array(12),
	            year = ctrl.activeDate.getFullYear(),
	            date;
	
	        for (var i = 0; i < 12; i++) {
	          date = new Date(year, i, 1);
	          ctrl.fixTimeZone(date);
	          months[i] = angular.extend(ctrl.createDateObject(date, ctrl.formatMonth), {
	            uid: scope.uniqueId + '-' + i
	          });
	        }
	
	        scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);
	        scope.rows = ctrl.split(months, 3);
	      };
	
	      ctrl.compare = function(date1, date2) {
	        return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
	      };
	
	      ctrl.handleKeyDown = function(key, evt) {
	        var date = ctrl.activeDate.getMonth();
	
	        if (key === 'left') {
	          date = date - 1;   // up
	        } else if (key === 'up') {
	          date = date - 3;   // down
	        } else if (key === 'right') {
	          date = date + 1;   // down
	        } else if (key === 'down') {
	          date = date + 3;
	        } else if (key === 'pageup' || key === 'pagedown') {
	          var year = ctrl.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
	          ctrl.activeDate.setFullYear(year);
	        } else if (key === 'home') {
	          date = 0;
	        } else if (key === 'end') {
	          date = 11;
	        }
	        ctrl.activeDate.setMonth(date);
	      };
	
	      ctrl.refreshView();
	    }
	  };
	}])
	
	.directive('yearpicker', ['dateFilter', function(dateFilter) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/datepicker/year.html',
	    require: '^datepicker',
	    link: function(scope, element, attrs, ctrl) {
	      var range = ctrl.yearRange;
	
	      ctrl.step = { years: range };
	      ctrl.element = element;
	
	      function getStartingYear( year ) {
	        return parseInt((year - 1) / range, 10) * range + 1;
	      }
	
	      ctrl._refreshView = function() {
	        var years = new Array(range), date;
	
	        for (var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++) {
	          date = new Date(start + i, 0, 1);
	          ctrl.fixTimeZone(date);
	          years[i] = angular.extend(ctrl.createDateObject(date, ctrl.formatYear), {
	            uid: scope.uniqueId + '-' + i
	          });
	        }
	
	        scope.title = [years[0].label, years[range - 1].label].join(' - ');
	        scope.rows = ctrl.split(years, 5);
	      };
	
	      ctrl.compare = function(date1, date2) {
	        return date1.getFullYear() - date2.getFullYear();
	      };
	
	      ctrl.handleKeyDown = function(key, evt) {
	        var date = ctrl.activeDate.getFullYear();
	
	        if (key === 'left') {
	          date = date - 1;   // up
	        } else if (key === 'up') {
	          date = date - 5;   // down
	        } else if (key === 'right') {
	          date = date + 1;   // down
	        } else if (key === 'down') {
	          date = date + 5;
	        } else if (key === 'pageup' || key === 'pagedown') {
	          date += (key === 'pageup' ? - 1 : 1) * ctrl.step.years;
	        } else if (key === 'home') {
	          date = getStartingYear(ctrl.activeDate.getFullYear());
	        } else if (key === 'end') {
	          date = getStartingYear(ctrl.activeDate.getFullYear()) + range - 1;
	        }
	        ctrl.activeDate.setFullYear(date);
	      };
	
	      ctrl.refreshView();
	    }
	  };
	}])
	
	.constant('datepickerPopupConfig', {
	  datepickerPopup: 'yyyy-MM-dd',
	  datepickerPopupTemplateUrl: 'template/datepicker/popup.html',
	  datepickerTemplateUrl: 'template/datepicker/datepicker.html',
	  html5Types: {
	    date: 'yyyy-MM-dd',
	    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
	    'month': 'yyyy-MM'
	  },
	  currentText: 'Today',
	  clearText: 'Clear',
	  closeText: 'Done',
	  closeOnDateSelection: true,
	  appendToBody: false,
	  showButtonBar: true,
	  onOpenFocus: true
	})
	
	.directive('datepickerPopup', ['$compile', '$parse', '$document', '$rootScope', '$position', 'dateFilter', 'dateParser', 'datepickerPopupConfig', '$timeout',
	function($compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {
	  return {
	    restrict: 'EA',
	    require: 'ngModel',
	    scope: {
	      isOpen: '=?',
	      currentText: '@',
	      clearText: '@',
	      closeText: '@',
	      dateDisabled: '&',
	      customClass: '&'
	    },
	    link: function(scope, element, attrs, ngModel) {
	      var dateFormat,
	          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,
	          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody,
	          onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus,
	          datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl,
	          datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl,
	          cache = {};
	
	      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
	
	      scope.getText = function(key) {
	        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
	      };
	
	      scope.isDisabled = function(date) {
	        if (date === 'today') {
	          date = new Date();
	        }
	
	        return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) ||
	          (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));
	      };
	
	      scope.compare = function(date1, date2) {
	        return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
	      };
	
	      var isHtml5DateInput = false;
	      if (datepickerPopupConfig.html5Types[attrs.type]) {
	        dateFormat = datepickerPopupConfig.html5Types[attrs.type];
	        isHtml5DateInput = true;
	      } else {
	        dateFormat = attrs.datepickerPopup || datepickerPopupConfig.datepickerPopup;
	        attrs.$observe('datepickerPopup', function(value, oldValue) {
	            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
	            // Invalidate the $modelValue to ensure that formatters re-run
	            // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
	            if (newDateFormat !== dateFormat) {
	              dateFormat = newDateFormat;
	              ngModel.$modelValue = null;
	
	              if (!dateFormat) {
	                throw new Error('datepickerPopup must have a date format specified.');
	              }
	            }
	        });
	      }
	
	      if (!dateFormat) {
	        throw new Error('datepickerPopup must have a date format specified.');
	      }
	
	      if (isHtml5DateInput && attrs.datepickerPopup) {
	        throw new Error('HTML5 date input types do not support custom formats.');
	      }
	
	      // popup element used to display calendar
	      var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');
	      popupEl.attr({
	        'ng-model': 'date',
	        'ng-change': 'dateSelection(date)',
	        'template-url': datepickerPopupTemplateUrl
	      });
	
	      function cameltoDash(string) {
	        return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
	      }
	
	      // datepicker element
	      var datepickerEl = angular.element(popupEl.children()[0]);
	      datepickerEl.attr('template-url', datepickerTemplateUrl);
	
	      if (isHtml5DateInput) {
	        if (attrs.type === 'month') {
	          datepickerEl.attr('datepicker-mode', '"month"');
	          datepickerEl.attr('min-mode', 'month');
	        }
	      }
	
	      if (attrs.datepickerOptions) {
	        var options = scope.$parent.$eval(attrs.datepickerOptions);
	        if (options && options.initDate) {
	          scope.initDate = options.initDate;
	          datepickerEl.attr('init-date', 'initDate');
	          delete options.initDate;
	        }
	        angular.forEach(options, function(value, option) {
	          datepickerEl.attr( cameltoDash(option), value );
	        });
	      }
	
	      scope.watchData = {};
	      angular.forEach(['minMode', 'maxMode', 'minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {
	        if (attrs[key]) {
	          var getAttribute = $parse(attrs[key]);
	          scope.$parent.$watch(getAttribute, function(value) {
	            scope.watchData[key] = value;
	            if (key === 'minDate' || key === 'maxDate') {
	              cache[key] = new Date(value);
	            }
	          });
	          datepickerEl.attr(cameltoDash(key), 'watchData.' + key);
	
	          // Propagate changes from datepicker to outside
	          if (key === 'datepickerMode') {
	            var setAttribute = getAttribute.assign;
	            scope.$watch('watchData.' + key, function(value, oldvalue) {
	              if (angular.isFunction(setAttribute) && value !== oldvalue) {
	                setAttribute(scope.$parent, value);
	              }
	            });
	          }
	        }
	      });
	      if (attrs.dateDisabled) {
	        datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
	      }
	
	      if (attrs.showWeeks) {
	        datepickerEl.attr('show-weeks', attrs.showWeeks);
	      }
	
	      if (attrs.customClass) {
	        datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');
	      }
	
	      function parseDate(viewValue) {
	        if (angular.isNumber(viewValue)) {
	          // presumably timestamp to date object
	          viewValue = new Date(viewValue);
	        }
	
	        if (!viewValue) {
	          return null;
	        } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
	          return viewValue;
	        } else if (angular.isString(viewValue)) {
	          var date = dateParser.parse(viewValue, dateFormat, scope.date);
	          if (isNaN(date)) {
	            return undefined;
	          } else {
	            return date;
	          }
	        } else {
	          return undefined;
	        }
	      }
	
	      function validator(modelValue, viewValue) {
	        var value = modelValue || viewValue;
	
	        if (!attrs.ngRequired && !value) {
	          return true;
	        }
	
	        if (angular.isNumber(value)) {
	          value = new Date(value);
	        }
	        if (!value) {
	          return true;
	        } else if (angular.isDate(value) && !isNaN(value)) {
	          return true;
	        } else if (angular.isString(value)) {
	          var date = dateParser.parse(value, dateFormat);
	          return !isNaN(date);
	        } else {
	          return false;
	        }
	      }
	
	      if (!isHtml5DateInput) {
	        // Internal API to maintain the correct ng-invalid-[key] class
	        ngModel.$$parserName = 'date';
	        ngModel.$validators.date = validator;
	        ngModel.$parsers.unshift(parseDate);
	        ngModel.$formatters.push(function(value) {
	          scope.date = value;
	          return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);
	        });
	      } else {
	        ngModel.$formatters.push(function(value) {
	          scope.date = value;
	          return value;
	        });
	      }
	
	      // Inner change
	      scope.dateSelection = function(dt) {
	        if (angular.isDefined(dt)) {
	          scope.date = dt;
	        }
	        var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
	        element.val(date);
	        ngModel.$setViewValue(date);
	
	        if (closeOnDateSelection) {
	          scope.isOpen = false;
	          element[0].focus();
	        }
	      };
	
	      // Detect changes in the view from the text box
	      ngModel.$viewChangeListeners.push(function() {
	        scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);
	      });
	
	      var documentClickBind = function(event) {
	        if (scope.isOpen && !(element[0].contains(event.target) || popupEl[0].contains(event.target))) {
	          scope.$apply(function() {
	            scope.isOpen = false;
	          });
	        }
	      };
	
	      var inputKeydownBind = function(evt) {
	        if (evt.which === 27 && scope.isOpen) {
	          evt.preventDefault();
	          evt.stopPropagation();
	          scope.$apply(function() {
	            scope.isOpen = false;
	          });
	          element[0].focus();
	        } else if (evt.which === 40 && !scope.isOpen) {
	          evt.preventDefault();
	          evt.stopPropagation();
	          scope.$apply(function() {
	            scope.isOpen = true;
	          });
	        }
	      };
	      element.bind('keydown', inputKeydownBind);
	
	      scope.keydown = function(evt) {
	        if (evt.which === 27) {
	          scope.isOpen = false;
	          element[0].focus();
	        }
	      };
	
	      scope.$watch('isOpen', function(value) {
	        if (value) {
	          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	          scope.position.top = scope.position.top + element.prop('offsetHeight');
	
	          $timeout(function() {
	            if (onOpenFocus) {
	              scope.$broadcast('datepicker.focus');
	            }
	            $document.bind('click', documentClickBind);
	          }, 0, false);
	        } else {
	          $document.unbind('click', documentClickBind);
	        }
	      });
	
	      scope.select = function(date) {
	        if (date === 'today') {
	          var today = new Date();
	          if (angular.isDate(scope.date)) {
	            date = new Date(scope.date);
	            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
	          } else {
	            date = new Date(today.setHours(0, 0, 0, 0));
	          }
	        }
	        scope.dateSelection(date);
	      };
	
	      scope.close = function() {
	        scope.isOpen = false;
	        element[0].focus();
	      };
	
	      var $popup = $compile(popupEl)(scope);
	      // Prevent jQuery cache memory leak (template is now redundant after linking)
	      popupEl.remove();
	
	      if (appendToBody) {
	        $document.find('body').append($popup);
	      } else {
	        element.after($popup);
	      }
	
	      scope.$on('$destroy', function() {
	        if (scope.isOpen === true) {
	          if (!$rootScope.$$phase) {
	            scope.$apply(function() {
	              scope.isOpen = false;
	            });
	          }
	        }
	
	        $popup.remove();
	        element.unbind('keydown', inputKeydownBind);
	        $document.unbind('click', documentClickBind);
	      });
	    }
	  };
	}])
	
	.directive('datepickerPopupWrap', function() {
	  return {
	    restrict:'EA',
	    replace: true,
	    transclude: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/datepicker/popup.html';
	    }
	  };
	});
	
	angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])
	
	.constant('dropdownConfig', {
	  openClass: 'open'
	})
	
	.service('dropdownService', ['$document', '$rootScope', function($document, $rootScope) {
	  var openScope = null;
	
	  this.open = function(dropdownScope) {
	    if (!openScope) {
	      $document.bind('click', closeDropdown);
	      $document.bind('keydown', keybindFilter);
	    }
	
	    if (openScope && openScope !== dropdownScope) {
	      openScope.isOpen = false;
	    }
	
	    openScope = dropdownScope;
	  };
	
	  this.close = function(dropdownScope) {
	    if (openScope === dropdownScope) {
	      openScope = null;
	      $document.unbind('click', closeDropdown);
	      $document.unbind('keydown', keybindFilter);
	    }
	  };
	
	  var closeDropdown = function(evt) {
	    // This method may still be called during the same mouse event that
	    // unbound this event handler. So check openScope before proceeding.
	    if (!openScope) { return; }
	
	    if (evt && openScope.getAutoClose() === 'disabled')  { return ; }
	
	    var toggleElement = openScope.getToggleElement();
	    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
	      return;
	    }
	
	    var dropdownElement = openScope.getDropdownElement();
	    if (evt && openScope.getAutoClose() === 'outsideClick' &&
	      dropdownElement && dropdownElement[0].contains(evt.target)) {
	      return;
	    }
	
	    openScope.isOpen = false;
	
	    if (!$rootScope.$$phase) {
	      openScope.$apply();
	    }
	  };
	
	  var keybindFilter = function(evt) {
	    if (evt.which === 27) {
	      openScope.focusToggleElement();
	      closeDropdown();
	    } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      openScope.focusDropdownEntry(evt.which);
	    }
	  };
	}])
	
	.controller('DropdownController', ['$scope', '$attrs', '$parse', 'dropdownConfig', 'dropdownService', '$animate', '$position', '$document', '$compile', '$templateRequest', function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate, $position, $document, $compile, $templateRequest) {
	  var self = this,
	    scope = $scope.$new(), // create a child scope so we are not polluting original one
	    templateScope,
	    openClass = dropdownConfig.openClass,
	    getIsOpen,
	    setIsOpen = angular.noop,
	    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
	    appendToBody = false,
	    keynavEnabled = false,
	    selectedOption = null,
	    body = $document.find('body');
	
	  this.init = function(element) {
	    self.$element = element;
	
	    if ($attrs.isOpen) {
	      getIsOpen = $parse($attrs.isOpen);
	      setIsOpen = getIsOpen.assign;
	
	      $scope.$watch(getIsOpen, function(value) {
	        scope.isOpen = !!value;
	      });
	    }
	
	    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
	    keynavEnabled = angular.isDefined($attrs.keyboardNav);
	
	    if (appendToBody && self.dropdownMenu) {
	      body.append(self.dropdownMenu);
	      body.addClass('dropdown');
	      element.on('$destroy', function handleDestroyEvent() {
	        self.dropdownMenu.remove();
	      });
	    }
	  };
	
	  this.toggle = function(open) {
	    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
	  };
	
	  // Allow other directives to watch status
	  this.isOpen = function() {
	    return scope.isOpen;
	  };
	
	  scope.getToggleElement = function() {
	    return self.toggleElement;
	  };
	
	  scope.getAutoClose = function() {
	    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
	  };
	
	  scope.getElement = function() {
	    return self.$element;
	  };
	
	  scope.isKeynavEnabled = function() {
	    return keynavEnabled;
	  };
	
	  scope.focusDropdownEntry = function(keyCode) {
	    var elems = self.dropdownMenu ? //If append to body is used.
	      (angular.element(self.dropdownMenu).find('a')) :
	      (angular.element(self.$element).find('ul').eq(0).find('a'));
	
	    switch (keyCode) {
	      case (40): {
	        if (!angular.isNumber(self.selectedOption)) {
	          self.selectedOption = 0;
	        } else {
	          self.selectedOption = (self.selectedOption === elems.length -1 ?
	            self.selectedOption :
	            self.selectedOption + 1);
	        }
	        break;
	      }
	      case (38): {
	        if (!angular.isNumber(self.selectedOption)) {
	          self.selectedOption = elems.length - 1;
	        } else {
	          self.selectedOption = self.selectedOption === 0 ?
	            0 : self.selectedOption - 1;
	        }
	        break;
	      }
	    }
	    elems[self.selectedOption].focus();
	  };
	
	  scope.getDropdownElement = function() {
	    return self.dropdownMenu;
	  };
	
	  scope.focusToggleElement = function() {
	    if (self.toggleElement) {
	      self.toggleElement[0].focus();
	    }
	  };
	
	  scope.$watch('isOpen', function(isOpen, wasOpen) {
	    if (appendToBody && self.dropdownMenu) {
	      var pos = $position.positionElements(self.$element, self.dropdownMenu, 'bottom-left', true);
	      var css = {
	        top: pos.top + 'px',
	        display: isOpen ? 'block' : 'none'
	      };
	
	      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
	      if (!rightalign) {
	        css.left = pos.left + 'px';
	        css.right = 'auto';
	      } else {
	        css.left = 'auto';
	        css.right = (window.innerWidth - (pos.left + self.$element.prop('offsetWidth'))) + 'px';
	      }
	
	      self.dropdownMenu.css(css);
	    }
	
	    var openContainer = appendToBody ? body : self.$element;
	
	    $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, openClass).then(function() {
	      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
	        toggleInvoker($scope, { open: !!isOpen });
	      }
	    });
	
	    if (isOpen) {
	      if (self.dropdownMenuTemplateUrl) {
	        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
	          templateScope = scope.$new();
	          $compile(tplContent.trim())(templateScope, function(dropdownElement) {
	            var newEl = dropdownElement;
	            self.dropdownMenu.replaceWith(newEl);
	            self.dropdownMenu = newEl;
	          });
	        });
	      }
	
	      scope.focusToggleElement();
	      dropdownService.open(scope);
	    } else {
	      if (self.dropdownMenuTemplateUrl) {
	        if (templateScope) {
	          templateScope.$destroy();
	        }
	        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
	        self.dropdownMenu.replaceWith(newEl);
	        self.dropdownMenu = newEl;
	      }
	
	      dropdownService.close(scope);
	      self.selectedOption = null;
	    }
	
	    if (angular.isFunction(setIsOpen)) {
	      setIsOpen($scope, isOpen);
	    }
	  });
	
	  $scope.$on('$locationChangeSuccess', function() {
	    if (scope.getAutoClose() !== 'disabled') {
	      scope.isOpen = false;
	    }
	  });
	
	  var offDestroy = $scope.$on('$destroy', function() {
	    scope.$destroy();
	  });
	  scope.$on('$destroy', offDestroy);
	}])
	
	.directive('dropdown', function() {
	  return {
	    controller: 'DropdownController',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      dropdownCtrl.init( element );
	      element.addClass('dropdown');
	    }
	  };
	})
	
	.directive('dropdownMenu', function() {
	  return {
	    restrict: 'AC',
	    require: '?^dropdown',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      if (!dropdownCtrl) {
	        return;
	      }
	      var tplUrl = attrs.templateUrl;
	      if (tplUrl) {
	        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
	      }
	      if (!dropdownCtrl.dropdownMenu) {
	        dropdownCtrl.dropdownMenu = element;
	      }
	    }
	  };
	})
	
	.directive('keyboardNav', function() {
	  return {
	    restrict: 'A',
	    require: '?^dropdown',
	    link: function (scope, element, attrs, dropdownCtrl) {
	
	      element.bind('keydown', function(e) {
	        if ([38, 40].indexOf(e.which) !== -1) {
	          e.preventDefault();
	          e.stopPropagation();
	
	          var elems = dropdownCtrl.dropdownMenu.find('a');
	
	          switch (e.which) {
	            case (40): { // Down
	              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
	                dropdownCtrl.selectedOption = 0;
	              } else {
	                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?
	                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;
	              }
	              break;
	            }
	            case (38): { // Up
	              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
	                dropdownCtrl.selectedOption = elems.length - 1;
	              } else {
	                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?
	                  0 : dropdownCtrl.selectedOption - 1;
	              }
	              break;
	            }
	          }
	          elems[dropdownCtrl.selectedOption].focus();
	        }
	      });
	    }
	  };
	})
	
	.directive('dropdownToggle', function() {
	  return {
	    require: '?^dropdown',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      if (!dropdownCtrl) {
	        return;
	      }
	
	      element.addClass('dropdown-toggle');
	
	      dropdownCtrl.toggleElement = element;
	
	      var toggleDropdown = function(event) {
	        event.preventDefault();
	
	        if (!element.hasClass('disabled') && !attrs.disabled) {
	          scope.$apply(function() {
	            dropdownCtrl.toggle();
	          });
	        }
	      };
	
	      element.bind('click', toggleDropdown);
	
	      // WAI-ARIA
	      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
	      scope.$watch(dropdownCtrl.isOpen, function( isOpen ) {
	        element.attr('aria-expanded', !!isOpen);
	      });
	
	      scope.$on('$destroy', function() {
	        element.unbind('click', toggleDropdown);
	      });
	    }
	  };
	});
	
	angular.module('ui.bootstrap.modal', [])
	
	/**
	 * A helper, internal data structure that acts as a map but also allows getting / removing
	 * elements in the LIFO order
	 */
	  .factory('$$stackedMap', function() {
	    return {
	      createNew: function() {
	        var stack = [];
	
	        return {
	          add: function(key, value) {
	            stack.push({
	              key: key,
	              value: value
	            });
	          },
	          get: function(key) {
	            for (var i = 0; i < stack.length; i++) {
	              if (key == stack[i].key) {
	                return stack[i];
	              }
	            }
	          },
	          keys: function() {
	            var keys = [];
	            for (var i = 0; i < stack.length; i++) {
	              keys.push(stack[i].key);
	            }
	            return keys;
	          },
	          top: function() {
	            return stack[stack.length - 1];
	          },
	          remove: function(key) {
	            var idx = -1;
	            for (var i = 0; i < stack.length; i++) {
	              if (key == stack[i].key) {
	                idx = i;
	                break;
	              }
	            }
	            return stack.splice(idx, 1)[0];
	          },
	          removeTop: function() {
	            return stack.splice(stack.length - 1, 1)[0];
	          },
	          length: function() {
	            return stack.length;
	          }
	        };
	      }
	    };
	  })
	
	/**
	 * A helper, internal data structure that stores all references attached to key
	 */
	  .factory('$$multiMap', function() {
	    return {
	      createNew: function() {
	        var map = {};
	
	        return {
	          entries: function() {
	            return Object.keys(map).map(function(key) {
	              return {
	                key: key,
	                value: map[key]
	              };
	            });
	          },
	          get: function(key) {
	            return map[key];
	          },
	          hasKey: function(key) {
	            return !!map[key];
	          },
	          keys: function() {
	            return Object.keys(map);
	          },
	          put: function(key, value) {
	            if (!map[key]) {
	              map[key] = [];
	            }
	
	            map[key].push(value);
	          },
	          remove: function(key, value) {
	            var values = map[key];
	
	            if (!values) {
	              return;
	            }
	
	            var idx = values.indexOf(value);
	
	            if (idx !== -1) {
	              values.splice(idx, 1);
	            }
	
	            if (!values.length) {
	              delete map[key];
	            }
	          }
	        };
	      }
	    };
	  })
	
	/**
	 * A helper directive for the $modal service. It creates a backdrop element.
	 */
	  .directive('modalBackdrop', [
	           '$animate', '$injector', '$modalStack',
	  function($animate ,  $injector,   $modalStack) {
	    var $animateCss = null;
	
	    if ($injector.has('$animateCss')) {
	      $animateCss = $injector.get('$animateCss');
	    }
	
	    return {
	      restrict: 'EA',
	      replace: true,
	      templateUrl: 'template/modal/backdrop.html',
	      compile: function(tElement, tAttrs) {
	        tElement.addClass(tAttrs.backdropClass);
	        return linkFn;
	      }
	    };
	
	    function linkFn(scope, element, attrs) {
	      if (attrs.modalInClass) {
	        if ($animateCss) {
	          $animateCss(element, {
	            addClass: attrs.modalInClass
	          }).start();
	        } else {
	          $animate.addClass(element, attrs.modalInClass);
	        }
	
	        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
	          var done = setIsAsync();
	          if ($animateCss) {
	            $animateCss(element, {
	              removeClass: attrs.modalInClass
	            }).start().then(done);
	          } else {
	            $animate.removeClass(element, attrs.modalInClass).then(done);
	          }
	        });
	      }
	    }
	  }])
	
	  .directive('modalWindow', [
	           '$modalStack', '$q', '$animate', '$injector',
	  function($modalStack ,  $q ,  $animate,   $injector) {
	    var $animateCss = null;
	
	    if ($injector.has('$animateCss')) {
	      $animateCss = $injector.get('$animateCss');
	    }
	
	    return {
	      restrict: 'EA',
	      scope: {
	        index: '@'
	      },
	      replace: true,
	      transclude: true,
	      templateUrl: function(tElement, tAttrs) {
	        return tAttrs.templateUrl || 'template/modal/window.html';
	      },
	      link: function(scope, element, attrs) {
	        element.addClass(attrs.windowClass || '');
	        scope.size = attrs.size;
	
	        scope.close = function(evt) {
	          var modal = $modalStack.getTop();
	          if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {
	            evt.preventDefault();
	            evt.stopPropagation();
	            $modalStack.dismiss(modal.key, 'backdrop click');
	          }
	        };
	
	        // This property is only added to the scope for the purpose of detecting when this directive is rendered.
	        // We can detect that by using this property in the template associated with this directive and then use
	        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
	        scope.$isRendered = true;
	
	        // Deferred object that will be resolved when this modal is render.
	        var modalRenderDeferObj = $q.defer();
	        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.
	        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.
	        attrs.$observe('modalRender', function(value) {
	          if (value == 'true') {
	            modalRenderDeferObj.resolve();
	          }
	        });
	
	        modalRenderDeferObj.promise.then(function() {
	          var animationPromise = null;
	
	          if (attrs.modalInClass) {
	            if ($animateCss) {
	              animationPromise = $animateCss(element, {
	                addClass: attrs.modalInClass
	              }).start();
	            } else {
	              animationPromise = $animate.addClass(element, attrs.modalInClass);
	            }
	
	            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
	              var done = setIsAsync();
	              if ($animateCss) {
	                $animateCss(element, {
	                  removeClass: attrs.modalInClass
	                }).start().then(done);
	              } else {
	                $animate.removeClass(element, attrs.modalInClass).then(done);
	              }
	            });
	          }
	
	
	          $q.when(animationPromise).then(function() {
	            var inputsWithAutofocus = element[0].querySelectorAll('[autofocus]');
	            /**
	             * Auto-focusing of a freshly-opened modal element causes any child elements
	             * with the autofocus attribute to lose focus. This is an issue on touch
	             * based devices which will show and then hide the onscreen keyboard.
	             * Attempts to refocus the autofocus element via JavaScript will not reopen
	             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
	             * the modal element if the modal does not contain an autofocus element.
	             */
	            if (inputsWithAutofocus.length) {
	              inputsWithAutofocus[0].focus();
	            } else {
	              element[0].focus();
	            }
	          });
	
	          // Notify {@link $modalStack} that modal is rendered.
	          var modal = $modalStack.getTop();
	          if (modal) {
	            $modalStack.modalRendered(modal.key);
	          }
	        });
	      }
	    };
	  }])
	
	  .directive('modalAnimationClass', [
	    function () {
	      return {
	        compile: function(tElement, tAttrs) {
	          if (tAttrs.modalAnimation) {
	            tElement.addClass(tAttrs.modalAnimationClass);
	          }
	        }
	      };
	    }])
	
	  .directive('modalTransclude', function() {
	    return {
	      link: function($scope, $element, $attrs, controller, $transclude) {
	        $transclude($scope.$parent, function(clone) {
	          $element.empty();
	          $element.append(clone);
	        });
	      }
	    };
	  })
	
	  .factory('$modalStack', [
	             '$animate', '$timeout', '$document', '$compile', '$rootScope',
	             '$q',
	             '$injector',
	             '$$multiMap',
	             '$$stackedMap',
	    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,
	              $q,
	              $injector,
	              $$multiMap,
	              $$stackedMap) {
	      var $animateCss = null;
	
	      if ($injector.has('$animateCss')) {
	        $animateCss = $injector.get('$animateCss');
	      }
	
	      var OPENED_MODAL_CLASS = 'modal-open';
	
	      var backdropDomEl, backdropScope;
	      var openedWindows = $$stackedMap.createNew();
	      var openedClasses = $$multiMap.createNew();
	      var $modalStack = {
	        NOW_CLOSING_EVENT: 'modal.stack.now-closing'
	      };
	
	      //Modal focus behavior
	      var focusableElementList;
	      var focusIndex = 0;
	      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +
	        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +
	        'iframe, object, embed, *[tabindex], *[contenteditable=true]';
	
	      function backdropIndex() {
	        var topBackdropIndex = -1;
	        var opened = openedWindows.keys();
	        for (var i = 0; i < opened.length; i++) {
	          if (openedWindows.get(opened[i]).value.backdrop) {
	            topBackdropIndex = i;
	          }
	        }
	        return topBackdropIndex;
	      }
	
	      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
	        if (backdropScope) {
	          backdropScope.index = newBackdropIndex;
	        }
	      });
	
	      function removeModalWindow(modalInstance, elementToReceiveFocus) {
	        var body = $document.find('body').eq(0);
	        var modalWindow = openedWindows.get(modalInstance).value;
	
	        //clean up the stack
	        openedWindows.remove(modalInstance);
	
	        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
	          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
	          openedClasses.remove(modalBodyClass, modalInstance);
	          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));
	        });
	        checkRemoveBackdrop();
	
	        //move focus to specified element if available, or else to body
	        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
	          elementToReceiveFocus.focus();
	        } else {
	          body.focus();
	        }
	      }
	
	      function checkRemoveBackdrop() {
	          //remove backdrop if no longer needed
	          if (backdropDomEl && backdropIndex() == -1) {
	            var backdropScopeRef = backdropScope;
	            removeAfterAnimate(backdropDomEl, backdropScope, function() {
	              backdropScopeRef = null;
	            });
	            backdropDomEl = undefined;
	            backdropScope = undefined;
	          }
	      }
	
	      function removeAfterAnimate(domEl, scope, done) {
	        var asyncDeferred;
	        var asyncPromise = null;
	        var setIsAsync = function() {
	          if (!asyncDeferred) {
	            asyncDeferred = $q.defer();
	            asyncPromise = asyncDeferred.promise;
	          }
	
	          return function asyncDone() {
	            asyncDeferred.resolve();
	          };
	        };
	        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
	
	        // Note that it's intentional that asyncPromise might be null.
	        // That's when setIsAsync has not been called during the
	        // NOW_CLOSING_EVENT broadcast.
	        return $q.when(asyncPromise).then(afterAnimating);
	
	        function afterAnimating() {
	          if (afterAnimating.done) {
	            return;
	          }
	          afterAnimating.done = true;
	
	          if ($animateCss) {
	            $animateCss(domEl, {
	              event: 'leave'
	            }).start().then(function() {
	              domEl.remove();
	            });
	          } else {
	            $animate.leave(domEl);
	          }
	          scope.$destroy();
	          if (done) {
	            done();
	          }
	        }
	      }
	
	      $document.bind('keydown', function(evt) {
	        if (evt.isDefaultPrevented()) {
	          return evt;
	        }
	
	        var modal = openedWindows.top();
	        if (modal && modal.value.keyboard) {
	          switch (evt.which){
	            case 27: {
	              evt.preventDefault();
	              $rootScope.$apply(function() {
	                $modalStack.dismiss(modal.key, 'escape key press');
	              });
	              break;
	            }
	            case 9: {
	              $modalStack.loadFocusElementList(modal);
	              var focusChanged = false;
	              if (evt.shiftKey) {
	                if ($modalStack.isFocusInFirstItem(evt)) {
	                  focusChanged = $modalStack.focusLastFocusableElement();
	                }
	              } else {
	                if ($modalStack.isFocusInLastItem(evt)) {
	                  focusChanged = $modalStack.focusFirstFocusableElement();
	                }
	              }
	
	              if (focusChanged) {
	                evt.preventDefault();
	                evt.stopPropagation();
	              }
	              break;
	            }
	          }
	        }
	      });
	
	      $modalStack.open = function(modalInstance, modal) {
	        var modalOpener = $document[0].activeElement,
	          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
	
	        openedWindows.add(modalInstance, {
	          deferred: modal.deferred,
	          renderDeferred: modal.renderDeferred,
	          modalScope: modal.scope,
	          backdrop: modal.backdrop,
	          keyboard: modal.keyboard,
	          openedClass: modal.openedClass
	        });
	
	        openedClasses.put(modalBodyClass, modalInstance);
	
	        var body = $document.find('body').eq(0),
	            currBackdropIndex = backdropIndex();
	
	        if (currBackdropIndex >= 0 && !backdropDomEl) {
	          backdropScope = $rootScope.$new(true);
	          backdropScope.index = currBackdropIndex;
	          var angularBackgroundDomEl = angular.element('<div modal-backdrop="modal-backdrop"></div>');
	          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);
	          if (modal.animation) {
	            angularBackgroundDomEl.attr('modal-animation', 'true');
	          }
	          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);
	          body.append(backdropDomEl);
	        }
	
	        var angularDomEl = angular.element('<div modal-window="modal-window"></div>');
	        angularDomEl.attr({
	          'template-url': modal.windowTemplateUrl,
	          'window-class': modal.windowClass,
	          'size': modal.size,
	          'index': openedWindows.length() - 1,
	          'animate': 'animate'
	        }).html(modal.content);
	        if (modal.animation) {
	          angularDomEl.attr('modal-animation', 'true');
	        }
	
	        var modalDomEl = $compile(angularDomEl)(modal.scope);
	        openedWindows.top().value.modalDomEl = modalDomEl;
	        openedWindows.top().value.modalOpener = modalOpener;
	        body.append(modalDomEl);
	        body.addClass(modalBodyClass);
	
	        $modalStack.clearFocusListCache();
	      };
	
	      function broadcastClosing(modalWindow, resultOrReason, closing) {
	          return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
	      }
	
	      $modalStack.close = function(modalInstance, result) {
	        var modalWindow = openedWindows.get(modalInstance);
	        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
	          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
	          modalWindow.value.deferred.resolve(result);
	          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
	          return true;
	        }
	        return !modalWindow;
	      };
	
	      $modalStack.dismiss = function(modalInstance, reason) {
	        var modalWindow = openedWindows.get(modalInstance);
	        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
	          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
	          modalWindow.value.deferred.reject(reason);
	          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
	          return true;
	        }
	        return !modalWindow;
	      };
	
	      $modalStack.dismissAll = function(reason) {
	        var topModal = this.getTop();
	        while (topModal && this.dismiss(topModal.key, reason)) {
	          topModal = this.getTop();
	        }
	      };
	
	      $modalStack.getTop = function() {
	        return openedWindows.top();
	      };
	
	      $modalStack.modalRendered = function(modalInstance) {
	        var modalWindow = openedWindows.get(modalInstance);
	        if (modalWindow) {
	          modalWindow.value.renderDeferred.resolve();
	        }
	      };
	
	      $modalStack.focusFirstFocusableElement = function() {
	        if (focusableElementList.length > 0) {
	          focusableElementList[0].focus();
	          return true;
	        }
	        return false;
	      };
	      $modalStack.focusLastFocusableElement = function() {
	        if (focusableElementList.length > 0) {
	          focusableElementList[focusableElementList.length - 1].focus();
	          return true;
	        }
	        return false;
	      };
	
	      $modalStack.isFocusInFirstItem = function(evt) {
	        if (focusableElementList.length > 0) {
	          return (evt.target || evt.srcElement) == focusableElementList[0];
	        }
	        return false;
	      };
	
	      $modalStack.isFocusInLastItem = function(evt) {
	        if (focusableElementList.length > 0) {
	          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];
	        }
	        return false;
	      };
	
	      $modalStack.clearFocusListCache = function() {
	        focusableElementList = [];
	        focusIndex = 0;
	      };
	
	      $modalStack.loadFocusElementList = function(modalWindow) {
	        if (focusableElementList === undefined || !focusableElementList.length0) {
	          if (modalWindow) {
	            var modalDomE1 = modalWindow.value.modalDomEl;
	            if (modalDomE1 && modalDomE1.length) {
	              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);
	            }
	          }
	        }
	      };
	
	      return $modalStack;
	    }])
	
	  .provider('$modal', function() {
	    var $modalProvider = {
	      options: {
	        animation: true,
	        backdrop: true, //can also be false or 'static'
	        keyboard: true
	      },
	      $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$modalStack',
	        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack) {
	          var $modal = {};
	
	          function getTemplatePromise(options) {
	            return options.template ? $q.when(options.template) :
	              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);
	          }
	
	          function getResolvePromises(resolves) {
	            var promisesArr = [];
	            angular.forEach(resolves, function(value) {
	              if (angular.isFunction(value) || angular.isArray(value)) {
	                promisesArr.push($q.when($injector.invoke(value)));
	              } else if (angular.isString(value)) {
	                promisesArr.push($q.when($injector.get(value)));
	              } else {
	                promisesArr.push($q.when(value));
	              }
	            });
	            return promisesArr;
	          }
	
	          var promiseChain = null;
	          $modal.getPromiseChain = function() {
	            return promiseChain;
	          };
	
	          $modal.open = function (modalOptions) {
	
	            var modalResultDeferred = $q.defer();
	            var modalOpenedDeferred = $q.defer();
	            var modalRenderDeferred = $q.defer();
	
	            //prepare an instance of a modal to be injected into controllers and returned to a caller
	            var modalInstance = {
	              result: modalResultDeferred.promise,
	              opened: modalOpenedDeferred.promise,
	              rendered: modalRenderDeferred.promise,
	              close: function (result) {
	                return $modalStack.close(modalInstance, result);
	              },
	              dismiss: function (reason) {
	                return $modalStack.dismiss(modalInstance, reason);
	              }
	            };
	
	            //merge and clean up options
	            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
	            modalOptions.resolve = modalOptions.resolve || {};
	
	            //verify options
	            if (!modalOptions.template && !modalOptions.templateUrl) {
	              throw new Error('One of template or templateUrl options is required.');
	            }
	
	            var templateAndResolvePromise =
	              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));
	
	            // Wait for the resolution of the existing promise chain.
	            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
	            // Then add to $modalStack and resolve opened.
	            // Finally clean up the chain variable if no subsequent modal has overwritten it.
	            var samePromise;
	            samePromise = promiseChain = $q.all([promiseChain])
	              .then(function() { return templateAndResolvePromise; }, function() { return templateAndResolvePromise; })
	              .then(function resolveSuccess(tplAndVars) {
	
	                var modalScope = (modalOptions.scope || $rootScope).$new();
	                modalScope.$close = modalInstance.close;
	                modalScope.$dismiss = modalInstance.dismiss;
	
	                modalScope.$on('$destroy', function() {
	                  if (!modalScope.$$uibDestructionScheduled) {
	                    modalScope.$dismiss('$uibUnscheduledDestruction');
	                  }
	                });
	
	                var ctrlInstance, ctrlLocals = {};
	                var resolveIter = 1;
	
	                //controllers
	                if (modalOptions.controller) {
	                  ctrlLocals.$scope = modalScope;
	                  ctrlLocals.$modalInstance = modalInstance;
	                  angular.forEach(modalOptions.resolve, function(value, key) {
	                    ctrlLocals[key] = tplAndVars[resolveIter++];
	                  });
	
	                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
	                  if (modalOptions.controllerAs) {
	                    if (modalOptions.bindToController) {
	                      angular.extend(ctrlInstance, modalScope);
	                    }
	
	                    modalScope[modalOptions.controllerAs] = ctrlInstance;
	                  }
	                }
	
	                $modalStack.open(modalInstance, {
	                  scope: modalScope,
	                  deferred: modalResultDeferred,
	                  renderDeferred: modalRenderDeferred,
	                  content: tplAndVars[0],
	                  animation: modalOptions.animation,
	                  backdrop: modalOptions.backdrop,
	                  keyboard: modalOptions.keyboard,
	                  backdropClass: modalOptions.backdropClass,
	                  windowClass: modalOptions.windowClass,
	                  windowTemplateUrl: modalOptions.windowTemplateUrl,
	                  size: modalOptions.size,
	                  openedClass: modalOptions.openedClass
	                });
	                modalOpenedDeferred.resolve(true);
	
	            }, function resolveError(reason) {
	              modalOpenedDeferred.reject(reason);
	              modalResultDeferred.reject(reason);
	            })
	            .finally(function() {
	              if (promiseChain === samePromise) {
	                promiseChain = null;
	              }
	            });
	
	            return modalInstance;
	          };
	
	          return $modal;
	        }]
	    };
	
	    return $modalProvider;
	  });
	
	angular.module('ui.bootstrap.pagination', [])
	.controller('PaginationController', ['$scope', '$attrs', '$parse', function($scope, $attrs, $parse) {
	  var self = this,
	      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
	      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
	
	  this.init = function(ngModelCtrl_, config) {
	    ngModelCtrl = ngModelCtrl_;
	    this.config = config;
	
	    ngModelCtrl.$render = function() {
	      self.render();
	    };
	
	    if ($attrs.itemsPerPage) {
	      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
	        self.itemsPerPage = parseInt(value, 10);
	        $scope.totalPages = self.calculateTotalPages();
	      });
	    } else {
	      this.itemsPerPage = config.itemsPerPage;
	    }
	
	    $scope.$watch('totalItems', function() {
	      $scope.totalPages = self.calculateTotalPages();
	    });
	
	    $scope.$watch('totalPages', function(value) {
	      setNumPages($scope.$parent, value); // Readonly variable
	
	      if ( $scope.page > value ) {
	        $scope.selectPage(value);
	      } else {
	        ngModelCtrl.$render();
	      }
	    });
	  };
	
	  this.calculateTotalPages = function() {
	    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
	    return Math.max(totalPages || 0, 1);
	  };
	
	  this.render = function() {
	    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
	  };
	
	  $scope.selectPage = function(page, evt) {
	    if (evt) {
	      evt.preventDefault();
	    }
	
	    var clickAllowed = !$scope.ngDisabled || !evt;
	    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
	      if (evt && evt.target) {
	        evt.target.blur();
	      }
	      ngModelCtrl.$setViewValue(page);
	      ngModelCtrl.$render();
	    }
	  };
	
	  $scope.getText = function(key) {
	    return $scope[key + 'Text'] || self.config[key + 'Text'];
	  };
	
	  $scope.noPrevious = function() {
	    return $scope.page === 1;
	  };
	
	  $scope.noNext = function() {
	    return $scope.page === $scope.totalPages;
	  };
	}])
	
	.constant('paginationConfig', {
	  itemsPerPage: 10,
	  boundaryLinks: false,
	  directionLinks: true,
	  firstText: 'First',
	  previousText: 'Previous',
	  nextText: 'Next',
	  lastText: 'Last',
	  rotate: true
	})
	
	.directive('pagination', ['$parse', 'paginationConfig', function($parse, paginationConfig) {
	  return {
	    restrict: 'EA',
	    scope: {
	      totalItems: '=',
	      firstText: '@',
	      previousText: '@',
	      nextText: '@',
	      lastText: '@',
	      ngDisabled:'='
	    },
	    require: ['pagination', '?ngModel'],
	    controller: 'PaginationController',
	    controllerAs: 'pagination',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/pagination/pagination.html';
	    },
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      if (!ngModelCtrl) {
	         return; // do nothing if no ng-model
	      }
	
	      // Setup configuration parameters
	      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
	          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
	      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
	      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;
	
	      paginationCtrl.init(ngModelCtrl, paginationConfig);
	
	      if (attrs.maxSize) {
	        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
	          maxSize = parseInt(value, 10);
	          paginationCtrl.render();
	        });
	      }
	
	      // Create page object used in template
	      function makePage(number, text, isActive) {
	        return {
	          number: number,
	          text: text,
	          active: isActive
	        };
	      }
	
	      function getPages(currentPage, totalPages) {
	        var pages = [];
	
	        // Default page limits
	        var startPage = 1, endPage = totalPages;
	        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
	
	        // recompute if maxSize
	        if (isMaxSized) {
	          if (rotate) {
	            // Current page is displayed in the middle of the visible ones
	            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
	            endPage   = startPage + maxSize - 1;
	
	            // Adjust if limit is exceeded
	            if (endPage > totalPages) {
	              endPage   = totalPages;
	              startPage = endPage - maxSize + 1;
	            }
	          } else {
	            // Visible pages are paginated with maxSize
	            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;
	
	            // Adjust last page if limit is exceeded
	            endPage = Math.min(startPage + maxSize - 1, totalPages);
	          }
	        }
	
	        // Add page number links
	        for (var number = startPage; number <= endPage; number++) {
	          var page = makePage(number, number, number === currentPage);
	          pages.push(page);
	        }
	
	        // Add links to move between page sets
	        if (isMaxSized && ! rotate) {
	          if (startPage > 1) {
	            var previousPageSet = makePage(startPage - 1, '...', false);
	            pages.unshift(previousPageSet);
	          }
	
	          if (endPage < totalPages) {
	            var nextPageSet = makePage(endPage + 1, '...', false);
	            pages.push(nextPageSet);
	          }
	        }
	
	        return pages;
	      }
	
	      var originalRender = paginationCtrl.render;
	      paginationCtrl.render = function() {
	        originalRender();
	        if (scope.page > 0 && scope.page <= scope.totalPages) {
	          scope.pages = getPages(scope.page, scope.totalPages);
	        }
	      };
	    }
	  };
	}])
	
	.constant('pagerConfig', {
	  itemsPerPage: 10,
	  previousText: ' Previous',
	  nextText: 'Next ',
	  align: true
	})
	
	.directive('pager', ['pagerConfig', function(pagerConfig) {
	  return {
	    restrict: 'EA',
	    scope: {
	      totalItems: '=',
	      previousText: '@',
	      nextText: '@',
	      ngDisabled: '='
	    },
	    require: ['pager', '?ngModel'],
	    controller: 'PaginationController',
	    controllerAs: 'pagination',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/pagination/pager.html';
	    },
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      if (!ngModelCtrl) {
	         return; // do nothing if no ng-model
	      }
	
	      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
	      paginationCtrl.init(ngModelCtrl, pagerConfig);
	    }
	  };
	}]);
	
	/**
	 * The following features are still outstanding: animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, html tooltips, and selector delegation.
	 */
	angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])
	
	/**
	 * The $tooltip service creates tooltip- and popover-like directives as well as
	 * houses global options for them.
	 */
	.provider('$tooltip', function() {
	  // The default options tooltip and popover.
	  var defaultOptions = {
	    placement: 'top',
	    animation: true,
	    popupDelay: 0,
	    useContentExp: false
	  };
	
	  // Default hide triggers for each show trigger
	  var triggerMap = {
	    'mouseenter': 'mouseleave',
	    'click': 'click',
	    'focus': 'blur',
	    'none': ''
	  };
	
	  // The options specified to the provider globally.
	  var globalOptions = {};
	
	  /**
	   * `options({})` allows global configuration of all tooltips in the
	   * application.
	   *
	   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
	   *     // place tooltips left instead of top by default
	   *     $tooltipProvider.options( { placement: 'left' } );
	   *   });
	   */
		this.options = function(value) {
			angular.extend(globalOptions, value);
		};
	
	  /**
	   * This allows you to extend the set of trigger mappings available. E.g.:
	   *
	   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
	   */
	  this.setTriggers = function setTriggers(triggers) {
	    angular.extend(triggerMap, triggers);
	  };
	
	  /**
	   * This is a helper function for translating camel-case to snake-case.
	   */
	  function snake_case(name) {
	    var regexp = /[A-Z]/g;
	    var separator = '-';
	    return name.replace(regexp, function(letter, pos) {
	      return (pos ? separator : '') + letter.toLowerCase();
	    });
	  }
	
	  /**
	   * Returns the actual instance of the $tooltip service.
	   * TODO support multiple triggers
	   */
	  this.$get = ['$window', '$compile', '$timeout', '$document', '$position', '$interpolate', '$rootScope', '$parse', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse) {
	    return function $tooltip(type, prefix, defaultTriggerShow, options) {
	      options = angular.extend({}, defaultOptions, globalOptions, options);
	
	      /**
	       * Returns an object of show and hide triggers.
	       *
	       * If a trigger is supplied,
	       * it is used to show the tooltip; otherwise, it will use the `trigger`
	       * option passed to the `$tooltipProvider.options` method; else it will
	       * default to the trigger supplied to this directive factory.
	       *
	       * The hide trigger is based on the show trigger. If the `trigger` option
	       * was passed to the `$tooltipProvider.options` method, it will use the
	       * mapped trigger from `triggerMap` or the passed trigger if the map is
	       * undefined; otherwise, it uses the `triggerMap` value of the show
	       * trigger; else it will just use the show trigger.
	       */
	      function getTriggers(trigger) {
	        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
	        var hide = show.map(function(trigger) {
	          return triggerMap[trigger] || trigger;
	        });
	        return {
	          show: show,
	          hide: hide
	        };
	      }
	
	      var directiveName = snake_case(type);
	
	      var startSym = $interpolate.startSymbol();
	      var endSym = $interpolate.endSymbol();
	      var template =
	        '<div '+ directiveName +'-popup '+
	          'title="'+startSym+'title'+endSym+'" '+
	          (options.useContentExp ?
	            'content-exp="contentExp()" ' :
	            'content="'+startSym+'content'+endSym+'" ') +
	          'placement="'+startSym+'placement'+endSym+'" '+
	          'popup-class="'+startSym+'popupClass'+endSym+'" '+
	          'animation="animation" '+
	          'is-open="isOpen"'+
	          'origin-scope="origScope" '+
	          '>'+
	        '</div>';
	
	      return {
	        restrict: 'EA',
	        compile: function(tElem, tAttrs) {
	          var tooltipLinker = $compile( template );
	
	          return function link(scope, element, attrs, tooltipCtrl) {
	            var tooltip;
	            var tooltipLinkedScope;
	            var transitionTimeout;
	            var popupTimeout;
	            var positionTimeout;
	            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
	            var triggers = getTriggers(undefined);
	            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
	            var ttScope = scope.$new(true);
	            var repositionScheduled = false;
	            var isOpenExp = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
	
	            var positionTooltip = function() {
	              if (!tooltip) { return; }
	
	              if (!positionTimeout) {
	                positionTimeout = $timeout(function() {
	                  // Reset the positioning and box size for correct width and height values.
	                  tooltip.css({ top: 0, left: 0, width: 'auto', height: 'auto' });
	
	                  var ttBox = $position.position(tooltip);
	                  var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
	                  ttCss.top += 'px';
	                  ttCss.left += 'px';
	
	                  ttCss.width = ttBox.width + 'px';
	                  ttCss.height = ttBox.height + 'px';
	
	                  // Now set the calculated positioning and size.
	                  tooltip.css(ttCss);
	
	                  positionTimeout = null;
	
	                }, 0, false);
	              }
	            };
	
	            // Set up the correct scope to allow transclusion later
	            ttScope.origScope = scope;
	
	            // By default, the tooltip is not open.
	            // TODO add ability to start tooltip opened
	            ttScope.isOpen = false;
	
	            function toggleTooltipBind() {
	              if (!ttScope.isOpen) {
	                showTooltipBind();
	              } else {
	                hideTooltipBind();
	              }
	            }
	
	            // Show the tooltip with delay if specified, otherwise show it immediately
	            function showTooltipBind() {
	              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
	                return;
	              }
	
	              prepareTooltip();
	
	              if (ttScope.popupDelay) {
	                // Do nothing if the tooltip was already scheduled to pop-up.
	                // This happens if show is triggered multiple times before any hide is triggered.
	                if (!popupTimeout) {
	                  popupTimeout = $timeout(show, ttScope.popupDelay, false);
	                }
	              } else {
	                show();
	              }
	            }
	
	            function hideTooltipBind () {
	              hide();
	              if (!$rootScope.$$phase) {
	                $rootScope.$digest();
	              }
	            }
	
	            // Show the tooltip popup element.
	            function show() {
	              popupTimeout = null;
	
	              // If there is a pending remove transition, we must cancel it, lest the
	              // tooltip be mysteriously removed.
	              if (transitionTimeout) {
	                $timeout.cancel(transitionTimeout);
	                transitionTimeout = null;
	              }
	
	              // Don't show empty tooltips.
	              if (!(options.useContentExp ? ttScope.contentExp() : ttScope.content)) {
	                return angular.noop;
	              }
	
	              createTooltip();
	
	              // And show the tooltip.
	              ttScope.isOpen = true;
	              if (isOpenExp) {
	                isOpenExp.assign(ttScope.origScope, ttScope.isOpen);
	              }
	
	              if (!$rootScope.$$phase) {
	                ttScope.$apply(); // digest required as $apply is not called
	              }
	
	              tooltip.css({ display: 'block' });
	
	              positionTooltip();
	            }
	
	            // Hide the tooltip popup element.
	            function hide() {
	              // First things first: we don't show it anymore.
	              ttScope.isOpen = false;
	              if (isOpenExp) {
	                isOpenExp.assign(ttScope.origScope, ttScope.isOpen);
	              }
	
	              //if tooltip is going to be shown after delay, we must cancel this
	              $timeout.cancel(popupTimeout);
	              popupTimeout = null;
	
	              $timeout.cancel(positionTimeout);
	              positionTimeout = null;
	
	              // And now we remove it from the DOM. However, if we have animation, we
	              // need to wait for it to expire beforehand.
	              // FIXME: this is a placeholder for a port of the transitions library.
	              if (ttScope.animation) {
	                if (!transitionTimeout) {
	                  transitionTimeout = $timeout(removeTooltip, 500);
	                }
	              } else {
	                removeTooltip();
	              }
	            }
	
	            function createTooltip() {
	              // There can only be one tooltip element per directive shown at once.
	              if (tooltip) {
	                removeTooltip();
	              }
	              tooltipLinkedScope = ttScope.$new();
	              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
	                if (appendToBody) {
	                  $document.find('body').append(tooltip);
	                } else {
	                  element.after(tooltip);
	                }
	              });
	
	              if (options.useContentExp) {
	                tooltipLinkedScope.$watch('contentExp()', function(val) {
	                  if (!val && ttScope.isOpen) {
	                    hide();
	                  }
	                });
	
	                tooltipLinkedScope.$watch(function() {
	                  if (!repositionScheduled) {
	                    repositionScheduled = true;
	                    tooltipLinkedScope.$$postDigest(function() {
	                      repositionScheduled = false;
	                      if (ttScope.isOpen) {
	                        positionTooltip();
	                      }
	                    });
	                  }
	                });
	
	              }
	            }
	
	            function removeTooltip() {
	              transitionTimeout = null;
	              if (tooltip) {
	                tooltip.remove();
	                tooltip = null;
	              }
	              if (tooltipLinkedScope) {
	                tooltipLinkedScope.$destroy();
	                tooltipLinkedScope = null;
	              }
	            }
	
	            function prepareTooltip() {
	              prepPopupClass();
	              prepPlacement();
	              prepPopupDelay();
	            }
	
	            ttScope.contentExp = function() {
	              return scope.$eval(attrs[type]);
	            };
	
	            /**
	             * Observe the relevant attributes.
	             */
	            if (!options.useContentExp) {
	              attrs.$observe(type, function(val) {
	                ttScope.content = val;
	
	                if (!val && ttScope.isOpen) {
	                  hide();
	                } else {
	                  positionTooltip();
	                }
	              });
	            }
	
	            attrs.$observe('disabled', function(val) {
	              if (popupTimeout && val) {
	                $timeout.cancel(popupTimeout);
	                popupTimeout = null;
	              }
	
	              if (val && ttScope.isOpen) {
	                hide();
	              }
	            });
	
	            attrs.$observe(prefix + 'Title', function(val) {
	              ttScope.title = val;
	              positionTooltip();
	            });
	
	            attrs.$observe(prefix + 'Placement', function() {
	              if (ttScope.isOpen) {
	                prepPlacement();
	                positionTooltip();
	              }
	            });
	
	            if (isOpenExp) {
	              scope.$watch(isOpenExp, function(val) {
	                if (val !== ttScope.isOpen) {
	                  toggleTooltipBind();
	                }
	              });
	            }
	
	            function prepPopupClass() {
	              ttScope.popupClass = attrs[prefix + 'Class'];
	            }
	
	            function prepPlacement() {
	              var val = attrs[prefix + 'Placement'];
	              ttScope.placement = angular.isDefined(val) ? val : options.placement;
	            }
	
	            function prepPopupDelay() {
	              var val = attrs[prefix + 'PopupDelay'];
	              var delay = parseInt(val, 10);
	              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
	            }
	
	            var unregisterTriggers = function() {
	              triggers.show.forEach(function(trigger) {
	                element.unbind(trigger, showTooltipBind);
	              });
	              triggers.hide.forEach(function(trigger) {
	                element.unbind(trigger, hideTooltipBind);
	              });
	            };
	
	            function prepTriggers() {
	              var val = attrs[prefix + 'Trigger'];
	              unregisterTriggers();
	
	              triggers = getTriggers(val);
	
	              if (triggers.show !== 'none') {
	                triggers.show.forEach(function(trigger, idx) {
	                  // Using raw addEventListener due to jqLite/jQuery bug - #4060
	                  if (trigger === triggers.hide[idx]) {
	                    element[0].addEventListener(trigger, toggleTooltipBind);
	                  } else if (trigger) {
	                    element[0].addEventListener(trigger, showTooltipBind);
	                    element[0].addEventListener(triggers.hide[idx], hideTooltipBind);
	                  }
	                });
	              }
	            }
	            prepTriggers();
	
	            var animation = scope.$eval(attrs[prefix + 'Animation']);
	            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
	
	            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);
	            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
	
	            // if a tooltip is attached to <body> we need to remove it on
	            // location change as its parent scope will probably not be destroyed
	            // by the change.
	            if (appendToBody) {
	              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
	                if (ttScope.isOpen) {
	                  hide();
	                }
	              });
	            }
	
	            // Make sure tooltip is destroyed and removed.
	            scope.$on('$destroy', function onDestroyTooltip() {
	              $timeout.cancel(transitionTimeout);
	              $timeout.cancel(popupTimeout);
	              $timeout.cancel(positionTimeout);
	              unregisterTriggers();
	              removeTooltip();
	              ttScope = null;
	            });
	          };
	        }
	      };
	    };
	  }];
	})
	
	// This is mostly ngInclude code but with a custom scope
	.directive('tooltipTemplateTransclude', [
	         '$animate', '$sce', '$compile', '$templateRequest',
	function ($animate ,  $sce ,  $compile ,  $templateRequest) {
	  return {
	    link: function(scope, elem, attrs) {
	      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
	
	      var changeCounter = 0,
	        currentScope,
	        previousElement,
	        currentElement;
	
	      var cleanupLastIncludeContent = function() {
	        if (previousElement) {
	          previousElement.remove();
	          previousElement = null;
	        }
	        if (currentScope) {
	          currentScope.$destroy();
	          currentScope = null;
	        }
	        if (currentElement) {
	          $animate.leave(currentElement).then(function() {
	            previousElement = null;
	          });
	          previousElement = currentElement;
	          currentElement = null;
	        }
	      };
	
	      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {
	        var thisChangeId = ++changeCounter;
	
	        if (src) {
	          //set the 2nd param to true to ignore the template request error so that the inner
	          //contents and scope can be cleaned up.
	          $templateRequest(src, true).then(function(response) {
	            if (thisChangeId !== changeCounter) { return; }
	            var newScope = origScope.$new();
	            var template = response;
	
	            var clone = $compile(template)(newScope, function(clone) {
	              cleanupLastIncludeContent();
	              $animate.enter(clone, elem);
	            });
	
	            currentScope = newScope;
	            currentElement = clone;
	
	            currentScope.$emit('$includeContentLoaded', src);
	          }, function() {
	            if (thisChangeId === changeCounter) {
	              cleanupLastIncludeContent();
	              scope.$emit('$includeContentError', src);
	            }
	          });
	          scope.$emit('$includeContentRequested', src);
	        } else {
	          cleanupLastIncludeContent();
	        }
	      });
	
	      scope.$on('$destroy', cleanupLastIncludeContent);
	    }
	  };
	}])
	
	/**
	 * Note that it's intentional that these classes are *not* applied through $animate.
	 * They must not be animated as they're expected to be present on the tooltip on
	 * initialization.
	 */
	.directive('tooltipClasses', function() {
	  return {
	    restrict: 'A',
	    link: function(scope, element, attrs) {
	      if (scope.placement) {
	        element.addClass(scope.placement);
	      }
	      if (scope.popupClass) {
	        element.addClass(scope.popupClass);
	      }
	      if (scope.animation()) {
	        element.addClass(attrs.tooltipAnimationClass);
	      }
	    }
	  };
	})
	
	.directive('tooltipPopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-popup.html'
	  };
	})
	
	.directive('tooltip', [ '$tooltip', function($tooltip) {
	  return $tooltip('tooltip', 'tooltip', 'mouseenter');
	}])
	
	.directive('tooltipTemplatePopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
	      originScope: '&' },
	    templateUrl: 'template/tooltip/tooltip-template-popup.html'
	  };
	})
	
	.directive('tooltipTemplate', ['$tooltip', function($tooltip) {
	  return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {
	    useContentExp: true
	  });
	}])
	
	.directive('tooltipHtmlPopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-html-popup.html'
	  };
	})
	
	.directive('tooltipHtml', ['$tooltip', function($tooltip) {
	  return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {
	    useContentExp: true
	  });
	}])
	
	/*
	Deprecated
	*/
	.directive('tooltipHtmlUnsafePopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
	  };
	})
	
	.value('tooltipHtmlUnsafeSuppressDeprecated', false)
	.directive('tooltipHtmlUnsafe', [
	          '$tooltip', 'tooltipHtmlUnsafeSuppressDeprecated', '$log',
	function($tooltip ,  tooltipHtmlUnsafeSuppressDeprecated ,  $log) {
	  if (!tooltipHtmlUnsafeSuppressDeprecated) {
	    $log.warn('tooltip-html-unsafe is now deprecated. Use tooltip-html or tooltip-template instead.');
	  }
	  return $tooltip('tooltipHtmlUnsafe', 'tooltip', 'mouseenter');
	}]);
	
	/**
	 * The following features are still outstanding: popup delay, animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, and selector delegatation.
	 */
	angular.module( 'ui.bootstrap.popover', ['ui.bootstrap.tooltip'])
	
	.directive('popoverTemplatePopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
	      originScope: '&' },
	    templateUrl: 'template/popover/popover-template.html'
	  };
	})
	
	.directive('popoverTemplate', ['$tooltip', function($tooltip) {
	  return $tooltip('popoverTemplate', 'popover', 'click', {
	    useContentExp: true
	  });
	}])
	
	.directive('popoverHtmlPopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/popover/popover-html.html'
	  };
	})
	
	.directive('popoverHtml', ['$tooltip', function($tooltip) {
	  return $tooltip( 'popoverHtml', 'popover', 'click', {
	    useContentExp: true
	  });
	}])
	
	.directive('popoverPopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/popover/popover.html'
	  };
	})
	
	.directive('popover', ['$tooltip', function($tooltip) {
	  return $tooltip( 'popover', 'popover', 'click' );
	}]);
	
	angular.module('ui.bootstrap.progressbar', [])
	
	.constant('progressConfig', {
	  animate: true,
	  max: 100
	})
	
	.value('$progressSuppressWarning', false)
	
	.controller('ProgressController', ['$scope', '$attrs', 'progressConfig', function($scope, $attrs, progressConfig) {
	  var self = this,
	      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
	
	  this.bars = [];
	  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;
	
	  this.addBar = function(bar, element) {
	    if (!animate) {
	      element.css({'transition': 'none'});
	    }
	
	    this.bars.push(bar);
	
	    bar.max = $scope.max;
	
	    bar.$watch('value', function(value) {
	      bar.recalculatePercentage();
	    });
	
	    bar.recalculatePercentage = function() {
	      bar.percent = +(100 * bar.value / bar.max).toFixed(2);
	
	      var totalPercentage = self.bars.reduce(function(total, bar) {
	        return total + bar.percent;
	      }, 0);
	
	      if (totalPercentage > 100) {
	        bar.percent -= totalPercentage - 100;
	      }
	    };
	
	    bar.$on('$destroy', function() {
	      element = null;
	      self.removeBar(bar);
	    });
	  };
	
	  this.removeBar = function(bar) {
	      this.bars.splice(this.bars.indexOf(bar), 1);
	  };
	
	  $scope.$watch('max', function(max) {
	    self.bars.forEach(function(bar) {
	      bar.max = $scope.max;
	      bar.recalculatePercentage();
	    });
	  });
	}])
	
	.directive('uibProgress', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    controller: 'ProgressController',
	    require: 'uibProgress',
	    scope: {
	      max: '=?'
	    },
	    templateUrl: 'template/progressbar/progress.html'
	  };
	})
	
	.directive('progress', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    controller: 'ProgressController',
	    require: 'progress',
	    scope: {
	      max: '=?'
	    },
	    templateUrl: 'template/progressbar/progress.html',
	    link: function() {
	      if ($progressSuppressWarning) {
	        $log.warn('progress is now deprecated. Use uib-progress instead');
	      }
	    }
	  };
	}])
	
	.directive('uibBar', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    require: '^uibProgress',
	    scope: {
	      value: '=',
	      type: '@'
	    },
	    templateUrl: 'template/progressbar/bar.html',
	    link: function(scope, element, attrs, progressCtrl) {
	      progressCtrl.addBar(scope, element);
	    }
	  };
	})
	
	.directive('bar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    require: '^progress',
	    scope: {
	      value: '=',
	      type: '@'
	    },
	    templateUrl: 'template/progressbar/bar.html',
	    link: function(scope, element, attrs, progressCtrl) {
	      if ($progressSuppressWarning) {
	        $log.warn('bar is now deprecated. Use uib-bar instead');
	      }
	      progressCtrl.addBar(scope, element);
	    }
	  };
	}])
	
	.directive('progressbar', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    controller: 'ProgressController',
	    scope: {
	      value: '=',
	      max: '=?',
	      type: '@'
	    },
	    templateUrl: 'template/progressbar/progressbar.html',
	    link: function(scope, element, attrs, progressCtrl) {
	      progressCtrl.addBar(scope, angular.element(element.children()[0]));
	    }
	  };
	});
	
	angular.module('ui.bootstrap.rating', [])
	
	.constant('ratingConfig', {
	  max: 5,
	  stateOn: null,
	  stateOff: null,
	  titles : ['one', 'two', 'three', 'four', 'five']
	})
	
	.controller('RatingController', ['$scope', '$attrs', 'ratingConfig', function($scope, $attrs, ratingConfig) {
	  var ngModelCtrl  = { $setViewValue: angular.noop };
	
	  this.init = function(ngModelCtrl_) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelCtrl.$render = this.render;
	
	    ngModelCtrl.$formatters.push(function(value) {
	      if (angular.isNumber(value) && value << 0 !== value) {
	        value = Math.round(value);
	      }
	      return value;
	    });
	
	    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
	    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
	    var tmpTitles = angular.isDefined($attrs.titles)  ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;    
	    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
	      tmpTitles : ratingConfig.titles;
	    
	    var ratingStates = angular.isDefined($attrs.ratingStates) ?
	      $scope.$parent.$eval($attrs.ratingStates) :
	      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
	    $scope.range = this.buildTemplateObjects(ratingStates);
	  };
	
	  this.buildTemplateObjects = function(states) {
	    for (var i = 0, n = states.length; i < n; i++) {
	      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
	    }
	    return states;
	  };
	  
	  this.getTitle = function(index) {
	    if (index >= this.titles.length) {
	      return index + 1;
	    } else {
	      return this.titles[index];
	    }
	  };
	  
	  $scope.rate = function(value) {
	    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
	      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);
	      ngModelCtrl.$render();
	    }
	  };
	
	  $scope.enter = function(value) {
	    if (!$scope.readonly) {
	      $scope.value = value;
	    }
	    $scope.onHover({value: value});
	  };
	
	  $scope.reset = function() {
	    $scope.value = ngModelCtrl.$viewValue;
	    $scope.onLeave();
	  };
	
	  $scope.onKeydown = function(evt) {
	    if (/(37|38|39|40)/.test(evt.which)) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
	    }
	  };
	
	  this.render = function() {
	    $scope.value = ngModelCtrl.$viewValue;
	  };
	}])
	
	.directive('rating', function() {
	  return {
	    restrict: 'EA',
	    require: ['rating', 'ngModel'],
	    scope: {
	      readonly: '=?',
	      onHover: '&',
	      onLeave: '&'
	    },
	    controller: 'RatingController',
	    templateUrl: 'template/rating/rating.html',
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	      ratingCtrl.init( ngModelCtrl );
	    }
	  };
	});
	
	
	/**
	 * @ngdoc overview
	 * @name ui.bootstrap.tabs
	 *
	 * @description
	 * AngularJS version of the tabs directive.
	 */
	
	angular.module('ui.bootstrap.tabs', [])
	
	.controller('TabsetController', ['$scope', function TabsetCtrl($scope) {
	  var ctrl = this,
	      tabs = ctrl.tabs = $scope.tabs = [];
	
	  ctrl.select = function(selectedTab) {
	    angular.forEach(tabs, function(tab) {
	      if (tab.active && tab !== selectedTab) {
	        tab.active = false;
	        tab.onDeselect();
	        selectedTab.selectCalled = false;
	      }
	    });
	    selectedTab.active = true;
	    // only call select if it has not already been called
	    if (!selectedTab.selectCalled) {
	      selectedTab.onSelect();
	      selectedTab.selectCalled = true;
	    }
	  };
	
	  ctrl.addTab = function addTab(tab) {
	    tabs.push(tab);
	    // we can't run the select function on the first tab
	    // since that would select it twice
	    if (tabs.length === 1 && tab.active !== false) {
	      tab.active = true;
	    } else if (tab.active) {
	      ctrl.select(tab);
	    } else {
	      tab.active = false;
	    }
	  };
	
	  ctrl.removeTab = function removeTab(tab) {
	    var index = tabs.indexOf(tab);
	    //Select a new tab if the tab to be removed is selected and not destroyed
	    if (tab.active && tabs.length > 1 && !destroyed) {
	      //If this is the last tab, select the previous tab. else, the next tab.
	      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
	      ctrl.select(tabs[newActiveIndex]);
	    }
	    tabs.splice(index, 1);
	  };
	
	  var destroyed;
	  $scope.$on('$destroy', function() {
	    destroyed = true;
	  });
	}])
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tabset
	 * @restrict EA
	 *
	 * @description
	 * Tabset is the outer container for the tabs directive
	 *
	 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
	 * @param {boolean=} justified Whether or not to use justified styling for the tabs.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <tabset>
	      <tab heading="Tab 1"><b>First</b> Content!</tab>
	      <tab heading="Tab 2"><i>Second</i> Content!</tab>
	    </tabset>
	    <hr />
	    <tabset vertical="true">
	      <tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</tab>
	      <tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</tab>
	    </tabset>
	    <tabset justified="true">
	      <tab heading="Justified Tab 1"><b>First</b> Justified Content!</tab>
	      <tab heading="Justified Tab 2"><i>Second</i> Justified Content!</tab>
	    </tabset>
	  </file>
	</example>
	 */
	.directive('tabset', function() {
	  return {
	    restrict: 'EA',
	    transclude: true,
	    replace: true,
	    scope: {
	      type: '@'
	    },
	    controller: 'TabsetController',
	    templateUrl: 'template/tabs/tabset.html',
	    link: function(scope, element, attrs) {
	      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
	      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
	    }
	  };
	})
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tab
	 * @restrict EA
	 *
	 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
	 * @param {string=} select An expression to evaluate when the tab is selected.
	 * @param {boolean=} active A binding, telling whether or not this tab is selected.
	 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
	 *
	 * @description
	 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <div ng-controller="TabsDemoCtrl">
	      <button class="btn btn-small" ng-click="items[0].active = true">
	        Select item 1, using active binding
	      </button>
	      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
	        Enable/disable item 2, using disabled binding
	      </button>
	      <br />
	      <tabset>
	        <tab heading="Tab 1">First Tab</tab>
	        <tab select="alertMe()">
	          <tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
	          Second Tab, with alert callback and html heading!
	        </tab>
	        <tab ng-repeat="item in items"
	          heading="{{item.title}}"
	          disabled="item.disabled"
	          active="item.active">
	          {{item.content}}
	        </tab>
	      </tabset>
	    </div>
	  </file>
	  <file name="script.js">
	    function TabsDemoCtrl($scope) {
	      $scope.items = [
	        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
	        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
	      ];
	
	      $scope.alertMe = function() {
	        setTimeout(function() {
	          alert("You've selected the alert tab!");
	        });
	      };
	    };
	  </file>
	</example>
	 */
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tabHeading
	 * @restrict EA
	 *
	 * @description
	 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <tabset>
	      <tab>
	        <tab-heading><b>HTML</b> in my titles?!</tab-heading>
	        And some content, too!
	      </tab>
	      <tab>
	        <tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
	        That's right.
	      </tab>
	    </tabset>
	  </file>
	</example>
	 */
	.directive('tab', ['$parse', '$log', function($parse, $log) {
	  return {
	    require: '^tabset',
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/tabs/tab.html',
	    transclude: true,
	    scope: {
	      active: '=?',
	      heading: '@',
	      onSelect: '&select', //This callback is called in contentHeadingTransclude
	                          //once it inserts the tab's content into the dom
	      onDeselect: '&deselect'
	    },
	    controller: function() {
	      //Empty controller so other directives can require being 'under' a tab
	    },
	    link: function(scope, elm, attrs, tabsetCtrl, transclude) {
	      scope.$watch('active', function(active) {
	        if (active) {
	          tabsetCtrl.select(scope);
	        }
	      });
	
	      scope.disabled = false;
	      if (attrs.disable) {
	        scope.$parent.$watch($parse(attrs.disable), function(value) {
	          scope.disabled = !! value;
	        });
	      }
	
	      // Deprecation support of "disabled" parameter
	      // fix(tab): IE9 disabled attr renders grey text on enabled tab #2677
	      // This code is duplicated from the lines above to make it easy to remove once
	      // the feature has been completely deprecated
	      if (attrs.disabled) {
	        $log.warn('Use of "disabled" attribute has been deprecated, please use "disable"');
	        scope.$parent.$watch($parse(attrs.disabled), function(value) {
	          scope.disabled = !! value;
	        });
	      }
	
	      scope.select = function() {
	        if (!scope.disabled) {
	          scope.active = true;
	        }
	      };
	
	      tabsetCtrl.addTab(scope);
	      scope.$on('$destroy', function() {
	        tabsetCtrl.removeTab(scope);
	      });
	
	      //We need to transclude later, once the content container is ready.
	      //when this link happens, we're inside a tab heading.
	      scope.$transcludeFn = transclude;
	    }
	  };
	}])
	
	.directive('tabHeadingTransclude', function() {
	  return {
	    restrict: 'A',
	    require: '^tab',
	    link: function(scope, elm, attrs, tabCtrl) {
	      scope.$watch('headingElement', function updateHeadingElement(heading) {
	        if (heading) {
	          elm.html('');
	          elm.append(heading);
	        }
	      });
	    }
	  };
	})
	
	.directive('tabContentTransclude', function() {
	  return {
	    restrict: 'A',
	    require: '^tabset',
	    link: function(scope, elm, attrs) {
	      var tab = scope.$eval(attrs.tabContentTransclude);
	
	      //Now our tab is ready to be transcluded: both the tab heading area
	      //and the tab content area are loaded.  Transclude 'em both.
	      tab.$transcludeFn(tab.$parent, function(contents) {
	        angular.forEach(contents, function(node) {
	          if (isTabHeading(node)) {
	            //Let tabHeadingTransclude know.
	            tab.headingElement = node;
	          } else {
	            elm.append(node);
	          }
	        });
	      });
	    }
	  };
	
	  function isTabHeading(node) {
	    return node.tagName && (
	      node.hasAttribute('tab-heading') ||
	      node.hasAttribute('data-tab-heading') ||
	      node.hasAttribute('x-tab-heading') ||
	      node.tagName.toLowerCase() === 'tab-heading' ||
	      node.tagName.toLowerCase() === 'data-tab-heading' ||
	      node.tagName.toLowerCase() === 'x-tab-heading'
	    );
	  }
	});
	
	angular.module('ui.bootstrap.timepicker', [])
	
	.constant('timepickerConfig', {
	  hourStep: 1,
	  minuteStep: 1,
	  showMeridian: true,
	  meridians: null,
	  readonlyInput: false,
	  mousewheel: true,
	  arrowkeys: true,
	  showSpinners: true
	})
	
	.controller('TimepickerController', ['$scope', '$attrs', '$parse', '$log', '$locale', 'timepickerConfig', function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
	  var selected = new Date(),
	      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
	      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
	
	  this.init = function(ngModelCtrl_, inputs) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelCtrl.$render = this.render;
	
	    ngModelCtrl.$formatters.unshift(function(modelValue) {
	      return modelValue ? new Date(modelValue) : null;
	    });
	
	    var hoursInputEl = inputs.eq(0),
	        minutesInputEl = inputs.eq(1);
	
	    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
	    if (mousewheel) {
	      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);
	    }
	
	    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
	    if (arrowkeys) {
	      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);
	    }
	
	    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
	    this.setupInputEvents(hoursInputEl, minutesInputEl);
	  };
	
	  var hourStep = timepickerConfig.hourStep;
	  if ($attrs.hourStep) {
	    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
	      hourStep = parseInt(value, 10);
	    });
	  }
	
	  var minuteStep = timepickerConfig.minuteStep;
	  if ($attrs.minuteStep) {
	    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
	      minuteStep = parseInt(value, 10);
	    });
	  }
	
	  var min;
	  $scope.$parent.$watch($parse($attrs.min), function(value) {
	    var dt = new Date(value);
	    min = isNaN(dt) ? undefined : dt;
	  });
	
	  var max;
	  $scope.$parent.$watch($parse($attrs.max), function(value) {
	    var dt = new Date(value);
	    max = isNaN(dt) ? undefined : dt;
	  });
	
	  $scope.noIncrementHours = function() {
	    var incrementedSelected = addMinutes(selected, hourStep * 60);
	    return incrementedSelected > max ||
	      (incrementedSelected < selected && incrementedSelected < min);
	  };
	
	  $scope.noDecrementHours = function() {
	    var decrementedSelected = addMinutes(selected, -hourStep * 60);
	    return decrementedSelected < min ||
	      (decrementedSelected > selected && decrementedSelected > max);
	  };
	
	  $scope.noIncrementMinutes = function() {
	    var incrementedSelected = addMinutes(selected, minuteStep);
	    return incrementedSelected > max ||
	      (incrementedSelected < selected && incrementedSelected < min);
	  };
	
	  $scope.noDecrementMinutes = function() {
	    var decrementedSelected = addMinutes(selected, -minuteStep);
	    return decrementedSelected < min ||
	      (decrementedSelected > selected && decrementedSelected > max);
	  };
	
	  $scope.noToggleMeridian = function() {
	    if (selected.getHours() < 13) {
	      return addMinutes(selected, 12 * 60) > max;
	    } else {
	      return addMinutes(selected, -12 * 60) < min;
	    }
	  };
	
	  // 12H / 24H mode
	  $scope.showMeridian = timepickerConfig.showMeridian;
	  if ($attrs.showMeridian) {
	    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
	      $scope.showMeridian = !!value;
	
	      if (ngModelCtrl.$error.time) {
	        // Evaluate from template
	        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
	        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
	          selected.setHours(hours);
	          refresh();
	        }
	      } else {
	        updateTemplate();
	      }
	    });
	  }
	
	  // Get $scope.hours in 24H mode if valid
	  function getHoursFromTemplate() {
	    var hours = parseInt($scope.hours, 10);
	    var valid = $scope.showMeridian ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
	    if (!valid) {
	      return undefined;
	    }
	
	    if ($scope.showMeridian) {
	      if (hours === 12) {
	        hours = 0;
	      }
	      if ($scope.meridian === meridians[1]) {
	        hours = hours + 12;
	      }
	    }
	    return hours;
	  }
	
	  function getMinutesFromTemplate() {
	    var minutes = parseInt($scope.minutes, 10);
	    return (minutes >= 0 && minutes < 60) ? minutes : undefined;
	  }
	
	  function pad(value) {
	    return (angular.isDefined(value) && value.toString().length < 2) ? '0' + value : value.toString();
	  }
	
	  // Respond on mousewheel spin
	  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {
	    var isScrollingUp = function(e) {
	      if (e.originalEvent) {
	        e = e.originalEvent;
	      }
	      //pick correct delta variable depending on event
	      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
	      return (e.detail || delta > 0);
	    };
	
	    hoursInputEl.bind('mousewheel wheel', function(e) {
	      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
	      e.preventDefault();
	    });
	
	    minutesInputEl.bind('mousewheel wheel', function(e) {
	      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
	      e.preventDefault();
	    });
	
	  };
	
	  // Respond on up/down arrowkeys
	  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {
	    hoursInputEl.bind('keydown', function(e) {
	      if (e.which === 38) { // up
	        e.preventDefault();
	        $scope.incrementHours();
	        $scope.$apply();
	      } else if (e.which === 40) { // down
	        e.preventDefault();
	        $scope.decrementHours();
	        $scope.$apply();
	      }
	    });
	
	    minutesInputEl.bind('keydown', function(e) {
	      if (e.which === 38) { // up
	        e.preventDefault();
	        $scope.incrementMinutes();
	        $scope.$apply();
	      } else if (e.which === 40) { // down
	        e.preventDefault();
	        $scope.decrementMinutes();
	        $scope.$apply();
	      }
	    });
	  };
	
	  this.setupInputEvents = function(hoursInputEl, minutesInputEl) {
	    if ($scope.readonlyInput) {
	      $scope.updateHours = angular.noop;
	      $scope.updateMinutes = angular.noop;
	      return;
	    }
	
	    var invalidate = function(invalidHours, invalidMinutes) {
	      ngModelCtrl.$setViewValue(null);
	      ngModelCtrl.$setValidity('time', false);
	      if (angular.isDefined(invalidHours)) {
	        $scope.invalidHours = invalidHours;
	      }
	      if (angular.isDefined(invalidMinutes)) {
	        $scope.invalidMinutes = invalidMinutes;
	      }
	    };
	
	    $scope.updateHours = function() {
	      var hours = getHoursFromTemplate(),
	        minutes = getMinutesFromTemplate();
	
	      if (angular.isDefined(hours) && angular.isDefined(minutes)) {
	        selected.setHours(hours);
	        if (selected < min || selected > max) {
	          invalidate(true);
	        } else {
	          refresh('h');
	        }
	      } else {
	        invalidate(true);
	      }
	    };
	
	    hoursInputEl.bind('blur', function(e) {
	      if (!$scope.invalidHours && $scope.hours < 10) {
	        $scope.$apply(function() {
	          $scope.hours = pad($scope.hours);
	        });
	      }
	    });
	
	    $scope.updateMinutes = function() {
	      var minutes = getMinutesFromTemplate(),
	        hours = getHoursFromTemplate();
	
	      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
	        selected.setMinutes(minutes);
	        if (selected < min || selected > max) {
	          invalidate(undefined, true);
	        } else {
	          refresh('m');
	        }
	      } else {
	        invalidate(undefined, true);
	      }
	    };
	
	    minutesInputEl.bind('blur', function(e) {
	      if (!$scope.invalidMinutes && $scope.minutes < 10) {
	        $scope.$apply(function() {
	          $scope.minutes = pad($scope.minutes);
	        });
	      }
	    });
	
	  };
	
	  this.render = function() {
	    var date = ngModelCtrl.$viewValue;
	
	    if (isNaN(date)) {
	      ngModelCtrl.$setValidity('time', false);
	      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	    } else {
	      if (date) {
	        selected = date;
	      }
	
	      if (selected < min || selected > max) {
	        ngModelCtrl.$setValidity('time', false);
	        $scope.invalidHours = true;
	        $scope.invalidMinutes = true;
	      } else {
	        makeValid();
	      }
	      updateTemplate();
	    }
	  };
	
	  // Call internally when we know that model is valid.
	  function refresh(keyboardChange) {
	    makeValid();
	    ngModelCtrl.$setViewValue(new Date(selected));
	    updateTemplate(keyboardChange);
	  }
	
	  function makeValid() {
	    ngModelCtrl.$setValidity('time', true);
	    $scope.invalidHours = false;
	    $scope.invalidMinutes = false;
	  }
	
	  function updateTemplate(keyboardChange) {
	    var hours = selected.getHours(), minutes = selected.getMinutes();
	
	    if ($scope.showMeridian) {
	      hours = (hours === 0 || hours === 12) ? 12 : hours % 12; // Convert 24 to 12 hour system
	    }
	
	    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
	    if (keyboardChange !== 'm') {
	      $scope.minutes = pad(minutes);
	    }
	    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
	  }
	
	  function addMinutes(date, minutes) {
	    var dt = new Date(date.getTime() + minutes * 60000);
	    var newDate = new Date(date);
	    newDate.setHours(dt.getHours(), dt.getMinutes());
	    return newDate;
	  }
	
	  function addMinutesToSelected(minutes) {
	    selected = addMinutes(selected, minutes);
	    refresh();
	  }
	
	  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
	    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
	
	  $scope.incrementHours = function() {
	    if (!$scope.noIncrementHours()) {
	      addMinutesToSelected(hourStep * 60);
	    }
	  };
	
	  $scope.decrementHours = function() {
	    if (!$scope.noDecrementHours()) {
	      addMinutesToSelected(-hourStep * 60);
	    }
	  };
	
	  $scope.incrementMinutes = function() {
	    if (!$scope.noIncrementMinutes()) {
	      addMinutesToSelected(minuteStep);
	    }
	  };
	
	  $scope.decrementMinutes = function() {
	    if (!$scope.noDecrementMinutes()) {
	      addMinutesToSelected(-minuteStep);
	    }
	  };
	
	  $scope.toggleMeridian = function() {
	    if (!$scope.noToggleMeridian()) {
	      addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));
	    }
	  };
	}])
	
	.directive('timepicker', function() {
	  return {
	    restrict: 'EA',
	    require: ['timepicker', '?^ngModel'],
	    controller:'TimepickerController',
	    controllerAs: 'timepicker',
	    replace: true,
	    scope: {},
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/timepicker/timepicker.html';
	    },
	    link: function(scope, element, attrs, ctrls) {
	      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      if (ngModelCtrl) {
	        timepickerCtrl.init(ngModelCtrl, element.find('input'));
	      }
	    }
	  };
	});
	
	angular.module('ui.bootstrap.transition', [])
	
	.value('$transitionSuppressDeprecated', false)
	/**
	 * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.
	 * @param  {DOMElement} element  The DOMElement that will be animated.
	 * @param  {string|object|function} trigger  The thing that will cause the transition to start:
	 *   - As a string, it represents the css class to be added to the element.
	 *   - As an object, it represents a hash of style attributes to be applied to the element.
	 *   - As a function, it represents a function to be called that will cause the transition to occur.
	 * @return {Promise}  A promise that is resolved when the transition finishes.
	 */
	.factory('$transition', [
	        '$q', '$timeout', '$rootScope', '$log', '$transitionSuppressDeprecated',
	function($q ,  $timeout ,  $rootScope ,  $log ,  $transitionSuppressDeprecated) {
	
	  if (!$transitionSuppressDeprecated) {
	    $log.warn('$transition is now deprecated. Use $animate from ngAnimate instead.');
	  }
	
	  var $transition = function(element, trigger, options) {
	    options = options || {};
	    var deferred = $q.defer();
	    var endEventName = $transition[options.animation ? 'animationEndEventName' : 'transitionEndEventName'];
	
	    var transitionEndHandler = function(event) {
	      $rootScope.$apply(function() {
	        element.unbind(endEventName, transitionEndHandler);
	        deferred.resolve(element);
	      });
	    };
	
	    if (endEventName) {
	      element.bind(endEventName, transitionEndHandler);
	    }
	
	    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
	    $timeout(function() {
	      if ( angular.isString(trigger) ) {
	        element.addClass(trigger);
	      } else if ( angular.isFunction(trigger) ) {
	        trigger(element);
	      } else if ( angular.isObject(trigger) ) {
	        element.css(trigger);
	      }
	      //If browser does not support transitions, instantly resolve
	      if ( !endEventName ) {
	        deferred.resolve(element);
	      }
	    });
	
	    // Add our custom cancel function to the promise that is returned
	    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
	    // i.e. it will therefore never raise a transitionEnd event for that transition
	    deferred.promise.cancel = function() {
	      if ( endEventName ) {
	        element.unbind(endEventName, transitionEndHandler);
	      }
	      deferred.reject('Transition cancelled');
	    };
	
	    return deferred.promise;
	  };
	
	  // Work out the name of the transitionEnd event
	  var transElement = document.createElement('trans');
	  var transitionEndEventNames = {
	    'WebkitTransition': 'webkitTransitionEnd',
	    'MozTransition': 'transitionend',
	    'OTransition': 'oTransitionEnd',
	    'transition': 'transitionend'
	  };
	  var animationEndEventNames = {
	    'WebkitTransition': 'webkitAnimationEnd',
	    'MozTransition': 'animationend',
	    'OTransition': 'oAnimationEnd',
	    'transition': 'animationend'
	  };
	  function findEndEventName(endEventNames) {
	    for (var name in endEventNames){
	      if (transElement.style[name] !== undefined) {
	        return endEventNames[name];
	      }
	    }
	  }
	  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
	  $transition.animationEndEventName = findEndEventName(animationEndEventNames);
	  return $transition;
	}]);
	
	angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position'])
	
	/**
	 * A helper service that can parse typeahead's syntax (string provided by users)
	 * Extracted to a separate service for ease of unit testing
	 */
	  .factory('typeaheadParser', ['$parse', function($parse) {
	
	  //                      00000111000000000000022200000000000000003333333333333330000000000044000
	  var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
	
	  return {
	    parse: function(input) {
	      var match = input.match(TYPEAHEAD_REGEXP);
	      if (!match) {
	        throw new Error(
	          'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
	            ' but got "' + input + '".');
	      }
	
	      return {
	        itemName:match[3],
	        source:$parse(match[4]),
	        viewMapper:$parse(match[2] || match[1]),
	        modelMapper:$parse(match[1])
	      };
	    }
	  };
	}])
	
	  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$position', 'typeaheadParser',
	    function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {
	    var HOT_KEYS = [9, 13, 27, 38, 40];
	    var eventDebounceTime = 200;
	
	    return {
	      require: ['ngModel', '^?ngModelOptions'],
	      link: function(originalScope, element, attrs, ctrls) {
	        var modelCtrl = ctrls[0];
	        var ngModelOptions = ctrls[1];
	        //SUPPORTED ATTRIBUTES (OPTIONS)
	
	        //minimal no of characters that needs to be entered before typeahead kicks-in
	        var minLength = originalScope.$eval(attrs.typeaheadMinLength);
	        if (!minLength && minLength !== 0) {
	          minLength = 1;
	        }
	
	        //minimal wait time after last character typed before typeahead kicks-in
	        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
	
	        //should it restrict model values to the ones selected from the popup only?
	        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
	
	        //binding to a variable that indicates if matches are being retrieved asynchronously
	        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
	
	        //a callback executed when a match is selected
	        var onSelectCallback = $parse(attrs.typeaheadOnSelect);
	
	        //should it select highlighted popup value when losing focus?
	        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
	
	        //binding to a variable that indicates if there were no results after the query is completed
	        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
	
	        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
	
	        var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
	
	        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
	
	        //If input matches an item of the list exactly, select it automatically
	        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
	
	        //INTERNAL VARIABLES
	
	        //model setter executed upon match selection
	        var parsedModel = $parse(attrs.ngModel);
	        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
	        var $setModelValue = function(scope, newValue) {
	          if (angular.isFunction(parsedModel(originalScope)) &&
	            ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
	            return invokeModelSetter(scope, {$$$p: newValue});
	          } else {
	            return parsedModel.assign(scope, newValue);
	          }
	        };
	
	        //expressions used by typeahead
	        var parserResult = typeaheadParser.parse(attrs.typeahead);
	
	        var hasFocus;
	
	        //Used to avoid bug in iOS webview where iOS keyboard does not fire
	        //mousedown & mouseup events
	        //Issue #3699
	        var selected;
	
	        //create a child scope for the typeahead directive so we are not polluting original scope
	        //with typeahead-specific data (matches, query etc.)
	        var scope = originalScope.$new();
	        var offDestroy = originalScope.$on('$destroy', function() {
				    scope.$destroy();
	        });
	        scope.$on('$destroy', offDestroy);
	
	        // WAI-ARIA
	        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
	        element.attr({
	          'aria-autocomplete': 'list',
	          'aria-expanded': false,
	          'aria-owns': popupId
	        });
	
	        //pop-up element used to display matches
	        var popUpEl = angular.element('<div typeahead-popup></div>');
	        popUpEl.attr({
	          id: popupId,
	          matches: 'matches',
	          active: 'activeIdx',
	          select: 'select(activeIdx)',
	          'move-in-progress': 'moveInProgress',
	          query: 'query',
	          position: 'position'
	        });
	        //custom item template
	        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
	          popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
	        }
	
	        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
	          popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
	        }
	
	        var resetMatches = function() {
	          scope.matches = [];
	          scope.activeIdx = -1;
	          element.attr('aria-expanded', false);
	        };
	
	        var getMatchId = function(index) {
	          return popupId + '-option-' + index;
	        };
	
	        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
	        // This attribute is added or removed automatically when the `activeIdx` changes.
	        scope.$watch('activeIdx', function(index) {
	          if (index < 0) {
	            element.removeAttr('aria-activedescendant');
	          } else {
	            element.attr('aria-activedescendant', getMatchId(index));
	          }
	        });
	
	        var inputIsExactMatch = function(inputValue, index) {
	          if (scope.matches.length > index && inputValue) {
	            return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
	          }
	
	          return false;
	        };
	
	        var getMatchesAsync = function(inputValue) {
	          var locals = {$viewValue: inputValue};
	          isLoadingSetter(originalScope, true);
	          isNoResultsSetter(originalScope, false);
	          $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
	            //it might happen that several async queries were in progress if a user were typing fast
	            //but we are interested only in responses that correspond to the current view value
	            var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
	            if (onCurrentRequest && hasFocus) {
	              if (matches && matches.length > 0) {
	
	                scope.activeIdx = focusFirst ? 0 : -1;
	                isNoResultsSetter(originalScope, false);
	                scope.matches.length = 0;
	
	                //transform labels
	                for (var i = 0; i < matches.length; i++) {
	                  locals[parserResult.itemName] = matches[i];
	                  scope.matches.push({
	                    id: getMatchId(i),
	                    label: parserResult.viewMapper(scope, locals),
	                    model: matches[i]
	                  });
	                }
	
	                scope.query = inputValue;
	                //position pop-up with matches - we need to re-calculate its position each time we are opening a window
	                //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
	                //due to other elements being rendered
	                recalculatePosition();
	
	                element.attr('aria-expanded', true);
	
	                //Select the single remaining option if user input matches
	                if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
	                  scope.select(0);
	                }
	              } else {
	                resetMatches();
	                isNoResultsSetter(originalScope, true);
	              }
	            }
	            if (onCurrentRequest) {
	              isLoadingSetter(originalScope, false);
	            }
	          }, function() {
	            resetMatches();
	            isLoadingSetter(originalScope, false);
	            isNoResultsSetter(originalScope, true);
	          });
	        };
	
	        // bind events only if appendToBody params exist - performance feature
	        if (appendToBody) {
	          angular.element($window).bind('resize', fireRecalculating);
	          $document.find('body').bind('scroll', fireRecalculating);
	        }
	
	        // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
	        var timeoutEventPromise;
	
	        // Default progress type
	        scope.moveInProgress = false;
	
	        function fireRecalculating() {
	          if (!scope.moveInProgress) {
	            scope.moveInProgress = true;
	            scope.$digest();
	          }
	
	          // Cancel previous timeout
	          if (timeoutEventPromise) {
	            $timeout.cancel(timeoutEventPromise);
	          }
	
	          // Debounced executing recalculate after events fired
	          timeoutEventPromise = $timeout(function() {
	            // if popup is visible
	            if (scope.matches.length) {
	              recalculatePosition();
	            }
	
	            scope.moveInProgress = false;
	            scope.$digest();
	          }, eventDebounceTime);
	        }
	
	        // recalculate actual position and set new values to scope
	        // after digest loop is popup in right position
	        function recalculatePosition() {
	          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	          scope.position.top += element.prop('offsetHeight');
	        }
	
	        resetMatches();
	
	        //we need to propagate user's query so we can higlight matches
	        scope.query = undefined;
	
	        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
	        var timeoutPromise;
	
	        var scheduleSearchWithTimeout = function(inputValue) {
	          timeoutPromise = $timeout(function() {
	            getMatchesAsync(inputValue);
	          }, waitTime);
	        };
	
	        var cancelPreviousTimeout = function() {
	          if (timeoutPromise) {
	            $timeout.cancel(timeoutPromise);
	          }
	        };
	
	        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
	        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
	        modelCtrl.$parsers.unshift(function(inputValue) {
	          hasFocus = true;
	
	          if (minLength === 0 || inputValue && inputValue.length >= minLength) {
	            if (waitTime > 0) {
	              cancelPreviousTimeout();
	              scheduleSearchWithTimeout(inputValue);
	            } else {
	              getMatchesAsync(inputValue);
	            }
	          } else {
	            isLoadingSetter(originalScope, false);
	            cancelPreviousTimeout();
	            resetMatches();
	          }
	
	          if (isEditable) {
	            return inputValue;
	          } else {
	            if (!inputValue) {
	              // Reset in case user had typed something previously.
	              modelCtrl.$setValidity('editable', true);
	              return null;
	            } else {
	              modelCtrl.$setValidity('editable', false);
	              return undefined;
	            }
	          }
	        });
	
	        modelCtrl.$formatters.push(function(modelValue) {
	          var candidateViewValue, emptyViewValue;
	          var locals = {};
	
	          // The validity may be set to false via $parsers (see above) if
	          // the model is restricted to selected values. If the model
	          // is set manually it is considered to be valid.
	          if (!isEditable) {
	            modelCtrl.$setValidity('editable', true);
	          }
	
	          if (inputFormatter) {
	            locals.$model = modelValue;
	            return inputFormatter(originalScope, locals);
	          } else {
	            //it might happen that we don't have enough info to properly render input value
	            //we need to check for this situation and simply return model value if we can't apply custom formatting
	            locals[parserResult.itemName] = modelValue;
	            candidateViewValue = parserResult.viewMapper(originalScope, locals);
	            locals[parserResult.itemName] = undefined;
	            emptyViewValue = parserResult.viewMapper(originalScope, locals);
	
	            return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;
	          }
	        });
	
	        scope.select = function(activeIdx) {
	          //called from within the $digest() cycle
	          var locals = {};
	          var model, item;
	
	          selected = true;
	          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
	          model = parserResult.modelMapper(originalScope, locals);
	          $setModelValue(originalScope, model);
	          modelCtrl.$setValidity('editable', true);
	          modelCtrl.$setValidity('parse', true);
	
	          onSelectCallback(originalScope, {
	            $item: item,
	            $model: model,
	            $label: parserResult.viewMapper(originalScope, locals)
	          });
	
	          resetMatches();
	
	          //return focus to the input element if a match was selected via a mouse click event
	          // use timeout to avoid $rootScope:inprog error
	          if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
	            $timeout(function() { element[0].focus(); }, 0, false);
	          }
	        };
	
	        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
	        element.bind('keydown', function(evt) {
	          //typeahead is open and an "interesting" key was pressed
	          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
	            return;
	          }
	
	          // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results
	          if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {
	            resetMatches();
	            scope.$digest();
	            return;
	          }
	
	          evt.preventDefault();
	
	          if (evt.which === 40) {
	            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
	            scope.$digest();
	
	          } else if (evt.which === 38) {
	            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
	            scope.$digest();
	
	          } else if (evt.which === 13 || evt.which === 9) {
	            scope.$apply(function () {
	              scope.select(scope.activeIdx);
	            });
	
	          } else if (evt.which === 27) {
	            evt.stopPropagation();
	
	            resetMatches();
	            scope.$digest();
	          }
	        });
	
	        element.bind('blur', function() {
	          if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
	            selected = true;
	            scope.$apply(function() {
	              scope.select(scope.activeIdx);
	            });
	          }
	          hasFocus = false;
	          selected = false;
	        });
	
	        // Keep reference to click handler to unbind it.
	        var dismissClickHandler = function(evt) {
	          // Issue #3973
	          // Firefox treats right click as a click on document
	          if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
	            resetMatches();
	            if (!$rootScope.$$phase) {
	              scope.$digest();
	            }
	          }
	        };
	
	        $document.bind('click', dismissClickHandler);
	
	        originalScope.$on('$destroy', function() {
	          $document.unbind('click', dismissClickHandler);
	          if (appendToBody) {
	            $popup.remove();
	          }
	          // Prevent jQuery cache memory leak
	          popUpEl.remove();
	        });
	
	        var $popup = $compile(popUpEl)(scope);
	
	        if (appendToBody) {
	          $document.find('body').append($popup);
	        } else {
	          element.after($popup);
	        }
	      }
	    };
	
	  }])
	
	  .directive('typeaheadPopup', function() {
	    return {
	      restrict: 'EA',
	      scope: {
	        matches: '=',
	        query: '=',
	        active: '=',
	        position: '&',
	        moveInProgress: '=',
	        select: '&'
	      },
	      replace: true,
	      templateUrl: function(element, attrs) {
	        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';
	      },
	      link: function(scope, element, attrs) {
	        scope.templateUrl = attrs.templateUrl;
	
	        scope.isOpen = function() {
	          return scope.matches.length > 0;
	        };
	
	        scope.isActive = function(matchIdx) {
	          return scope.active == matchIdx;
	        };
	
	        scope.selectActive = function(matchIdx) {
	          scope.active = matchIdx;
	        };
	
	        scope.selectMatch = function(activeIdx) {
	          scope.select({activeIdx:activeIdx});
	        };
	      }
	    };
	  })
	
	  .directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
	    return {
	      restrict: 'EA',
	      scope: {
	        index: '=',
	        match: '=',
	        query: '='
	      },
	      link:function(scope, element, attrs) {
	        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
	        $templateRequest(tplUrl).then(function(tplContent) {
	          $compile(tplContent.trim())(scope, function(clonedElement) {
	            element.replaceWith(clonedElement);
	          });
	        });
	      }
	    };
	  }])
	
	  .filter('typeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
	    var isSanitizePresent;
	    isSanitizePresent = $injector.has('$sanitize');
	
	    function escapeRegexp(queryToEscape) {
	      // Regex: capture the whole query string and replace it with the string that will be used to match
	      // the results, for example if the capture is "a" the result will be \a
	      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
	    }
	
	    function containsHtml(matchItem) {
	      return /<.*>/g.test(matchItem);
	    }
	
	    return function(matchItem, query) {
	      if (!isSanitizePresent && containsHtml(matchItem)) {
	        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
	      }
	      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
	      if (!isSanitizePresent) {
	        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
	      }
	      return matchItem;
	    };
	  }]);
	
	angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/accordion/accordion-group.html",
	    "<div class=\"panel {{panelClass || 'panel-default'}}\">\n" +
	    "  <div class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" +
	    "    <h4 class=\"panel-title\">\n" +
	    "      <a href tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" accordion-transclude=\"heading\"><span ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" +
	    "    </h4>\n" +
	    "  </div>\n" +
	    "  <div class=\"panel-collapse collapse\" collapse=\"!isOpen\">\n" +
	    "	  <div class=\"panel-body\" ng-transclude></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/accordion/accordion.html",
	    "<div class=\"panel-group\" ng-transclude></div>");
	}]);
	
	angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/alert/alert.html",
	    "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\">\n" +
	    "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close($event)\">\n" +
	    "        <span aria-hidden=\"true\">&times;</span>\n" +
	    "        <span class=\"sr-only\">Close</span>\n" +
	    "    </button>\n" +
	    "    <div ng-transclude></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/carousel/carousel.html",
	    "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" +
	    "    <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
	    "        <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{active: isActive(slide)}\" ng-click=\"select(slide)\"></li>\n" +
	    "    </ol>\n" +
	    "    <div class=\"carousel-inner\" ng-transclude></div>\n" +
	    "    <a class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\"><span class=\"glyphicon glyphicon-chevron-left\"></span></a>\n" +
	    "    <a class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\"><span class=\"glyphicon glyphicon-chevron-right\"></span></a>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/carousel/slide.html",
	    "<div ng-class=\"{\n" +
	    "    'active': active\n" +
	    "  }\" class=\"item text-center\" ng-transclude></div>\n" +
	    "");
	}]);
	
	angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/datepicker.html",
	    "<div ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" +
	    "  <daypicker ng-switch-when=\"day\" tabindex=\"0\"></daypicker>\n" +
	    "  <monthpicker ng-switch-when=\"month\" tabindex=\"0\"></monthpicker>\n" +
	    "  <yearpicker ng-switch-when=\"year\" tabindex=\"0\"></yearpicker>\n" +
	    "</div>");
	}]);
	
	angular.module("template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/day.html",
	    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	    "  <thead>\n" +
	    "    <tr>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	    "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	    "    </tr>\n" +
	    "    <tr>\n" +
	    "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
	    "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
	    "    </tr>\n" +
	    "  </thead>\n" +
	    "  <tbody>\n" +
	    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
	    "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
	    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" +
	    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default btn-sm\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	    "      </td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);
	
	angular.module("template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/month.html",
	    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	    "  <thead>\n" +
	    "    <tr>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	    "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	    "    </tr>\n" +
	    "  </thead>\n" +
	    "  <tbody>\n" +
	    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
	    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" +
	    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	    "      </td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);
	
	angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/popup.html",
	    "<ul class=\"dropdown-menu\" ng-if=\"isOpen\" style=\"display: block\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
	    "	<li ng-transclude></li>\n" +
	    "	<li ng-if=\"showButtonBar\" style=\"padding:10px 9px 2px\">\n" +
	    "		<span class=\"btn-group pull-left\">\n" +
	    "			<button type=\"button\" class=\"btn btn-sm btn-info\" ng-click=\"select('today')\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
	    "			<button type=\"button\" class=\"btn btn-sm btn-danger\" ng-click=\"select(null)\">{{ getText('clear') }}</button>\n" +
	    "		</span>\n" +
	    "		<button type=\"button\" class=\"btn btn-sm btn-success pull-right\" ng-click=\"close()\">{{ getText('close') }}</button>\n" +
	    "	</li>\n" +
	    "</ul>\n" +
	    "");
	}]);
	
	angular.module("template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/year.html",
	    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	    "  <thead>\n" +
	    "    <tr>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	    "      <th colspan=\"3\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	    "    </tr>\n" +
	    "  </thead>\n" +
	    "  <tbody>\n" +
	    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
	    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\">\n" +
	    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	    "      </td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);
	
	angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/modal/backdrop.html",
	    "<div class=\"modal-backdrop\"\n" +
	    "     modal-animation-class=\"fade\"\n" +
	    "     modal-in-class=\"in\"\n" +
	    "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" +
	    "></div>\n" +
	    "");
	}]);
	
	angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/modal/window.html",
	    "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" +
	    "    modal-animation-class=\"fade\"\n" +
	    "    modal-in-class=\"in\"\n" +
	    "	ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\" ng-click=\"close($event)\">\n" +
	    "    <div class=\"modal-dialog\" ng-class=\"size ? 'modal-' + size : ''\"><div class=\"modal-content\" modal-transclude></div></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/pagination/pager.html",
	    "<ul class=\"pager\">\n" +
	    "  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
	    "  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
	    "</ul>\n" +
	    "");
	}]);
	
	angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/pagination/pagination.html",
	    "<ul class=\"pagination\">\n" +
	    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\">{{::getText('first')}}</a></li>\n" +
	    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
	    "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\n" +
	    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
	    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\">{{::getText('last')}}</a></li>\n" +
	    "</ul>\n" +
	    "");
	}]);
	
	angular.module("template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tooltip/tooltip-html-popup.html",
	    "<div class=\"tooltip\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html",
	    "<div class=\"tooltip\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\" bind-html-unsafe=\"content\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tooltip/tooltip-popup.html",
	    "<div class=\"tooltip\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tooltip/tooltip-template-popup.html",
	    "<div class=\"tooltip\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\"\n" +
	    "    tooltip-template-transclude=\"contentExp()\"\n" +
	    "    tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/popover/popover-html.html",
	    "<div class=\"popover\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"arrow\"></div>\n" +
	    "\n" +
	    "  <div class=\"popover-inner\">\n" +
	    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
	    "      <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/popover/popover-template.html",
	    "<div class=\"popover\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"arrow\"></div>\n" +
	    "\n" +
	    "  <div class=\"popover-inner\">\n" +
	    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
	    "      <div class=\"popover-content\"\n" +
	    "        tooltip-template-transclude=\"contentExp()\"\n" +
	    "        tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/popover/popover.html",
	    "<div class=\"popover\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"arrow\"></div>\n" +
	    "\n" +
	    "  <div class=\"popover-inner\">\n" +
	    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
	    "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/progressbar/bar.html",
	    "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" style=\"min-width: 0;\" ng-transclude></div>\n" +
	    "");
	}]);
	
	angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/progressbar/progress.html",
	    "<div class=\"progress\" ng-transclude></div>");
	}]);
	
	angular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/progressbar/progressbar.html",
	    "<div class=\"progress\">\n" +
	    "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" style=\"min-width: 0;\" ng-transclude></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/rating/rating.html",
	    "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\">\n" +
	    "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
	    "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\" ></i>\n" +
	    "</span>\n" +
	    "");
	}]);
	
	angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tabs/tab.html",
	    "<li ng-class=\"{active: active, disabled: disabled}\">\n" +
	    "  <a href ng-click=\"select()\" tab-heading-transclude>{{heading}}</a>\n" +
	    "</li>\n" +
	    "");
	}]);
	
	angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tabs/tabset.html",
	    "<div>\n" +
	    "  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
	    "  <div class=\"tab-content\">\n" +
	    "    <div class=\"tab-pane\" \n" +
	    "         ng-repeat=\"tab in tabs\" \n" +
	    "         ng-class=\"{active: tab.active}\"\n" +
	    "         tab-content-transclude=\"tab\">\n" +
	    "    </div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/timepicker/timepicker.html",
	    "<table>\n" +
	    "  <tbody>\n" +
	    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
	    "      <td><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	    "      <td>&nbsp;</td>\n" +
	    "      <td><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	    "      <td ng-show=\"showMeridian\"></td>\n" +
	    "    </tr>\n" +
	    "    <tr>\n" +
	    "      <td class=\"form-group\" ng-class=\"{'has-error': invalidHours}\">\n" +
	    "        <input style=\"width:50px;\" type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\">\n" +
	    "      </td>\n" +
	    "      <td>:</td>\n" +
	    "      <td class=\"form-group\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
	    "        <input style=\"width:50px;\" type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\">\n" +
	    "      </td>\n" +
	    "      <td ng-show=\"showMeridian\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\">{{meridian}}</button></td>\n" +
	    "    </tr>\n" +
	    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
	    "      <td><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	    "      <td>&nbsp;</td>\n" +
	    "      <td><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	    "      <td ng-show=\"showMeridian\"></td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);
	
	angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/typeahead/typeahead-match.html",
	    "<a href tabindex=\"-1\" ng-bind-html=\"match.label | typeaheadHighlight:query\"></a>\n" +
	    "");
	}]);
	
	angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/typeahead/typeahead-popup.html",
	    "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" style=\"display: block;\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
	    "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\" role=\"option\" id=\"{{::match.id}}\">\n" +
	    "        <div typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
	    "    </li>\n" +
	    "</ul>\n" +
	    "");
	}]);
	!angular.$$csp() && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(5);
	module.exports = 'ngSanitize';


/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * @license AngularJS v1.4.7
	 * (c) 2010-2015 Google, Inc. http://angularjs.org
	 * License: MIT
	 */
	(function(window, angular, undefined) {'use strict';
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 *     Any commits to this file should be reviewed with security in mind.  *
	 *   Changes to this file can potentially create security vulnerabilities. *
	 *          An approval from 2 Core members with history of modifying      *
	 *                         this file is required.                          *
	 *                                                                         *
	 *  Does the change somehow allow for arbitrary javascript to be executed? *
	 *    Or allows for someone to change the prototype of built-in objects?   *
	 *     Or gives undesired access to variables likes document or window?    *
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
	
	var $sanitizeMinErr = angular.$$minErr('$sanitize');
	
	/**
	 * @ngdoc module
	 * @name ngSanitize
	 * @description
	 *
	 * # ngSanitize
	 *
	 * The `ngSanitize` module provides functionality to sanitize HTML.
	 *
	 *
	 * <div doc-module-components="ngSanitize"></div>
	 *
	 * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
	 */
	
	/*
	 * HTML Parser By Misko Hevery (misko@hevery.com)
	 * based on:  HTML Parser By John Resig (ejohn.org)
	 * Original code by Erik Arvidsson, Mozilla Public License
	 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
	 *
	 * // Use like so:
	 * htmlParser(htmlString, {
	 *     start: function(tag, attrs, unary) {},
	 *     end: function(tag) {},
	 *     chars: function(text) {},
	 *     comment: function(text) {}
	 * });
	 *
	 */
	
	
	/**
	 * @ngdoc service
	 * @name $sanitize
	 * @kind function
	 *
	 * @description
	 *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
	 *   then serialized back to properly escaped html string. This means that no unsafe input can make
	 *   it into the returned string, however, since our parser is more strict than a typical browser
	 *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a
	 *   browser, won't make it through the sanitizer. The input may also contain SVG markup.
	 *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and
	 *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.
	 *
	 * @param {string} html HTML input.
	 * @returns {string} Sanitized HTML.
	 *
	 * @example
	   <example module="sanitizeExample" deps="angular-sanitize.js">
	   <file name="index.html">
	     <script>
	         angular.module('sanitizeExample', ['ngSanitize'])
	           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
	             $scope.snippet =
	               '<p style="color:blue">an html\n' +
	               '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
	               'snippet</p>';
	             $scope.deliberatelyTrustDangerousSnippet = function() {
	               return $sce.trustAsHtml($scope.snippet);
	             };
	           }]);
	     </script>
	     <div ng-controller="ExampleController">
	        Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
	       <table>
	         <tr>
	           <td>Directive</td>
	           <td>How</td>
	           <td>Source</td>
	           <td>Rendered</td>
	         </tr>
	         <tr id="bind-html-with-sanitize">
	           <td>ng-bind-html</td>
	           <td>Automatically uses $sanitize</td>
	           <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
	           <td><div ng-bind-html="snippet"></div></td>
	         </tr>
	         <tr id="bind-html-with-trust">
	           <td>ng-bind-html</td>
	           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
	           <td>
	           <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
	&lt;/div&gt;</pre>
	           </td>
	           <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
	         </tr>
	         <tr id="bind-default">
	           <td>ng-bind</td>
	           <td>Automatically escapes</td>
	           <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
	           <td><div ng-bind="snippet"></div></td>
	         </tr>
	       </table>
	       </div>
	   </file>
	   <file name="protractor.js" type="protractor">
	     it('should sanitize the html snippet by default', function() {
	       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
	         toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
	     });
	
	     it('should inline raw snippet if bound to a trusted value', function() {
	       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).
	         toBe("<p style=\"color:blue\">an html\n" +
	              "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
	              "snippet</p>");
	     });
	
	     it('should escape snippet without any filter', function() {
	       expect(element(by.css('#bind-default div')).getInnerHtml()).
	         toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
	              "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
	              "snippet&lt;/p&gt;");
	     });
	
	     it('should update', function() {
	       element(by.model('snippet')).clear();
	       element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
	       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
	         toBe('new <b>text</b>');
	       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(
	         'new <b onclick="alert(1)">text</b>');
	       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(
	         "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
	     });
	   </file>
	   </example>
	 */
	function $SanitizeProvider() {
	  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
	    return function(html) {
	      var buf = [];
	      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
	        return !/^unsafe/.test($$sanitizeUri(uri, isImage));
	      }));
	      return buf.join('');
	    };
	  }];
	}
	
	function sanitizeText(chars) {
	  var buf = [];
	  var writer = htmlSanitizeWriter(buf, angular.noop);
	  writer.chars(chars);
	  return buf.join('');
	}
	
	
	// Regular Expressions for parsing tags and attributes
	var START_TAG_REGEXP =
	       /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
	  END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
	  ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
	  BEGIN_TAG_REGEXP = /^</,
	  BEGING_END_TAGE_REGEXP = /^<\//,
	  COMMENT_REGEXP = /<!--(.*?)-->/g,
	  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
	  CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
	  SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
	  // Match everything outside of normal chars and " (quote character)
	  NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
	
	
	// Good source of info about elements and attributes
	// http://dev.w3.org/html5/spec/Overview.html#semantics
	// http://simon.html5.org/html-elements
	
	// Safe Void Elements - HTML5
	// http://dev.w3.org/html5/spec/Overview.html#void-elements
	var voidElements = makeMap("area,br,col,hr,img,wbr");
	
	// Elements that you can, intentionally, leave open (and which close themselves)
	// http://dev.w3.org/html5/spec/Overview.html#optional-tags
	var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
	    optionalEndTagInlineElements = makeMap("rp,rt"),
	    optionalEndTagElements = angular.extend({},
	                                            optionalEndTagInlineElements,
	                                            optionalEndTagBlockElements);
	
	// Safe Block Elements - HTML5
	var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," +
	        "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
	        "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
	
	// Inline Elements - HTML5
	var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," +
	        "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
	        "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
	
	// SVG Elements
	// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
	// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.
	// They can potentially allow for arbitrary javascript to be executed. See #11290
	var svgElements = makeMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," +
	        "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," +
	        "radialGradient,rect,stop,svg,switch,text,title,tspan,use");
	
	// Special Elements (can contain anything)
	var specialElements = makeMap("script,style");
	
	var validElements = angular.extend({},
	                                   voidElements,
	                                   blockElements,
	                                   inlineElements,
	                                   optionalEndTagElements,
	                                   svgElements);
	
	//Attributes that have href and hence need to be sanitized
	var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
	
	var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
	    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
	    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
	    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +
	    'valign,value,vspace,width');
	
	// SVG attributes (without "id" and "name" attributes)
	// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
	var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
	    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +
	    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +
	    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +
	    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +
	    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +
	    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +
	    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +
	    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +
	    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +
	    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +
	    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +
	    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +
	    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +
	    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
	
	var validAttrs = angular.extend({},
	                                uriAttrs,
	                                svgAttrs,
	                                htmlAttrs);
	
	function makeMap(str, lowercaseKeys) {
	  var obj = {}, items = str.split(','), i;
	  for (i = 0; i < items.length; i++) {
	    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
	  }
	  return obj;
	}
	
	
	/**
	 * @example
	 * htmlParser(htmlString, {
	 *     start: function(tag, attrs, unary) {},
	 *     end: function(tag) {},
	 *     chars: function(text) {},
	 *     comment: function(text) {}
	 * });
	 *
	 * @param {string} html string
	 * @param {object} handler
	 */
	function htmlParser(html, handler) {
	  if (typeof html !== 'string') {
	    if (html === null || typeof html === 'undefined') {
	      html = '';
	    } else {
	      html = '' + html;
	    }
	  }
	  var index, chars, match, stack = [], last = html, text;
	  stack.last = function() { return stack[stack.length - 1]; };
	
	  while (html) {
	    text = '';
	    chars = true;
	
	    // Make sure we're not in a script or style element
	    if (!stack.last() || !specialElements[stack.last()]) {
	
	      // Comment
	      if (html.indexOf("<!--") === 0) {
	        // comments containing -- are not allowed unless they terminate the comment
	        index = html.indexOf("--", 4);
	
	        if (index >= 0 && html.lastIndexOf("-->", index) === index) {
	          if (handler.comment) handler.comment(html.substring(4, index));
	          html = html.substring(index + 3);
	          chars = false;
	        }
	      // DOCTYPE
	      } else if (DOCTYPE_REGEXP.test(html)) {
	        match = html.match(DOCTYPE_REGEXP);
	
	        if (match) {
	          html = html.replace(match[0], '');
	          chars = false;
	        }
	      // end tag
	      } else if (BEGING_END_TAGE_REGEXP.test(html)) {
	        match = html.match(END_TAG_REGEXP);
	
	        if (match) {
	          html = html.substring(match[0].length);
	          match[0].replace(END_TAG_REGEXP, parseEndTag);
	          chars = false;
	        }
	
	      // start tag
	      } else if (BEGIN_TAG_REGEXP.test(html)) {
	        match = html.match(START_TAG_REGEXP);
	
	        if (match) {
	          // We only have a valid start-tag if there is a '>'.
	          if (match[4]) {
	            html = html.substring(match[0].length);
	            match[0].replace(START_TAG_REGEXP, parseStartTag);
	          }
	          chars = false;
	        } else {
	          // no ending tag found --- this piece should be encoded as an entity.
	          text += '<';
	          html = html.substring(1);
	        }
	      }
	
	      if (chars) {
	        index = html.indexOf("<");
	
	        text += index < 0 ? html : html.substring(0, index);
	        html = index < 0 ? "" : html.substring(index);
	
	        if (handler.chars) handler.chars(decodeEntities(text));
	      }
	
	    } else {
	      // IE versions 9 and 10 do not understand the regex '[^]', so using a workaround with [\W\w].
	      html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'),
	        function(all, text) {
	          text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
	
	          if (handler.chars) handler.chars(decodeEntities(text));
	
	          return "";
	      });
	
	      parseEndTag("", stack.last());
	    }
	
	    if (html == last) {
	      throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " +
	                                        "of html: {0}", html);
	    }
	    last = html;
	  }
	
	  // Clean up any remaining tags
	  parseEndTag();
	
	  function parseStartTag(tag, tagName, rest, unary) {
	    tagName = angular.lowercase(tagName);
	    if (blockElements[tagName]) {
	      while (stack.last() && inlineElements[stack.last()]) {
	        parseEndTag("", stack.last());
	      }
	    }
	
	    if (optionalEndTagElements[tagName] && stack.last() == tagName) {
	      parseEndTag("", tagName);
	    }
	
	    unary = voidElements[tagName] || !!unary;
	
	    if (!unary) {
	      stack.push(tagName);
	    }
	
	    var attrs = {};
	
	    rest.replace(ATTR_REGEXP,
	      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
	        var value = doubleQuotedValue
	          || singleQuotedValue
	          || unquotedValue
	          || '';
	
	        attrs[name] = decodeEntities(value);
	    });
	    if (handler.start) handler.start(tagName, attrs, unary);
	  }
	
	  function parseEndTag(tag, tagName) {
	    var pos = 0, i;
	    tagName = angular.lowercase(tagName);
	    if (tagName) {
	      // Find the closest opened tag of the same type
	      for (pos = stack.length - 1; pos >= 0; pos--) {
	        if (stack[pos] == tagName) break;
	      }
	    }
	
	    if (pos >= 0) {
	      // Close all the open elements, up the stack
	      for (i = stack.length - 1; i >= pos; i--)
	        if (handler.end) handler.end(stack[i]);
	
	      // Remove the open elements from the stack
	      stack.length = pos;
	    }
	  }
	}
	
	var hiddenPre=document.createElement("pre");
	/**
	 * decodes all entities into regular string
	 * @param value
	 * @returns {string} A string with decoded entities.
	 */
	function decodeEntities(value) {
	  if (!value) { return ''; }
	
	  hiddenPre.innerHTML = value.replace(/</g,"&lt;");
	  // innerText depends on styling as it doesn't display hidden elements.
	  // Therefore, it's better to use textContent not to cause unnecessary reflows.
	  return hiddenPre.textContent;
	}
	
	/**
	 * Escapes all potentially dangerous characters, so that the
	 * resulting string can be safely inserted into attribute or
	 * element text.
	 * @param value
	 * @returns {string} escaped text
	 */
	function encodeEntities(value) {
	  return value.
	    replace(/&/g, '&amp;').
	    replace(SURROGATE_PAIR_REGEXP, function(value) {
	      var hi = value.charCodeAt(0);
	      var low = value.charCodeAt(1);
	      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
	    }).
	    replace(NON_ALPHANUMERIC_REGEXP, function(value) {
	      return '&#' + value.charCodeAt(0) + ';';
	    }).
	    replace(/</g, '&lt;').
	    replace(/>/g, '&gt;');
	}
	
	/**
	 * create an HTML/XML writer which writes to buffer
	 * @param {Array} buf use buf.jain('') to get out sanitized html string
	 * @returns {object} in the form of {
	 *     start: function(tag, attrs, unary) {},
	 *     end: function(tag) {},
	 *     chars: function(text) {},
	 *     comment: function(text) {}
	 * }
	 */
	function htmlSanitizeWriter(buf, uriValidator) {
	  var ignore = false;
	  var out = angular.bind(buf, buf.push);
	  return {
	    start: function(tag, attrs, unary) {
	      tag = angular.lowercase(tag);
	      if (!ignore && specialElements[tag]) {
	        ignore = tag;
	      }
	      if (!ignore && validElements[tag] === true) {
	        out('<');
	        out(tag);
	        angular.forEach(attrs, function(value, key) {
	          var lkey=angular.lowercase(key);
	          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
	          if (validAttrs[lkey] === true &&
	            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
	            out(' ');
	            out(key);
	            out('="');
	            out(encodeEntities(value));
	            out('"');
	          }
	        });
	        out(unary ? '/>' : '>');
	      }
	    },
	    end: function(tag) {
	        tag = angular.lowercase(tag);
	        if (!ignore && validElements[tag] === true) {
	          out('</');
	          out(tag);
	          out('>');
	        }
	        if (tag == ignore) {
	          ignore = false;
	        }
	      },
	    chars: function(chars) {
	        if (!ignore) {
	          out(encodeEntities(chars));
	        }
	      }
	  };
	}
	
	
	// define ngSanitize module and register $sanitize service
	angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
	
	/* global sanitizeText: false */
	
	/**
	 * @ngdoc filter
	 * @name linky
	 * @kind function
	 *
	 * @description
	 * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and
	 * plain email address links.
	 *
	 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
	 *
	 * @param {string} text Input text.
	 * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.
	 * @returns {string} Html-linkified text.
	 *
	 * @usage
	   <span ng-bind-html="linky_expression | linky"></span>
	 *
	 * @example
	   <example module="linkyExample" deps="angular-sanitize.js">
	     <file name="index.html">
	       <script>
	         angular.module('linkyExample', ['ngSanitize'])
	           .controller('ExampleController', ['$scope', function($scope) {
	             $scope.snippet =
	               'Pretty text with some links:\n'+
	               'http://angularjs.org/,\n'+
	               'mailto:us@somewhere.org,\n'+
	               'another@somewhere.org,\n'+
	               'and one more: ftp://127.0.0.1/.';
	             $scope.snippetWithTarget = 'http://angularjs.org/';
	           }]);
	       </script>
	       <div ng-controller="ExampleController">
	       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
	       <table>
	         <tr>
	           <td>Filter</td>
	           <td>Source</td>
	           <td>Rendered</td>
	         </tr>
	         <tr id="linky-filter">
	           <td>linky filter</td>
	           <td>
	             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
	           </td>
	           <td>
	             <div ng-bind-html="snippet | linky"></div>
	           </td>
	         </tr>
	         <tr id="linky-target">
	          <td>linky target</td>
	          <td>
	            <pre>&lt;div ng-bind-html="snippetWithTarget | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
	          </td>
	          <td>
	            <div ng-bind-html="snippetWithTarget | linky:'_blank'"></div>
	          </td>
	         </tr>
	         <tr id="escaped-html">
	           <td>no filter</td>
	           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
	           <td><div ng-bind="snippet"></div></td>
	         </tr>
	       </table>
	     </file>
	     <file name="protractor.js" type="protractor">
	       it('should linkify the snippet with urls', function() {
	         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
	             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
	                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
	         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
	       });
	
	       it('should not linkify snippet without the linky filter', function() {
	         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
	             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
	                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
	         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
	       });
	
	       it('should update', function() {
	         element(by.model('snippet')).clear();
	         element(by.model('snippet')).sendKeys('new http://link.');
	         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
	             toBe('new http://link.');
	         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
	         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
	             .toBe('new http://link.');
	       });
	
	       it('should work with the target property', function() {
	        expect(element(by.id('linky-target')).
	            element(by.binding("snippetWithTarget | linky:'_blank'")).getText()).
	            toBe('http://angularjs.org/');
	        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
	       });
	     </file>
	   </example>
	 */
	angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
	  var LINKY_URL_REGEXP =
	        /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
	      MAILTO_REGEXP = /^mailto:/i;
	
	  return function(text, target) {
	    if (!text) return text;
	    var match;
	    var raw = text;
	    var html = [];
	    var url;
	    var i;
	    while ((match = raw.match(LINKY_URL_REGEXP))) {
	      // We can not end in these as they are sometimes found at the end of the sentence
	      url = match[0];
	      // if we did not match ftp/http/www/mailto then assume mailto
	      if (!match[2] && !match[4]) {
	        url = (match[3] ? 'http://' : 'mailto:') + url;
	      }
	      i = match.index;
	      addText(raw.substr(0, i));
	      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
	      raw = raw.substring(i + match[0].length);
	    }
	    addText(raw);
	    return $sanitize(html.join(''));
	
	    function addText(text) {
	      if (!text) {
	        return;
	      }
	      html.push(sanitizeText(text));
	    }
	
	    function addLink(url, text) {
	      html.push('<a ');
	      if (angular.isDefined(target)) {
	        html.push('target="',
	                  target,
	                  '" ');
	      }
	      html.push('href="',
	                url.replace(/"/g, '&quot;'),
	                '">');
	      addText(text);
	      html.push('</a>');
	    }
	  };
	}]);
	
	
	})(window, window.angular);


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(7);
	var Slider = __webpack_require__(11);
	
	angular.module('ui.bootstrap-slider', [])
	    .directive('slider', ['$parse', '$timeout', '$rootScope', function ($parse, $timeout, $rootScope) {
	        return {
	            restrict: 'AE',
	            replace: true,
	            template: '<div><input class="slider-input" type="text" style="width:100%" /></div>',
	            require: 'ngModel',
	            scope: {
	                max: "=",
	                min: "=",
	                step: "=",
	                value: "=",
	                ngModel: '=',
	                ngDisabled: '=',
	                range: '=',
	                sliderid: '=',
	                ticks: '=',
	                ticksLabels: '=',
	                ticksSnapBounds: '=',
	                ticksPositions: '=',
	                scale: '=',
	                formatter: '&',
	                onStartSlide: '&',
	                onStopSlide: '&',
	                onSlide: '&'
	            },
	            link: function ($scope, element, attrs, ngModelCtrl, $compile) {
	                var ngModelDeregisterFn, ngDisabledDeregisterFn;
	
	                initSlider();
	
	                function initSlider() {
	                    var options = {};
	
	                    function setOption(key, value, defaultValue) {
	                        options[key] = value || defaultValue;
	                    }
	
	                    function setFloatOption(key, value, defaultValue) {
	                        options[key] = value || value === 0 ? parseFloat(value) : defaultValue;
	                    }
	
	                    function setBooleanOption(key, value, defaultValue) {
	                        options[key] = value ? value + '' === 'true' : defaultValue;
	                    }
	
	                    function getArrayOrValue(value) {
	                        return (angular.isString(value) && value.indexOf("[") === 0) ? angular.fromJson(value) : value;
	                    }
	
	                    setOption('id', $scope.sliderid);
	                    setOption('orientation', attrs.orientation, 'horizontal');
	                    setOption('selection', attrs.selection, 'before');
	                    setOption('handle', attrs.handle, 'round');
	                    setOption('tooltip', attrs.sliderTooltip || attrs.tooltip, 'show');
	                    setOption('tooltip_position', attrs.sliderTooltipPosition, 'top');
	                    setOption('tooltipseparator', attrs.tooltipseparator, ':');
	                    setOption('ticks', $scope.ticks);
	                    setOption('ticks_labels', $scope.ticksLabels);
	                    setOption('ticks_snap_bounds', $scope.ticksSnapBounds);
	                    setOption('ticks_positions', $scope.ticksPositions);
	                    setOption('scale', $scope.scale, 'linear');
	
	                    setFloatOption('min', $scope.min, 0);
	                    setFloatOption('max', $scope.max, 10);
	                    setFloatOption('step', $scope.step, 1);
	                    var strNbr = options.step + '';
	                    var decimals = strNbr.substring(strNbr.lastIndexOf('.') + 1);
	                    setFloatOption('precision', attrs.precision, decimals);
	
	                    setBooleanOption('tooltip_split', attrs.tooltipsplit, false);
	                    setBooleanOption('enabled', attrs.enabled, true);
	                    setBooleanOption('naturalarrowkeys', attrs.naturalarrowkeys, false);
	                    setBooleanOption('reversed', attrs.reversed, false);
	
	                    setBooleanOption('range', $scope.range, false);
	                    if (options.range) {
	                        if (angular.isArray($scope.value)) {
	                            options.value = $scope.value;
	                        }
	                        else if (angular.isString($scope.value)) {
	                            options.value = getArrayOrValue($scope.value);
	                            if (!angular.isArray(options.value)) {
	                                var value = parseFloat($scope.value);
	                                if (isNaN(value)) value = 5;
	
	                                if (value < $scope.min) {
	                                    value = $scope.min;
	                                    options.value = [value, options.max];
	                                }
	                                else if (value > $scope.max) {
	                                    value = $scope.max;
	                                    options.value = [options.min, value];
	                                }
	                                else {
	                                    options.value = [options.min, options.max];
	                                }
	                            }
	                        }
	                        else {
	                            options.value = [options.min, options.max]; // This is needed, because of value defined at $.fn.slider.defaults - default value 5 prevents creating range slider
	                        }
	                        $scope.ngModel = options.value; // needed, otherwise turns value into [null, ##]
	                    }
	                    else {
	                        setFloatOption('value', $scope.value, 5);
	                    }
	
	                    if ($scope.formatter) options.formatter = $scope.$eval($scope.formatter);
	
	
	                    // check if slider jQuery plugin exists
	                    if ('$' in window && $.fn.slider) {
	                        // adding methods to jQuery slider plugin prototype
	                        $.fn.slider.constructor.prototype.disable = function () {
	                            this.picker.off();
	                        };
	                        $.fn.slider.constructor.prototype.enable = function () {
	                            this.picker.on();
	                        };
	                    }
	
	                    // destroy previous slider to reset all options
	                    if (element[0].__slider)
	                        element[0].__slider.destroy();
	
	                    var slider = new Slider(element[0].getElementsByClassName('slider-input')[0], options);
	                    element[0].__slider = slider;
	
	                    // everything that needs slider element
	                    var updateEvent = getArrayOrValue(attrs.updateevent);
	                    if (angular.isString(updateEvent)) {
	                        // if only single event name in string
	                        updateEvent = [updateEvent];
	                    }
	                    else {
	                        // default to slide event
	                        updateEvent = ['slide'];
	                    }
	                    angular.forEach(updateEvent, function (sliderEvent) {
	                        slider.on(sliderEvent, function (ev) {
	                            ngModelCtrl.$setViewValue(ev);
	                            $timeout(function () {
	                                $scope.$apply();
	                            });
	                        });
	                    });
	                    slider.on('change', function (ev) {
	                        ngModelCtrl.$setViewValue(ev.newValue);
	                        $timeout(function () {
	                            $scope.$apply();
	                        });
	                    });
	
	                    // Event listeners
	                    var sliderEvents = {
	                        slideStart: 'onStartSlide',
	                        slide: 'onSlide',
	                        slideStop: 'onStopSlide'
	                    };
	                    angular.forEach(sliderEvents, function (sliderEventAttr, sliderEvent) {
	                        var fn = $parse(attrs[sliderEventAttr]);
	                        slider.on(sliderEvent, function (ev) {
	                            if ($scope[sliderEventAttr]) {
	
	                                var callback = function () {
	                                    fn($scope.$parent, { $event: ev, value: ev });
	                                }
	
	                                if ($rootScope.$$phase) {
	                                    $scope.$evalAsync(callback);
	                                } else {
	                                    $scope.$apply(callback);
	                                }
	                            }
	                        });
	                    });
	
	                    // deregister ngDisabled watcher to prevent memory leaks
	                    if (angular.isFunction(ngDisabledDeregisterFn)) {
	                        ngDisabledDeregisterFn();
	                        ngDisabledDeregisterFn = null;
	                    }
	
	                    ngDisabledDeregisterFn = $scope.$watch('ngDisabled', function (value) {
	                        if (value) {
	                            slider.disable();
	                        }
	                        else {
	                            slider.enable();
	                        }
	                    });
	
	                    // deregister ngModel watcher to prevent memory leaks
	                    if (angular.isFunction(ngModelDeregisterFn)) ngModelDeregisterFn();
	                    ngModelDeregisterFn = $scope.$watch('ngModel', function (value) {
	                        if($scope.range){
	                            slider.setValue(value);
	                        }else{
	                            slider.setValue(parseFloat(value));
	                        }
	                    }, true);
	                }
	
	
	                var watchers = ['min', 'max', 'step', 'range', 'scale'];
	                angular.forEach(watchers, function (prop) {
	                    $scope.$watch(prop, function () {
	                        initSlider();
	                    });
	                });
	            }
	        };
	    }])
	;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(8);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./bootstrap-slider.min.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./bootstrap-slider.min.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	// imports
	
	
	// module
	exports.push([module.id, "/*! =======================================================\r\n                      VERSION  5.1.1\r\n========================================================= */\r\n/*! =========================================================\r\n * bootstrap-slider.js\r\n *\r\n * Maintainers:\r\n *\t\tKyle Kemp\r\n *\t\t\t- Twitter: @seiyria\r\n *\t\t\t- Github:  seiyria\r\n *\t\tRohit Kalkur\r\n *\t\t\t- Twitter: @Rovolutionary\r\n *\t\t\t- Github:  rovolution\r\n *\r\n * =========================================================\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ========================================================= */.slider{display:inline-block;vertical-align:middle;position:relative}.slider.slider-horizontal{width:210px;height:20px}.slider.slider-horizontal .slider-track{height:10px;width:100%;margin-top:-5px;top:50%;left:0}.slider.slider-horizontal .slider-selection,.slider.slider-horizontal .slider-track-low,.slider.slider-horizontal .slider-track-high{height:100%;top:0;bottom:0}.slider.slider-horizontal .slider-tick,.slider.slider-horizontal .slider-handle{margin-left:-10px;margin-top:-5px}.slider.slider-horizontal .slider-tick.triangle,.slider.slider-horizontal .slider-handle.triangle{border-width:0 10px 10px 10px;width:0;height:0;border-bottom-color:#0480be;margin-top:0}.slider.slider-horizontal .slider-tick-label-container{white-space:nowrap;margin-top:20px}.slider.slider-horizontal .slider-tick-label-container .slider-tick-label{padding-top:4px;display:inline-block;text-align:center}.slider.slider-vertical{height:210px;width:20px}.slider.slider-vertical .slider-track{width:10px;height:100%;margin-left:-5px;left:50%;top:0}.slider.slider-vertical .slider-selection{width:100%;left:0;top:0;bottom:0}.slider.slider-vertical .slider-track-low,.slider.slider-vertical .slider-track-high{width:100%;left:0;right:0}.slider.slider-vertical .slider-tick,.slider.slider-vertical .slider-handle{margin-left:-5px;margin-top:-10px}.slider.slider-vertical .slider-tick.triangle,.slider.slider-vertical .slider-handle.triangle{border-width:10px 0 10px 10px;width:1px;height:1px;border-left-color:#0480be;margin-left:0}.slider.slider-disabled .slider-handle{background-image:-webkit-linear-gradient(top,#dfdfdf 0,#bebebe 100%);background-image:-o-linear-gradient(top,#dfdfdf 0,#bebebe 100%);background-image:linear-gradient(to bottom,#dfdfdf 0,#bebebe 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffdfdfdf',endColorstr='#ffbebebe',GradientType=0)}.slider.slider-disabled .slider-track{background-image:-webkit-linear-gradient(top,#e5e5e5 0,#e9e9e9 100%);background-image:-o-linear-gradient(top,#e5e5e5 0,#e9e9e9 100%);background-image:linear-gradient(to bottom,#e5e5e5 0,#e9e9e9 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffe5e5e5',endColorstr='#ffe9e9e9',GradientType=0);cursor:not-allowed}.slider input{display:none}.slider .tooltip.top{margin-top:-36px}.slider .tooltip-inner{white-space:nowrap}.slider .hide{display:none}.slider-track{position:absolute;cursor:pointer;background-image:-webkit-linear-gradient(top,#f5f5f5 0,#f9f9f9 100%);background-image:-o-linear-gradient(top,#f5f5f5 0,#f9f9f9 100%);background-image:linear-gradient(to bottom,#f5f5f5 0,#f9f9f9 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff5f5f5',endColorstr='#fff9f9f9',GradientType=0);-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);border-radius:4px}.slider-selection{position:absolute;background-image:-webkit-linear-gradient(top,#f9f9f9 0,#f5f5f5 100%);background-image:-o-linear-gradient(top,#f9f9f9 0,#f5f5f5 100%);background-image:linear-gradient(to bottom,#f9f9f9 0,#f5f5f5 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff9f9f9',endColorstr='#fff5f5f5',GradientType=0);-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;border-radius:4px}.slider-selection.tick-slider-selection{background-image:-webkit-linear-gradient(top,#89cdef 0,#81bfde 100%);background-image:-o-linear-gradient(top,#89cdef 0,#81bfde 100%);background-image:linear-gradient(to bottom,#89cdef 0,#81bfde 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff89cdef',endColorstr='#ff81bfde',GradientType=0)}.slider-track-low,.slider-track-high{position:absolute;background:transparent;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;border-radius:4px}.slider-handle{position:absolute;width:20px;height:20px;background-color:#337ab7;background-image:-webkit-linear-gradient(top,#149bdf 0,#0480be 100%);background-image:-o-linear-gradient(top,#149bdf 0,#0480be 100%);background-image:linear-gradient(to bottom,#149bdf 0,#0480be 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff149bdf',endColorstr='#ff0480be',GradientType=0);filter:none;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05);box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05);border:0 solid transparent}.slider-handle.round{border-radius:50%}.slider-handle.triangle{background:transparent none}.slider-handle.custom{background:transparent none}.slider-handle.custom::before{line-height:20px;font-size:20px;content:'\\2605';color:#726204}.slider-tick{position:absolute;width:20px;height:20px;background-image:-webkit-linear-gradient(top,#f9f9f9 0,#f5f5f5 100%);background-image:-o-linear-gradient(top,#f9f9f9 0,#f5f5f5 100%);background-image:linear-gradient(to bottom,#f9f9f9 0,#f5f5f5 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff9f9f9',endColorstr='#fff5f5f5',GradientType=0);-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;filter:none;opacity:.8;border:0 solid transparent}.slider-tick.round{border-radius:50%}.slider-tick.triangle{background:transparent none}.slider-tick.custom{background:transparent none}.slider-tick.custom::before{line-height:20px;font-size:20px;content:'\\2605';color:#726204}.slider-tick.in-selection{background-image:-webkit-linear-gradient(top,#89cdef 0,#81bfde 100%);background-image:-o-linear-gradient(top,#89cdef 0,#81bfde 100%);background-image:linear-gradient(to bottom,#89cdef 0,#81bfde 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff89cdef',endColorstr='#ff81bfde',GradientType=0);opacity:1}", ""]);
	
	// exports


/***/ },
/* 9 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0;
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function createStyleElement() {
		var styleElement = document.createElement("style");
		var head = getHeadElement();
		styleElement.type = "text/css";
		head.appendChild(styleElement);
		return styleElement;
	}
	
	function createLinkElement() {
		var linkElement = document.createElement("link");
		var head = getHeadElement();
		linkElement.rel = "stylesheet";
		head.appendChild(linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement());
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement();
			update = updateLink.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement();
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! =======================================================
	                      VERSION  5.1.1
	========================================================= */
	/*! =========================================================
	 * bootstrap-slider.js
	 *
	 * Maintainers:
	 *		Kyle Kemp
	 *			- Twitter: @seiyria
	 *			- Github:  seiyria
	 *		Rohit Kalkur
	 *			- Twitter: @Rovolutionary
	 *			- Github:  rovolution
	 *
	 * =========================================================
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================= */
	!function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(12)], __WEBPACK_AMD_DEFINE_FACTORY__ = (b), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if("object"==typeof module&&module.exports){var c;try{c=require("jquery")}catch(d){c=null}module.exports=b(c)}else a.Slider=b(a.jQuery)}(this,function(a){var b;return function(a){"use strict";function b(){}function c(a){function c(b){b.prototype.option||(b.prototype.option=function(b){a.isPlainObject(b)&&(this.options=a.extend(!0,this.options,b))})}function e(b,c){a.fn[b]=function(e){if("string"==typeof e){for(var g=d.call(arguments,1),h=0,i=this.length;i>h;h++){var j=this[h],k=a.data(j,b);if(k)if(a.isFunction(k[e])&&"_"!==e.charAt(0)){var l=k[e].apply(k,g);if(void 0!==l&&l!==k)return l}else f("no such method '"+e+"' for "+b+" instance");else f("cannot call methods on "+b+" prior to initialization; attempted to call '"+e+"'")}return this}var m=this.map(function(){var d=a.data(this,b);return d?(d.option(e),d._init()):(d=new c(this,e),a.data(this,b,d)),a(this)});return!m||m.length>1?m:m[0]}}if(a){var f="undefined"==typeof console?b:function(a){console.error(a)};return a.bridget=function(a,b){c(b),e(a,b)},a.bridget}}var d=Array.prototype.slice;c(a)}(a),function(a){function c(b,c){function d(a,b){var c="data-slider-"+b.replace(/_/g,"-"),d=a.getAttribute(c);try{return JSON.parse(d)}catch(e){return d}}this._state={value:null,enabled:null,offset:null,size:null,percentage:null,inDrag:!1,over:!1},"string"==typeof b?this.element=document.querySelector(b):b instanceof HTMLElement&&(this.element=b),c=c?c:{};for(var f=Object.keys(this.defaultOptions),g=0;g<f.length;g++){var h=f[g],i=c[h];i="undefined"!=typeof i?i:d(this.element,h),i=null!==i?i:this.defaultOptions[h],this.options||(this.options={}),this.options[h]=i}"vertical"!==this.options.orientation||"top"!==this.options.tooltip_position&&"bottom"!==this.options.tooltip_position?"horizontal"!==this.options.orientation||"left"!==this.options.tooltip_position&&"right"!==this.options.tooltip_position||(this.options.tooltip_position="top"):this.options.tooltip_position="right";var j,k,l,m,n,o=this.element.style.width,p=!1,q=this.element.parentNode;if(this.sliderElem)p=!0;else{this.sliderElem=document.createElement("div"),this.sliderElem.className="slider";var r=document.createElement("div");if(r.className="slider-track",k=document.createElement("div"),k.className="slider-track-low",j=document.createElement("div"),j.className="slider-selection",l=document.createElement("div"),l.className="slider-track-high",m=document.createElement("div"),m.className="slider-handle min-slider-handle",n=document.createElement("div"),n.className="slider-handle max-slider-handle",r.appendChild(k),r.appendChild(j),r.appendChild(l),this.ticks=[],Array.isArray(this.options.ticks)&&this.options.ticks.length>0){for(g=0;g<this.options.ticks.length;g++){var s=document.createElement("div");s.className="slider-tick",this.ticks.push(s),r.appendChild(s)}j.className+=" tick-slider-selection"}if(r.appendChild(m),r.appendChild(n),this.tickLabels=[],Array.isArray(this.options.ticks_labels)&&this.options.ticks_labels.length>0)for(this.tickLabelContainer=document.createElement("div"),this.tickLabelContainer.className="slider-tick-label-container",g=0;g<this.options.ticks_labels.length;g++){var t=document.createElement("div");t.className="slider-tick-label",t.innerHTML=this.options.ticks_labels[g],this.tickLabels.push(t),this.tickLabelContainer.appendChild(t)}var u=function(a){var b=document.createElement("div");b.className="tooltip-arrow";var c=document.createElement("div");c.className="tooltip-inner",a.appendChild(b),a.appendChild(c)},v=document.createElement("div");v.className="tooltip tooltip-main",u(v);var w=document.createElement("div");w.className="tooltip tooltip-min",u(w);var x=document.createElement("div");x.className="tooltip tooltip-max",u(x),this.sliderElem.appendChild(r),this.sliderElem.appendChild(v),this.sliderElem.appendChild(w),this.sliderElem.appendChild(x),this.tickLabelContainer&&this.sliderElem.appendChild(this.tickLabelContainer),q.insertBefore(this.sliderElem,this.element),this.element.style.display="none"}if(a&&(this.$element=a(this.element),this.$sliderElem=a(this.sliderElem)),this.eventToCallbackMap={},this.sliderElem.id=this.options.id,this.touchCapable="ontouchstart"in window||window.DocumentTouch&&document instanceof window.DocumentTouch,this.tooltip=this.sliderElem.querySelector(".tooltip-main"),this.tooltipInner=this.tooltip.querySelector(".tooltip-inner"),this.tooltip_min=this.sliderElem.querySelector(".tooltip-min"),this.tooltipInner_min=this.tooltip_min.querySelector(".tooltip-inner"),this.tooltip_max=this.sliderElem.querySelector(".tooltip-max"),this.tooltipInner_max=this.tooltip_max.querySelector(".tooltip-inner"),e[this.options.scale]&&(this.options.scale=e[this.options.scale]),p===!0&&(this._removeClass(this.sliderElem,"slider-horizontal"),this._removeClass(this.sliderElem,"slider-vertical"),this._removeClass(this.tooltip,"hide"),this._removeClass(this.tooltip_min,"hide"),this._removeClass(this.tooltip_max,"hide"),["left","top","width","height"].forEach(function(a){this._removeProperty(this.trackLow,a),this._removeProperty(this.trackSelection,a),this._removeProperty(this.trackHigh,a)},this),[this.handle1,this.handle2].forEach(function(a){this._removeProperty(a,"left"),this._removeProperty(a,"top")},this),[this.tooltip,this.tooltip_min,this.tooltip_max].forEach(function(a){this._removeProperty(a,"left"),this._removeProperty(a,"top"),this._removeProperty(a,"margin-left"),this._removeProperty(a,"margin-top"),this._removeClass(a,"right"),this._removeClass(a,"top")},this)),"vertical"===this.options.orientation?(this._addClass(this.sliderElem,"slider-vertical"),this.stylePos="top",this.mousePos="pageY",this.sizePos="offsetHeight"):(this._addClass(this.sliderElem,"slider-horizontal"),this.sliderElem.style.width=o,this.options.orientation="horizontal",this.stylePos="left",this.mousePos="pageX",this.sizePos="offsetWidth"),this._setTooltipPosition(),Array.isArray(this.options.ticks)&&this.options.ticks.length>0&&(this.options.max=Math.max.apply(Math,this.options.ticks),this.options.min=Math.min.apply(Math,this.options.ticks)),Array.isArray(this.options.value)?(this.options.range=!0,this._state.value=this.options.value):this._state.value=this.options.range?[this.options.value,this.options.max]:this.options.value,this.trackLow=k||this.trackLow,this.trackSelection=j||this.trackSelection,this.trackHigh=l||this.trackHigh,"none"===this.options.selection&&(this._addClass(this.trackLow,"hide"),this._addClass(this.trackSelection,"hide"),this._addClass(this.trackHigh,"hide")),this.handle1=m||this.handle1,this.handle2=n||this.handle2,p===!0)for(this._removeClass(this.handle1,"round triangle"),this._removeClass(this.handle2,"round triangle hide"),g=0;g<this.ticks.length;g++)this._removeClass(this.ticks[g],"round triangle hide");var y=["round","triangle","custom"],z=-1!==y.indexOf(this.options.handle);if(z)for(this._addClass(this.handle1,this.options.handle),this._addClass(this.handle2,this.options.handle),g=0;g<this.ticks.length;g++)this._addClass(this.ticks[g],this.options.handle);this._state.offset=this._offset(this.sliderElem),this._state.size=this.sliderElem[this.sizePos],this.setValue(this._state.value),this.handle1Keydown=this._keydown.bind(this,0),this.handle1.addEventListener("keydown",this.handle1Keydown,!1),this.handle2Keydown=this._keydown.bind(this,1),this.handle2.addEventListener("keydown",this.handle2Keydown,!1),this.mousedown=this._mousedown.bind(this),this.touchCapable&&this.sliderElem.addEventListener("touchstart",this.mousedown,!1),this.sliderElem.addEventListener("mousedown",this.mousedown,!1),"hide"===this.options.tooltip?(this._addClass(this.tooltip,"hide"),this._addClass(this.tooltip_min,"hide"),this._addClass(this.tooltip_max,"hide")):"always"===this.options.tooltip?(this._showTooltip(),this._alwaysShowTooltip=!0):(this.showTooltip=this._showTooltip.bind(this),this.hideTooltip=this._hideTooltip.bind(this),this.sliderElem.addEventListener("mouseenter",this.showTooltip,!1),this.sliderElem.addEventListener("mouseleave",this.hideTooltip,!1),this.handle1.addEventListener("focus",this.showTooltip,!1),this.handle1.addEventListener("blur",this.hideTooltip,!1),this.handle2.addEventListener("focus",this.showTooltip,!1),this.handle2.addEventListener("blur",this.hideTooltip,!1)),this.options.enabled?this.enable():this.disable()}var d={formatInvalidInputErrorMsg:function(a){return"Invalid input value '"+a+"' passed in"},callingContextNotSliderInstance:"Calling context element does not have instance of Slider bound to it. Check your code to make sure the JQuery object returned from the call to the slider() initializer is calling the method"},e={linear:{toValue:function(a){var b=a/100*(this.options.max-this.options.min);if(this.options.ticks_positions.length>0){for(var c,d,e,f=0,g=0;g<this.options.ticks_positions.length;g++)if(a<=this.options.ticks_positions[g]){c=g>0?this.options.ticks[g-1]:0,e=g>0?this.options.ticks_positions[g-1]:0,d=this.options.ticks[g],f=this.options.ticks_positions[g];break}if(g>0){var h=(a-e)/(f-e);b=c+h*(d-c)}}var i=this.options.min+Math.round(b/this.options.step)*this.options.step;return i<this.options.min?this.options.min:i>this.options.max?this.options.max:i},toPercentage:function(a){if(this.options.max===this.options.min)return 0;if(this.options.ticks_positions.length>0){for(var b,c,d,e=0,f=0;f<this.options.ticks.length;f++)if(a<=this.options.ticks[f]){b=f>0?this.options.ticks[f-1]:0,d=f>0?this.options.ticks_positions[f-1]:0,c=this.options.ticks[f],e=this.options.ticks_positions[f];break}if(f>0){var g=(a-b)/(c-b);return d+g*(e-d)}}return 100*(a-this.options.min)/(this.options.max-this.options.min)}},logarithmic:{toValue:function(a){var b=0===this.options.min?0:Math.log(this.options.min),c=Math.log(this.options.max),d=Math.exp(b+(c-b)*a/100);return d=this.options.min+Math.round((d-this.options.min)/this.options.step)*this.options.step,d<this.options.min?this.options.min:d>this.options.max?this.options.max:d},toPercentage:function(a){if(this.options.max===this.options.min)return 0;var b=Math.log(this.options.max),c=0===this.options.min?0:Math.log(this.options.min),d=0===a?0:Math.log(a);return 100*(d-c)/(b-c)}}};if(b=function(a,b){return c.call(this,a,b),this},b.prototype={_init:function(){},constructor:b,defaultOptions:{id:"",min:0,max:10,step:1,precision:0,orientation:"horizontal",value:5,range:!1,selection:"before",tooltip:"show",tooltip_split:!1,handle:"round",reversed:!1,enabled:!0,formatter:function(a){return Array.isArray(a)?a[0]+" : "+a[1]:a},natural_arrow_keys:!1,ticks:[],ticks_positions:[],ticks_labels:[],ticks_snap_bounds:0,scale:"linear",focus:!1,tooltip_position:null},getElement:function(){return this.sliderElem},getValue:function(){return this.options.range?this._state.value:this._state.value[0]},setValue:function(a,b,c){a||(a=0);var d=this.getValue();this._state.value=this._validateInputValue(a);var e=this._applyPrecision.bind(this);this.options.range?(this._state.value[0]=e(this._state.value[0]),this._state.value[1]=e(this._state.value[1]),this._state.value[0]=Math.max(this.options.min,Math.min(this.options.max,this._state.value[0])),this._state.value[1]=Math.max(this.options.min,Math.min(this.options.max,this._state.value[1]))):(this._state.value=e(this._state.value),this._state.value=[Math.max(this.options.min,Math.min(this.options.max,this._state.value))],this._addClass(this.handle2,"hide"),this._state.value[1]="after"===this.options.selection?this.options.max:this.options.min),this._state.percentage=this.options.max>this.options.min?[this._toPercentage(this._state.value[0]),this._toPercentage(this._state.value[1]),100*this.options.step/(this.options.max-this.options.min)]:[0,0,100],this._layout();var f=this.options.range?this._state.value:this._state.value[0];return b===!0&&this._trigger("slide",f),d!==f&&c===!0&&this._trigger("change",{oldValue:d,newValue:f}),this._setDataVal(f),this},destroy:function(){this._removeSliderEventHandlers(),this.sliderElem.parentNode.removeChild(this.sliderElem),this.element.style.display="",this._cleanUpEventCallbacksMap(),this.element.removeAttribute("data"),a&&(this._unbindJQueryEventHandlers(),this.$element.removeData("slider"))},disable:function(){return this._state.enabled=!1,this.handle1.removeAttribute("tabindex"),this.handle2.removeAttribute("tabindex"),this._addClass(this.sliderElem,"slider-disabled"),this._trigger("slideDisabled"),this},enable:function(){return this._state.enabled=!0,this.handle1.setAttribute("tabindex",0),this.handle2.setAttribute("tabindex",0),this._removeClass(this.sliderElem,"slider-disabled"),this._trigger("slideEnabled"),this},toggle:function(){return this._state.enabled?this.disable():this.enable(),this},isEnabled:function(){return this._state.enabled},on:function(a,b){return this._bindNonQueryEventHandler(a,b),this},off:function(b,c){a?(this.$element.off(b,c),this.$sliderElem.off(b,c)):this._unbindNonQueryEventHandler(b,c)},getAttribute:function(a){return a?this.options[a]:this.options},setAttribute:function(a,b){return this.options[a]=b,this},refresh:function(){return this._removeSliderEventHandlers(),c.call(this,this.element,this.options),a&&a.data(this.element,"slider",this),this},relayout:function(){return this._layout(),this},_removeSliderEventHandlers:function(){this.handle1.removeEventListener("keydown",this.handle1Keydown,!1),this.handle1.removeEventListener("focus",this.showTooltip,!1),this.handle1.removeEventListener("blur",this.hideTooltip,!1),this.handle2.removeEventListener("keydown",this.handle2Keydown,!1),this.handle2.removeEventListener("focus",this.handle2Keydown,!1),this.handle2.removeEventListener("blur",this.handle2Keydown,!1),this.sliderElem.removeEventListener("mouseenter",this.showTooltip,!1),this.sliderElem.removeEventListener("mouseleave",this.hideTooltip,!1),this.sliderElem.removeEventListener("touchstart",this.mousedown,!1),this.sliderElem.removeEventListener("mousedown",this.mousedown,!1)},_bindNonQueryEventHandler:function(a,b){void 0===this.eventToCallbackMap[a]&&(this.eventToCallbackMap[a]=[]),this.eventToCallbackMap[a].push(b)},_unbindNonQueryEventHandler:function(a,b){var c=this.eventToCallbackMap[a];if(void 0!==c)for(var d=0;d<c.length;d++)if(c[d]===b){c.splice(d,1);break}},_cleanUpEventCallbacksMap:function(){for(var a=Object.keys(this.eventToCallbackMap),b=0;b<a.length;b++){var c=a[b];this.eventToCallbackMap[c]=null}},_showTooltip:function(){this.options.tooltip_split===!1?(this._addClass(this.tooltip,"in"),this.tooltip_min.style.display="none",this.tooltip_max.style.display="none"):(this._addClass(this.tooltip_min,"in"),this._addClass(this.tooltip_max,"in"),this.tooltip.style.display="none"),this._state.over=!0},_hideTooltip:function(){this._state.inDrag===!1&&this.alwaysShowTooltip!==!0&&(this._removeClass(this.tooltip,"in"),this._removeClass(this.tooltip_min,"in"),this._removeClass(this.tooltip_max,"in")),this._state.over=!1},_layout:function(){var a;if(a=this.options.reversed?[100-this._state.percentage[0],this.options.range?100-this._state.percentage[1]:this._state.percentage[1]]:[this._state.percentage[0],this._state.percentage[1]],this.handle1.style[this.stylePos]=a[0]+"%",this.handle2.style[this.stylePos]=a[1]+"%",Array.isArray(this.options.ticks)&&this.options.ticks.length>0){var b=Math.max.apply(Math,this.options.ticks),c=Math.min.apply(Math,this.options.ticks),d="vertical"===this.options.orientation?"height":"width",e="vertical"===this.options.orientation?"marginTop":"marginLeft",f=this._state.size/(this.options.ticks.length-1);if(this.tickLabelContainer){var g=0;if(0===this.options.ticks_positions.length)this.tickLabelContainer.style[e]=-f/2+"px",g=this.tickLabelContainer.offsetHeight;else for(h=0;h<this.tickLabelContainer.childNodes.length;h++)this.tickLabelContainer.childNodes[h].offsetHeight>g&&(g=this.tickLabelContainer.childNodes[h].offsetHeight);"horizontal"===this.options.orientation&&(this.sliderElem.style.marginBottom=g+"px")}for(var h=0;h<this.options.ticks.length;h++){var i=this.options.ticks_positions[h]||100*(this.options.ticks[h]-c)/(b-c);this.ticks[h].style[this.stylePos]=i+"%",this._removeClass(this.ticks[h],"in-selection"),this.options.range?i>=a[0]&&i<=a[1]&&this._addClass(this.ticks[h],"in-selection"):"after"===this.options.selection&&i>=a[0]?this._addClass(this.ticks[h],"in-selection"):"before"===this.options.selection&&i<=a[0]&&this._addClass(this.ticks[h],"in-selection"),this.tickLabels[h]&&(this.tickLabels[h].style[d]=f+"px",void 0!==this.options.ticks_positions[h]&&(this.tickLabels[h].style.position="absolute",this.tickLabels[h].style[this.stylePos]=this.options.ticks_positions[h]+"%",this.tickLabels[h].style[e]=-f/2+"px"))}}var j;if(this.options.range){j=this.options.formatter(this._state.value),this._setText(this.tooltipInner,j),this.tooltip.style[this.stylePos]=(a[1]+a[0])/2+"%","vertical"===this.options.orientation?this._css(this.tooltip,"margin-top",-this.tooltip.offsetHeight/2+"px"):this._css(this.tooltip,"margin-left",-this.tooltip.offsetWidth/2+"px"),"vertical"===this.options.orientation?this._css(this.tooltip,"margin-top",-this.tooltip.offsetHeight/2+"px"):this._css(this.tooltip,"margin-left",-this.tooltip.offsetWidth/2+"px");var k=this.options.formatter(this._state.value[0]);this._setText(this.tooltipInner_min,k);var l=this.options.formatter(this._state.value[1]);this._setText(this.tooltipInner_max,l),this.tooltip_min.style[this.stylePos]=a[0]+"%","vertical"===this.options.orientation?this._css(this.tooltip_min,"margin-top",-this.tooltip_min.offsetHeight/2+"px"):this._css(this.tooltip_min,"margin-left",-this.tooltip_min.offsetWidth/2+"px"),this.tooltip_max.style[this.stylePos]=a[1]+"%","vertical"===this.options.orientation?this._css(this.tooltip_max,"margin-top",-this.tooltip_max.offsetHeight/2+"px"):this._css(this.tooltip_max,"margin-left",-this.tooltip_max.offsetWidth/2+"px")}else j=this.options.formatter(this._state.value[0]),this._setText(this.tooltipInner,j),this.tooltip.style[this.stylePos]=a[0]+"%","vertical"===this.options.orientation?this._css(this.tooltip,"margin-top",-this.tooltip.offsetHeight/2+"px"):this._css(this.tooltip,"margin-left",-this.tooltip.offsetWidth/2+"px");if("vertical"===this.options.orientation)this.trackLow.style.top="0",this.trackLow.style.height=Math.min(a[0],a[1])+"%",this.trackSelection.style.top=Math.min(a[0],a[1])+"%",this.trackSelection.style.height=Math.abs(a[0]-a[1])+"%",this.trackHigh.style.bottom="0",this.trackHigh.style.height=100-Math.min(a[0],a[1])-Math.abs(a[0]-a[1])+"%";else{this.trackLow.style.left="0",this.trackLow.style.width=Math.min(a[0],a[1])+"%",this.trackSelection.style.left=Math.min(a[0],a[1])+"%",this.trackSelection.style.width=Math.abs(a[0]-a[1])+"%",this.trackHigh.style.right="0",this.trackHigh.style.width=100-Math.min(a[0],a[1])-Math.abs(a[0]-a[1])+"%";var m=this.tooltip_min.getBoundingClientRect(),n=this.tooltip_max.getBoundingClientRect();m.right>n.left?(this._removeClass(this.tooltip_max,"top"),this._addClass(this.tooltip_max,"bottom"),this.tooltip_max.style.top="18px"):(this._removeClass(this.tooltip_max,"bottom"),this._addClass(this.tooltip_max,"top"),this.tooltip_max.style.top=this.tooltip_min.style.top)}},_removeProperty:function(a,b){a.style.removeProperty?a.style.removeProperty(b):a.style.removeAttribute(b)},_mousedown:function(a){if(!this._state.enabled)return!1;this._state.offset=this._offset(this.sliderElem),this._state.size=this.sliderElem[this.sizePos];var b=this._getPercentage(a);if(this.options.range){var c=Math.abs(this._state.percentage[0]-b),d=Math.abs(this._state.percentage[1]-b);this._state.dragged=d>c?0:1}else this._state.dragged=0;this._state.percentage[this._state.dragged]=b,this._layout(),this.touchCapable&&(document.removeEventListener("touchmove",this.mousemove,!1),document.removeEventListener("touchend",this.mouseup,!1)),this.mousemove&&document.removeEventListener("mousemove",this.mousemove,!1),this.mouseup&&document.removeEventListener("mouseup",this.mouseup,!1),this.mousemove=this._mousemove.bind(this),this.mouseup=this._mouseup.bind(this),this.touchCapable&&(document.addEventListener("touchmove",this.mousemove,!1),document.addEventListener("touchend",this.mouseup,!1)),document.addEventListener("mousemove",this.mousemove,!1),document.addEventListener("mouseup",this.mouseup,!1),this._state.inDrag=!0;var e=this._calculateValue();return this._trigger("slideStart",e),this._setDataVal(e),this.setValue(e,!1,!0),this._pauseEvent(a),this.options.focus&&this._triggerFocusOnHandle(this._state.dragged),!0},_triggerFocusOnHandle:function(a){0===a&&this.handle1.focus(),1===a&&this.handle2.focus()},_keydown:function(a,b){if(!this._state.enabled)return!1;var c;switch(b.keyCode){case 37:case 40:c=-1;break;case 39:case 38:c=1}if(c){if(this.options.natural_arrow_keys){var d="vertical"===this.options.orientation&&!this.options.reversed,e="horizontal"===this.options.orientation&&this.options.reversed;(d||e)&&(c=-c)}var f=this._state.value[a]+c*this.options.step;return this.options.range&&(f=[a?this._state.value[0]:f,a?f:this._state.value[1]]),this._trigger("slideStart",f),this._setDataVal(f),this.setValue(f,!0,!0),this._setDataVal(f),this._trigger("slideStop",f),this._layout(),this._pauseEvent(b),!1}},_pauseEvent:function(a){a.stopPropagation&&a.stopPropagation(),a.preventDefault&&a.preventDefault(),a.cancelBubble=!0,a.returnValue=!1},_mousemove:function(a){if(!this._state.enabled)return!1;var b=this._getPercentage(a);this._adjustPercentageForRangeSliders(b),this._state.percentage[this._state.dragged]=b,this._layout();var c=this._calculateValue(!0);return this.setValue(c,!0,!0),!1},_adjustPercentageForRangeSliders:function(a){if(this.options.range){var b=this._getNumDigitsAfterDecimalPlace(a);b=b?b-1:0;var c=this._applyToFixedAndParseFloat(a,b);0===this._state.dragged&&this._applyToFixedAndParseFloat(this._state.percentage[1],b)<c?(this._state.percentage[0]=this._state.percentage[1],this._state.dragged=1):1===this._state.dragged&&this._applyToFixedAndParseFloat(this._state.percentage[0],b)>c&&(this._state.percentage[1]=this._state.percentage[0],this._state.dragged=0)}},_mouseup:function(){if(!this._state.enabled)return!1;this.touchCapable&&(document.removeEventListener("touchmove",this.mousemove,!1),document.removeEventListener("touchend",this.mouseup,!1)),document.removeEventListener("mousemove",this.mousemove,!1),document.removeEventListener("mouseup",this.mouseup,!1),this._state.inDrag=!1,this._state.over===!1&&this._hideTooltip();var a=this._calculateValue(!0);return this._layout(),this._setDataVal(a),this._trigger("slideStop",a),!1},_calculateValue:function(a){var b;if(this.options.range?(b=[this.options.min,this.options.max],0!==this._state.percentage[0]&&(b[0]=this._toValue(this._state.percentage[0]),b[0]=this._applyPrecision(b[0])),100!==this._state.percentage[1]&&(b[1]=this._toValue(this._state.percentage[1]),b[1]=this._applyPrecision(b[1]))):(b=this._toValue(this._state.percentage[0]),b=parseFloat(b),b=this._applyPrecision(b)),a){for(var c=[b,1/0],d=0;d<this.options.ticks.length;d++){var e=Math.abs(this.options.ticks[d]-b);e<=c[1]&&(c=[this.options.ticks[d],e])}if(c[1]<=this.options.ticks_snap_bounds)return c[0]}return b},_applyPrecision:function(a){var b=this.options.precision||this._getNumDigitsAfterDecimalPlace(this.options.step);return this._applyToFixedAndParseFloat(a,b)},_getNumDigitsAfterDecimalPlace:function(a){var b=(""+a).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return b?Math.max(0,(b[1]?b[1].length:0)-(b[2]?+b[2]:0)):0},_applyToFixedAndParseFloat:function(a,b){var c=a.toFixed(b);return parseFloat(c)},_getPercentage:function(a){!this.touchCapable||"touchstart"!==a.type&&"touchmove"!==a.type||(a=a.touches[0]);var b=a[this.mousePos],c=this._state.offset[this.stylePos],d=b-c,e=d/this._state.size*100;return e=Math.round(e/this._state.percentage[2])*this._state.percentage[2],this.options.reversed&&(e=100-e),Math.max(0,Math.min(100,e))},_validateInputValue:function(a){if("number"==typeof a)return a;if(Array.isArray(a))return this._validateArray(a),a;throw new Error(d.formatInvalidInputErrorMsg(a))},_validateArray:function(a){for(var b=0;b<a.length;b++){var c=a[b];if("number"!=typeof c)throw new Error(d.formatInvalidInputErrorMsg(c))}},_setDataVal:function(a){this.element.setAttribute("data-value",a),this.element.setAttribute("value",a),this.element.value=a},_trigger:function(b,c){c=c||0===c?c:void 0;var d=this.eventToCallbackMap[b];if(d&&d.length)for(var e=0;e<d.length;e++){var f=d[e];f(c)}a&&this._triggerJQueryEvent(b,c)},_triggerJQueryEvent:function(a,b){var c={type:a,value:b};this.$element.trigger(c),this.$sliderElem.trigger(c)},_unbindJQueryEventHandlers:function(){this.$element.off(),this.$sliderElem.off()},_setText:function(a,b){"undefined"!=typeof a.innerText?a.innerText=b:"undefined"!=typeof a.textContent&&(a.textContent=b)},_removeClass:function(a,b){for(var c=b.split(" "),d=a.className,e=0;e<c.length;e++){var f=c[e],g=new RegExp("(?:\\s|^)"+f+"(?:\\s|$)");d=d.replace(g," ")}a.className=d.trim()},_addClass:function(a,b){for(var c=b.split(" "),d=a.className,e=0;e<c.length;e++){var f=c[e],g=new RegExp("(?:\\s|^)"+f+"(?:\\s|$)"),h=g.test(d);h||(d+=" "+f)}a.className=d.trim()},_offsetLeft:function(a){return a.getBoundingClientRect().left},_offsetTop:function(a){for(var b=a.offsetTop;(a=a.offsetParent)&&!isNaN(a.offsetTop);)b+=a.offsetTop;return b},_offset:function(a){return{left:this._offsetLeft(a),top:this._offsetTop(a)}},_css:function(b,c,d){if(a)a.style(b,c,d);else{var e=c.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,function(a,b){return b.toUpperCase()});b.style[e]=d}},_toValue:function(a){return this.options.scale.toValue.apply(this,[a])},_toPercentage:function(a){return this.options.scale.toPercentage.apply(this,[a])},_setTooltipPosition:function(){var a=[this.tooltip,this.tooltip_min,this.tooltip_max];if("vertical"===this.options.orientation){var b=this.options.tooltip_position||"right",c="left"===b?"right":"left";a.forEach(function(a){this._addClass(a,b),a.style[c]="100%"}.bind(this))}else a.forEach("bottom"===this.options.tooltip_position?function(a){this._addClass(a,"bottom"),a.style.top="22px"}.bind(this):function(a){this._addClass(a,"top"),a.style.top=-this.tooltip.outerHeight-14+"px"}.bind(this))}},a){var f=a.fn.slider?"bootstrapSlider":"slider";a.bridget(f,b)}}(a),b});

/***/ },
/* 12 */
/***/ function(module, exports) {

	(function() { module.exports = this["$"]; }());

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
	  if (true) {
	    // AMD. Register as an anonymous module unless amdModuleId is set
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return (root['SignaturePad'] = factory());
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    // Node. Does not work with strict CommonJS, but
	    // only CommonJS-like environments that support module.exports,
	    // like Node.
	    module.exports = factory();
	  } else {
	    root['SignaturePad'] = factory();
	  }
	}(this, function () {
	
	/*!
	 * Signature Pad v1.4.0
	 * https://github.com/szimek/signature_pad
	 *
	 * Copyright 2015 Szymon Nowak
	 * Released under the MIT license
	 *
	 * The main idea and some parts of the code (e.g. drawing variable width Bzier curve) are taken from:
	 * http://corner.squareup.com/2012/07/smoother-signatures.html
	 *
	 * Implementation of interpolation using cubic Bzier curves is taken from:
	 * http://benknowscode.wordpress.com/2012/09/14/path-interpolation-using-cubic-bezier-and-control-point-estimation-in-javascript
	 *
	 * Algorithm for approximated length of a Bzier curve is taken from:
	 * http://www.lemoda.net/maths/bezier-length/index.html
	 *
	 */
	var SignaturePad = (function (document) {
	    "use strict";
	
	    var SignaturePad = function (canvas, options) {
	        var self = this,
	            opts = options || {};
	
	        this.velocityFilterWeight = opts.velocityFilterWeight || 0.7;
	        this.minWidth = opts.minWidth || 0.5;
	        this.maxWidth = opts.maxWidth || 2.5;
	        this.dotSize = opts.dotSize || function () {
	            return (this.minWidth + this.maxWidth) / 2;
	        };
	        this.penColor = opts.penColor || "black";
	        this.backgroundColor = opts.backgroundColor || "rgba(0,0,0,0)";
	        this.onEnd = opts.onEnd;
	        this.onBegin = opts.onBegin;
	
	        this._canvas = canvas;
	        this._ctx = canvas.getContext("2d");
	        this.clear();
	
	        // we need add these inline so they are available to unbind while still having
	        //  access to 'self' we could use _.bind but it's not worth adding a dependency
	        this._handleMouseDown = function (event) {
	            if (event.which === 1) {
	                self._mouseButtonDown = true;
	                self._strokeBegin(event);
	            }
	        };
	
	        this._handleMouseMove = function (event) {
	            if (self._mouseButtonDown) {
	                self._strokeUpdate(event);
	            }
	        };
	
	        this._handleMouseUp = function (event) {
	            if (event.which === 1 && self._mouseButtonDown) {
	                self._mouseButtonDown = false;
	                self._strokeEnd(event);
	            }
	        };
	
	        this._handleTouchStart = function (event) {
	            var touch = event.changedTouches[0];
	            self._strokeBegin(touch);
	        };
	
	        this._handleTouchMove = function (event) {
	            // Prevent scrolling.
	            event.preventDefault();
	
	            var touch = event.changedTouches[0];
	            self._strokeUpdate(touch);
	        };
	
	        this._handleTouchEnd = function (event) {
	            var wasCanvasTouched = event.target === self._canvas;
	            if (wasCanvasTouched) {
	                self._strokeEnd(event);
	            }
	        };
	
	        this._handleMouseEvents();
	        this._handleTouchEvents();
	    };
	
	    SignaturePad.prototype.clear = function () {
	        var ctx = this._ctx,
	            canvas = this._canvas;
	
	        ctx.fillStyle = this.backgroundColor;
	        ctx.clearRect(0, 0, canvas.width, canvas.height);
	        ctx.fillRect(0, 0, canvas.width, canvas.height);
	        this._reset();
	    };
	
	    SignaturePad.prototype.toDataURL = function (imageType, quality) {
	        var canvas = this._canvas;
	        return canvas.toDataURL.apply(canvas, arguments);
	    };
	
	    SignaturePad.prototype.fromDataURL = function (dataUrl) {
	        var self = this,
	            image = new Image(),
	            ratio = window.devicePixelRatio || 1,
	            width = this._canvas.width / ratio,
	            height = this._canvas.height / ratio;
	
	        this._reset();
	        image.src = dataUrl;
	        image.onload = function () {
	            self._ctx.drawImage(image, 0, 0, width, height);
	        };
	        this._isEmpty = false;
	    };
	
	    SignaturePad.prototype._strokeUpdate = function (event) {
	        var point = this._createPoint(event);
	        this._addPoint(point);
	    };
	
	    SignaturePad.prototype._strokeBegin = function (event) {
	        this._reset();
	        this._strokeUpdate(event);
	        if (typeof this.onBegin === 'function') {
	            this.onBegin(event);
	        }
	    };
	
	    SignaturePad.prototype._strokeDraw = function (point) {
	        var ctx = this._ctx,
	            dotSize = typeof(this.dotSize) === 'function' ? this.dotSize() : this.dotSize;
	
	        ctx.beginPath();
	        this._drawPoint(point.x, point.y, dotSize);
	        ctx.closePath();
	        ctx.fill();
	    };
	
	    SignaturePad.prototype._strokeEnd = function (event) {
	        var canDrawCurve = this.points.length > 2,
	            point = this.points[0];
	
	        if (!canDrawCurve && point) {
	            this._strokeDraw(point);
	        }
	        if (typeof this.onEnd === 'function') {
	            this.onEnd(event);
	        }
	    };
	
	    SignaturePad.prototype._handleMouseEvents = function () {
	        var self = this;
	        this._mouseButtonDown = false;
	
	        this._canvas.addEventListener("mousedown", this._handleMouseDown);
	        this._canvas.addEventListener("mousemove", this._handleMouseMove);
	        document.addEventListener("mouseup", this._handleMouseUp);
	    };
	
	    SignaturePad.prototype._handleTouchEvents = function () {
	        var self = this;
	
	        // Pass touch events to canvas element on mobile IE.
	        this._canvas.style.msTouchAction = 'none';
	
	        this._canvas.addEventListener("touchstart", this._handleTouchStart);
	        this._canvas.addEventListener("touchmove", this._handleTouchMove);
	        document.addEventListener("touchend", this._handleTouchEnd);
	    };
	
	    SignaturePad.prototype.off = function () {
	        this._canvas.removeEventListener("mousedown", this._handleMouseDown);
	        this._canvas.removeEventListener("mousemove", this._handleMouseMove);
	        document.removeEventListener("mouseup", this._handleMouseUp);
	
	        this._canvas.removeEventListener("touchstart", this._handleTouchStart);
	        this._canvas.removeEventListener("touchmove", this._handleTouchMove);
	        document.removeEventListener("touchend", this._handleTouchEnd);
	    };
	
	    SignaturePad.prototype.isEmpty = function () {
	        return this._isEmpty;
	    };
	
	    SignaturePad.prototype._reset = function () {
	        this.points = [];
	        this._lastVelocity = 0;
	        this._lastWidth = (this.minWidth + this.maxWidth) / 2;
	        this._isEmpty = true;
	        this._ctx.fillStyle = this.penColor;
	    };
	
	    SignaturePad.prototype._createPoint = function (event) {
	        var rect = this._canvas.getBoundingClientRect();
	        return new Point(
	            event.clientX - rect.left,
	            event.clientY - rect.top
	        );
	    };
	
	    SignaturePad.prototype._addPoint = function (point) {
	        var points = this.points,
	            c2, c3,
	            curve, tmp;
	
	        points.push(point);
	
	        if (points.length > 2) {
	            // To reduce the initial lag make it work with 3 points
	            // by copying the first point to the beginning.
	            if (points.length === 3) points.unshift(points[0]);
	
	            tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);
	            c2 = tmp.c2;
	            tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);
	            c3 = tmp.c1;
	            curve = new Bezier(points[1], c2, c3, points[2]);
	            this._addCurve(curve);
	
	            // Remove the first element from the list,
	            // so that we always have no more than 4 points in points array.
	            points.shift();
	        }
	    };
	
	    SignaturePad.prototype._calculateCurveControlPoints = function (s1, s2, s3) {
	        var dx1 = s1.x - s2.x, dy1 = s1.y - s2.y,
	            dx2 = s2.x - s3.x, dy2 = s2.y - s3.y,
	
	            m1 = {x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0},
	            m2 = {x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0},
	
	            l1 = Math.sqrt(dx1*dx1 + dy1*dy1),
	            l2 = Math.sqrt(dx2*dx2 + dy2*dy2),
	
	            dxm = (m1.x - m2.x),
	            dym = (m1.y - m2.y),
	
	            k = l2 / (l1 + l2),
	            cm = {x: m2.x + dxm*k, y: m2.y + dym*k},
	
	            tx = s2.x - cm.x,
	            ty = s2.y - cm.y;
	
	        return {
	            c1: new Point(m1.x + tx, m1.y + ty),
	            c2: new Point(m2.x + tx, m2.y + ty)
	        };
	    };
	
	    SignaturePad.prototype._addCurve = function (curve) {
	        var startPoint = curve.startPoint,
	            endPoint = curve.endPoint,
	            velocity, newWidth;
	
	        velocity = endPoint.velocityFrom(startPoint);
	        velocity = this.velocityFilterWeight * velocity
	            + (1 - this.velocityFilterWeight) * this._lastVelocity;
	
	        newWidth = this._strokeWidth(velocity);
	        this._drawCurve(curve, this._lastWidth, newWidth);
	
	        this._lastVelocity = velocity;
	        this._lastWidth = newWidth;
	    };
	
	    SignaturePad.prototype._drawPoint = function (x, y, size) {
	        var ctx = this._ctx;
	
	        ctx.moveTo(x, y);
	        ctx.arc(x, y, size, 0, 2 * Math.PI, false);
	        this._isEmpty = false;
	    };
	
	    SignaturePad.prototype._drawCurve = function (curve, startWidth, endWidth) {
	        var ctx = this._ctx,
	            widthDelta = endWidth - startWidth,
	            drawSteps, width, i, t, tt, ttt, u, uu, uuu, x, y;
	
	        drawSteps = Math.floor(curve.length());
	        ctx.beginPath();
	        for (i = 0; i < drawSteps; i++) {
	            // Calculate the Bezier (x, y) coordinate for this step.
	            t = i / drawSteps;
	            tt = t * t;
	            ttt = tt * t;
	            u = 1 - t;
	            uu = u * u;
	            uuu = uu * u;
	
	            x = uuu * curve.startPoint.x;
	            x += 3 * uu * t * curve.control1.x;
	            x += 3 * u * tt * curve.control2.x;
	            x += ttt * curve.endPoint.x;
	
	            y = uuu * curve.startPoint.y;
	            y += 3 * uu * t * curve.control1.y;
	            y += 3 * u * tt * curve.control2.y;
	            y += ttt * curve.endPoint.y;
	
	            width = startWidth + ttt * widthDelta;
	            this._drawPoint(x, y, width);
	        }
	        ctx.closePath();
	        ctx.fill();
	    };
	
	    SignaturePad.prototype._strokeWidth = function (velocity) {
	        return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
	    };
	
	
	    var Point = function (x, y, time) {
	        this.x = x;
	        this.y = y;
	        this.time = time || new Date().getTime();
	    };
	
	    Point.prototype.velocityFrom = function (start) {
	        return (this.time !== start.time) ? this.distanceTo(start) / (this.time - start.time) : 1;
	    };
	
	    Point.prototype.distanceTo = function (start) {
	        return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
	    };
	
	    var Bezier = function (startPoint, control1, control2, endPoint) {
	        this.startPoint = startPoint;
	        this.control1 = control1;
	        this.control2 = control2;
	        this.endPoint = endPoint;
	    };
	
	    // Returns approximated length.
	    Bezier.prototype.length = function () {
	        var steps = 10,
	            length = 0,
	            i, t, cx, cy, px, py, xdiff, ydiff;
	
	        for (i = 0; i <= steps; i++) {
	            t = i / steps;
	            cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
	            cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
	            if (i > 0) {
	                xdiff = cx - px;
	                ydiff = cy - py;
	                length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
	            }
	            px = cx;
	            py = cy;
	        }
	        return length;
	    };
	
	    Bezier.prototype._point = function (t, start, c1, c2, end) {
	        return          start * (1.0 - t) * (1.0 - t)  * (1.0 - t)
	               + 3.0 *  c1    * (1.0 - t) * (1.0 - t)  * t
	               + 3.0 *  c2    * (1.0 - t) * t          * t
	               +        end   * t         * t          * t;
	    };
	
	    return SignaturePad;
	})(document);
	
	return SignaturePad;
	
	}));


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var angular = __webpack_require__(1);
	var autosave = __webpack_require__(15);
	exports.autosave = autosave;
	exports.moduleName = 'rl.ui.behaviors';
	angular.module(exports.moduleName, [
	    autosave.moduleName,
	]);
	//# sourceMappingURL=behaviors.module.js.map

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __autosave = typescript_angular_utilities_1.services.autosave;
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var __objectUtility = typescript_angular_utilities_1.services.object;
	var __autosaveAction = typescript_angular_utilities_1.services.autosaveAction;
	exports.moduleName = 'rl.ui.behaviors.autosave';
	exports.directiveName = 'rlAutosave';
	exports.controllerName = 'AutosaveController';
	var AutosaveController = (function () {
	    function AutosaveController($scope, $attrs, $parse, $element, $timeout, autosaveFactory, parentChildBehavior, objectUtility) {
	        this.$scope = $scope;
	        this.$element = $element;
	        this.$timeout = $timeout;
	        var contentForm = $element.controller('form');
	        var hasValidator = objectUtility.isNullOrWhitespace($attrs.validate) === false;
	        var validateExpression = $parse($attrs.validate);
	        var validate;
	        if (hasValidator) {
	            validate = function () {
	                return validateExpression($scope);
	            };
	        }
	        var saveExpression = $parse($attrs.save);
	        var save = function () {
	            return saveExpression($scope);
	        };
	        var debounce = $parse($attrs.debounceDuration)($scope);
	        this.autosave = autosaveFactory.getInstance({
	            save: save,
	            validate: validate,
	            contentForm: contentForm,
	            debounceDuration: debounce,
	        });
	        var behavior = {
	            autosave: this.autosave.autosave,
	        };
	        // register autosave behavior and assign the value back to the parent
	        var childLink = $parse($attrs.rlAutosave)($scope);
	        parentChildBehavior.registerChildBehavior(childLink, behavior);
	    }
	    AutosaveController.$inject = ['$scope',
	        '$attrs',
	        '$parse',
	        '$element',
	        '$timeout',
	        __autosave.factoryName,
	        __parentChild.serviceName,
	        __objectUtility.serviceName,
	        __autosaveAction.serviceName];
	    return AutosaveController;
	})();
	exports.AutosaveController = AutosaveController;
	function autosave() {
	    'use strict';
	    return {
	        restrict: 'A',
	        require: ['rlAutosave', '?ngForm'],
	        controller: exports.controllerName,
	        link: function (scope, element, attrs, controllers) {
	            var autosaveController = controllers[0];
	            autosaveController.autosave.setChangeListener = function (callback) {
	                element.on('keyup', scope.$apply(callback));
	                return function () {
	                    element.off('keyup');
	                };
	            };
	        },
	    };
	}
	exports.autosave = autosave;
	angular.module(exports.moduleName, [
	    __autosave.moduleName,
	    __autosaveAction.moduleName,
	    __objectUtility.moduleName,
	    __parentChild.moduleName,
	])
	    .directive(exports.directiveName, autosave)
	    .controller(exports.controllerName, AutosaveController);
	//# sourceMappingURL=autosave.js.map

/***/ },
/* 16 */
/***/ function(module, exports) {

	(function() { module.exports = this["rl_utilities"]; }());

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var autosaveDialogFooter = __webpack_require__(18);
	exports.autosaveDialogFooter = autosaveDialogFooter;
	var busy = __webpack_require__(20);
	exports.busy = busy;
	var buttonAsync = __webpack_require__(21);
	exports.buttonAsync = buttonAsync;
	var buttonToggle = __webpack_require__(24);
	exports.buttonToggle = buttonToggle;
	var cardContainer = __webpack_require__(26);
	exports.cardContainer = cardContainer;
	var commaList = __webpack_require__(73);
	exports.commaList = commaList;
	var dateTime = __webpack_require__(74);
	exports.dateTime = dateTime;
	var genericContainer = __webpack_require__(75);
	exports.genericContainer = genericContainer;
	var lazyLoad = __webpack_require__(77);
	exports.lazyLoad = lazyLoad;
	var longClickButton = __webpack_require__(78);
	exports.longClickButton = longClickButton;
	var messageLog = __webpack_require__(80);
	exports.messageLog = messageLog;
	var multiStepIndicator = __webpack_require__(85);
	exports.multiStepIndicator = multiStepIndicator;
	var radio = __webpack_require__(87);
	exports.radio = radio;
	var ratingBar = __webpack_require__(90);
	exports.ratingBar = ratingBar;
	var responsiveCardGrid = __webpack_require__(93);
	exports.responsiveCardGrid = responsiveCardGrid;
	var richTextEditor = __webpack_require__(100);
	exports.richTextEditor = richTextEditor;
	var signaturePad = __webpack_require__(108);
	exports.signaturePad = signaturePad;
	var simpleCardList = __webpack_require__(109);
	exports.simpleCardList = simpleCardList;
	var spinner = __webpack_require__(112);
	exports.spinner = spinner;
	var stringWithWatermark = __webpack_require__(117);
	exports.stringWithWatermark = stringWithWatermark;
	var typeahead = __webpack_require__(118);
	exports.typeahead = typeahead;
	var userRating = __webpack_require__(120);
	exports.userRating = userRating;
	exports.moduleName = 'rl.ui.components';
	angular.module(exports.moduleName, [
	    autosaveDialogFooter.moduleName,
	    busy.moduleName,
	    buttonAsync.moduleName,
	    buttonToggle.moduleName,
	    cardContainer.moduleName,
	    commaList.moduleName,
	    dateTime.moduleName,
	    genericContainer.moduleName,
	    lazyLoad.moduleName,
	    longClickButton.moduleName,
	    messageLog.moduleName,
	    multiStepIndicator.moduleName,
	    radio.moduleName,
	    ratingBar.moduleName,
	    responsiveCardGrid.moduleName,
	    richTextEditor.moduleName,
	    signaturePad.moduleName,
	    simpleCardList.moduleName,
	    spinner.moduleName,
	    stringWithWatermark.moduleName,
	    typeahead.moduleName,
	    userRating.moduleName,
	]);
	//# sourceMappingURL=components.module.js.map

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.autosaveDialogFooter';
	exports.directiveName = 'rlAutosaveDialogFooter';
	function autosaveDialogFooter() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(19),
	    };
	}
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, autosaveDialogFooter);
	//# sourceMappingURL=autosaveDialogFooter.js.map

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = "<div class=\"modal-footer\">\r\n\t<button class=\"btn btn-default\" type=\"button\" ng-click=\"$close()\">Cancel</button>\r\n\t<button class=\"btn btn-primary\" type=\"button\" ng-click=\"$dismiss()\">Save</button>\r\n</div>"

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.busy';
	exports.directiveName = 'rlBusy';
	function busy() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: '<i class="fa fa-spin fa-spinner fa-{{size}}" ng-show="loading"></i>',
	        scope: {
	            loading: '=',
	            // Valid values are:
	            // `lg`, `2x`, `3x`, `4x`, and `5x`
	            size: '@',
	        },
	    };
	}
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, busy);
	//# sourceMappingURL=busy.js.map

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __promiseUtility = typescript_angular_utilities_1.services.promise;
	exports.moduleName = 'rl.ui.components.button';
	exports.directiveName = 'rlButtonAsync';
	exports.controllerName = 'ButtonAsyncController';
	var ButtonAsyncController = (function () {
	    function ButtonAsyncController(promiseUtility) {
	        this.promiseUtility = promiseUtility;
	        this.type = this.type != null ? this.type : 'default';
	        this.sizeClass = this.size != null ? 'btn-' + this.size : null;
	    }
	    ButtonAsyncController.prototype.trigger = function () {
	        var _this = this;
	        if (!this.busy) {
	            this.busy = true;
	            var result = this.action();
	            if (this.promiseUtility.isPromise(result) && _.isFunction(result.finally)) {
	                result.finally(function () {
	                    _this.busy = false;
	                });
	            }
	        }
	    };
	    ButtonAsyncController.$inject = [__promiseUtility.serviceName];
	    return ButtonAsyncController;
	})();
	exports.ButtonAsyncController = ButtonAsyncController;
	function buttonAsync() {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: __webpack_require__(23),
	        scope: {},
	        bindToController: {
	            busy: '=',
	            action: '&',
	            type: '@',
	            ngDisabled: '=',
	            rightAligned: '=',
	            size: '@',
	        },
	        controller: exports.controllerName,
	        controllerAs: 'button',
	    };
	}
	angular.module(exports.moduleName, [__promiseUtility.moduleName])
	    .directive(exports.directiveName, buttonAsync)
	    .controller(exports.controllerName, ButtonAsyncController);
	//# sourceMappingURL=buttonAsync.js.map

/***/ },
/* 22 */
/***/ function(module, exports) {

	(function() { module.exports = this["_"]; }());

/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = "<button type=\"button\" class=\"btn btn-{{button.type}} {{button.sizeClass}}\" ng-click=\"button.trigger()\" ng-disabled=\"button.busy || button.ngDisabled\">\r\n\t<rl-busy ng-show=\"button.rightAligned\" loading=\"button.busy\"></rl-busy>\r\n\t<span ng-transclude></span>\r\n\t<rl-busy ng-hide=\"button.rightAligned\" loading=\"button.busy\"></rl-busy>\r\n</button>"

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __boolean = typescript_angular_utilities_1.services.boolean;
	exports.moduleName = 'rl.ui.components.buttonToggle';
	exports.directiveName = 'rlButtonToggle';
	exports.controllerName = 'ButtonToggleController';
	var ButtonToggleController = (function () {
	    function ButtonToggleController($scope, bool) {
	        var _this = this;
	        this.$scope = $scope;
	        this.buttonClass = $scope.type != null ? $scope.type : 'default';
	        this.buttonSize = $scope.size != null ? 'btn-' + $scope.size : null;
	        $scope.$watch('ngModel.$modelValue', function (value) {
	            _this.isActive = bool.toBool(value);
	            if (value != null && _.isFunction($scope.onToggle)) {
	                $scope.onToggle({ value: value });
	            }
	        });
	    }
	    ButtonToggleController.prototype.clicked = function () {
	        this.$scope.ngModel.$setViewValue(!this.$scope.ngModel.$viewValue);
	    };
	    ButtonToggleController.$inject = ['$scope', __boolean.serviceName];
	    return ButtonToggleController;
	})();
	function buttonToggle() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: '^ngModel',
	        transclude: true,
	        template: __webpack_require__(25),
	        controller: exports.controllerName,
	        controllerAs: 'buttonToggle',
	        scope: {
	            type: '@',
	            size: '@',
	            onToggle: '&',
	            disabled: '=ngDisabled',
	        },
	        link: function (scope, element, attrs, ngModel) {
	            scope.ngModel = ngModel;
	        }
	    };
	}
	angular.module(exports.moduleName, [__boolean.moduleName])
	    .directive(exports.directiveName, buttonToggle)
	    .controller(exports.controllerName, ButtonToggleController);
	//# sourceMappingURL=buttonToggle.js.map

/***/ },
/* 25 */
/***/ function(module, exports) {

	module.exports = "<button type=\"button\" class=\"btn btn-{{buttonToggle.buttonClass}} {{buttonToggle.buttonSize}}\" \r\n\t\tng-class=\"{ active : buttonToggle.isActive }\" ng-click=\"buttonToggle.clicked()\" ng-disabled=\"disabled\">\r\n\t<i ng-show=\"buttonToggle.isActive\" class=\"fa fa-check completed\"></i> <span ng-transclude></span>\r\n</button>"

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __object = typescript_angular_utilities_1.services.object;
	var __array = typescript_angular_utilities_1.services.array;
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var card = __webpack_require__(27);
	exports.card = card;
	var cardSearch = __webpack_require__(33);
	exports.cardSearch = cardSearch;
	var columnHeader = __webpack_require__(35);
	exports.columnHeader = columnHeader;
	var dataSources = __webpack_require__(37);
	exports.dataSources = dataSources;
	var filters = __webpack_require__(49);
	exports.filters = filters;
	var itemCount = __webpack_require__(59);
	exports.itemCount = itemCount;
	var pager = __webpack_require__(61);
	exports.pager = pager;
	var pageSize = __webpack_require__(63);
	exports.pageSize = pageSize;
	var selectionControl = __webpack_require__(65);
	exports.selectionControl = selectionControl;
	var sorts = __webpack_require__(38);
	exports.sorts = sorts;
	var cardContainer_1 = __webpack_require__(67);
	__export(__webpack_require__(67));
	__export(__webpack_require__(68));
	__export(__webpack_require__(72));
	exports.moduleName = 'rl.ui.components.cardContainer';
	angular.module(exports.moduleName, [
	    // dependencies
	    dataSources.dataPager.moduleName,
	    __object.moduleName,
	    __array.moduleName,
	    __parentChild.moduleName,
	    // components
	    card.moduleName,
	    cardSearch.moduleName,
	    columnHeader.moduleName,
	    itemCount.moduleName,
	    pager.moduleName,
	    pageSize.moduleName,
	    selectionControl.moduleName,
	    // submodules
	    dataSources.moduleName,
	    filters.moduleName,
	    sorts.moduleName,
	])
	    .directive(cardContainer_1.directiveName, cardContainer_1.cardContainer)
	    .controller(cardContainer_1.controllerName, cardContainer_1.CardContainerController);
	//# sourceMappingURL=cardContainer.module.js.map

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var __object = typescript_angular_utilities_1.services.object;
	var headerColumn_module_1 = __webpack_require__(28);
	exports.moduleName = 'rl.ui.components.cardContainer.card';
	exports.directiveName = 'rlCard';
	exports.controllerName = 'CardController';
	var CardController = (function () {
	    function CardController($scope, $controller, $q, parentChild, object) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$q = $q;
	        this.parentChild = parentChild;
	        this.showContent = false;
	        this.dirty = false;
	        this.autosaveLink = {};
	        this.autosave = function () {
	            if (_this.showContent === false) {
	                return true;
	            }
	            return _this.parentChild.triggerChildBehavior(_this.autosaveLink, function (behavior) {
	                if (behavior.autosave()) {
	                    _this.showContent = false;
	                    return true;
	                }
	                else {
	                    return false;
	                }
	            });
	        };
	        if (this.cardAs) {
	            $scope[this.cardAs] = this.item;
	        }
	        $scope.collapse = this.autosave;
	        $scope.setSelected = this.setSelected.bind(this);
	        $scope.refresh = function () {
	            _this.source.refresh();
	            $scope.$broadcast('card.refresh');
	        };
	        $scope.remove = function () {
	            _this.source.remove(_this.item);
	        };
	        $scope.containerData = this.containerData;
	        if (object.isNullOrWhitespace(this.cardController) === false) {
	            var controller = $controller(this.cardController, { $scope: $scope });
	            if (object.isNullOrWhitespace(this.cardControllerAs) === false) {
	                $scope[this.cardControllerAs] = controller;
	            }
	        }
	        parentChild.registerChildBehavior(this.item, {
	            close: this.autosave,
	        });
	        $scope.__initContents = function (hasBody, hasFooter) {
	            _this.hasBody = hasBody;
	            _this.hasFooter = hasFooter;
	        };
	    }
	    CardController.prototype.toggleContent = function () {
	        if (!this.showContent) {
	            this.open();
	        }
	        else {
	            this.autosave();
	        }
	    };
	    CardController.prototype.validateCard = function () {
	        var behavior = this.parentChild.getChildBehavior(this.item);
	        if (_.isFunction(behavior.validateCard)) {
	            return behavior.validateCard();
	        }
	        else {
	            return true;
	        }
	    };
	    CardController.prototype.saveCard = function () {
	        var behavior = this.parentChild.getChildBehavior(this.item);
	        if (_.isFunction(behavior.saveCard)) {
	            return behavior.saveCard();
	        }
	        else {
	            return this.$q.when();
	        }
	    };
	    CardController.prototype.clickCard = function () {
	        this.parentChild.triggerChildBehavior(this.item, function (behavior) {
	            if (_.isFunction(behavior.clickCard)) {
	                return behavior.clickCard();
	            }
	        });
	    };
	    CardController.prototype.open = function () {
	        this.parentChild.triggerChildBehavior(this.item, function (behavior) {
	            if (_.isFunction(behavior.initCard)) {
	                behavior.initCard();
	            }
	        });
	        if (this.$scope.__rlCardContainer.openCard()) {
	            this.showContent = true;
	        }
	    };
	    CardController.prototype.setSelected = function (value) {
	        if (_.isUndefined(this.item.viewData)) {
	            this.item.viewData = {};
	        }
	        this.item.viewData.selected = value;
	        this.selectionChanged();
	    };
	    CardController.$inject = ['$scope', '$controller', '$q', __parentChild.serviceName, __object.serviceName];
	    return CardController;
	})();
	exports.CardController = CardController;
	function card() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(32),
	        require: '^^rlCardContainer',
	        controller: exports.controllerName,
	        controllerAs: '__card',
	        scope: {},
	        bindToController: {
	            columns: '=',
	            item: '=',
	            clickable: '=',
	            source: '=',
	            containerData: '=',
	            cardController: '=',
	            cardControllerAs: '=',
	            cardAs: '=',
	            permanentFooter: '=',
	            selectable: '=',
	            selectionChanged: '&',
	        },
	        compile: function () {
	            var content;
	            var footer;
	            return {
	                pre: function (scope, element, attrs, rlCardContainer) {
	                    scope.__rlCardContainer = rlCardContainer;
	                    rlCardContainer.makeCard(scope, function (clone) {
	                        content = clone.filter('rl-card-content');
	                        footer = clone.filter('rl-card-footer');
	                    });
	                },
	                post: function (scope, element) {
	                    var contentArea = element.find('.content-template');
	                    contentArea.append(content);
	                    var hasBody = content.length > 0;
	                    var hasFooter = (footer.length > 0);
	                    if (hasFooter) {
	                        var footerArea = element.find('.footer-template');
	                        footerArea.append(footer);
	                    }
	                    scope.__initContents(hasBody, hasFooter);
	                },
	            };
	        },
	    };
	}
	exports.card = card;
	angular.module(exports.moduleName, [
	    __parentChild.moduleName,
	    __object.moduleName,
	    headerColumn_module_1.moduleName,
	])
	    .directive(exports.directiveName, card)
	    .controller(exports.controllerName, CardController);
	//# sourceMappingURL=card.js.map

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var headerColumn_1 = __webpack_require__(29);
	var sizeForBreakpoints_1 = __webpack_require__(30);
	exports.moduleName = 'rl.ui.components.cardContainer.card.headerColumn';
	angular.module(exports.moduleName, [
	    typescript_angular_utilities_1.services.string.moduleName,
	])
	    .directive(sizeForBreakpoints_1.sizeForBreakpointsName, sizeForBreakpoints_1.sizeForBreakpoints)
	    .directive(headerColumn_1.directiveName, headerColumn_1.headerColumn)
	    .controller(headerColumn_1.controllerName, headerColumn_1.HeaderColumnController);
	//# sourceMappingURL=headerColumn.module.js.map

/***/ },
/* 29 */
/***/ function(module, exports) {

	// /// <reference path='../../../../../typings/jquery/jquery.d.ts' />
	'use strict';
	exports.directiveName = 'rlCardHeaderColumn';
	exports.controllerName = 'CardHeaderColumnController';
	var HeaderColumnController = (function () {
	    function HeaderColumnController($scope) {
	        var _this = this;
	        this.$scope = $scope;
	        this.update = function () {
	            _this.value = _this.column.getValue(_this.item);
	        };
	        this.update();
	        $scope.$on('card.refresh', this.update); //*event?
	    }
	    HeaderColumnController.$inject = ['$scope'];
	    return HeaderColumnController;
	})();
	exports.HeaderColumnController = HeaderColumnController;
	headerColumn.$inject = ['$compile'];
	function headerColumn($compile) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<div rl-size-for-breakpoints=\"header.column.size\" title=\"{{::header.column.description}}\">\n\t\t\t\t<div class=\"template-container\" style=\"display: inline-block\"></div>\n\t\t\t</div>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'header',
	        scope: {},
	        bindToController: {
	            column: '=',
	            item: '=',
	        },
	        compile: function () {
	            return {
	                pre: function (scope, element, attrs, header) {
	                    var column = header.column;
	                    if (column.templateUrl != null) {
	                        header.renderedTemplate = $compile('<div ng-include="\'' + column.templateUrl + '\'"></div>')(scope);
	                    }
	                    else if (column.template != null) {
	                        header.renderedTemplate = $compile(column.template)(scope);
	                    }
	                    else {
	                        header.renderedTemplate = $compile('<span>{{header.value}}</span>')(scope);
	                    }
	                },
	                post: function (scope, element, attrs, header) {
	                    var container = element.find('.template-container');
	                    container.append(header.renderedTemplate);
	                },
	            };
	        },
	    };
	}
	exports.headerColumn = headerColumn;
	//# sourceMappingURL=headerColumn.js.map

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __string = typescript_angular_utilities_1.services.string;
	var breakpoint_1 = __webpack_require__(31);
	exports.sizeForBreakpointsName = 'rlSizeForBreakpoints';
	sizeForBreakpoints.$inject = ['$parse', __string.serviceName];
	function sizeForBreakpoints($parse, stringUtility) {
	    'use strict';
	    return {
	        restrict: 'A',
	        link: linkDirective,
	    };
	    function linkDirective(scope, element, attributes) {
	        var sizes = $parse(attributes.rlSizeForBreakpoints)(scope);
	        var classes = [];
	        classes.push(getColumnClass(sizes, breakpoint_1.xs));
	        classes.push(getColumnClass(sizes, breakpoint_1.sm));
	        classes.push(getColumnClass(sizes, breakpoint_1.md));
	        classes.push(getColumnClass(sizes, breakpoint_1.lg));
	        element.addClass(classes.join(' '));
	    }
	    function getColumnClass(columnSizes, breakpoint) {
	        var value = columnSizes[breakpoint];
	        if (value > 0 && value !== 'hidden') {
	            return stringUtility.substitute('col-{0}-{1}', breakpoint, value);
	        }
	        else {
	            return 'hidden-' + breakpoint;
	        }
	    }
	}
	exports.sizeForBreakpoints = sizeForBreakpoints;
	//# sourceMappingURL=sizeForBreakpoints.js.map

/***/ },
/* 31 */
/***/ function(module, exports) {

	'use strict';
	exports.lg = 'lg';
	exports.md = 'md';
	exports.sm = 'sm';
	exports.xs = 'xs';
	//# sourceMappingURL=breakpoint.js.map

/***/ },
/* 32 */
/***/ function(module, exports) {

	module.exports = "<rl-generic-container selector=\"__card.selectable\">\r\n\t<template when-selector=\"false\" default>\r\n\t\t<div class=\"card\" ng-class=\"{ 'selected': __card.item.viewData.selected }\">\r\n\t\t\t<div class=\"header\" ng-click=\"__card.toggleContent()\" ng-class=\"{ 'active': __card.hasBody || !__card.permanentFooter }\">\r\n\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t<div ng-repeat=\"column in __card.columns\">\r\n\t\t\t\t\t\t<rl-card-header-column column=\"column\" item=\"__card.item\"></rl-card-header-column>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\r\n\t\t\t<div ng-show=\"__card.showContent\">\r\n\t\t\t\t<ng-form rl-autosave=\"__card.autosaveLink\" save=\"__card.saveCard()\" validate=\"__card.validateCard()\">\r\n\t\t\t\t\t<div class=\"body\" ng-class=\"{ 'active': __card.clickable }\" ng-click=\"__card.clickCard()\">\r\n\t\t\t\t\t\t<div class=\"content-template\"></div>\r\n\t\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</ng-form>\r\n\t\t\t</div>\r\n\t\t\t<div ng-show=\"__card.hasFooter && (__card.showContent || __card.permanentFooter)\">\r\n\t\t\t\t<div class=\"footer\">\r\n\t\t\t\t\t<div class=\"footer-template\"></div>\r\n\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</template>\r\n\t<template when-selector=\"true\">\r\n\t\t<div class=\"select-group\">\r\n\t\t\t<div class=\"select-column\">\r\n\t\t\t\t<input type=\"checkbox\" class=\"stand-alone-checkbox\" ng-model=\"__card.item.viewData.selected\" ng-change=\"__card.selectionChanged()\"\r\n\t\t\t\t\t   ng-disabled=\"__card.item.viewData.disabledSelection\" title=\"{{__card.item.viewData.selectionTitle}}\" />\r\n\t\t\t</div>\r\n\t\t\t<div class=\"select-content\">\r\n\r\n\t\t\t\t<div class=\"card selectable\" ng-class=\"{ 'selected': __card.item.viewData.selected }\">\r\n\t\t\t\t\t<div class=\"header active\" ng-click=\"__card.toggleContent()\">\r\n\t\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t\t<div ng-repeat=\"column in __card.columns\">\r\n\t\t\t\t\t\t\t\t<rl-card-header-column column=\"column\" item=\"__card.item\"></rl-card-header-column>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\r\n\t\t\t\t\t<div ng-show=\"__card.showContent\">\r\n\t\t\t\t\t\t<ng-form rl-autosave=\"__card.autosaveLink\" save=\"__card.saveCard()\" validate=\"__card.validateCard()\">\r\n\t\t\t\t\t\t\t<div class=\"body\" ng-class=\"{ 'active': __card.clickable }\" ng-click=\"__card.clickCard()\">\r\n\t\t\t\t\t\t\t\t<div class=\"content-template\"></div>\r\n\t\t\t\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</ng-form>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div ng-show=\"__card.hasFooter && (__card.showContent || __card.permanentFooter)\">\r\n\t\t\t\t\t\t<div class=\"footer\">\r\n\t\t\t\t\t\t\t<div class=\"footer-template\"></div>\r\n\t\t\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</template>\r\n</rl-generic-container>"

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __genericSearchFilter = typescript_angular_utilities_1.services.genericSearchFilter;
	exports.moduleName = 'rl.ui.components.cardContainer.cardSearch';
	exports.directiveName = 'rlCardSearch';
	exports.controllerName = 'CardSearchController';
	exports.defaultSearchPlaceholder = 'Search';
	exports.defaultSearchDelay = 1000;
	var CardSearchController = (function () {
	    function CardSearchController($scope, $timeout) {
	        var _this = this;
	        this.searchLengthError = false;
	        this.hasSearchFilter = true;
	        if (this.containerService == null) {
	            return;
	        }
	        if (this.searchFilter == null) {
	            var filter = this.containerService.lookupFilter(__genericSearchFilter.filterName);
	            this.searchFilter = filter;
	            if (filter == null) {
	                this.hasSearchFilter = false;
	            }
	        }
	        if (this.hasSearchFilter) {
	            this.searchPlaceholder = exports.defaultSearchPlaceholder;
	            var dataSource = this.containerService.dataSource;
	            var delay = this.delay != null
	                ? this.delay
	                : exports.defaultSearchDelay;
	            var timer;
	            $scope.$watch(function () { return _this.searchText; }, function (search) {
	                _this.searchFilter.searchText = search;
	                _this.minSearchLength = _this.searchFilter.minSearchLength;
	                _this.validateSearchLength(search, _this.minSearchLength);
	                if (timer != null) {
	                    $timeout.cancel(timer);
	                }
	                timer = $timeout(dataSource.refresh.bind(dataSource), delay);
	            });
	        }
	    }
	    CardSearchController.prototype.validateSearchLength = function (search, minLength) {
	        // show error if search string exists but is below minimum size
	        this.searchLengthError = search != null
	            && search.length > 0
	            && search.length < minLength;
	    };
	    CardSearchController.$inject = ['$scope', '$timeout'];
	    return CardSearchController;
	})();
	exports.CardSearchController = CardSearchController;
	function cardSearch() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(34),
	        controller: exports.controllerName,
	        controllerAs: 'cardSearch',
	        scope: {},
	        bindToController: {
	            delay: '=searchDelay',
	            containerService: '=',
	            searchFilter: '=',
	        },
	    };
	}
	exports.cardSearch = cardSearch;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, cardSearch)
	    .controller(exports.controllerName, CardSearchController);
	//# sourceMappingURL=cardSearch.js.map

/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = "<div class=\"input-group\" ng-show=\"cardSearch.hasSearchFilter\" ng-class=\"{ 'has-error': cardSearch.searchLengthError }\">\r\n\t<input class=\"form-control\" type=\"text\" placeholder=\"{{cardSearch.searchPlaceholder}}\" ng-model=\"cardSearch.searchText\"\r\n\t\t\tpopover=\"You must enter at least {{cardSearch.minSearchLength}} characters to perform a search\" popover-trigger=\"mouseenter\" popover-enable=\"cardSearch.searchLengthError\" />\r\n\t<div class=\"input-group-btn\">\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-disabled=\"cardSearch.searchText | isEmpty\" ng-click=\"cardSearch.searchText = null\">\r\n\t\t\t<i class=\"fa fa-times\"></i>\r\n\t\t</button>\r\n\t</div>\r\n</div>"

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var sortDirection_1 = __webpack_require__(36);
	exports.moduleName = 'rl.ui.components.cardContainer.columnHeader';
	exports.directiveName = 'rlColumnHeader';
	cardColumnHeader.$inject = ['$compile'];
	function cardColumnHeader($compile) {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: '^^rlCardContainer',
	        template: "\n\t\t\t<div rl-size-for-breakpoints=\"column.size\" ng-click=\"sort()\" title=\"{{::column.description}}\"\n\t\t\t\t\tclass=\"column-header\">\n\t\t\t\t<div class=\"template-container\" style=\"display: inline-block\"></div>\n\t\t\t\t<i ng-show=\"sorting === sortDirection.ascending\" class=\"fa fa-sort-asc\"></i>\n\t\t\t\t<i ng-show=\"sorting === sortDirection.descending\" class=\"fa fa-sort-desc\"></i>\n\t\t\t</div>\n\t\t",
	        scope: {
	            column: '=',
	            sorting: '=',
	            sort: '&',
	        },
	        compile: function () {
	            return {
	                pre: function (scope) {
	                    var column = scope.column;
	                    if (column.headerTemplateUrl != null) {
	                        scope.renderedTemplate = $compile('<div ng-include="\'' + column.headerTemplateUrl + '\'"></div>')(scope);
	                    }
	                    else if (column.headerTemplate != null) {
	                        scope.renderedTemplate = $compile(column.headerTemplate)(scope);
	                    }
	                    else {
	                        scope.renderedTemplate = ('<h5>' + column.label + '</h5');
	                    }
	                },
	                post: function (scope, element) {
	                    var container = element.find('.template-container');
	                    container.append(scope.renderedTemplate);
	                    scope.sortDirection = sortDirection_1.SortDirection;
	                },
	            };
	        }
	    };
	}
	exports.cardColumnHeader = cardColumnHeader;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, cardColumnHeader);
	//# sourceMappingURL=columnHeader.js.map

/***/ },
/* 36 */
/***/ function(module, exports) {

	'use strict';
	var SortDirection = (function () {
	    function SortDirection(value) {
	        this.value = value;
	    }
	    SortDirection.toggle = function (direction) {
	        if (direction === SortDirection.ascending) {
	            return SortDirection.descending;
	        }
	        else if (direction === SortDirection.descending) {
	            return SortDirection.none;
	        }
	        else {
	            return SortDirection.ascending;
	        }
	    };
	    SortDirection.getFullName = function (direction) {
	        'use strict';
	        if (direction === SortDirection.ascending) {
	            return 'ascending';
	        }
	        else if (direction === SortDirection.descending) {
	            return 'descending';
	        }
	        else {
	            return 'none';
	        }
	    };
	    SortDirection.none = new SortDirection(0);
	    SortDirection.ascending = new SortDirection(1);
	    SortDirection.descending = new SortDirection(2);
	    return SortDirection;
	})();
	exports.SortDirection = SortDirection;
	//# sourceMappingURL=sortDirection.js.map

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var sorts_module_1 = __webpack_require__(38);
	var dataPager = __webpack_require__(42);
	exports.dataPager = dataPager;
	var dataServiceDataSource = __webpack_require__(43);
	exports.dataServiceDataSource = dataServiceDataSource;
	var simpleDataSource = __webpack_require__(46);
	exports.simpleDataSource = simpleDataSource;
	var serverSearchDataSource = __webpack_require__(47);
	exports.serverSearchDataSource = serverSearchDataSource;
	var dataSourceProcessor = __webpack_require__(45);
	exports.dataSourceProcessor = dataSourceProcessor;
	var dataSourceBase = __webpack_require__(44);
	exports.dataSourceBase = dataSourceBase;
	__export(__webpack_require__(48));
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources';
	angular.module(exports.moduleName, [
	    typescript_angular_utilities_1.services.object.moduleName,
	    sorts_module_1.moduleName,
	    dataPager.moduleName,
	    dataServiceDataSource.moduleName,
	    simpleDataSource.moduleName,
	    serverSearchDataSource.moduleName,
	])
	    .service(dataSourceProcessor.processorServiceName, dataSourceProcessor.DataSourceProcessor);
	//# sourceMappingURL=dataSources.module.js.map

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var mergeSort = __webpack_require__(39);
	exports.mergeSort = mergeSort;
	var sorter = __webpack_require__(40);
	exports.sorter = sorter;
	__export(__webpack_require__(41));
	__export(__webpack_require__(36));
	exports.moduleName = 'rl.ui.components.cardContainer.sorts';
	angular.module(exports.moduleName, [
	    mergeSort.moduleName,
	    sorter.moduleName,
	]);
	//# sourceMappingURL=sorts.module.js.map

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	exports.moduleName = 'rl.ui.components.cardContainer.sorts.mergeSort';
	exports.serviceName = 'mergeSort';
	var MergeSort = (function () {
	    function MergeSort() {
	    }
	    MergeSort.prototype.sort = function (data, compare) {
	        if (data.length < 2) {
	            return data;
	        }
	        if (compare == null) {
	            compare = this.defaultCompare;
	        }
	        var mid;
	        var left;
	        var right;
	        mid = data.length / 2;
	        left = this.sort(data.slice(0, mid), compare);
	        right = this.sort(data.slice(mid, data.length), compare);
	        return this.merge(left, right, compare);
	    };
	    MergeSort.prototype.defaultCompare = function (a, b) {
	        return a < b
	            ? typescript_angular_utilities_1.types.CompareResult.less
	            : (a > b ? typescript_angular_utilities_1.types.CompareResult.greater : typescript_angular_utilities_1.types.CompareResult.equal);
	    };
	    MergeSort.prototype.merge = function (left, right, compare) {
	        var result = [];
	        while (left.length && right.length) {
	            if (compare(left[0], right[0]) === typescript_angular_utilities_1.types.CompareResult.greater) {
	                result.push(right.shift());
	            }
	            else {
	                // if equal it should preserve same order (stable)
	                result.push(left.shift());
	            }
	        }
	        if (left.length) {
	            result.push.apply(result, left);
	        }
	        if (right.length) {
	            result.push.apply(result, right);
	        }
	        return result;
	    };
	    return MergeSort;
	})();
	exports.MergeSort = MergeSort;
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, MergeSort);
	//# sourceMappingURL=mergeSort.service.js.map

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var sortDirection_1 = __webpack_require__(36);
	var mergeSort_service_1 = __webpack_require__(39);
	exports.moduleName = 'rl.ui.components.cardContainer.sorts.sorter';
	exports.serviceName = 'sorter';
	var Sorter = (function () {
	    function Sorter(mergeSort) {
	        this.mergeSort = mergeSort;
	    }
	    Sorter.prototype.sort = function (data, sort) {
	        var _this = this;
	        if (sort === null) {
	            return data;
	        }
	        if (_.isArray(sort)) {
	            var reverseSorts = _.clone(sort);
	            reverseSorts.reverse();
	            return _.reduce(reverseSorts, function (sortedData, nextSort) {
	                return _this.singleSort(sortedData, nextSort);
	            }, data);
	        }
	        return this.singleSort(data, sort);
	    };
	    Sorter.prototype.singleSort = function (data, sort) {
	        var compareFunction = this.buildSortFunction(sort);
	        return this.mergeSort.sort(data, compareFunction);
	    };
	    Sorter.prototype.buildSortFunction = function (sort) {
	        return function (a, b) {
	            if (sort.direction === sortDirection_1.SortDirection.none) {
	                return typescript_angular_utilities_1.types.CompareResult.equal;
	            }
	            var valueOfA = sort.column.getValue(a);
	            var valueOfB = sort.column.getValue(b);
	            var greaterResult = typescript_angular_utilities_1.types.CompareResult.greater;
	            var lessResult = typescript_angular_utilities_1.types.CompareResult.less;
	            var descendingSort = (sort.direction === sortDirection_1.SortDirection.descending);
	            var flip = sort.column.flipSort;
	            // Exclusive OR... if flipping a descending sort, you get an ascending sort
	            if ((descendingSort || flip) && !(descendingSort && flip)) {
	                greaterResult = typescript_angular_utilities_1.types.CompareResult.less;
	                lessResult = typescript_angular_utilities_1.types.CompareResult.greater;
	            }
	            return valueOfA > valueOfB
	                ? greaterResult
	                : (valueOfA < valueOfB ? lessResult : typescript_angular_utilities_1.types.CompareResult.equal);
	        };
	    };
	    Sorter.$inject = [mergeSort_service_1.serviceName];
	    return Sorter;
	})();
	exports.Sorter = Sorter;
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, Sorter);
	//# sourceMappingURL=sorter.service.js.map

/***/ },
/* 41 */
/***/ function(module, exports) {

	'use strict';
	//# sourceMappingURL=sort.js.map

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../../typings/lodashTypeExtensions.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.dataPager';
	exports.factoryName = 'dataPager';
	exports.defaultPageSize = 10;
	var DataPager = (function () {
	    function DataPager() {
	        this.pageNumber = 1;
	        this.pageSize = exports.defaultPageSize;
	    }
	    DataPager.prototype.filter = function (dataSet) {
	        var size = this.pageSize;
	        var start = (this.pageNumber - 1) * size;
	        return _(dataSet)
	            .drop(start)
	            .take(size)
	            .value();
	    };
	    return DataPager;
	})();
	exports.DataPager = DataPager;
	function dataPagerFactory() {
	    'use strict';
	    return {
	        getInstance: function () {
	            return new DataPager();
	        },
	    };
	}
	exports.dataPagerFactory = dataPagerFactory;
	angular.module(exports.moduleName, [])
	    .factory(exports.factoryName, dataPagerFactory);
	//# sourceMappingURL=dataPager.service.js.map

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __array = typescript_angular_utilities_1.services.array;
	var dataSourceBase_service_1 = __webpack_require__(44);
	var dataSourceProcessor_service_1 = __webpack_require__(45);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.dataServiceDataSource';
	exports.factoryName = 'dataServiceDataSource';
	var DataServiceDataSource = (function (_super) {
	    __extends(DataServiceDataSource, _super);
	    function DataServiceDataSource(getDataSet, $q, observableFactory, dataSourceProcessor, array) {
	        _super.call(this, observableFactory, dataSourceProcessor, array);
	        this.getDataSet = getDataSet;
	        this.$q = $q;
	        this.countFilterGroups = true;
	        if (_.isFunction(this.getDataSet)) {
	            this.reload();
	        }
	    }
	    DataServiceDataSource.prototype.reload = function () {
	        var _this = this;
	        this.dataSet = null;
	        this.rawDataSet = null;
	        this.loadingDataSet = true;
	        this.$q.when(this.getDataSet()).then(function (data) {
	            _this.loadingDataSet = false;
	            _this.rawDataSet = data;
	            _this.refresh();
	            _this.observable.fire('reloaded');
	            _this.observable.fire('changed');
	        });
	    };
	    return DataServiceDataSource;
	})(dataSourceBase_service_1.DataSourceBase);
	exports.DataServiceDataSource = DataServiceDataSource;
	dataServiceDataSourceFactory.$inject = [__observable.factoryName, dataSourceProcessor_service_1.processorServiceName, __array.serviceName, '$q'];
	function dataServiceDataSourceFactory(observableFactory, dataSourceProcessor, array, $q) {
	    'use strict';
	    return {
	        getInstance: function (getDataSet) {
	            return new DataServiceDataSource(getDataSet, $q, observableFactory, dataSourceProcessor, array);
	        },
	    };
	}
	exports.dataServiceDataSourceFactory = dataServiceDataSourceFactory;
	angular.module(exports.moduleName, [__observable.moduleName, __array.moduleName])
	    .factory(exports.factoryName, dataServiceDataSourceFactory);
	//# sourceMappingURL=dataServiceDataSource.service.js.map

/***/ },
/* 44 */
/***/ function(module, exports) {

	'use strict';
	var DataSourceBase = (function () {
	    function DataSourceBase(observableFactory, dataSourceProcessor, array) {
	        this.dataSourceProcessor = dataSourceProcessor;
	        this.array = array;
	        this.sorts = [];
	        this.filters = {};
	        this.count = 0;
	        this.countFilterGroups = false;
	        this.loadingDataSet = false;
	        this.observable = observableFactory.getInstance();
	    }
	    DataSourceBase.prototype.watch = function (action, event) {
	        return this.observable.register(action, event);
	    };
	    DataSourceBase.prototype.processData = function () {
	        var processedData;
	        if (this.countFilterGroups) {
	            processedData = this.dataSourceProcessor.processAndCount(this.sorts, this.filters, this.pager, this.rawDataSet);
	        }
	        else {
	            processedData = this.dataSourceProcessor.process(this.sorts, this.filters, this.pager, this.rawDataSet);
	        }
	        this.count = processedData.count;
	        this.dataSet = processedData.dataSet;
	        this.filteredDataSet = processedData.filteredDataSet;
	    };
	    DataSourceBase.prototype.refresh = function () {
	        if (!this.loadingDataSet) {
	            this.processData();
	            this.observable.fire('redrawing');
	        }
	    };
	    DataSourceBase.prototype.remove = function (data) {
	        var item = this.array.remove(this.rawDataSet, data);
	        if (item != null) {
	            this.observable.fire('removed');
	            this.observable.fire('changed');
	            if (this.pager) {
	                this.refresh();
	            }
	        }
	    };
	    DataSourceBase.prototype.push = function (data) {
	        this.rawDataSet.push(data);
	        this.observable.fire('added');
	        this.observable.fire('changed');
	        this.refresh();
	    };
	    DataSourceBase.prototype.replace = function (oldData, newData) {
	        var locationOfOldData = this.rawDataSet.indexOf(oldData);
	        if (locationOfOldData >= 0) {
	            this.array.replace(this.rawDataSet, oldData, newData);
	            this.observable.fire('replaced');
	            this.observable.fire('changed');
	            this.refresh();
	        }
	    };
	    return DataSourceBase;
	})();
	exports.DataSourceBase = DataSourceBase;
	//# sourceMappingURL=dataSourceBase.service.js.map

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __object = typescript_angular_utilities_1.services.object;
	var sorter_service_1 = __webpack_require__(40);
	exports.processorServiceName = 'dataSourceProcessor';
	var DataSourceProcessor = (function () {
	    function DataSourceProcessor(object, sorter) {
	        this.object = object;
	        this.sorter = sorter;
	    }
	    DataSourceProcessor.prototype.process = function (sorts, filters, pager, data) {
	        var processedData = data;
	        if (this.object.isNullOrEmpty(sorts) === false) {
	            processedData = this.sorter.sort(processedData, sorts);
	        }
	        if (this.object.isNullOrEmpty(filters) === false) {
	            processedData = _.reduce(filters, function (filteredData, filter) {
	                // Filter the data set using the filter function on the filter
	                return _.filter(filteredData, filter.filter, filter);
	            }, processedData);
	        }
	        var result = {
	            count: (processedData != null ? processedData.length : 0),
	            filteredDataSet: processedData,
	            dataSet: processedData,
	        };
	        if (pager != null) {
	            result.dataSet = pager.filter(processedData);
	        }
	        return result;
	    };
	    DataSourceProcessor.prototype.processAndCount = function (sorts, filters, pager, data) {
	        var _this = this;
	        // If there are no filters that need to updated option counts, use the normal processor
	        if (this.object.isNullOrEmpty(filters)
	            || _.any(filters, function (filter) { return _.isFunction(filter.updateOptionCounts); }) === false) {
	            return this.process(sorts, filters, pager, data);
	        }
	        var processedData = data;
	        if (this.object.isNullOrEmpty(sorts) === false) {
	            processedData = this.sorter.sort(processedData, sorts);
	        }
	        var wrappedData = this.wrapData(processedData);
	        // Run filtration logic and compute visible items
	        _.each(filters, function (filter) {
	            _.each(wrappedData, function (item) {
	                item.filterData[filter.type] = filter.filter(item.data);
	            });
	        });
	        // Give each filter a chance to update option counts
	        _.each(filters, function (filter) {
	            if (_.isFunction(filter.updateOptionCounts)) {
	                var otherFiltersApplied = _.filter(wrappedData, function (item) {
	                    // Omit the true or false of the current filter an
	                    //  only filter out items removed by other filters
	                    var filterData = _.omit(item.filterData, filter.type); //*filterData
	                    return _.all(_.values(filterData));
	                });
	                filter.updateOptionCounts(_this.unwrapData(otherFiltersApplied));
	            }
	        });
	        // Filter down to final data set by removing items that don't match all filters
	        wrappedData = _.filter(wrappedData, function (item) {
	            return _.all(_.values(item.filterData));
	        });
	        processedData = this.unwrapData(wrappedData);
	        var result = {
	            count: processedData.length,
	            filteredDataSet: processedData,
	            dataSet: processedData,
	        };
	        if (pager != null) {
	            result.dataSet = pager.filter(processedData);
	        }
	        return result;
	    };
	    DataSourceProcessor.prototype.wrapData = function (data) {
	        return _.map(data, function (item) {
	            return {
	                data: item,
	                filterData: {},
	            };
	        });
	    };
	    DataSourceProcessor.prototype.unwrapData = function (data) {
	        return _.map(data, function (item) {
	            return item.data;
	        });
	    };
	    DataSourceProcessor.$inject = [__object.serviceName, sorter_service_1.serviceName];
	    return DataSourceProcessor;
	})();
	exports.DataSourceProcessor = DataSourceProcessor;
	//# sourceMappingURL=dataSourceProcessor.service.js.map

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __array = typescript_angular_utilities_1.services.array;
	var dataSourceBase_service_1 = __webpack_require__(44);
	var dataSourceProcessor_service_1 = __webpack_require__(45);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.simpleDataSource';
	exports.factoryName = 'simpleDataSource';
	var SimpleDataSource = (function (_super) {
	    __extends(SimpleDataSource, _super);
	    function SimpleDataSource(data, observableFactory, dataSourceProcessor, array) {
	        _super.call(this, observableFactory, dataSourceProcessor, array);
	        this.countFilterGroups = false;
	        this.rawDataSet = data;
	        this.processData();
	    }
	    return SimpleDataSource;
	})(dataSourceBase_service_1.DataSourceBase);
	exports.SimpleDataSource = SimpleDataSource;
	simpleDataSourceFactory.$inject = [__observable.factoryName, dataSourceProcessor_service_1.processorServiceName, __array.serviceName];
	function simpleDataSourceFactory(observableFactory, dataSourceProcessor, array) {
	    'use strict';
	    return {
	        getInstance: function (data) {
	            return new SimpleDataSource(data, observableFactory, dataSourceProcessor, array);
	        },
	    };
	}
	exports.simpleDataSourceFactory = simpleDataSourceFactory;
	angular.module(exports.moduleName, [__observable.moduleName, __array.moduleName])
	    .factory(exports.factoryName, simpleDataSourceFactory);
	//# sourceMappingURL=simpleDataSource.service.js.map

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __array = typescript_angular_utilities_1.services.array;
	var __object = typescript_angular_utilities_1.services.object;
	var __synchronizedRequests = typescript_angular_utilities_1.services.synchronizedRequests;
	var dataSourceBase_service_1 = __webpack_require__(44);
	var dataSourceProcessor_service_1 = __webpack_require__(45);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.serverSearchDataSource';
	exports.factoryName = 'serverSearchDataSource';
	var ServerSearchDataSource = (function (_super) {
	    __extends(ServerSearchDataSource, _super);
	    function ServerSearchDataSource(getDataSet, searchFilter, getFilterModel, validateModel, observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory) {
	        var _this = this;
	        _super.call(this, observableFactory, dataSourceProcessor, array);
	        this.searchFilter = searchFilter;
	        this.getFilterModel = getFilterModel;
	        this.validateModel = validateModel;
	        this.object = object;
	        this.minSearchLength = 4;
	        this.resolveReload = function (data) {
	            _this.loadingDataSet = false;
	            _this.rawDataSet = data;
	            _this.refresh();
	            _this.observable.fire('reloaded');
	            _this.observable.fire('changed');
	        };
	        this.getFilterModel = this.getFilterModel || function () { return null; };
	        this.validateModel = this.validateModel || function () { return true; };
	        this.countFilterGroups = true;
	        this.search = searchFilter.searchText;
	        this.filterModel = _.clone(this.getFilterModel());
	        searchFilter.minSearchLength = this.minSearchLength;
	        this.synchronizedRequests = synchronizedRequestsFactory.getInstance(getDataSet, this.resolveReload.bind(this));
	    }
	    Object.defineProperty(ServerSearchDataSource.prototype, "getDataSet", {
	        set: function (value) {
	            this.synchronizedRequests.dataProvider = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ServerSearchDataSource.prototype.refresh = function () {
	        if (this.searchFilter.searchText !== this.search
	            || this.filterModelChanged()) {
	            this.reload();
	        }
	        else {
	            _super.prototype.refresh.call(this);
	        }
	    };
	    ServerSearchDataSource.prototype.reload = function () {
	        this.search = this.searchFilter.searchText;
	        this.filterModel = _.clone(this.getFilterModel());
	        var hasValidSearch = !this.object.isNullOrEmpty(this.search) && this.search.length >= this.minSearchLength;
	        var hasValidFilterModel = this.filterModel != null && this.validateModel(this.filterModel);
	        if (!hasValidSearch && !hasValidFilterModel) {
	            this.resolveReload(null);
	            return;
	        }
	        this.dataSet = null;
	        this.rawDataSet = null;
	        this.loadingDataSet = true;
	        this.synchronizedRequests.getData(this.buildSearchParams());
	    };
	    ServerSearchDataSource.prototype.filterModelChanged = function () {
	        return !this.object.areEqual(this.getFilterModel(), this.filterModel);
	    };
	    ServerSearchDataSource.prototype.buildSearchParams = function () {
	        var searchModel = this.getFilterModel();
	        if (searchModel != null) {
	            searchModel.search = this.search;
	        }
	        else {
	            searchModel = this.search;
	        }
	        return searchModel;
	    };
	    return ServerSearchDataSource;
	})(dataSourceBase_service_1.DataSourceBase);
	exports.ServerSearchDataSource = ServerSearchDataSource;
	serverSearchDataSourceFactory.$inject = [__observable.factoryName, dataSourceProcessor_service_1.processorServiceName, __array.serviceName, __object.serviceName, __synchronizedRequests.factoryName];
	function serverSearchDataSourceFactory(observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory) {
	    'use strict';
	    return {
	        getInstance: function (getDataSet, searchFilter, getFilterModel, validateModel) {
	            return new ServerSearchDataSource(getDataSet, searchFilter, getFilterModel, validateModel, observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory);
	        },
	    };
	}
	exports.serverSearchDataSourceFactory = serverSearchDataSourceFactory;
	angular.module(exports.moduleName, [__observable.moduleName, __array.moduleName, __object.moduleName, __synchronizedRequests.moduleName])
	    .factory(exports.factoryName, serverSearchDataSourceFactory);
	//# sourceMappingURL=serverSearchDataSource.service.js.map

/***/ },
/* 48 */
/***/ function(module, exports) {

	'use strict';
	//# sourceMappingURL=dataSource.js.map

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var columnSearchFilter = __webpack_require__(50);
	exports.columnSearchFilter = columnSearchFilter;
	var filterGroup = __webpack_require__(51);
	exports.filterGroup = filterGroup;
	exports.moduleName = 'rl.ui.components.cardContainer.filters';
	angular.module(exports.moduleName, [
	    columnSearchFilter.moduleName,
	    filterGroup.moduleName,
	]);
	//# sourceMappingURL=filters.module.js.map

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __object = typescript_angular_utilities_1.services.object;
	var __string = typescript_angular_utilities_1.services.string;
	exports.moduleName = 'rl.ui.components.cardContainer.filters.columnSearchFilter';
	exports.factoryName = 'columnSearchFilter';
	exports.filterName = 'column-search';
	var ColumnSearchFilter = (function () {
	    function ColumnSearchFilter(object, string) {
	        this.object = object;
	        this.string = string;
	        this.type = exports.filterName;
	    }
	    ColumnSearchFilter.prototype.filter = function (item) {
	        if (this.column == null) {
	            return true;
	        }
	        var value = this.object.toString(this.column.getValue(item));
	        var search = this.searchText;
	        if (!this.caseSensitive) {
	            search = search.toLowerCase();
	            value = value.toLowerCase();
	        }
	        return this.string.contains(value, search);
	    };
	    return ColumnSearchFilter;
	})();
	exports.ColumnSearchFilter = ColumnSearchFilter;
	columnSearchFilterFactory.$inject = [__object.serviceName, __string.serviceName];
	function columnSearchFilterFactory(object, string) {
	    'use strict';
	    return {
	        getInstance: function () {
	            return new ColumnSearchFilter(object, string);
	        },
	    };
	}
	exports.columnSearchFilterFactory = columnSearchFilterFactory;
	angular.module(exports.moduleName, [__object.moduleName, __string.moduleName])
	    .factory(exports.factoryName, columnSearchFilterFactory);
	//# sourceMappingURL=columnSearchFilter.service.js.map

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var filterOption = __webpack_require__(52);
	exports.filterOption = filterOption;
	var modeFilterGroup = __webpack_require__(54);
	exports.modeFilterGroup = modeFilterGroup;
	var rangeFilterGroup = __webpack_require__(56);
	exports.rangeFilterGroup = rangeFilterGroup;
	var filterGroup_service_1 = __webpack_require__(55);
	var filterGroup_directive_1 = __webpack_require__(57);
	__export(__webpack_require__(57));
	__export(__webpack_require__(55));
	exports.moduleName = 'rl.ui.components.cardContainer.filters.filterGroup';
	angular.module(exports.moduleName, [
	    typescript_angular_utilities_1.services.object.moduleName,
	    filterOption.moduleName,
	    modeFilterGroup.moduleName,
	    rangeFilterGroup.moduleName,
	])
	    .factory(filterGroup_service_1.factoryName, filterGroup_service_1.filterGroupFactory)
	    .directive(filterGroup_directive_1.directiveName, filterGroup_directive_1.filterGroup)
	    .controller(filterGroup_directive_1.controllerName, filterGroup_directive_1.FilterGroupController);
	//# sourceMappingURL=filterGroup.module.js.map

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.cardContainer.filters.filterGroup.filterOption';
	exports.directiveName = 'rlFilterOption';
	function filterOption() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(53),
	        scope: {
	            activate: '&',
	            isActive: '=active',
	            option: '=',
	        },
	    };
	}
	exports.filterOption = filterOption;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, filterOption);
	//# sourceMappingURL=filterOption.js.map

/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row filter-option\" ng-class=\"{ 'active': isActive }\" ng-click=\"activate()\">\r\n\t<div class=\"col-sm-1\">\r\n\t\t<i class='fa fa-arrow-right' ng-show=\"isActive == true\"></i>\r\n\t</div>\r\n\t<div class=\"col-sm-1\" ng-if=\"hasIcon\" ng-bind-html=\"option.icon\"></div>\r\n\t<div ng-class=\"{ 'col-sm-6': hasIcon, 'col-sm-7': !hasIcon }\">\r\n\t\t{{option.label}}\r\n\t</div>\r\n\t<div class=\"col-sm-3 text-right\" ng-show=\"option.count != null\">\r\n\t\t({{option.count}})\r\n\t</div>\r\n</div>"

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __object = typescript_angular_utilities_1.services.object;
	var filterGroup_service_1 = __webpack_require__(55);
	exports.moduleName = 'rl.ui.components.cardContainer.filters.filterGroup.modeFilterGroup';
	exports.factoryName = 'modeFilterGroup';
	var ModeFilterGroup = (function (_super) {
	    __extends(ModeFilterGroup, _super);
	    function ModeFilterGroup(settings, object) {
	        this.getValue = settings.getValue;
	        settings.options = _.map(settings.options, this.buildModeOption, this);
	        _super.call(this, settings, object);
	    }
	    ModeFilterGroup.prototype.buildModeOption = function (option) {
	        var _this = this;
	        var modeOption = option;
	        modeOption.filter = function (item) {
	            if (modeOption.displayAll) {
	                return true;
	            }
	            return _this.getValue(item) === modeOption.value;
	        };
	        return modeOption;
	    };
	    return ModeFilterGroup;
	})(filterGroup_service_1.FilterGroup);
	exports.ModeFilterGroup = ModeFilterGroup;
	modeFilterGroupFactory.$inject = [__object.serviceName];
	function modeFilterGroupFactory(object) {
	    'use strict';
	    return {
	        getInstance: function (settings) {
	            return new ModeFilterGroup(settings, object);
	        },
	    };
	}
	exports.modeFilterGroupFactory = modeFilterGroupFactory;
	angular.module(exports.moduleName, [__object.moduleName])
	    .factory(exports.factoryName, modeFilterGroupFactory);
	//# sourceMappingURL=modeFilterGroup.service.js.map

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __object = typescript_angular_utilities_1.services.object;
	exports.factoryName = 'filterGroup';
	var FilterGroup = (function () {
	    function FilterGroup(settings, object) {
	        this.label = settings.label;
	        this.type = settings.type != null ? settings.type : settings.label;
	        this.options = settings.options;
	        this.activeOption = this.options[0];
	        _.each(this.options, function (option) {
	            if (_.isUndefined(option.type)) {
	                option.type = option.label;
	            }
	            option.type = object.toString(option.type).toLowerCase();
	        });
	    }
	    FilterGroup.prototype.filter = function (item) {
	        return this.activeOption.filter(item);
	    };
	    FilterGroup.prototype.setActiveOption = function (index) {
	        if (index >= 0 && index < this.options.length) {
	            this.activeOption = this.options[index];
	        }
	    };
	    FilterGroup.prototype.setOptionCounts = function (counts) {
	        _.each(this.options, function (option) {
	            if (_.has(counts, option.type)) {
	                option.count = counts[option.type];
	            }
	        });
	    };
	    FilterGroup.prototype.updateOptionCounts = function (filteredDataSet) {
	        _.each(this.options, function (option) {
	            option.count = _.filter(filteredDataSet, option.filter, option).length;
	        });
	    };
	    return FilterGroup;
	})();
	exports.FilterGroup = FilterGroup;
	filterGroupFactory.$inject = [__object.serviceName];
	function filterGroupFactory(object) {
	    'use strict';
	    return {
	        getInstance: function (settings) {
	            return new FilterGroup(settings, object);
	        },
	    };
	}
	exports.filterGroupFactory = filterGroupFactory;
	//# sourceMappingURL=filterGroup.service.js.map

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __object = typescript_angular_utilities_1.services.object;
	var filterGroup_service_1 = __webpack_require__(55);
	exports.moduleName = 'rl.ui.components.cardContainer.filters.filterGroup.rangeFilterGroup';
	exports.factoryName = 'rangeFilterGroup';
	var RangeFilterGroup = (function (_super) {
	    __extends(RangeFilterGroup, _super);
	    function RangeFilterGroup(settings, object) {
	        this.getValue = settings.getValue;
	        settings.options = _.map(settings.options, this.buildRangeOption, this);
	        _super.call(this, settings, object);
	    }
	    RangeFilterGroup.prototype.buildRangeOption = function (option) {
	        var _this = this;
	        var modeOption = option;
	        modeOption.filter = function (item) {
	            var value = _this.getValue(item);
	            var result = true;
	            if (_.isUndefined(option.highExclusive) === false) {
	                result = value < option.highExclusive;
	            }
	            else if (_.isUndefined(option.highInclusive) === false) {
	                result = value <= option.highInclusive;
	            }
	            if (_.isUndefined(option.lowExclusive) === false) {
	                result = result && value > option.lowExclusive;
	            }
	            else if (_.isUndefined(option.lowInclusive) === false) {
	                result = result && value >= option.lowInclusive;
	            }
	            return result;
	        };
	        return modeOption;
	    };
	    return RangeFilterGroup;
	})(filterGroup_service_1.FilterGroup);
	rangeFilterGroupFactory.$inject = [__object.serviceName];
	function rangeFilterGroupFactory(object) {
	    'use strict';
	    return {
	        getInstance: function (settings) {
	            return new RangeFilterGroup(settings, object);
	        },
	    };
	}
	exports.rangeFilterGroupFactory = rangeFilterGroupFactory;
	angular.module(exports.moduleName, [__object.moduleName])
	    .factory(exports.factoryName, rangeFilterGroupFactory);
	//# sourceMappingURL=rangeFilterGroup.service.js.map

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../../typings/commonjs.d.ts' />
	'use strict';
	exports.directiveName = 'rlFilterGroup';
	exports.controllerName = 'FilterGroupController';
	var FilterGroupController = (function () {
	    function FilterGroupController($scope) {
	        this.$scope = $scope;
	        this.hasIcon = this.icon != null && this.icon !== '';
	        this.showChildren = true;
	    }
	    FilterGroupController.prototype.toggleChildren = function () {
	        this.showChildren = !this.showChildren;
	    };
	    FilterGroupController.prototype.selectOption = function (option) {
	        this.filterGroup.activeOption = option;
	        this.showChildren = false;
	        if (this.source != null) {
	            this.source.refresh();
	        }
	        else {
	            this.$scope.$emit('dataSource.requestRefresh'); //*event?
	        }
	    };
	    FilterGroupController.$inject = ['$scope'];
	    return FilterGroupController;
	})();
	exports.FilterGroupController = FilterGroupController;
	function filterGroup() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(58),
	        controller: exports.controllerName,
	        controllerAs: 'controller',
	        scope: {},
	        bindToController: {
	            icon: '=',
	            filterGroup: '=',
	            source: '=',
	        },
	    };
	}
	exports.filterGroup = filterGroup;
	//# sourceMappingURL=filterGroup.directive.js.map

/***/ },
/* 58 */
/***/ function(module, exports) {

	module.exports = "<div class=\"filter-group\">\r\n\t<div class=\"row filter-header\" ng-click=\"controller.toggleChildren()\">\r\n\t\t<div class=\"col-sm-12\">\r\n\t\t\t<i class=\"collapse-icon fa fa-caret-down fa-2x\" ng-show=\"controller.showChildren\" title=\"Hide filter list\"></i>\r\n\t\t\t<i class=\"collapse-icon fa fa-caret-right fa-2x\" ng-hide=\"controller.showChildren\" title=\"Show filter list\"></i>\r\n\t\t\t<div class=\"filter-option\">\r\n\t\t\t\t<div style=\"display:inline-block\" ng-show=\"controller.hasIcon\" ng-bind-html=\"controller.icon\"></div>\r\n\t\t\t\t<h4 style=\"display: inline-block\">{{controller.filterGroup.label}}: {{controller.filterGroup.activeOption.label}}</h4>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</div>\r\n\t<div ng-show=\"controller.showChildren\" ng-repeat=\"filterOption in controller.filterGroup.options\">\r\n\t\t<rl-filter-option option=\"filterOption\" active=\"filterGroup.activeOption === filterOption\" activate=\"controller.selectOption(filterOption)\"></rl-filter-option>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.cardContainer.itemCount';
	exports.directiveName = 'rlItemCount';
	function itemCount() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: '^^rlCardContainer',
	        template: __webpack_require__(60),
	        scope: {
	            containerService: '=',
	        },
	    };
	}
	exports.itemCount = itemCount;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, itemCount);
	//# sourceMappingURL=itemCount.js.map

/***/ },
/* 60 */
/***/ function(module, exports) {

	module.exports = "<p ng-show=\"!containerService.dataSource.loadingDataSet\">\r\n\tShowing <strong>{{containerService.dataSource.dataSet.length}} of {{containerService.dataSource.count}}</strong> total items\r\n</p>"

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	exports.moduleName = 'rl.ui.components.cardContainer.pager';
	exports.directiveName = 'rlPager';
	exports.controllerName = 'PagerController';
	exports.defaultVisiblePageCount = 5;
	var PagerController = (function () {
	    function PagerController($scope) {
	        var _this = this;
	        this.canGoBack = false;
	        this.canGoForward = false;
	        this.hasPageFilter = true;
	        this.updatePageCount = function () {
	            var totalItems = _this.dataSource.count;
	            var newLastPage = Math.ceil(totalItems / _this.pager.pageSize);
	            if (newLastPage !== _this.lastPage) {
	                _this.lastPage = newLastPage;
	                _this.currentPage = 1;
	            }
	            _this.updatePaging();
	        };
	        if (this.containerService == null) {
	            return;
	        }
	        this.pager = this.containerService.pager;
	        if (this.pager == null) {
	            this.hasPageFilter = false;
	        }
	        else {
	            this.visiblePageCount = this.pageCount != null ? this.pageCount : exports.defaultVisiblePageCount;
	            this.lastPage = 1;
	            this.dataSource = this.containerService.dataSource;
	            $scope.$watch(function () { return _this.dataSource.count; }, this.updatePageCount);
	            $scope.$watch(function () { return _this.pager.pageSize; }, this.updatePageCount);
	            $scope.$watch(function () { return _this.currentPage; }, function (page) {
	                _this.updatePaging();
	                _this.pager.pageNumber = page;
	                _this.dataSource.refresh();
	            });
	        }
	    }
	    PagerController.prototype.updatePaging = function () {
	        var page = this.currentPage;
	        this.canGoBack = page > 1;
	        this.canGoForward = page < this.lastPage;
	        var nonCurrentVisiblePages = this.visiblePageCount - 1;
	        var before = Math.floor(nonCurrentVisiblePages / 2);
	        var after = Math.ceil(nonCurrentVisiblePages / 2);
	        var startPage = page - before;
	        var endPage = page + after;
	        if (startPage < 1) {
	            startPage = 1;
	            endPage = Math.min(this.visiblePageCount, this.lastPage);
	        }
	        else if (endPage > this.lastPage) {
	            endPage = this.lastPage;
	            startPage = Math.max(this.lastPage - nonCurrentVisiblePages, 1);
	        }
	        this.pages = _.range(startPage, endPage + 1);
	    };
	    PagerController.prototype.first = function () {
	        this.currentPage = 1;
	    };
	    PagerController.prototype.previous = function () {
	        if (this.currentPage > 1) {
	            this.currentPage--;
	        }
	    };
	    PagerController.prototype.goto = function (page) {
	        if (page >= 1 && page <= this.lastPage) {
	            this.currentPage = page;
	        }
	    };
	    PagerController.prototype.next = function () {
	        if (this.currentPage < this.lastPage) {
	            this.currentPage++;
	        }
	    };
	    PagerController.prototype.last = function () {
	        this.currentPage = this.lastPage;
	    };
	    PagerController.$inject = ['$scope'];
	    return PagerController;
	})();
	exports.PagerController = PagerController;
	function pager() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(62),
	        controller: exports.controllerName,
	        controllerAs: 'pager',
	        scope: {},
	        bindToController: {
	            pageCount: '=visiblePages',
	            containerService: '=',
	        },
	    };
	}
	exports.pager = pager;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, pager)
	    .controller(exports.controllerName, PagerController);
	//# sourceMappingURL=pager.js.map

/***/ },
/* 62 */
/***/ function(module, exports) {

	module.exports = "<nav ng-if=\"pager.hasPageFilter\">\r\n\t<ul class=\"pagination\">\r\n\t\t<li title=\"Go to first page\" ng-click=\"pager.first()\"\r\n\t\t\tng-class=\"{ 'disabled': !pager.canGoBack }\">\r\n\t\t\t<a><i class=\"fa fa-angle-double-left\"></i></a>\r\n\t\t</li>\r\n\t\t<li title=\"Go to previous page\" ng-click=\"pager.previous()\"\r\n\t\t\tng-class=\"{ 'disabled': !pager.canGoBack }\">\r\n\t\t\t<a><i class=\"fa fa-angle-left\"></i></a>\r\n\t\t</li>\r\n\t\t<li title=\"Go to page {{pager.page}}\" ng-click=\"pager.goto(page)\"\r\n\t\t\tng-repeat=\"page in pager.pages\"\r\n\t\t\tng-class=\"{ 'active': pager.currentPage == page }\">\r\n\t\t\t<a>{{page}}</a>\r\n\t\t</li>\r\n\t\t<li title=\"Go to next page\" ng-click=\"pager.next()\"\r\n\t\t\tng-class=\"{ 'disabled': !pager.canGoForward }\">\r\n\t\t\t<a><i class=\"fa fa-angle-right\"></i></a>\r\n\t\t</li>\r\n\t\t<li title=\"Go to last page\" ng-click=\"pager.last()\"\r\n\t\t\tng-class=\"{ 'disabled': !pager.canGoForward }\">\r\n\t\t\t<a><i class=\"fa fa-angle-double-right\"></i></a>\r\n\t\t</li>\r\n\t</ul>\r\n</nav>\r\n"

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.cardContainer.pageSize';
	exports.directiveName = 'rlPageSize';
	exports.controllerName = 'PageSizeController';
	exports.availablePageSizes = [10, 25, 50, 100];
	exports.defaultPageSize = 10;
	var PageSizeController = (function () {
	    function PageSizeController($scope) {
	        var _this = this;
	        if (this.containerService == null) {
	            return;
	        }
	        this.selectedPageSize = exports.defaultPageSize;
	        this.pageSizes = exports.availablePageSizes;
	        this.hasPageFilter = true;
	        var pager = this.containerService.pager;
	        if (pager == null) {
	            this.hasPageFilter = false;
	        }
	        else {
	            $scope.$watch(function () { return _this.selectedPageSize; }, function (newPageSize) {
	                if (pager != null) {
	                    pager.pageSize = newPageSize;
	                    _this.containerService.dataSource.refresh();
	                }
	            });
	        }
	    }
	    PageSizeController.$inject = ['$scope'];
	    return PageSizeController;
	})();
	exports.PageSizeController = PageSizeController;
	function pageSize() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(64),
	        controller: exports.controllerName,
	        controllerAs: 'controller',
	        scope: {},
	        bindToController: {
	            containerService: '=',
	        },
	    };
	}
	exports.pageSize = pageSize;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, pageSize)
	    .controller(exports.controllerName, PageSizeController);
	//# sourceMappingURL=pageSize.js.map

/***/ },
/* 64 */
/***/ function(module, exports) {

	module.exports = "<div ng-show=\"controller.hasPageFilter\">\r\n\t<select class=\"form-control\" title=\"Cards per page\" ng-model=\"controller.selectedPageSize\"\r\n\t\t\tng-options=\"pageSize for pageSize in controller.pageSizes\"></select>\r\n</div>\r\n"

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __boolean = typescript_angular_utilities_1.services.boolean;
	exports.moduleName = 'rl.ui.components.cardContainer.selectionControl';
	exports.directiveName = 'rlSelectionControl';
	exports.controllerName = 'SelectionControlController';
	var SelectionControlController = (function () {
	    function SelectionControlController($scope, bool) {
	        var _this = this;
	        this.$scope = $scope;
	        if (this.containerService == null) {
	            return;
	        }
	        this.selectedItems = this.containerService.numberSelected;
	        this.pagingEnabled = bool.toBool(this.containerService.pager);
	        this.dataSource = this.containerService.dataSource;
	        $scope.$watch(function () { return _this.containerService.numberSelected; }, function (value) {
	            _this.selectedItems = value;
	        });
	    }
	    SelectionControlController.prototype.selectPage = function () {
	        _.each(this.dataSource.dataSet, function (item) {
	            item.viewData.selected = true;
	        });
	        this.$scope.$emit('selectionChanged'); //*events?
	    };
	    SelectionControlController.prototype.selectAll = function () {
	        _.each(this.dataSource.filteredDataSet, function (item) {
	            item.viewData.selected = true;
	        });
	        this.$scope.$emit('selectionChanged'); //*events?
	    };
	    SelectionControlController.prototype.clearPage = function () {
	        _.each(this.dataSource.dataSet, function (item) {
	            item.viewData.selected = false;
	        });
	        this.$scope.$emit('selectionChanged'); //*events?
	    };
	    SelectionControlController.prototype.clearAll = function () {
	        _.each(this.dataSource.filteredDataSet, function (item) {
	            item.viewData.selected = false;
	        });
	        this.$scope.$emit('selectionChanged'); //*events?
	    };
	    SelectionControlController.$inject = ['$scope', __boolean.serviceName];
	    return SelectionControlController;
	})();
	exports.SelectionControlController = SelectionControlController;
	function selectionControl() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(66),
	        controller: exports.controllerName,
	        controllerAs: 'selection',
	        scope: {},
	        bindToController: {
	            containerService: '=',
	        },
	    };
	}
	exports.selectionControl = selectionControl;
	angular.module(exports.moduleName, [__boolean.moduleName])
	    .directive(exports.directiveName, selectionControl)
	    .controller(exports.controllerName, SelectionControlController);
	//# sourceMappingURL=selectionControl.js.map

/***/ },
/* 66 */
/***/ function(module, exports) {

	module.exports = "<div>\r\n\t<div style=\"margin-bottom: 5px\">\r\n\t\t<span><strong>{{selection.selectedItems}}</strong> items selected</span>\r\n\t</div>\r\n\t<div style=\"margin-bottom: 5px\" ng-if=\"selection.pagingEnabled\">\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-click=\"selection.selectPage()\">Select page</button>\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-click=\"selection.clearPage()\">Clear page</button>\r\n\t</div>\r\n\t<div>\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-click=\"selection.selectAll()\">Select all</button>\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-click=\"selection.clearAll()\">Clear all</button>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	// /// <reference path='../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __object = typescript_angular_utilities_1.services.object;
	var __array = typescript_angular_utilities_1.services.array;
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var dataSources_module_1 = __webpack_require__(37);
	var sorts_module_1 = __webpack_require__(38);
	var breakpoint_1 = __webpack_require__(31);
	var cardContainer_service_1 = __webpack_require__(68);
	exports.directiveName = 'rlCardContainer';
	exports.controllerName = 'CardContainerController';
	exports.defaultMaxColumnSorts = 2;
	exports.defaultSelectionTitle = 'Select card';
	var CardContainerController = (function () {
	    function CardContainerController($scope, $attrs, object, array, dataPagerFactory, parentChild) {
	        var _this = this;
	        this.$scope = $scope;
	        this.object = object;
	        this.array = array;
	        this.dataPagerFactory = dataPagerFactory;
	        this.parentChild = parentChild;
	        this.numberSelected = 0;
	        this.addViewData = function () {
	            _.each(_this.dataSource.rawDataSet, function (item) {
	                if (_.isUndefined(item.viewData)) {
	                    item.viewData = {
	                        selected: false,
	                    };
	                }
	            });
	            _this.updateDisabledSelections();
	        };
	        this.clearFilteredSelections = function () {
	            var nonVisibleItems = _.difference(_this.dataSource.rawDataSet, _this.dataSource.filteredDataSet);
	            _.each(nonVisibleItems, function (item) {
	                if (_.isUndefined(item.viewData)) {
	                    item.viewData = {
	                        selected: false,
	                    };
	                }
	                item.viewData.selected = false;
	                item.viewData.selectionTitle = exports.defaultSelectionTitle;
	            });
	            _this.updateSelected();
	        };
	        this.updateSelected = function () {
	            _this.numberSelected = _.filter(_this.dataSource.filteredDataSet, function (item) {
	                return item.viewData != null && item.viewData.selected;
	            }).length;
	        };
	        this.updateDisabledSelections = function () {
	            if (_this.disablingSelections) {
	                _.each(_this.dataSource.rawDataSet, function (item) {
	                    var disabledReason = _this.disableSelection({ item: item });
	                    item.viewData.disabledSelection = (disabledReason != null);
	                    item.viewData.selectionTitle = (item.viewData.disabledSelection ? disabledReason : exports.defaultSelectionTitle);
	                });
	            }
	        };
	        this.dataSource = this.source;
	        this.permanentFooters = _.isUndefined(this.permanentFooters) ? false : this.permanentFooters;
	        this.maxColSorts = this.maxColumnSorts != null ? this.maxColumnSorts : exports.defaultMaxColumnSorts;
	        this.disablingSelections = object.isNullOrWhitespace($attrs.disableSelection) === false;
	        this.sortDirection = sorts_module_1.SortDirection;
	        this.syncFilters();
	        this.setupPaging();
	        this.buildColumnSizes();
	        if (this.selectableCards) {
	            //*use card container event service?
	            $scope.$on('selectionChanged', this.updateSelected);
	            $scope.$on('updateDisabledSelections', this.updateDisabledSelections);
	            this.dataSource.watch(this.addViewData, 'changed');
	            this.dataSource.watch(this.clearFilteredSelections, 'redrawing');
	            this.addViewData();
	            this.selectionColumn = {
	                label: null,
	                size: null,
	                getValue: function (item) {
	                    return item.viewData.selected;
	                },
	                flipSort: true,
	            };
	        }
	        if (this.dataSource.sorts == null) {
	            this.dataSource.sorts = [];
	        }
	        $scope.containerService = new cardContainer_service_1.CardContainerService(this);
	        $scope.containerData = this.containerData;
	    }
	    CardContainerController.prototype.sortSelected = function () {
	        this.sort(this.selectionColumn);
	    };
	    CardContainerController.prototype.openCard = function () {
	        var behaviors = this.parentChild.getAllChildBehaviors(this.dataSource.dataSet);
	        return _.all(_.map(behaviors, function (behavior) { return behavior.close(); }));
	    };
	    CardContainerController.prototype.sort = function (column) {
	        var sortList = this.dataSource.sorts;
	        var firstSort = sortList[0];
	        // If column is already the primary sort, change the direction
	        if (firstSort != null
	            && firstSort.column === column) {
	            firstSort.direction = sorts_module_1.SortDirection.toggle(firstSort.direction);
	            // Clear sort
	            if (firstSort.direction === sorts_module_1.SortDirection.none) {
	                this.clearVisualSortIndicator(firstSort);
	                firstSort = null;
	                // If the column has secondary sorts don't fall back to a
	                //  secondary sort, instead just clear all sorts
	                if (column.secondarySorts != null) {
	                    sortList.length = 0;
	                }
	                else {
	                    sortList.shift();
	                }
	            }
	        }
	        else {
	            // Else make column primary ascending sort
	            // Remove any existing non-primary sorts on column
	            this.array.remove(sortList, function (sort) {
	                return column === sort.column;
	            });
	            // Build ascending sort for column
	            var newSort = {
	                column: column,
	                direction: sorts_module_1.SortDirection.ascending,
	            };
	            sortList.unshift(newSort);
	            firstSort = newSort;
	        }
	        this.updateVisualColumnSorting();
	        // If column has secondary sorts, wipe the sort order and just apply the secondary sorts
	        if (firstSort != null && column.secondarySorts != null) {
	            sortList.length = 0;
	            var secondarySorts = this.buildSecondarySorts(firstSort.direction, column.secondarySorts);
	            sortList.push(firstSort);
	            sortList.push.apply(sortList, secondarySorts);
	        }
	        else {
	            // If not using column secondary sorts, limit the maximum number
	            //  of sorts applied to the maximum number of sorts
	            this.dataSource.sorts = _.take(sortList, this.maxColSorts);
	        }
	        this.dataSource.refresh();
	    };
	    CardContainerController.prototype.selectionChanged = function () {
	        this.updateSelected();
	        this.$scope.$emit('selectionChanged');
	    };
	    CardContainerController.prototype.syncFilters = function () {
	        if (this.filters != null) {
	            // Convert filter array to dictionary if necessary
	            if (_.isArray(this.filters)) {
	                this.filters = this.array.toDictionary(this.filters, function (filter) { return filter.type; });
	            }
	            this.dataSource.filters = this.filters;
	            this.dataSource.refresh();
	        }
	        else if (this.dataSource.filters != null) {
	            this.filters = this.dataSource.filters;
	        }
	    };
	    CardContainerController.prototype.setupPaging = function () {
	        // If paging flag is specified, card container controls pager instance
	        if (this.paging != null) {
	            if (this.paging === false) {
	                this.dataSource.pager = null;
	            }
	            else {
	                this.pager = this.dataPagerFactory.getInstance();
	                this.dataSource.pager = this.pager;
	            }
	        }
	        else if (this.dataSource.pager) {
	            // If the paging flag is not set and the dataSource has a pager, save a reference here
	            this.pager = this.dataSource.pager;
	        }
	    };
	    CardContainerController.prototype.buildColumnSizes = function () {
	        var _this = this;
	        _.each(this.columns, function (column) {
	            var sizes = column.size;
	            if (_.isObject(sizes)) {
	                sizes[breakpoint_1.xs] = _this.object.valueOrDefault(sizes[breakpoint_1.xs], 0);
	                sizes[breakpoint_1.sm] = _this.object.valueOrDefault(sizes[breakpoint_1.sm], sizes[breakpoint_1.xs]);
	                sizes[breakpoint_1.md] = _this.object.valueOrDefault(sizes[breakpoint_1.md], sizes[breakpoint_1.sm]);
	                sizes[breakpoint_1.lg] = _this.object.valueOrDefault(sizes[breakpoint_1.lg], sizes[breakpoint_1.md]);
	            }
	            else {
	                column.size = {
	                    xs: sizes,
	                    sm: sizes,
	                    md: sizes,
	                    lg: sizes,
	                };
	            }
	        });
	    };
	    CardContainerController.prototype.lookupColumn = function (label) {
	        return _.find(this.columns, function (column) {
	            return column.label === label;
	        });
	    };
	    CardContainerController.prototype.buildSecondarySorts = function (direction, secondarySorts) {
	        var _this = this;
	        var sortList = secondarySorts[sorts_module_1.SortDirection.getFullName(direction)];
	        return _.map(sortList, function (sort) {
	            return {
	                direction: sort.direction,
	                column: _this.lookupColumn(sort.column),
	            };
	        });
	    };
	    CardContainerController.prototype.updateVisualColumnSorting = function () {
	        var _this = this;
	        _.each(this.dataSource.sorts, function (sort, index) {
	            // Only first sort should have visible direction
	            if (index === 0) {
	                _this.updateVisualSortIndicator(sort);
	            }
	            else {
	                _this.clearVisualSortIndicator(sort);
	            }
	        });
	    };
	    CardContainerController.prototype.updateVisualSortIndicator = function (sort) {
	        sort.column.sortDirection = sort.direction;
	    };
	    CardContainerController.prototype.clearVisualSortIndicator = function (sort) {
	        sort.column.sortDirection = null;
	    };
	    CardContainerController.$inject = ['$scope', '$attrs', __object.serviceName, __array.serviceName, dataSources_module_1.dataPager.factoryName, __parentChild.serviceName];
	    return CardContainerController;
	})();
	exports.CardContainerController = CardContainerController;
	cardContainer.$inject = ['$compile'];
	function cardContainer($compile) {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: __webpack_require__(69),
	        controller: exports.controllerName,
	        controllerAs: 'cardContainer',
	        scope: {},
	        bindToController: {
	            // summary: The data source for the card container
	            // remarks: Can be an array of objects, or an implementation of the data source contract: {
	            //     sorts: A list of sorts to apply to the data. Sorts should be in this format: {
	            //         column: The name of the column to sort on,
	            //         direction: Sort ascending or descending (sortDirection.js)
	            //     },
	            //     filters: A list of filters to apply to the data source,
	            //     pager: A pager that can be optionally used to page the data: {
	            //         filter: function(dataSet) {
	            //             Takes the data set and filters it down to pages
	            //         }
	            //     },
	            //     refresh: [function] Call to trigger the data source to refresh,
	            //     dataSet: Will contain the resulting data provided by the source, after sorts and filters are applied,
	            //     count: The number of items available in the data set (used for paging).
	            //     loadingDataSet: A boolean indicating if the dataSet is being refreshed / loaded,
	            // }
	            source: '=',
	            // summary: A list of filters to be applied to the data source
	            // remarks: Each filter should implement the data filter contract: {
	            //     type: A name that can be used to look up the filter,
	            //     filter: function(item) { takes an item and returns false if it should be removed from the data set },
	            // }
	            filters: '=',
	            // summary: Turn paging on or off (true / false)
	            paging: '=',
	            // summary: A list of the columns for building the column header and card headers.
	            // remarks: Each column object should be in the following format: {
	            //     label: The label for the column header,
	            //     description: A description for the column; shown in tooltips,
	            //     size: A description of the column size at breakpoints; either a constant int (for constant size) or breakpoint detail object: {
	            //         [xs]: optional size for xs breakpoint (defaults to 0),
	            //         [sm]: optional size for sm breakpoint (defaults to xs),
	            //         [md]: optional size for md breakpoint (defaults to sm),
	            //         [lg]: optional size for lg breakpoint (defaults to md),
	            //     },
	            //     getValue: A function that takes a data record and retrieves the value for the column,
	            //     headerTemplateUrl: The path to an HTML template for the column header,
	            //     headerTemplate: An HTML template string for the column header (overriden by headerTemplateUrl if present),
	            //     templateUrl: The path to an HTML template for the card header,
	            //     template: An HTML template string for the card header (overriden by templateUrl if present),
	            //     secondarySorts: A set of secondary sorts to apply on other columns when this column is sorted (ascending and / or descending): {
	            //        sortDirection.ascending ('asc'):  [
	            //             {
	            //                 column: The label of another column to sort on,
	            //                 direction: The direction to sort the column,
	            //             },
	            //             ...
	            //        ],
	            //        sortDirection.descending ('desc'): [
	            //             {
	            //                 column: The label of another column to sort on,
	            //                 direction: The direction to sort the column,
	            //             },
	            //             ...
	            //        ],
	            //     }
	            // }
	            columns: '=',
	            // summary: container-wide data available in cards
	            containerData: '=',
	            // summary: controller shared by all components on a card
	            // remarks: this controller cannot override any of the following variable names:
	            //          columns
	            //          item
	            //          contentTemplate
	            //          footerTemplate
	            //          clickable
	            //          cardController
	            //          cardControllerAs
	            //          cardAs
	            //          showContent
	            //          toggleContent
	            //          collapse
	            //          selected
	            //          setSelected
	            cardController: '@',
	            // summary: controller alias specified using controllerAs syntax
	            cardControllerAs: '@',
	            // summary: name used to access the card data
	            cardAs: '@',
	            // summary: Indicates if cards should show active state on mouse over
	            clickableCards: '=',
	            // summary: The number of sorts that can be applied at a time.
	            maxColumnSorts: '=',
	            permanentFooters: '=',
	            // summary: If true, turns on selection for cards via the cardData.viewData.selected property
	            selectableCards: '=',
	            // summary: Function called with each item. If true is returned selection is disabled for this item.
	            //          If function is not defined, selection is enabled for all by default.
	            disableSelection: '&',
	        },
	        link: function (scope, element, attrs, controller, transclude) {
	            var headerArea = element.find('.container-header-template');
	            var footerArea = element.find('.container-footer-template');
	            controller.makeCard = transclude;
	            transclude(scope, function (clone) {
	                var header = clone.filter('rl-container-header');
	                if (header.length === 0) {
	                    var defaultHeader = __webpack_require__(70);
	                    header = $compile(defaultHeader)(scope);
	                }
	                headerArea.append(header);
	                var footer = clone.filter('rl-container-footer');
	                if (footer.length === 0) {
	                    var defaultFooter = __webpack_require__(71);
	                    footer = $compile(defaultFooter)(scope);
	                }
	                footerArea.append(footer);
	            });
	        }
	    };
	}
	exports.cardContainer = cardContainer;
	//# sourceMappingURL=cardContainer.js.map

/***/ },
/* 68 */
/***/ function(module, exports) {

	var CardContainerService = (function () {
	    function CardContainerService(cardContainer) {
	        this.cardContainer = cardContainer;
	        this.pager = cardContainer.pager;
	        this.dataSource = cardContainer.dataSource;
	        this.filters = cardContainer.filters;
	    }
	    CardContainerService.prototype.lookupFilter = function (type) {
	        return this.filters[type];
	    };
	    Object.defineProperty(CardContainerService.prototype, "numberSelected", {
	        get: function () {
	            return this.cardContainer.numberSelected;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CardContainerService;
	})();
	exports.CardContainerService = CardContainerService;
	//# sourceMappingURL=cardContainer.service.js.map

/***/ },
/* 69 */
/***/ function(module, exports) {

	module.exports = "<div class=\"card-container\">\r\n\t<div>\r\n\t\t<div class=\"card-container-header\">\r\n\t\t\t<div class=\"container-header-template\"></div>\r\n\t\t</div>\r\n\r\n\t\t<rl-generic-container selector=\"cardContainer.selectableCards\">\r\n\t\t\t<template when-selector=\"false\" default>\r\n\t\t\t\t<div class=\"card-columns-header\">\r\n\t\t\t\t\t<div ng-repeat=\"column in cardContainer.columns\">\r\n\t\t\t\t\t\t<rl-column-header sort=\"cardContainer.sort(column)\" sorting=\"column.sortDirection\" column=\"column\"></rl-column-header>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t</div>\r\n\t\t\t</template>\r\n\t\t\t<template when-selector=\"true\">\r\n\t\t\t\t<div class=\"card-columns-header\">\r\n\t\t\t\t\t<div class=\"select-group\">\r\n\t\t\t\t\t\t<div class=\"select-column\">\r\n\t\t\t\t\t\t\t<i class=\"fa fa-check\" style=\"margin-left: 6px; cursor: pointer\" ng-click=\"cardContainer.sortSelected()\"></i>\r\n\t\t\t\t\t\t\t<i ng-show=\"cardContainer.sortColumn.sortDirection === cardContainer.sortDirection.ascending\" class=\"fa fa-sort-asc\"></i>\r\n\t\t\t\t\t\t\t<i ng-show=\"cardContainer.sortColumn.sortDirection === cardContainer.sortDirection.descending\" class=\"fa fa-sort-desc\"></i>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t<div class=\"select-content\">\r\n\t\t\t\t\t\t\t<div ng-repeat=\"column in cardContainer.columns\">\r\n\t\t\t\t\t\t\t\t<rl-column-header sort=\"cardContainer.sort(column)\" sorting=\"column.sortDirection\" column=\"column\"></rl-column-header>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t</div>\r\n\t\t\t</template>\r\n\t\t</rl-generic-container>\r\n\r\n\t\t<div ng-repeat=\"card in cardContainer.dataSource.dataSet\">\r\n\t\t\t<rl-card columns=\"cardContainer.columns\" item=\"card\"\r\n\t\t\t\t\t clickable=\"cardContainer.clickableCards\"\r\n\t\t\t\t\t selectable=\"cardContainer.selectableCards\"\r\n\t\t\t\t\t selection-changed=\"cardContainer.selectionChanged()\"\r\n\t\t\t\t\t container-data=\"cardContainer.containerData\"\r\n\t\t\t\t\t source=\"cardContainer.dataSource\"\r\n\t\t\t\t\t permanent-footer=\"cardContainer.permanentFooters\"\r\n\t\t\t\t\t card-controller=\"cardContainer.cardController\"\r\n\t\t\t\t\t card-controller-as=\"cardContainer.cardControllerAs\"\r\n\t\t\t\t\t card-as=\"cardContainer.cardAs\"></rl-card>\r\n\t\t</div>\r\n\r\n\t\t<div>\r\n\t\t\t<rl-busy loading=\"cardContainer.dataSource.loadingDataSet\" size=\"2x\"></rl-busy>\r\n\t\t</div>\r\n\r\n\t\t<div class=\"card-container-footer\">\r\n\t\t\t<div class=\"container-footer-template\"></div>\r\n\t\t</div>\r\n\t</div>\r\n</div>"

/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row\">\r\n\t<div class=\"col-sm-9\">\r\n\t\t<rl-card-search container-service=\"containerService\"></rl-card-search>\r\n\t</div>\r\n\t<div class=\"col-sm-3\">\r\n\t\t<rl-page-size container-service=\"containerService\"></rl-page-size>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row\">\r\n\t<div ng-if=\"!cardContainer.selectableCards\" class=\"col-sm-6\">\r\n\t\t<rl-item-count container-service=\"containerService\"></rl-item-count>\r\n\t</div>\r\n\t<span ng-if=\"cardContainer.selectableCards\">\r\n\t\t<div class=\"col-sm-3\">\r\n\t\t\t<rl-selection-control container-service=\"containerService\"></rl-selection-control>\r\n\t\t</div>\r\n\t\t<div class=\"col-sm-3\">\r\n\t\t\t<rl-item-count container-service=\"containerService\"></rl-item-count>\r\n\t\t</div>\r\n\t</span>\r\n\t<div class=\"col-sm-6\">\r\n\t\t<rl-pager class=\"pull-right\" container-service=\"containerService\"></rl-pager>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 72 */
/***/ function(module, exports) {

	'use strict';
	//# sourceMappingURL=column.js.map

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __object = typescript_angular_utilities_1.services.object;
	exports.moduleName = 'rl.ui.components.commaList';
	exports.directiveName = 'rlCommaList';
	exports.controllerName = 'CommaListController';
	var CommaListController = (function () {
	    function CommaListController($attrs, object) {
	        this.remainingItems = 0;
	        this.hasTransform = object.isNullOrWhitespace($attrs.transform) === false;
	        this.list = this.getFirstItems(this.inList);
	    }
	    CommaListController.prototype.getFirstItems = function (list) {
	        var _this = this;
	        if (this.hasTransform) {
	            list = _.map(list, function (item) {
	                return _this.transform({ item: item });
	            });
	        }
	        ;
	        var newList;
	        if (this.max != null) {
	            newList = _.take(list, this.max);
	            this.remainingItems = list.length - this.max;
	        }
	        else {
	            newList = _.clone(list);
	        }
	        return newList;
	    };
	    CommaListController.$inject = ['$attrs', __object.serviceName];
	    return CommaListController;
	})();
	exports.CommaListController = CommaListController;
	function commaList() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<span>\n\t\t\t\t<span ng-repeat=\"item in commaList.list track by $index\">\n\t\t\t\t\t<span>{{item}}</span><span ng-hide=\"$last\">, </span>\n\t\t\t\t</span>\n\t\t\t\t<span ng-show=\"commaList.remainingItems > 0\">... {{commaList.remainingItems}} more items</span>\n\t\t\t</span>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'commaList',
	        scope: {},
	        bindToController: {
	            inList: '=list',
	            max: '=',
	            transform: '&',
	        },
	    };
	}
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(exports.directiveName, commaList)
	    .controller(exports.controllerName, CommaListController);
	//# sourceMappingURL=commaList.js.map

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// /// <reference path='../../../typings/bootstrapDateTimePicker.d.ts' />
	var angular = __webpack_require__(1);
	var $ = __webpack_require__(12);
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	exports.moduleName = 'rl.ui.components.dateTime';
	exports.directiveName = 'rlDateTime';
	var __dateTimeFormatStrings = typescript_angular_utilities_1.services.date;
	dateTime.$inject = [typescript_angular_utilities_1.services.moment.serviceName, __dateTimeFormatStrings.dateTimeFormatServiceName];
	function dateTime(moment, dateTimeFormatStrings) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<div class=\"input-group\" ng-class=\"{ 'has-warning': !validFormat}\" id=\"{{inputId}}\">\n\t\t\t\t<input type=\"text\" class=\"form-control\" ng-model=\"ngModel\" />\n\t\t\t\t<span class=\"input-group-btn\">\n\t\t\t\t\t<button class=\"btn btn-default show-date-picker\" ng-click=\"toggle()\"><i class=\"fa fa-calendar\"></i></button>\n\t\t\t\t</span>\n\t\t\t</div>\n\t\t",
	        require: '?^ngModel',
	        scope: {
	            minuteStepping: '=',
	            ngModel: '=',
	            useDate: '=',
	            useTime: '=',
	            min: '=',
	            max: '=',
	        },
	        link: function (scope, element, attrs, ngModel) {
	            // defaults to true
	            var hasDate = _.isUndefined(scope.useDate) ? true : scope.useDate;
	            var hasTime = _.isUndefined(scope.useTime) ? true : scope.useTime;
	            var defaults = element.datetimepicker.defaults;
	            var min = scope.min != null ? scope.min : defaults.minDate;
	            var max = scope.max != null ? scope.max : defaults.maxDate;
	            scope.$watch('ngModel', function (newValue) {
	                if (newValue !== '') {
	                    scope.validFormat = moment(newValue).isValid();
	                }
	            });
	            // --- Implementation ---
	            element.datetimepicker({
	                stepping: scope.minuteStepping || 1,
	                format: scope.format || defaultFormat(hasDate, hasTime),
	                direction: 'bottom',
	                elementHeight: 32,
	                pickDate: hasDate,
	                pickTime: hasTime,
	                minDate: min,
	                maxDate: max,
	            }).on('change.dp', function () {
	                var newValue = $(this).find('input').val();
	                ngModel.$setViewValue(newValue);
	                scope.$apply();
	            });
	            function defaultFormat(hasDate, hasTime) {
	                if (hasDate && hasTime) {
	                    return dateTimeFormatStrings.dateTimeFormat;
	                }
	                else if (hasDate) {
	                    return dateTimeFormatStrings.dateFormat;
	                }
	                else if (hasTime) {
	                    return dateTimeFormatStrings.timeFormat;
	                }
	                else {
	                    // revert to default format
	                    return false;
	                }
	            }
	        },
	    };
	}
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, dateTime);
	//# sourceMappingURL=dateTime.js.map

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var jquery_service_1 = __webpack_require__(76);
	exports.moduleName = 'rl.ui.components.genericContainer';
	exports.directiveName = 'rlGenericContainer';
	exports.controllerName = 'GenericContainerController';
	var __object = typescript_angular_utilities_1.services.object;
	var GenericContainerController = (function () {
	    function GenericContainerController($scope, object) {
	        var _this = this;
	        this.object = object;
	        $scope.$watch(function () { return _this.selector; }, function (newType, oldType) {
	            if (_this.object.areEqual(newType, oldType)) {
	                return;
	            }
	            var template = _this.resolveTemplate(newType);
	            _this.swapTemplates(template);
	        });
	    }
	    GenericContainerController.prototype.refresh = function () {
	        var template = this.resolveTemplate(this.selector);
	        this.swapTemplates(template);
	    };
	    GenericContainerController.prototype.resolveTemplate = function (type) {
	        var templateObject;
	        if (_.has(this.templates, type)) {
	            templateObject = this.templates[type];
	        }
	        else {
	            templateObject = this.default;
	        }
	        var template = templateObject;
	        if (!_.isUndefined(template.templateUrl)) {
	            return '<ng-include src="\'' + template.templateUrl + '\'"></ng-include>';
	        }
	        else if (!_.isUndefined(template.template)) {
	            return template.template;
	        }
	        else {
	            return templateObject;
	        }
	    };
	    GenericContainerController.$inject = ['$scope', __object.serviceName];
	    return GenericContainerController;
	})();
	exports.GenericContainerController = GenericContainerController;
	genericContainer.$inject = ['$compile', '$interpolate', jquery_service_1.serviceName, __object.serviceName];
	function genericContainer($compile, $interpolate, jquery, object) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: '<div id="container"></div>',
	        transclude: true,
	        controller: exports.controllerName,
	        controllerAs: 'genericContainer',
	        scope: {},
	        bindToController: {
	            selector: '=',
	            configuredTemplates: '=templates',
	            defaultTemplate: '=',
	        },
	        link: function (scope, element, attributes, controller, transclude) {
	            initDefaults(controller);
	            var container = element.find('#container');
	            var templateScope;
	            // Load templates from the DOM
	            transclude(function (clone, transclusionScope) {
	                var templates = clone.filter('template');
	                templates.each(function (index, template) {
	                    var templateElement = angular.element(template);
	                    var templateHtml = templateElement.html();
	                    var triggerAttribute = templateElement.attr('when-selector');
	                    if (!object.isNullOrWhitespace(triggerAttribute)) {
	                        var trigger = $interpolate(triggerAttribute)(transclusionScope);
	                        controller.templates[trigger] = templateHtml;
	                    }
	                    var isDefault = templateElement.attr('default');
	                    if (!_.isUndefined(isDefault) && isDefault.toLowerCase() !== 'false') {
	                        controller.default = templateHtml;
	                    }
	                });
	                templateScope = transclusionScope;
	            });
	            if (!controller.default) {
	                controller.default = {
	                    template: '<div></div>',
	                };
	            }
	            controller.refresh();
	            function initDefaults(controller) {
	                controller.default = controller.defaultTemplate;
	                controller.templates = controller.configuredTemplates ? controller.configuredTemplates : {};
	                controller.swapTemplates = swapTemplates;
	            }
	            function swapTemplates(template) {
	                var content = $compile(template)(templateScope);
	                jquery.replaceContent(container, content);
	            }
	        }
	    };
	}
	angular.module(exports.moduleName, [jquery_service_1.moduleName, __object.moduleName])
	    .directive(exports.directiveName, genericContainer)
	    .controller(exports.controllerName, GenericContainerController);
	//# sourceMappingURL=genericContainer.js.map

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path="../../../typings/jquery/jquery.d.ts" />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.utilities.services.jquery';
	exports.serviceName = 'jqueryUtility';
	var JQueryUtility = (function () {
	    function JQueryUtility() {
	    }
	    JQueryUtility.prototype.replaceContent = function (contentArea, newContent) {
	        contentArea.empty();
	        contentArea.append(newContent);
	    };
	    return JQueryUtility;
	})();
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, JQueryUtility);
	//# sourceMappingURL=jquery.service.js.map

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.lazyLoad';
	exports.directiveName = 'rlLazyLoad';
	exports.controllerName = 'LazyLoadController';
	var LazyLoadController = (function () {
	    function LazyLoadController($scope) {
	        var _this = this;
	        this.init = false;
	        var unbind = $scope.$watch(function () { return _this.show; }, function (value) {
	            if (value) {
	                _this.init = true;
	                unbind();
	            }
	        });
	    }
	    LazyLoadController.$inject = ['$scope'];
	    return LazyLoadController;
	})();
	exports.LazyLoadController = LazyLoadController;
	function lazyLoad() {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: "\n\t\t\t<div ng-if=\"lazyLoad.init\">\n\t\t\t\t<div ng-show=\"lazyLoad.show\">\n\t\t\t\t\t<div ng-transclude></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'lazyLoad',
	        scope: {},
	        bindToController: {
	            show: '=',
	        },
	    };
	}
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, lazyLoad)
	    .controller(exports.controllerName, LazyLoadController);
	//# sourceMappingURL=lazyLoad.js.map

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var $ = __webpack_require__(12);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __promise = typescript_angular_utilities_1.services.promise;
	exports.moduleName = 'rl.ui.components.longClickButton';
	exports.directiveName = 'rlLongClickButton';
	exports.controllerName = 'LongClickButtonController';
	var __object = typescript_angular_utilities_1.services.object;
	var LongClickButtonController = (function () {
	    function LongClickButtonController($scope, $interval, $timeout, objectUtility, promise) {
	        var _this = this;
	        this.$interval = $interval;
	        this.$timeout = $timeout;
	        this.objectUtility = objectUtility;
	        this.promise = promise;
	        this.interval = 25;
	        this.duration = 1500;
	        this.buttonText = this.text;
	        this.type = this.type != null ? this.type : 'default';
	        this.size = this.size != null ? 'btn-' + this.size : null;
	        $scope.$watch(function () { return _this.buttonText; }, function () {
	            $timeout(function () {
	                _this.width = $('#actionButton').outerWidth();
	            });
	        });
	    }
	    LongClickButtonController.prototype.startAction = function () {
	        var _this = this;
	        if (this.active || this.busy) {
	            return;
	        }
	        this.actionProgress = 0;
	        this.active = true;
	        this.actionInterval = this.$interval(function () {
	            _this.actionProgress += _this.interval;
	            if (_this.actionProgress >= _this.duration) {
	                _this.cleanup();
	                _this.buttonText = _this.text;
	                _this.trigger();
	            }
	        }, this.interval);
	    };
	    LongClickButtonController.prototype.stopAction = function () {
	        if (this.active) {
	            if (this.actionProgress < this.duration) {
	                this.warn();
	            }
	            this.cleanup();
	        }
	    };
	    LongClickButtonController.prototype.cleanup = function () {
	        this.$interval.cancel(this.actionInterval);
	        this.actionProgress = 0;
	        this.active = false;
	    };
	    LongClickButtonController.prototype.warn = function () {
	        if (this.objectUtility.isNullOrEmpty(this.onShortClickText) === false) {
	            this.buttonText = this.onShortClickText;
	        }
	    };
	    LongClickButtonController.prototype.trigger = function () {
	        var _this = this;
	        if (!this.busy) {
	            this.busy = true;
	            var result = this.action();
	            if (this.promise.isPromise(result) && _.isFunction(result.finally)) {
	                result.finally(function () {
	                    _this.busy = false;
	                });
	            }
	        }
	    };
	    LongClickButtonController.$inject = ['$scope', '$interval', '$timeout', __object.serviceName, __promise.serviceName];
	    return LongClickButtonController;
	})();
	exports.LongClickButtonController = LongClickButtonController;
	function longClickButton() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(79),
	        controller: exports.controllerName,
	        controllerAs: 'button',
	        scope: {},
	        bindToController: {
	            action: '&',
	            text: '@',
	            onShortClickText: '@',
	            icon: '@',
	            busy: '=',
	            rightAligned: '=',
	            type: '@',
	            ngDisabled: '=',
	        },
	    };
	}
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(exports.directiveName, longClickButton)
	    .controller(exports.controllerName, LongClickButtonController);
	//# sourceMappingURL=longClickButton.js.map

/***/ },
/* 79 */
/***/ function(module, exports) {

	module.exports = "<div class=\"long-click-button\">\r\n\t<button id=\"actionButton\" class=\"btn btn-{{button.type}} {{button.size}}\" ng-mousedown=\"button.startAction()\" ng-mouseleave=\"button.stopAction()\" ng-mouseup=\"button.stopAction()\" ng-disabled=\"button.busy || button.ngDisabled\">\r\n\t\t<rl-busy loading=\"button.busy\" ng-if=\"button.rightAligned\"></rl-busy>\r\n\t\t<i ng-show=\"button.icon != null\" class=\"fa fa-{{button.icon}}\"></i> {{button.buttonText}}\r\n\t\t<rl-busy loading=\"button.busy\" ng-if=\"!button.rightAligned\"></rl-busy>\r\n\t</button>\r\n\t<rl-rating-bar ng-if=\"button.active\" width=\"button.width\" height=\"5\" min=\"0\" max=\"button.duration\"\r\n\t\t\t\tvalue=\"button.actionProgress\" background=\"transparent\"></rl-rating-bar>\r\n</div>"

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __object = typescript_angular_utilities_1.services.object;
	var messageLog_service_1 = __webpack_require__(81);
	var messageLog_directive_1 = __webpack_require__(82);
	var editableMessageLog_1 = __webpack_require__(84);
	__export(__webpack_require__(81));
	__export(__webpack_require__(82));
	exports.moduleName = 'rl.ui.components.messageLog';
	angular.module(exports.moduleName, [__object.moduleName])
	    .factory(messageLog_service_1.factoryName, messageLog_service_1.messageLogFactory)
	    .directive(messageLog_directive_1.directiveName, messageLog_directive_1.messageLog)
	    .controller(messageLog_directive_1.controllerName, messageLog_directive_1.MessageLogController)
	    .directive(editableMessageLog_1.directiveName, editableMessageLog_1.editableMessageLog)
	    .controller(editableMessageLog_1.controllerName, editableMessageLog_1.EditableMessageLogController);
	//# sourceMappingURL=messageLog.module.js.map

/***/ },
/* 81 */
/***/ function(module, exports) {

	'use strict';
	exports.factoryName = 'messageLog';
	exports.defaultPageSize = 10;
	var MessageLog = (function () {
	    function MessageLog() {
	        this.currentStartingMessage = 0;
	        this._hasForwardMessages = false;
	        this._hasBackwardMessages = false;
	        this._pageSize = exports.defaultPageSize;
	    }
	    Object.defineProperty(MessageLog.prototype, "pageSize", {
	        get: function () {
	            return this._pageSize;
	        },
	        /* tslint:disable */
	        set: function (value) {
	            this._pageSize = value;
	            this.updateCurrentPage();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MessageLog.prototype, "hasForwardMessages", {
	        /* tslint:enable */
	        get: function () {
	            return this._hasForwardMessages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MessageLog.prototype, "hasBackwardMessages", {
	        get: function () {
	            return this._hasBackwardMessages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MessageLog.prototype, "dataService", {
	        get: function () {
	            return this._dataService;
	        },
	        /* tslint:disable */
	        set: function (value) {
	            this._dataService = value;
	            if (value != null) {
	                this.visibleMessages = null;
	                this.updateCurrentPage();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /* tslint:enable */
	    MessageLog.prototype.addMessage = function (message) {
	        var _this = this;
	        return this.dataService.saveMessage(message).then(function () {
	            _this.getTopPage();
	        });
	    };
	    MessageLog.prototype.getNextPage = function () {
	        if (!this.hasForwardMessages) {
	            return;
	        }
	        this.currentStartingMessage += this.pageSize;
	        return this.updateCurrentPage();
	    };
	    MessageLog.prototype.getPreviousPage = function () {
	        if (!this.hasBackwardMessages) {
	            return;
	        }
	        this.currentStartingMessage -= this.pageSize;
	        if (this.currentStartingMessage < 0) {
	            this.currentStartingMessage = 0;
	        }
	        return this.updateCurrentPage();
	    };
	    MessageLog.prototype.getTopPage = function () {
	        this.currentStartingMessage = 0;
	        return this.updateCurrentPage();
	    };
	    MessageLog.prototype.refresh = function () {
	        return this.updateCurrentPage();
	    };
	    MessageLog.prototype.updateCurrentPage = function () {
	        var _this = this;
	        if (this.dataService == null) {
	            return null;
	        }
	        this.busy = true;
	        return this.dataService.getMessages(this.currentStartingMessage, this.pageSize).then(function (result) {
	            _this.visibleMessages = result.messages;
	            _this._hasForwardMessages = result.hasMoreMessages;
	            _this._hasBackwardMessages = (_this.currentStartingMessage > 0);
	            _this.busy = false;
	        });
	    };
	    return MessageLog;
	})();
	exports.MessageLog = MessageLog;
	function messageLogFactory() {
	    'use strict';
	    return {
	        getInstance: function () {
	            return new MessageLog();
	        },
	    };
	}
	exports.messageLogFactory = messageLogFactory;
	//# sourceMappingURL=messageLog.service.js.map

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var messageLog_service_1 = __webpack_require__(81);
	exports.directiveName = 'rlMessageLog';
	exports.controllerName = 'MessageLogController';
	var MessageLogController = (function () {
	    function MessageLogController($scope, messageLogFactory) {
	        var _this = this;
	        this.messageLog = this.messageLogBinding || messageLogFactory.getInstance();
	        $scope.$watch(function () { return _this.messageLog.visibleMessages; }, function (value) {
	            _this.messages = value;
	        });
	        $scope.$watch(function () { return _this.messageLog.hasForwardMessages; }, function (value) {
	            _this.hasNextPage = value;
	        });
	        $scope.$watch(function () { return _this.messageLog.hasBackwardMessages; }, function (value) {
	            _this.hasPreviousPage = value;
	        });
	        $scope.$watch(function () { return _this.messageLog.busy; }, function (value) {
	            if (!value) {
	                _this.loading = false;
	                _this.loadingInitial = false;
	            }
	            else {
	                _this.loading = true;
	            }
	        });
	        $scope.$watch(function () { return _this.service; }, function (service) {
	            _this.messageLog.dataService = service;
	            _this.loadingInitial = true;
	        });
	        this.messageLog.pageSize = this.pageSize != null ? this.pageSize : 8;
	    }
	    MessageLogController.prototype.getOlder = function () {
	        return this.messageLog.getNextPage();
	    };
	    MessageLogController.prototype.getTop = function () {
	        return this.messageLog.getTopPage();
	    };
	    MessageLogController.$inject = ['$scope', messageLog_service_1.factoryName];
	    return MessageLogController;
	})();
	exports.MessageLogController = MessageLogController;
	function messageLog() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(83),
	        controller: exports.controllerName,
	        controllerAs: 'log',
	        scope: {},
	        bindToController: {
	            service: '=',
	            pageSize: '=',
	            messageLogBinding: '=messageLog',
	        },
	    };
	}
	exports.messageLog = messageLog;
	//# sourceMappingURL=messageLog.directive.js.map

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = "<div>\r\n\t<rl-busy loading=\"log.loadingInitial\" size=\"2x\"></rl-busy>\r\n\t<div class=\"content-group\" ng-repeat=\"entry in log.messages\">\r\n\t\t<div ng-bind-html=\"entry.message\"></div>\r\n\t\t<div class=\"byline\">{{entry.createdBy}}</div>\r\n\t\t<div class=\"byline\">{{entry.createdDate}} {{entry.createdTime}} UTC</div>\r\n\t</div>\r\n\t<div class=\"content-group\" ng-if=\"(log.messages | isEmpty) && !log.loadingInitial\">No existing messages</div>\r\n\t<div class=\"row\">\r\n\t\t<div class=\"col-xs-12\">\r\n\t\t\t<div class=\"text-center\">\r\n\t\t\t\t<rl-button-async type=\"default\" action=\"log.getTopPage()\" ng-disabled=\"log.loading\" right-aligned=\"true\">\r\n\t\t\t\t\t<span ng-show=\"log.hasPreviousPage\">Top</span>\r\n\t\t\t\t\t<span ng-hide=\"log.hasPreviousPage\">Refresh</span>\r\n\t\t\t\t</rl-button-async>\r\n\t\t\t\t<rl-button-async type=\"default\" ng-disabled=\"log.hasNextPage == false || log.loading\" action=\"log.getNextPage()\">\r\n\t\t\t\t\tOlder <i class=\"fa fa-chevron-right\"></i>\r\n\t\t\t\t</rl-button-async>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</div>\r\n</div>"

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var messageLog_service_1 = __webpack_require__(81);
	exports.directiveName = 'rlEditableMessageLog';
	exports.controllerName = 'EditableMessageLogController';
	var __object = typescript_angular_utilities_1.services.object;
	;
	var EditableMessageLogController = (function () {
	    function EditableMessageLogController($scope, messageLogFactory, object) {
	        var _this = this;
	        this.object = object;
	        this.messageLogService = messageLogFactory.getInstance();
	        $scope.$watch(function () { return _this.messageLogService.busy; }, function (value) {
	            if (value === false) {
	                _this.busy = false;
	                _this.savingMessage = false;
	            }
	            else {
	                _this.busy = true;
	            }
	        });
	    }
	    EditableMessageLogController.prototype.add = function () {
	        if (this.object.isNullOrWhitespace(this.newMessage)) {
	            return null;
	        }
	        this.savingMessage = true;
	        var message = this.newMessage;
	        this.newMessage = '';
	        return this.messageLogService.addMessage(message);
	    };
	    EditableMessageLogController.$inject = ['$scope', messageLog_service_1.factoryName, __object.serviceName];
	    return EditableMessageLogController;
	})();
	exports.EditableMessageLogController = EditableMessageLogController;
	function editableMessageLog() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<form ng-submit=\"log.add()\">\n\t\t\t\t<div class=\"input-group\">\n\t\t\t\t\t<input type=\"text\" class=\"form-control\" ng-model=\"log.newMessage\" placeholder=\"Enter log message\" />\n\t\t\t\t\t<span class=\"input-group-btn\">\n\t\t\t\t\t\t<button class=\"btn btn-default\" type=\"submit\" ng-disabled=\"log.busy\">\n\t\t\t\t\t\t\t<rl-busy loading=\"log.savingMessage\"></rl-busy> Add\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</span>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"shallow well\">\n\t\t\t\t\t<rl-message-log service=\"log.service\" page-size=\"log.pageSize\" message-log=\"log.messageLogService\"></rl-message-log>\n\t\t\t\t</div>\n\t\t\t</form>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'log',
	        scope: {},
	        bindToController: {
	            service: '=',
	            pageSize: '=',
	        },
	    };
	}
	exports.editableMessageLog = editableMessageLog;
	//# sourceMappingURL=editableMessageLog.js.map

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	exports.moduleName = 'rl.ui.components.multiStepIndicator';
	exports.directiveName = 'rlMultiStepIndicator';
	exports.controllerName = 'MultiStepIndicatorController';
	var __object = typescript_angular_utilities_1.services.object;
	var MultiStepIndicatorController = (function () {
	    function MultiStepIndicatorController($state, $q, object) {
	        this.$state = $state;
	        this.$q = $q;
	        this.object = object;
	        this.configureSteps();
	    }
	    MultiStepIndicatorController.prototype.onClick = function (step) {
	        if (!this.anyLoading()) {
	            step.loading = true;
	            this.$q.when(step.onClick()).then(function () {
	                step.loading = false;
	            });
	        }
	    };
	    MultiStepIndicatorController.prototype.anyLoading = function () {
	        return _.any(this.steps, function (step) {
	            return step.loading;
	        });
	    };
	    MultiStepIndicatorController.prototype.configureSteps = function () {
	        var _this = this;
	        _.each(this.steps, function (step) {
	            step.hasCount = _.isFunction(step.count);
	            if (!_.isFunction(step.onClick)) {
	                if (_this.object.isNullOrWhitespace(step.stateName)) {
	                    step.inactive = true;
	                }
	                else {
	                    step.onClick = function () { return _this.redirectToState(step); };
	                    if (_this.$state.includes(step.stateName)) {
	                        step.isCurrent = true;
	                    }
	                }
	            }
	        });
	    };
	    MultiStepIndicatorController.prototype.redirectToState = function (step) {
	        var _this = this;
	        return this.$state.go(step.stateName).then(function () {
	            _this.clearCurrentState();
	            step.isCurrent = true;
	        });
	    };
	    MultiStepIndicatorController.prototype.clearCurrentState = function () {
	        _.each(this.steps, function (step) {
	            step.isCurrent = false;
	        });
	    };
	    MultiStepIndicatorController.$inject = ['$state', '$q', __object.serviceName];
	    return MultiStepIndicatorController;
	})();
	exports.MultiStepIndicatorController = MultiStepIndicatorController;
	function multiStepIndicator() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(86),
	        controller: exports.controllerName,
	        controllerAs: 'breadcrumb',
	        scope: {},
	        bindToController: {
	            steps: '=',
	            numbered: '=',
	        },
	    };
	}
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(exports.directiveName, multiStepIndicator)
	    .controller(exports.controllerName, MultiStepIndicatorController);
	//# sourceMappingURL=multiStepIndicator.js.map

/***/ },
/* 86 */
/***/ function(module, exports) {

	module.exports = "<div class=\"multi-step\" ng-class=\"{ 'numbered': breadcrumb.numbered }\">\r\n\t<ol>\r\n\t\t<li ng-repeat=\"step in breadcrumb.steps\" ng-click=\"breadcrumb.onClick(step)\"\r\n\t\t\tng-class=\"{ 'completed': step.isCompleted, 'current': step.isCurrent, 'active': !step.inactive && !breadcrumb.anyLoading() }\">\r\n\t\t\t<div class=\"wrap\">\r\n\t\t\t\t<p class=\"badge\" ng-show=\"step.hasCount\">{{step.count()}}</p>\r\n\t\t\t\t<p class=\"title\">{{step.title}} <rl-busy loading=\"step.loading\"></rl-busy></p>\r\n\t\t\t\t<p class=\"subtitle\">{{step.subtitle}}</p>\r\n\t\t\t</div>\r\n\t\t</li>\r\n\t</ol>\r\n</div>"

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __object = typescript_angular_utilities_1.services.object;
	var radioGroup_1 = __webpack_require__(88);
	exports.radioGroupDirectiveName = radioGroup_1.directiveName;
	exports.radioGroup = radioGroup_1.radioGroup;
	exports.radioGroupControllerName = radioGroup_1.controllerName;
	exports.RadioGroupController = radioGroup_1.RadioGroupController;
	var radio_1 = __webpack_require__(89);
	exports.radioDirectiveName = radio_1.directiveName;
	exports.radio = radio_1.radio;
	exports.radioControllerName = radio_1.controllerName;
	exports.RadioController = radio_1.RadioController;
	exports.moduleName = 'rl21.components.radio';
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(radioGroup_1.directiveName, radioGroup_1.radioGroup)
	    .controller(radioGroup_1.controllerName, radioGroup_1.RadioGroupController)
	    .directive(radio_1.directiveName, radio_1.radio)
	    .controller(radio_1.controllerName, radio_1.RadioController);
	//# sourceMappingURL=radio.module.js.map

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __object = typescript_angular_utilities_1.services.object;
	exports.directiveName = 'rlRadioGroup';
	exports.controllerName = 'RadioGroupController';
	var RadioGroup = (function () {
	    function RadioGroup($scope, ngModel, name) {
	        var _this = this;
	        this.name = name;
	        $scope.$watch(function () { return ngModel.$viewValue; }, function (value) {
	            _this.selection = value;
	        });
	        $scope.$watch(function () { return _this.selection; }, function (value) {
	            ngModel.$setViewValue(value);
	        });
	    }
	    return RadioGroup;
	})();
	exports.RadioGroup = RadioGroup;
	var RadioGroupController = (function () {
	    function RadioGroupController($scope, $attrs, $element, object) {
	        var name;
	        if (!object.isNullOrWhitespace($attrs.rlRadioGroup)) {
	            name = $attrs.rlRadioGroup;
	        }
	        else if (!object.isNullOrWhitespace($attrs.name)) {
	            name = $attrs.name;
	        }
	        else {
	            name = 'RadioGroup' + this.getNextId();
	        }
	        var ngModel = $element.controller('ngModel');
	        this.group = new RadioGroup($scope, ngModel, name);
	    }
	    RadioGroupController.prototype.registerButton = function () {
	        return this.group;
	    };
	    RadioGroupController.prototype.getNextId = function () {
	        var nextId = RadioGroupController.nextId.toString();
	        RadioGroupController.nextId++;
	        return nextId;
	    };
	    RadioGroupController.nextId = 1;
	    RadioGroupController.$inject = ['$scope', '$attrs', '$element', __object.serviceName];
	    return RadioGroupController;
	})();
	exports.RadioGroupController = RadioGroupController;
	function radioGroup() {
	    'use strict';
	    return {
	        restrict: 'AE',
	        require: 'ngModel',
	        controller: exports.controllerName,
	    };
	}
	exports.radioGroup = radioGroup;
	//# sourceMappingURL=radioGroup.js.map

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var radioGroup_1 = __webpack_require__(88);
	exports.directiveName = 'rlRadio';
	exports.controllerName = 'RadioController';
	var RadioController = (function () {
	    function RadioController($scope, $element) {
	        var radioGroupController = $element.controller('rlRadioGroup');
	        if (radioGroupController != null) {
	            this.radioGroup = radioGroupController.registerButton();
	        }
	        else {
	            var ngModel = $element.controller('ngModel');
	            this.radioGroup = new radioGroup_1.RadioGroup($scope, ngModel);
	        }
	    }
	    RadioController.$inject = ['$scope', '$element'];
	    return RadioController;
	})();
	exports.RadioController = RadioController;
	function radio() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: ['?^^rlRadioGroup', '?ngModel'],
	        transclude: true,
	        template: "\n\t\t\t<label>\n\t\t\t\t<input id=\"radio\" type=\"radio\" name=\"{{radio.radioGroup.name}}\" ng-model=\"radio.radioGroup.selection\" ng-value=\"radio.value\" />\n\t\t\t\t<span ng-transclude></div>\n\t\t\t</label>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'radio',
	        scope: true,
	        bindToController: {
	            value: '=',
	        },
	    };
	}
	exports.radio = radio;
	//# sourceMappingURL=radio.js.map

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var ratingBarBackgrounds_service_1 = __webpack_require__(91);
	var ratingBarClass_service_1 = __webpack_require__(92);
	exports.moduleName = 'rl.ui.components.ratingBar';
	exports.directiveName = 'rlRatingBar';
	exports.controllerName = 'RatingBarController';
	var RatingBarController = (function () {
	    function RatingBarController($scope) {
	        var _this = this;
	        this.$scope = $scope;
	        var ratingBarBackgrounds = new ratingBarBackgrounds_service_1.RatingBarBackgroundService;
	        this.ratingBarClass = new ratingBarClass_service_1.RatingBarClassService;
	        this.backgroundClass = ratingBarBackgrounds.getBackground(this.background);
	        if (this.value == null) {
	            this.value = 0;
	        }
	        $scope.$watch(function () { return _this.value; }, function (newValue) {
	            _this.updateValue(newValue);
	        });
	        $scope.$watch(function () { return _this.totalWidth; }, function (newWidth) {
	            _this.dimensions = {
	                width: newWidth + 2,
	                height: _this.height + 2,
	            };
	            _this.updateValue(_this.value);
	        });
	    }
	    RatingBarController.prototype.updateValue = function (newValue) {
	        var confidenceScore = (newValue - this.min) / (this.max - this.min);
	        this.barClass = this.ratingBarClass.getClass(confidenceScore);
	        this.width = Math.round(confidenceScore * this.totalWidth);
	    };
	    RatingBarController.$inject = ['$scope'];
	    return RatingBarController;
	})();
	exports.RatingBarController = RatingBarController;
	function ratingBar() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<div class=\"rating-bar\">\n\t\t\t\t<div class=\"{{ratingBar.backgroundClass}}\" ng-class=\"{ empty: ratingBar.value == min }\" ng-style=\"ratingBar.dimensions\">\n\t\t\t\t\t<div ng-class=\"ratingBar.barClass\" ng-style=\"{ width: ratingBar.width, height: ratingBar.height }\"></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'ratingBar',
	        scope: {},
	        bindToController: {
	            totalWidth: '=width',
	            height: '=',
	            value: '=',
	            min: '=',
	            max: '=',
	            background: '=',
	        },
	    };
	}
	exports.ratingBar = ratingBar;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, ratingBar)
	    .controller(exports.controllerName, RatingBarController);
	//# sourceMappingURL=ratingBar.js.map

/***/ },
/* 91 */
/***/ function(module, exports) {

	'use strict';
	var RatingBarBackgroundService = (function () {
	    function RatingBarBackgroundService() {
	        this.standard = {
	            type: 'standard',
	            class: 'background',
	        };
	        this.dark = {
	            type: 'dark',
	            class: 'background-dark',
	        };
	        this.transparent = {
	            type: 'transparent',
	            class: 'background-transparent',
	        };
	    }
	    RatingBarBackgroundService.prototype.getBackground = function (type) {
	        if (type === this.dark.type) {
	            return this.dark.class;
	        }
	        else if (type === this.transparent.type) {
	            return this.transparent.class;
	        }
	        else {
	            return this.standard.class;
	        }
	    };
	    return RatingBarBackgroundService;
	})();
	exports.RatingBarBackgroundService = RatingBarBackgroundService;
	//# sourceMappingURL=ratingBarBackgrounds.service.js.map

/***/ },
/* 92 */
/***/ function(module, exports) {

	'use strict';
	var RatingBarClassService = (function () {
	    function RatingBarClassService() {
	    }
	    RatingBarClassService.prototype.getClass = function (confidence) {
	        if (confidence >= 0.8) {
	            return 'very-high';
	        }
	        else if (confidence >= 0.6) {
	            return 'high';
	        }
	        else if (confidence >= 0.4) {
	            return 'medium';
	        }
	        else if (confidence >= 0.2) {
	            return 'low';
	        }
	        else {
	            return 'very-low';
	        }
	    };
	    return RatingBarClassService;
	})();
	exports.RatingBarClassService = RatingBarClassService;
	//# sourceMappingURL=ratingBarClass.service.js.map

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __parentChildBehavior = typescript_angular_utilities_1.services.parentChildBehavior;
	var __observable = typescript_angular_utilities_1.services.observable;
	var __promiseUtility = typescript_angular_utilities_1.services.promise;
	var __numberUtility = typescript_angular_utilities_1.services.number;
	var jquery_service_1 = __webpack_require__(76);
	var grid = __webpack_require__(94);
	exports.responsiveCardGrid = grid;
	var card = __webpack_require__(99);
	exports.responsiveCard = card;
	exports.moduleName = 'rl.ui.components.responsiveCardGrid';
	angular.module(exports.moduleName, [
	    jquery_service_1.moduleName,
	    __parentChildBehavior.moduleName,
	    __observable.moduleName,
	    __promiseUtility.moduleName,
	    __numberUtility.moduleName,
	])
	    .directive(grid.directiveName, grid.responsiveCardGrid)
	    .controller(grid.controllerName, grid.ResponsiveCardGridController)
	    .directive(card.directiveName, card.responsiveCard)
	    .controller(card.controllerName, card.ResponsiveCardController);
	//# sourceMappingURL=responsiveCardGrid.module.js.map

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var breakpoints_module_1 = __webpack_require__(95);
	exports.directiveName = 'rlResponsiveCardGrid';
	exports.controllerName = 'ResponsiveCardGridController';
	var __observable = typescript_angular_utilities_1.services.observable;
	var __numberUtility = typescript_angular_utilities_1.services.number;
	var ResponsiveCardGridController = (function () {
	    function ResponsiveCardGridController(observableFactory, $q, breakpoints, numberUtility) {
	        var _this = this;
	        this.$q = $q;
	        this.breakpoints = breakpoints;
	        this.numberUtility = numberUtility;
	        this.emptyCards = [];
	        this.behaviors = [];
	        this.updateCardEndOfRowStatus = function () {
	            _this.observable.fire('updateEndOfRowStatus');
	        };
	        this.observable = observableFactory.getInstance();
	        if (this.startingIndex != null) {
	            this.emptyCards = _.range(this.startingIndex);
	        }
	        breakpoints.register(this.updateCardEndOfRowStatus);
	    }
	    ResponsiveCardGridController.prototype.registerCard = function (behavior, element) {
	        var index = this.findPosition(element);
	        index = this.startingIndex != null ? index + this.startingIndex : index;
	        var unregisterFunctions = [];
	        unregisterFunctions.push(this.observable.register(behavior.autosave, 'autosave'));
	        unregisterFunctions.push(this.observable.register(behavior.close, 'close'));
	        unregisterFunctions.push(this.observable.register(behavior.hoverOut, 'hoverOut'));
	        unregisterFunctions.push(this.observable.register(behavior.updateEndOfRowStatus, 'updateEndOfRowStatus'));
	        var indexedBehavior = behavior;
	        indexedBehavior.index = index;
	        this.behaviors.push(indexedBehavior);
	        return function () {
	            _.each(unregisterFunctions, function (unregister) {
	                unregister();
	            });
	        };
	    };
	    ResponsiveCardGridController.prototype.openCard = function (openingCard) {
	        if (this.autosaveCard()) {
	            _.each(this.getCurrentRow(openingCard.index), function (card) {
	                card.open();
	            });
	        }
	    };
	    ResponsiveCardGridController.prototype.closeCard = function () {
	        this.autosaveCard();
	    };
	    ResponsiveCardGridController.prototype.autosaveCard = function () {
	        var results = this.observable.fire('autosave');
	        if (_.all(results)) {
	            this.observable.fire('close');
	            return true;
	        }
	        return false;
	    };
	    ResponsiveCardGridController.prototype.hoverIn = function (currentCard) {
	        _.each(this.getCurrentRow(currentCard.index), function (card) {
	            card.hoverIn();
	        });
	    };
	    ResponsiveCardGridController.prototype.hoverOut = function () {
	        this.observable.fire('hoverOut');
	    };
	    ResponsiveCardGridController.prototype.cardIsEndOfRow = function (currentCard) {
	        return (currentCard.index + 1) % this.cardsPerRow === 0;
	    };
	    ResponsiveCardGridController.prototype.getCurrentRow = function (index) {
	        var _this = this;
	        // cache the value of cardsPerRow to avoid cases where the breakpoint updates in the middle of this function
	        var cardsPerRow = this.cardsPerRow;
	        var currentRow = this.numberUtility.integerDivide(index, cardsPerRow);
	        return _.filter(this.behaviors, function (behavior) {
	            return currentRow === _this.numberUtility.integerDivide(behavior.index, cardsPerRow);
	        });
	    };
	    Object.defineProperty(ResponsiveCardGridController.prototype, "cardsPerRow", {
	        get: function () {
	            var currentBreakpoint = this.breakpoints.currentBreakpoint;
	            return this.breakpointRowDictionary[currentBreakpoint];
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResponsiveCardGridController.prototype, "breakpointRowDictionary", {
	        get: function () {
	            var list = [];
	            list[breakpoints_module_1.xs] = 1;
	            list[breakpoints_module_1.sm] = 1;
	            list[breakpoints_module_1.md] = 2;
	            list[breakpoints_module_1.lg] = 3;
	            return list;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ResponsiveCardGridController.$inject = [__observable.factoryName, '$q', breakpoints_module_1.breakpointServiceName, __numberUtility.serviceName];
	    return ResponsiveCardGridController;
	})();
	exports.ResponsiveCardGridController = ResponsiveCardGridController;
	function responsiveCardGrid() {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: "\n\t\t\t<div>\n\t\t\t\t<div class=\"col-lg-4 col-md-6 col-sm-12 smallCardsList\" ng-repeat=\"emptyCard in grid.emptyCards\" ng-if=\"grid.fillEmptySpace\"></div>\n\t\t\t\t<div ng-transclude></div>\n\t\t\t</div>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'grid',
	        scope: {},
	        bindToController: {
	            startingIndex: '=',
	            fillEmptySpace: '=',
	        },
	        link: {
	            pre: function (scope, element, attrs, grid) {
	                grid.findPosition = function (cardElement) {
	                    // find the position of the specified element by iterating over the cards and finding a matching element
	                    var cards = element.find('rl-responsive-card');
	                    var num;
	                    cards.each(function (index, elem) {
	                        if (cardElement[0] === elem) {
	                            num = index;
	                            return false;
	                        }
	                    });
	                    return num;
	                };
	            },
	        },
	    };
	}
	exports.responsiveCardGrid = responsiveCardGrid;
	//# sourceMappingURL=responsiveCardGrid.js.map

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var windowWrapper_service_1 = __webpack_require__(96);
	var visibleBreakpoint_service_1 = __webpack_require__(97);
	var breakpoints_service_1 = __webpack_require__(98);
	__export(__webpack_require__(31));
	__export(__webpack_require__(97));
	__export(__webpack_require__(98));
	exports.moduleName = 'rl.ui.services.breakpoints';
	angular.module(exports.moduleName, [
	    typescript_angular_utilities_1.services.observable.moduleName,
	    windowWrapper_service_1.moduleName,
	])
	    .constant('resizeDebounceMilliseconds', 500)
	    .service(visibleBreakpoint_service_1.visibleBreakpointServiceName, visibleBreakpoint_service_1.VisibleBreakpointService)
	    .service(breakpoints_service_1.breakpointServiceName, breakpoints_service_1.BreakpointService);
	//# sourceMappingURL=breakpoints.module.js.map

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var $ = __webpack_require__(12);
	exports.moduleName = 'rl.ui.services.windowWrapper';
	exports.serviceName = 'windowWrapper';
	var WindowService = (function () {
	    function WindowService() {
	        this.windowControl = $(window);
	    }
	    WindowService.prototype.resize = function (callback) {
	        this.windowControl.resize(callback);
	    };
	    return WindowService;
	})();
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, WindowService);
	//# sourceMappingURL=windowWrapper.service.js.map

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $ = __webpack_require__(12);
	/*
	 * Implementation also requires the following elements to be inserted on the page:
	 *   <div class="device-xs visible-xs"></div>
	 *   <div class="device-sm visible-sm"></div>
	 *   <div class="device-md visible-md"></div>
	 *   <div class="device-lg visible-lg"></div>
	 * They have been inserted into index.html for your convenience.
	 */
	exports.visibleBreakpointServiceName = 'visibleBreakpoint';
	var VisibleBreakpointService = (function () {
	    function VisibleBreakpointService() {
	    }
	    VisibleBreakpointService.prototype.isVisible = function (breakpoint) {
	        // jquery gets the breakpoint trigger directives listed above on line 3
	        return $('.device-' + breakpoint).is(':visible');
	    };
	    return VisibleBreakpointService;
	})();
	exports.VisibleBreakpointService = VisibleBreakpointService;
	//# sourceMappingURL=visibleBreakpoint.service.js.map

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var windowWrapper_service_1 = __webpack_require__(96);
	var visibleBreakpoint_service_1 = __webpack_require__(97);
	var breakpoint_1 = __webpack_require__(31);
	exports.breakpointServiceName = 'breakpoints';
	var __observable = typescript_angular_utilities_1.services.observable;
	var BreakpointService = (function () {
	    function BreakpointService($rootScope, visibleBreakpoints, resizeDebounceMilliseconds, windowService, observableFactory) {
	        var _this = this;
	        this.$rootScope = $rootScope;
	        this.visibleBreakpoints = visibleBreakpoints;
	        this.updateBreakpoint = function () {
	            var newBreakPoint = _this.getBreakpoint();
	            if (newBreakPoint !== _this.currentBreakpoint) {
	                _this.$rootScope.$apply(function () {
	                    _this.currentBreakpoint = newBreakPoint;
	                    _this.observable.fire('window.breakpointChanged', _this.currentBreakpoint);
	                });
	            }
	        };
	        this.currentBreakpoint = this.getBreakpoint();
	        this.observable = observableFactory.getInstance();
	        var efficientResize = _.debounce(this.updateBreakpoint, resizeDebounceMilliseconds, {
	            leading: true,
	            trailing: true,
	            maxWait: resizeDebounceMilliseconds,
	        });
	        windowService.resize(efficientResize);
	    }
	    BreakpointService.prototype.getBreakpoint = function () {
	        if (this.visibleBreakpoints.isVisible(breakpoint_1.lg)) {
	            return breakpoint_1.lg;
	        }
	        else if (this.visibleBreakpoints.isVisible(breakpoint_1.md)) {
	            return breakpoint_1.md;
	        }
	        else if (this.visibleBreakpoints.isVisible(breakpoint_1.sm)) {
	            return breakpoint_1.sm;
	        }
	        else {
	            return breakpoint_1.xs;
	        }
	    };
	    BreakpointService.prototype.isBreakpoint = function (breakpoint) {
	        return this.currentBreakpoint === breakpoint;
	    };
	    BreakpointService.prototype.register = function (action) {
	        return this.observable.register(action, 'window.breakpointChanged');
	    };
	    BreakpointService.$inject = ['$rootScope', visibleBreakpoint_service_1.visibleBreakpointServiceName, 'resizeDebounceMilliseconds', windowWrapper_service_1.serviceName, __observable.factoryName];
	    return BreakpointService;
	})();
	exports.BreakpointService = BreakpointService;
	//# sourceMappingURL=breakpoints.service.js.map

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var jquery_service_1 = __webpack_require__(76);
	exports.directiveName = 'rlResponsiveCard';
	exports.controllerName = 'ResponsiveCardController';
	var __parentChildBehavior = typescript_angular_utilities_1.services.parentChildBehavior;
	var __promiseUtility = typescript_angular_utilities_1.services.promise;
	var ResponsiveCardController = (function () {
	    function ResponsiveCardController($scope, $q, $element, parentChildBehavior, promiseUtility) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$q = $q;
	        this.$element = $element;
	        this.parentChildBehavior = parentChildBehavior;
	        this.promiseUtility = promiseUtility;
	        this.autosaveLink = { viewData: null };
	        // behavior functions
	        this.autosave = function () {
	            if (_this.showDetails === false) {
	                return true;
	            }
	            var behavior = _this.parentChildBehavior.getChildBehavior(_this.autosaveLink);
	            return behavior.autosave();
	        };
	        this.close = function () {
	            _this.showDetails = false;
	        };
	        this.open = function () {
	            _this.showDetails = true;
	        };
	        this.hoverIn = function () {
	            _this.isHovering = true;
	        };
	        this.hoverOut = function () {
	            _this.isHovering = false;
	        };
	        this.updateEndOfRowStatus = function () {
	            _this.isEndOfRow = _this.cardGridController.cardIsEndOfRow(_this.behavior);
	        };
	        this.behavior = {
	            autosave: this.autosave,
	            close: this.close,
	            open: this.open,
	            hoverIn: this.hoverIn,
	            hoverOut: this.hoverOut,
	            updateEndOfRowStatus: this.updateEndOfRowStatus,
	        };
	        this.summary = this.header.summary || function () { return ''; };
	        this.summaryLength = _.isUndefined(this.header.summaryLength) ? 25 : this.header.summaryLength;
	        this.showIcon = this.header.showIcon || function () { return false; };
	        this.cardGridController = $element.controller('rlResponsiveCardGrid');
	        this.unregister = this.cardGridController.registerCard(this.behavior, $element);
	        this.isEndOfRow = this.cardGridController.cardIsEndOfRow(this.behavior);
	        $scope.$on('$destroy', function () {
	            _this.unregister();
	        });
	    }
	    ResponsiveCardController.prototype.toggle = function () {
	        if (this.showDetails) {
	            this.cardGridController.closeCard();
	        }
	        else {
	            this.cardGridController.openCard(this.behavior);
	        }
	    };
	    ResponsiveCardController.prototype.triggerHoverIn = function () {
	        this.cardGridController.hoverIn(this.behavior);
	    };
	    ResponsiveCardController.prototype.triggerHoverOut = function () {
	        this.cardGridController.hoverOut();
	    };
	    ResponsiveCardController.$inject = ['$scope', '$q', '$element', __parentChildBehavior.serviceName, __promiseUtility.serviceName];
	    return ResponsiveCardController;
	})();
	exports.ResponsiveCardController = ResponsiveCardController;
	responsiveCard.$inject = [jquery_service_1.serviceName];
	function responsiveCard(jqueryHelper) {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: true,
	        require: '^^rlResponsiveCardGrid',
	        template: "\n\t\t\t<div class=\"smallCardsList col-lg-4 col-md-6 col-sm-12\">\n\t\t\t\t<div class=\"small-card\">\n\t\t\t\t\t<div class=\"small-card-header\" ng-class=\"{ 'smallCardHeaderHover': card.isHovering }\"\n\t\t\t\t\t\tng-click=\"card.toggle()\" ng-mouseover=\"card.triggerHoverIn()\" ng-mouseleave=\"card.triggerHoverOut()\">\n\t\t\t\t\t\t<div class=\"small-card-header-card-name\">\n\t\t\t\t\t\t\t<span ng-bind-html=\"card.header.name\"></span>\n\t\t\t\t\t\t\t<span ng-if=\"card.summary() | isEmpty:false\"> - </span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"small-card-header-summary-text\" ng-bind-html=\"card.summary()|truncate:card.summaryLength:true\"></div>\n\t\t\t\t\t\t<span class=\"small-card-header-item-count\" ng-if=\"card.header.count != null\"><span class=\"badge\">{{card.header.count()}}</span></span>\n\t\t\t\t\t\t<span class=\"small-card-header-item-count\" ng-if=\"card.header.status != null\"><span class=\"badge\">{{card.header.status()}}</span></span>\n\t\t\t\t\t\t<span class=\"small-card-header-icon\" ng-if=\"card.showIcon()\"> <i class=\"small-card-indicator fa fa-2x fa-{{card.header.icon}}\" title=\"{{card.header.iconTooltip}}\" /></span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<ng-form rl-autosave=\"card.autosaveLink\" validate=\"card.validate()\" save=\"card.save()\">\n\t\t\t\t\t\t<div ng-if=\"card.showDetails\">\n\t\t\t\t\t\t\t<div class=\"small-card-content\">\n\t\t\t\t\t\t\t\t<div ng-transclude></div>\n\t\t\t\t\t\t\t\t<div class=\"clearfix\"></div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</ng-form>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"clearfix\" ng-if=\"card.isEndOfRow\"></div>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'card',
	        scope: {},
	        bindToController: {
	            header: '=',
	            validate: '&',
	            save: '&',
	        },
	    };
	}
	exports.responsiveCard = responsiveCard;
	//# sourceMappingURL=responsiveCard.js.map

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	__webpack_require__(101);
	__webpack_require__(103);
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __object = typescript_angular_utilities_1.services.object;
	var richTextEditor_config_1 = __webpack_require__(104);
	var headerButton_1 = __webpack_require__(105);
	var paragraphButton_1 = __webpack_require__(106);
	var externalProviderName = richTextEditor_config_1.providerName + 'Provider';
	exports.providerName = externalProviderName;
	exports.moduleName = 'rl.ui.components.richTextEditor';
	exports.directiveName = 'rlRichTextEditor';
	exports.controllerName = 'RichTextEditorController';
	var RichTextEditorController = (function () {
	    function RichTextEditorController(object, provider) {
	        this.toolbar = 'h1, paragraph, bold, italic, underline, list1, list2, indent, outdent';
	        if (!object.isNullOrEmpty(this.customButtons)) {
	            this.toolbar += ', ' + this.customButtons;
	        }
	    }
	    RichTextEditorController.$inject = [__object.serviceName, richTextEditor_config_1.providerName];
	    return RichTextEditorController;
	})();
	exports.RichTextEditorController = RichTextEditorController;
	function richTextEditor() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(107),
	        controller: exports.controllerName,
	        controllerAs: 'editor',
	        scope: {},
	        bindToController: {
	            ngModel: '=',
	            customButtons: '=',
	        },
	    };
	}
	exports.richTextEditor = richTextEditor;
	angular.module(exports.moduleName, ['ngWig', __object.moduleName])
	    .directive(exports.directiveName, richTextEditor)
	    .controller(exports.controllerName, RichTextEditorController)
	    .directive(headerButton_1.headerButtonDirectiveName, headerButton_1.headerButton)
	    .directive(paragraphButton_1.paragraphButtonDirectiveName, paragraphButton_1.paragraphButton)
	    .provider(richTextEditor_config_1.providerName, richTextEditor_config_1.richTextEditorProvider);
	//# sourceMappingURL=richTextEditor.js.map

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(102);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./ng-wig.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./ng-wig.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	// imports
	exports.push([module.id, "@import url(https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css);", ""]);
	
	// module
	exports.push([module.id, "/* -------- NG-WIG -------- */\n/**\n *\n *  RESET BOX MODEL\n *\n */\n.ng-wig,\n[class^=\"nw-\"] {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -o-box-sizing: border-box;\n  -ms-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n\n/**\n *   main wrapper for the editor\n *\n *  .ng-wig\n *\n */\n.ng-wig {\n  display: block;\n  padding: 0;\n  margin: 0;\n}\n\n\n/**\n *  styling for toolbar and its items\n *\n *  .nw-toolbar\n *    &__item\n *\n */\n.nw-toolbar {\n  display: block;\n  margin: 0 !important;\n  padding: 0 !important;\n  list-style: none !important;\n  font-size: 12px;\n  color: #6B7277;\n\n  background: -webkit-linear-gradient(90deg, #ffffff 0%, #f9f9f9 100%);\n  background:    -moz-linear-gradient(90deg, #ffffff 0%, #f9f9f9 100%);\n  background:         linear-gradient(180deg, #ffffff 0%, #f9f9f9 100%);\n  border: 1px solid #CCCCCC;\n  border-radius: 3px 3px 0 0;\n}\n\n.nw-toolbar__item {\n  display: inline-block;\n  vertical-align: top;\n\n  border-right: 1px solid #DEDEDE;\n}\n\n.nw-toolbar label {\n  line-height: 30px;\n  display: inline-block;\n  padding: 0 6px 0 3px;\n}\n\n.nw-toolbar input[type=checkbox] {\n  vertical-align: -3px;\n  margin-right: -1px;\n}\n\n/**\n *  styling for the editor part: source code (original textarea) and resulting div\n *\n *  .nw-editor\n *    &__src\n *    &__res\n *\n */\n.nw-editor {\n  display: block;\n  position: relative;\n  overflow-y: auto;\n  padding: 0 8px;\n  /* Default when height is not set */\n  min-height: 300px;\n  background: #fff;\n  cursor: text;\n}\n\n.nw-invisible {\n  display: none;\n}\n\n.nw-editor-container {\n  border: 1px solid #CCCCCC;\n  border-top: none;\n  border-radius: 0 0 3px 3px;\n}\n\n.nw-editor__res {\n  min-height: 100%;\n  margin: -1px 0;\n  padding: 1px 0;\n}\n\n.nw-editor__src,\n.nw-editor__res {\n  width: 100%;\n  outline: none;\n  box-sizing: border-box;\n  border: none;\n}\n\n.nw-editor__src {\n  resize: none;\n  display: block;\n  height: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  padding: 8px;\n}\n\n\n/**\n *  styling for toolbar button, has two modifiers: active and type of icon for background\n *\n *  .nw-button\n *    &--active\n *    &--{button type}\n *\n */\n.nw-button {\n  -webkit-appearance: none;\n  -moz-appearance:    none;\n  appearance:         none;\n\n  display: block;\n  width: 30px;\n  height: 30px;\n  margin: 0;\n  padding: 0;\n  opacity: 0.5;\n\n  background-color: transparent;\n  background-position: center center;\n  background-repeat: no-repeat;\n  border: none;\n  border-radius: 2px;\n\n  cursor: pointer;\n}\n\n.nw-button:focus {\n  outline: none;\n}\n\n.nw-button:hover,\n.nw-button.nw-button--active {\n  opacity: 1\n}\n\n.nw-button--active {\n  background-color: #EEEEEE;\n}\n\n/**\n *  styling & formatting of content inside contenteditable div\n *\n *  .nw-content\n *\n */\n.nw-content {\n  padding: 12px;\n  margin: 0;\n\n  font-family: sans-serif;\n  font-size: 14px;\n  line-height: 24px;\n}\n\n.nw-select {\n  height: 30px;\n  padding: 6px;\n  color: #555;\n  background-color: inherit;\n  border: 0;\n}\n\n.nw-select:focus { outline: none; }\n\n", ""]);
	
	// exports


/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * version: 2.2.0
	 */
	angular.module('ngWig', ['ngwig-app-templates']);
	
	angular.module('ngWig')
	  .directive('ngWig', ["$window", "$document", "ngWigToolbar", function ($window, $document, ngWigToolbar) {
	
	    return {
	      scope: {
	        content: '=ngWig',
	        onPaste: '='
	      },
	      restrict: 'A',
	      replace: true,
	      templateUrl: 'ng-wig/views/ng-wig.html',
	      link: function (scope, element, attrs) {
	
	        scope.editMode = false;
	        scope.autoexpand = !('autoexpand' in attrs) || attrs['autoexpand'] !== 'off';
	        scope.toolbarButtons = ngWigToolbar.getToolbarButtons(attrs.buttons && string2array(attrs.buttons));
	
	        function string2array(keysString){
	          return keysString.split(',').map(Function.prototype.call, String.prototype.trim);
	        }
	
	        scope.toggleEditMode = function () {
	          scope.editMode = !scope.editMode;
	
	          if ($window.getSelection().removeAllRanges) {
	            $window.getSelection().removeAllRanges();
	          }
	        };
	
	        scope.execCommand = function (command, options) {
	          if(scope.editMode ) return false;
	
	          if (command === 'createlink') {
	            options = prompt('Please enter the URL', 'http://');
	            if(!options) {
	              return;
	            }
	          }
	          scope.$broadcast('execCommand', {command: command, options: options});
	        };
	      }
	    }
	  }]
	);
	
	
	angular.module('ngWig')
	  .directive('ngWigEditable', ["$document", function ($document) {
	    function init(scope, $element, attrs, ngModelController) {
	
	      $element.attr('contenteditable', true);
	
	      //model --> view
	      ngModelController.$render = function () {
	        $element.html(ngModelController.$viewValue || '');
	      };
	
	      //view --> model
	      function viewToModel() {
	        ngModelController.$setViewValue($element.html());
	      }
	
	      var eventsToBind = [
	        'blur',
	        'keyup',
	        'change',
	        'focus',
	        'click'
	      ];
	
	      if (angular.isFunction(scope.onPaste)) {
	        $element.on('paste', function(e) {
	          scope.onPaste(e, $element.html()).then(function(val) {
	            $element.html(val);
	          })
	        });
	      }else{
	        eventsToBind.push('paste');
	      }
	
	      $element.bind(eventsToBind.join(' '), function() {
	        viewToModel();
	        scope.$applyAsync();
	      });
	
	      scope.isEditorActive = function () {
	        return $element[0] === $document[0].activeElement;
	      };
	
	      scope.$on('execCommand', function (event, params) {
	        $element[0].focus();
	
	        var ieStyleTextSelection = $document[0].selection,
	          command = params.command,
	          options = params.options;
	
	        if (ieStyleTextSelection) {
	          var textRange = ieStyleTextSelection.createRange();
	        }
	
	        if ($document[0].queryCommandSupported && !$document[0].queryCommandSupported(command)) {
	          throw 'The command "' + command + '" is not supported';
	        }
	
	        $document[0].execCommand(command, false, options);
	
	        if (ieStyleTextSelection) {
	          textRange.collapse(false);
	          textRange.select();
	        }
	
	        viewToModel();
	      });
	    }
	
	    return {
	      restrict: 'A',
	      require: 'ngModel',
	      replace: true,
	      link: init
	    }
	  }]
	);
	
	angular.module('ngWig')
	    .directive('ngWigPlugin', ["$compile", function ($compile) {
	        return {
	            restrict: 'E',
	            link: function(scope, element) {
	                var template = '<' + scope.button.pluginName + ' />',
	                    compiled = $compile(template)(scope);
	
	                element.replaceWith(compiled);
	            }
	        }
	    }]);
	
	angular.module('ngWig').provider('ngWigToolbar', function () {
	
	  var buttonLibrary = {
	    list1: {title: 'Unordered List', command: 'insertunorderedlist', styleClass: 'fa-list-ul'},
	    list2: {title: 'Ordered List', command: 'insertorderedlist', styleClass: 'fa-list-ol'},
	    bold: {title: 'Bold', command: 'bold', styleClass: 'fa-bold'},
	    italic: {title: 'Italic', command: 'italic', styleClass: 'fa-italic'},
	    link: {title: 'Link', command: 'createlink', styleClass: 'fa-link'}
	  };
	
	  var defaultButtonsList = ['list1', 'list2', 'bold', 'italic', 'link'];
	
	  var isButtonActive = function () {
	    return this.command && document.queryCommandState(this.command);
	  };
	
	  this.setButtons = function(buttons) {
	    if(!angular.isArray(buttons)) {
	      throw 'Argument "buttons" should be an array';
	    }
	
	    defaultButtonsList = buttons;
	  };
	
	  this.addStandardButton = function (name, title, command, styleClass) {
	    if(!name || !title || !command) {
	      throw 'Arguments "name", "title" and "command" are required';
	    }
	
	    styleClass = styleClass || '';
	    buttonLibrary[name] = {title: title, command: command, styleClass: styleClass}
	    defaultButtonsList.push(name);
	  };
	
	  this.addCustomButton = function (name, pluginName) {
	    if(!name || !pluginName) {
	      throw 'Arguments "name" and "pluginName" are required';
	    }
	
	    buttonLibrary[name] = {pluginName: pluginName, isComplex: true};
	    defaultButtonsList.push(name);
	  };
	
	  this.$get = function () {
	    return {
	      getToolbarButtons: function(list) {
	        var toolbarButtons = [];
	        (list || defaultButtonsList).forEach(function(buttonKey) {
	          if(!buttonLibrary[buttonKey]) {
	            throw 'There is no "' + buttonKey + '" in your library. Possible variants: ' + Object.keys(buttonLibrary);
	          }
	
	          var button = angular.copy(buttonLibrary[buttonKey]);
	
	          if(!angular.isFunction(button.isActive)) {
	            button.isActive = isButtonActive;
	          }
	
	          toolbarButtons.push(button);
	        });
	        return toolbarButtons;
	      }
	    };
	  };
	
	
	});
	angular.module('ngWig')
	    .config(['ngWigToolbarProvider', function (ngWigToolbarProvider) {
	       ngWigToolbarProvider.addCustomButton('formats', 'nw-formats-button');
	    }])
	    .directive('nwFormatsButton', function() {
	        return {
	            restrict: 'E',
	            replace: true,
	            template: '<select class="nw-select" ng-model="format" ng-change="execCommand(\'formatblock\', format.value)" ng-options="format.name for format in formats" ng-disabled="editMode"></select>',
	            link: function (scope) {
	                scope.formats = [
	                    {name: 'Normal text', value: 'p'},
	                    {name: 'Header 1', value: 'h1'},
	                    {name: 'Header 2', value: 'h2'},
	                    {name: 'Header 3', value: 'h3'}
	                ];
	
	                scope.format = scope.formats[0];
	            }
	        };
	    });
	
	
	angular.module('ngwig-app-templates', ['ng-wig/views/ng-wig.html']);
	
	angular.module("ng-wig/views/ng-wig.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("ng-wig/views/ng-wig.html",
	    "<div class=\"ng-wig\">\n" +
	    "  <ul class=\"nw-toolbar\">\n" +
	    "    <li class=\"nw-toolbar__item\" ng-repeat=\"button in toolbarButtons\" >\n" +
	    "        <div ng-if=\"!button.isComplex\">\n" +
	    "          <button type=\"button\" class=\"nw-button\" title=\"{{button.title}}\" ng-click=\"execCommand(button.command)\" ng-class=\"{ 'nw-button--active': isEditorActive() && button.isActive() }\" ng-disabled=\"editMode\">\n" +
	    "            <i class=\"fa {{button.styleClass}}\"></i>\n" +
	    "          </button>\n" +
	    "        </div>\n" +
	    "        <div ng-if=\"button.isComplex\">\n" +
	    "          <ng-wig-plugin plugin=\"{{button}}\"></ng-wig-plugin>\n" +
	    "        </div>\n" +
	    "    </li><!--\n" +
	    "    --><li class=\"nw-toolbar__item\">\n" +
	    "      <button type=\"button\" class=\"nw-button nw-button--source\" ng-class=\"{ 'nw-button--active': editMode }\" ng-click=\"toggleEditMode()\"><i class=\"fa fa-pencil\"></i></button>\n" +
	    "    </li>\n" +
	    "  </ul>\n" +
	    "\n" +
	    "  <div class=\"nw-editor-container\">\n" +
	    "    <div class=\"nw-editor\">\n" +
	    "      <textarea  class=\"nw-editor__src\" ng-show=\"editMode\" ng-model=\"content\"></textarea>\n" +
	    "      <div tabindex=\"-1\" ng-class=\"{'nw-invisible': editMode, 'nw-autoexpand': autoexpand}\" class=\"nw-editor__res\" ng-model=\"content\" ng-wig-editable on-paste=\"onPaste\"></div>\n" +
	    "    </div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);


/***/ },
/* 104 */
/***/ function(module, exports) {

	'use strict';
	exports.providerName = 'richTextEditor';
	richTextEditorProvider.$inject = ['ngWigToolbarProvider'];
	function richTextEditorProvider(ngWigToolbarProvider) {
	    'use strict';
	    return {
	        addCustomButton: function (name, component) {
	            ngWigToolbarProvider.addCustomButton(name, component);
	        },
	        addStandardButton: function (name, tooltip, command, icon) {
	            ngWigToolbarProvider.addStandardButton(name, toolbar, command, 'fa-' + icon);
	        },
	        $get: function () {
	            ngWigToolbarProvider.addCustomButton('paragraph', 'rl-paragraph-button');
	            ngWigToolbarProvider.addCustomButton('h1', 'rl-header-button');
	            ngWigToolbarProvider.addStandardButton('underline', 'Underline', 'underline', 'fa-underline');
	            ngWigToolbarProvider.addStandardButton('indent', 'Indent', 'indent', 'fa-indent');
	            ngWigToolbarProvider.addStandardButton('outdent', 'Outdent', 'outdent', 'fa-outdent');
	        },
	    };
	}
	exports.richTextEditorProvider = richTextEditorProvider;
	//# sourceMappingURL=richTextEditor.config.js.map

/***/ },
/* 105 */
/***/ function(module, exports) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	exports.headerButtonDirectiveName = 'rlHeaderButton';
	function headerButton() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<button type=\"button\" class=\"nw-button\" ng-click=\"trigger()\" ng-disabled=\"editMode\" title=\"Header 1\">\n\t\t\t\t<i class=\"fa fa-header\"></i>\n\t\t\t</button>\n\t\t",
	        link: function (scope) {
	            scope.trigger = function () {
	                scope.execCommand('formatblock', 'h1');
	            };
	        },
	    };
	}
	exports.headerButton = headerButton;
	//# sourceMappingURL=headerButton.js.map

/***/ },
/* 106 */
/***/ function(module, exports) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	exports.paragraphButtonDirectiveName = 'rlParagraphButton';
	function paragraphButton() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<button type=\"button\" class=\"nw-button\" ng-click=\"trigger()\" ng-disabled=\"editMode\" title=\"paragraph\">\n\t\t\t\t<i class=\"fa fa-paragraph\"></i>\n\t\t\t</button>\n\t\t",
	        link: function (scope) {
	            scope.trigger = function () {
	                scope.execCommand('formatblock', 'p');
	            };
	        },
	    };
	}
	exports.paragraphButton = paragraphButton;
	//# sourceMappingURL=paragraphButton.js.map

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = "<textarea class=\"rich-text-editor\" ng-wig=\"editor.ngModel\" buttons=\"{{editor.toolbar}}\"></textarea>"

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var SignaturePad = __webpack_require__(13);
	exports.moduleName = 'rl.ui.components.signaturePad';
	exports.directiveName = 'rlSignaturePad';
	function signaturePad() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: 'ngModel',
	        template: "\n\t\t\t<canvas class=\"signature-pad\" ng-if=\"!ngDisabled\"></canvas>\n\t\t\t<img ng-src=\"{{ngModel.$viewValue}}\" ng-style=\"style\" ng-if=\"ngDisabled\" />\n\t\t",
	        scope: {
	            pad: '=',
	            height: '=',
	            width: '=',
	            ngDisabled: '=',
	        },
	        link: function (scope, element, attrs, ngModel) {
	            scope.$watch('ngDisabled', function (disabled) {
	                scope.ngModel = ngModel;
	                if (disabled) {
	                    scope.style = {
	                        height: scope.height != null ? scope.height : 100,
	                        width: scope.width != null ? scope.width : 200,
	                    };
	                }
	                else {
	                    var canvas = element.find('.signature-pad').get(0);
	                    var options = {
	                        backgroundColor: 'rgb(255, 255, 255)',
	                    };
	                    scope.pad = new SignaturePad(canvas, options);
	                    canvas.height = scope.height != null ? scope.height : 100;
	                    canvas.width = scope.width != null ? scope.width : 200;
	                    scope.$watch(function () { return ngModel.$viewValue; }, function (value) {
	                        if (value != null) {
	                            scope.pad.fromDataURL(value);
	                        }
	                    });
	                    scope.$watch(function () { return scope.pad.toDataURL(); }, function (value) {
	                        if (value != null) {
	                            ngModel.$setViewValue(value);
	                        }
	                    });
	                }
	            });
	        },
	    };
	}
	exports.signaturePad = signaturePad;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, signaturePad);
	//# sourceMappingURL=signaturePad.js.map

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var card = __webpack_require__(110);
	exports.simpleCard = card;
	var list = __webpack_require__(111);
	exports.simpleCardList = list;
	exports.moduleName = 'rl.ui.components.simpleCardList';
	angular.module(exports.moduleName, [__observable.moduleName, __parentChild.moduleName])
	    .directive(list.directiveName, list.simpleCardList)
	    .controller(list.controllerName, list.SimpleCardListController)
	    .directive(card.directiveName, card.simpleCard)
	    .controller(card.controllerName, card.SimpleCardController);
	//# sourceMappingURL=simpleCardList.module.js.map

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	exports.directiveName = 'rlSimpleCard';
	exports.controllerName = 'SimpleCardController';
	var SimpleCardController = (function () {
	    function SimpleCardController($scope, $element, parentChild) {
	        var _this = this;
	        this.$scope = $scope;
	        this.parentChild = parentChild;
	        this.showContent = false;
	        this.autosaveLink = {};
	        this.close = function () {
	            if (_this.showContent === false || _this.alwaysOpen) {
	                return true;
	            }
	            return _this.autosave();
	        };
	        if (this.canOpen == null) {
	            this.canOpen = true;
	        }
	        this.listController = $element.controller('rlSimpleCardList');
	        if (this.listController == null) {
	            this.listController = this.noList();
	        }
	        var behavior = {
	            autosave: this.autosave.bind(this),
	            close: this.close,
	            setAlwaysOpen: function (value) {
	                _this.alwaysOpen = value;
	            },
	        };
	        this.listController.registerCard(behavior);
	        parentChild.registerChildBehavior(this.childLink, behavior);
	        $scope.$watch(function () { return _this.alwaysOpen; }, function (value) {
	            if (value) {
	                _this.showContent = true;
	            }
	            else {
	                _this.close();
	            }
	        });
	    }
	    SimpleCardController.prototype.toggleContent = function () {
	        if (this.showContent) {
	            this.close();
	        }
	        else {
	            this.open();
	        }
	    };
	    SimpleCardController.prototype.open = function () {
	        if (this.canOpen && this.listController.openCard()) {
	            this.showContent = true;
	            this.onOpen();
	        }
	    };
	    SimpleCardController.prototype.autosave = function () {
	        var _this = this;
	        return this.parentChild.triggerChildBehavior(this.autosaveLink, function (behavior) {
	            var canClose = behavior.autosave();
	            if (canClose) {
	                _this.showContent = false;
	            }
	            return canClose;
	        });
	    };
	    SimpleCardController.prototype.noList = function () {
	        return {
	            openCard: function () {
	                return true;
	            },
	            registerCard: function (behavior) {
	                return null;
	            },
	        };
	    };
	    SimpleCardController.$inject = ['$scope', '$element', __parentChild.serviceName];
	    return SimpleCardController;
	})();
	exports.SimpleCardController = SimpleCardController;
	function simpleCard() {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: true,
	        require: '?^^rlSimpleCardList',
	        template: "\n\t\t\t<div class=\"card col-xs-12\">\n\t\t\t\t<div class=\"header row\" ng-class=\"{ 'active': card.canOpen && !card.alwaysOpen }\" ng-click=\"card.toggleContent()\">\n\t\t\t\t\t<div class=\"header-template\"></div>\n\t\t\t\t\t<div class=\"clearfix\"></div>\n\t\t\t\t</div>\n\n\t\t\t\t<ng-form rl-autosave=\"card.autosaveLink\" validate=\"card.validate()\" save=\"card.save()\">\n\t\t\t\t\t<div ng-show=\"card.showContent || card.alwaysOpen\">\n\t\t\t\t\t\t<div class=\"body row\">\n\t\t\t\t\t\t\t<div class=\"content-template\"></div>\n\t\t\t\t\t\t\t<div class=\"clearfix\"></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</ng-form>\n\t\t\t\t<div ng-show=\"hasFooter && card.showContent\">\n\t\t\t\t\t<div class=\"footer row\">\n\t\t\t\t\t\t<div class=\"footer-template\"></div>\n\t\t\t\t\t\t<div class=\"clearfix\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'card',
	        scope: {},
	        bindToController: {
	            onOpen: '&',
	            canOpen: '=',
	            alwaysOpen: '=',
	            childLink: '=',
	            validate: '&',
	            save: '&',
	        },
	        compile: function () {
	            var header;
	            var content;
	            var footer;
	            return {
	                pre: function (scope, element, attrs, controller, transclude) {
	                    transclude(function (clone) {
	                        header = clone.filter('rl-card-header');
	                        content = clone.filter('rl-card-content');
	                        footer = clone.filter('rl-card-footer');
	                    });
	                },
	                post: function (scope, element) {
	                    var headerArea = element.find('.header-template');
	                    headerArea.append(header);
	                    var contentArea = element.find('.content-template');
	                    contentArea.append(content);
	                    scope.hasFooter = (footer.length > 0);
	                    if (scope.hasFooter) {
	                        var footerArea = element.find('.footer-template');
	                        footerArea.append(footer);
	                    }
	                },
	            };
	        },
	    };
	}
	exports.simpleCard = simpleCard;
	//# sourceMappingURL=simpleCard.js.map

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __observable = typescript_angular_utilities_1.services.observable;
	exports.directiveName = 'rlSimpleCardList';
	exports.controllerName = 'SimpleCardListController';
	var SimpleCardListController = (function () {
	    function SimpleCardListController($scope, $attrs, $parse, observableFactory) {
	        var _this = this;
	        this.observable = observableFactory.getInstance();
	        $scope.$watch(function () { return $parse($attrs.alwaysOpen)($scope); }, function (value) {
	            _this.alwaysOpen = value;
	            _this.observable.fire('alwaysOpen', value);
	        });
	    }
	    SimpleCardListController.prototype.registerCard = function (behavior) {
	        behavior.setAlwaysOpen(this.alwaysOpen);
	        var unregisterFunctions = [];
	        unregisterFunctions.push(this.observable.register(behavior.close, 'close'));
	        unregisterFunctions.push(this.observable.register(behavior.setAlwaysOpen, 'alwaysOpen'));
	        return function () {
	            _.each(unregisterFunctions, function (unregister) {
	                unregister();
	            });
	        };
	    };
	    SimpleCardListController.prototype.openCard = function () {
	        return _.all(this.observable.fire('close'));
	    };
	    SimpleCardListController.$inject = ['$scope', '$attrs', '$parse', __observable.factoryName];
	    return SimpleCardListController;
	})();
	exports.SimpleCardListController = SimpleCardListController;
	function simpleCardList() {
	    'use strict';
	    return {
	        restrict: 'AE',
	        controller: exports.controllerName,
	    };
	}
	exports.simpleCardList = simpleCardList;
	//# sourceMappingURL=simpleCardList.js.map

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/bootstrap-touchspin/bootstrap-touchspin.d.ts' />
	// /// <reference path='../../../typings/jquery/jquery.d.ts' />
	'use strict';
	__webpack_require__(113);
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __string = typescript_angular_utilities_1.services.string;
	var __number = typescript_angular_utilities_1.services.number;
	exports.moduleName = 'rl.ui.components.spinner';
	exports.directiveName = 'rlSpinner';
	exports.controllerName = 'SpinnerController';
	spinner.$inject = ['$timeout', __string.serviceName, __number.serviceName];
	function spinner($timeout, stringUtility, numberUtility) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<rl-generic-container selector=\"ngDisabled\">\n\t\t\t\t<template default>\n\t\t\t\t\t<input name=\"{{name}}\" class=\"spinner\" id=\"{{spinnerId}}\" type=\"text\" />\n\t\t\t\t</template>\n\t\t\t\t<template when-selector=\"true\">\n\t\t\t\t\t<div class=\"input-group\" ng-show=\"prefix != null && postfix != null\">\n\t\t\t\t\t\t<span class=\"input-group-addon\">{{prefix}}</span>\n\t\t\t\t\t\t<input ng-disabled=\"ngDisabled\" type=\"text\" ng-model=\"ngModel\" class=\"form-control\" />\n\t\t\t\t\t\t<span class=\"input-group-addon\">{{postfix}}</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"input-group\" ng-show=\"prefix != null && postfix == null\">\n\t\t\t\t\t\t<span class=\"input-group-addon\">{{prefix}}</span>\n\t\t\t\t\t\t<input ng-disabled=\"ngDisabled\" type=\"text\" ng-model=\"ngModel\" class=\"form-control\" />\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"input-group\" ng-show=\"prefix == null && postfix != null\">\n\t\t\t\t\t\t<input ng-disabled=\"ngDisabled\" type=\"text\" ng-model=\"ngModel\" class=\"form-control\" />\n\t\t\t\t\t\t<span class=\"input-group-addon\">{{postfix}}</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div ng-show=\"prefix == null && postfix == null\">\n\t\t\t\t\t\t<input ng-disabled=\"ngDisabled\" type=\"text\" ng-model=\"ngModel\" class=\"form-control\" />\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</rl-generic-container>\n\t\t",
	        require: '?^ngModel',
	        scope: {
	            min: '=',
	            max: '=',
	            step: '=',
	            decimals: '=',
	            prefix: '@',
	            postfix: '@',
	            roundToStep: '=',
	            ngDisabled: '=',
	            ngModel: '=',
	            spinnerId: '@',
	            name: '@',
	        },
	        link: function (scope, element, attrs, ngModel) {
	            var unbindWatches;
	            scope.$watch('ngDisabled', function (disabled) {
	                if (disabled) {
	                    if (_.isFunction(unbindWatches)) {
	                        unbindWatches();
	                    }
	                }
	                else {
	                    // Initialize the spinner after $timeout to give angular a chance initialize ngModel
	                    $timeout(function () {
	                        var touchspin = element.find('input.spinner').TouchSpin({
	                            min: (scope.min != null ? scope.min : Number.MIN_VALUE),
	                            max: (scope.max != null ? scope.max : Number.MAX_VALUE),
	                            step: scope.step,
	                            prefix: scope.prefix,
	                            postfix: scope.postfix,
	                            decimals: scope.decimals,
	                            initval: ngModel.$viewValue,
	                            forcestepdivisibility: scope.roundToStep ? 'round' : 'none',
	                        });
	                        touchspin.on('change', function () {
	                            scope.$apply(function () {
	                                var spinValue = touchspin.val();
	                                ngModel.$setViewValue(stringUtility.toNumber(spinValue));
	                            });
	                        });
	                        var unbindViewWatch = scope.$watch(function () {
	                            return ngModel.$viewValue;
	                        }, function (newValue) {
	                            touchspin.val(newValue != null ? newValue.toString() : '');
	                        });
	                        var unbindModelWatch = scope.$watch(function () {
	                            return ngModel.$modelValue;
	                        }, function (newModel) {
	                            scope.ngModel = round(newModel);
	                        });
	                        unbindWatches = function () {
	                            unbindViewWatch();
	                            unbindModelWatch();
	                        };
	                    });
	                }
	            });
	            function round(num) {
	                if (num != null && scope.roundToStep) {
	                    num = numberUtility.roundToStep(num, scope.step);
	                    num = numberUtility.preciseRound(num, scope.decimals);
	                }
	                return num;
	            }
	        }
	    };
	}
	angular.module(exports.moduleName, [__string.moduleName])
	    .directive(exports.directiveName, spinner);
	//# sourceMappingURL=spinner.js.map

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	jQuery = __webpack_require__(12);
	
	__webpack_require__(114);
	__webpack_require__(116);

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(115);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./jquery.bootstrap-touchspin.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./jquery.bootstrap-touchspin.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	// imports
	
	
	// module
	exports.push([module.id, "/*\r\n *  Bootstrap TouchSpin - v3.0.1\r\n *  A mobile and touch friendly input spinner component for Bootstrap 3.\r\n *  http://www.virtuosoft.eu/code/bootstrap-touchspin/\r\n *\r\n *  Made by Istvn Ujj-Mszros\r\n *  Under Apache License v2.0 License\r\n */\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical {\r\n  position: relative;\r\n  white-space: nowrap;\r\n  width: 1%;\r\n  vertical-align: middle;\r\n  display: table-cell;\r\n}\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical > .btn {\r\n  display: block;\r\n  float: none;\r\n  width: 100%;\r\n  max-width: 100%;\r\n  padding: 8px 10px;\r\n  margin-left: -1px;\r\n  position: relative;\r\n}\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical .bootstrap-touchspin-up {\r\n  border-radius: 0;\r\n  border-top-right-radius: 4px;\r\n}\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical .bootstrap-touchspin-down {\r\n  margin-top: -2px;\r\n  border-radius: 0;\r\n  border-bottom-right-radius: 4px;\r\n}\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical i {\r\n  position: absolute;\r\n  top: 3px;\r\n  left: 5px;\r\n  font-size: 9px;\r\n  font-weight: normal;\r\n}\r\n", ""]);
	
	// exports


/***/ },
/* 116 */
/***/ function(module, exports) {

	/*
	 *  Bootstrap TouchSpin - v3.0.1
	 *  A mobile and touch friendly input spinner component for Bootstrap 3.
	 *  http://www.virtuosoft.eu/code/bootstrap-touchspin/
	 *
	 *  Made by Istvn Ujj-Mszros
	 *  Under Apache License v2.0 License
	 */
	(function($) {
	  'use strict';
	
	  var _currentSpinnerId = 0;
	
	  function _scopedEventName(name, id) {
	    return name + '.touchspin_' + id;
	  }
	
	  function _scopeEventNames(names, id) {
	    return $.map(names, function(name) {
	      return _scopedEventName(name, id);
	    });
	  }
	
	  $.fn.TouchSpin = function(options) {
	
	    if (options === 'destroy') {
	      this.each(function() {
	        var originalinput = $(this),
	            originalinput_data = originalinput.data();
	        $(document).off(_scopeEventNames([
	          'mouseup',
	          'touchend',
	          'touchcancel',
	          'mousemove',
	          'touchmove',
	          'scroll',
	          'scrollstart'], originalinput_data.spinnerid).join(' '));
	      });
	      return;
	    }
	
	    var defaults = {
	      min: 0,
	      max: 100,
	      initval: '',
	      step: 1,
	      decimals: 0,
	      stepinterval: 100,
	      forcestepdivisibility: 'round', // none | floor | round | ceil
	      stepintervaldelay: 500,
	      verticalbuttons: false,
	      verticalupclass: 'glyphicon glyphicon-chevron-up',
	      verticaldownclass: 'glyphicon glyphicon-chevron-down',
	      prefix: '',
	      postfix: '',
	      prefix_extraclass: '',
	      postfix_extraclass: '',
	      booster: true,
	      boostat: 10,
	      maxboostedstep: false,
	      mousewheel: true,
	      buttondown_class: 'btn btn-default',
	      buttonup_class: 'btn btn-default',
		  buttondown_txt: '-',
		  buttonup_txt: '+'
	    };
	
	    var attributeMap = {
	      min: 'min',
	      max: 'max',
	      initval: 'init-val',
	      step: 'step',
	      decimals: 'decimals',
	      stepinterval: 'step-interval',
	      verticalbuttons: 'vertical-buttons',
	      verticalupclass: 'vertical-up-class',
	      verticaldownclass: 'vertical-down-class',
	      forcestepdivisibility: 'force-step-divisibility',
	      stepintervaldelay: 'step-interval-delay',
	      prefix: 'prefix',
	      postfix: 'postfix',
	      prefix_extraclass: 'prefix-extra-class',
	      postfix_extraclass: 'postfix-extra-class',
	      booster: 'booster',
	      boostat: 'boostat',
	      maxboostedstep: 'max-boosted-step',
	      mousewheel: 'mouse-wheel',
	      buttondown_class: 'button-down-class',
	      buttonup_class: 'button-up-class',
		  buttondown_txt: 'button-down-txt',
		  buttonup_txt: 'button-up-txt'
	    };
	
	    return this.each(function() {
	
	      var settings,
	          originalinput = $(this),
	          originalinput_data = originalinput.data(),
	          container,
	          elements,
	          value,
	          downSpinTimer,
	          upSpinTimer,
	          downDelayTimeout,
	          upDelayTimeout,
	          spincount = 0,
	          spinning = false;
	
	      init();
	
	
	      function init() {
	        if (originalinput.data('alreadyinitialized')) {
	          return;
	        }
	
	        originalinput.data('alreadyinitialized', true);
	        _currentSpinnerId += 1;
	        originalinput.data('spinnerid', _currentSpinnerId);
	
	
	        if (!originalinput.is('input')) {
	          console.log('Must be an input.');
	          return;
	        }
	
	        _initSettings();
	        _setInitval();
	        _checkValue();
	        _buildHtml();
	        _initElements();
	        _hideEmptyPrefixPostfix();
	        _bindEvents();
	        _bindEventsInterface();
	        elements.input.css('display', 'block');
	      }
	
	      function _setInitval() {
	        if (settings.initval !== '' && originalinput.val() === '') {
	          originalinput.val(settings.initval);
	        }
	      }
	
	      function changeSettings(newsettings) {
	        _updateSettings(newsettings);
	        _checkValue();
	
	        var value = elements.input.val();
	
	        if (value !== '') {
	          value = Number(elements.input.val());
	          elements.input.val(value.toFixed(settings.decimals));
	        }
	      }
	
	      function _initSettings() {
	        settings = $.extend({}, defaults, originalinput_data, _parseAttributes(), options);
	      }
	
	      function _parseAttributes() {
	        var data = {};
	        $.each(attributeMap, function(key, value) {
	          var attrName = 'bts-' + value + '';
	          if (originalinput.is('[data-' + attrName + ']')) {
	            data[key] = originalinput.data(attrName);
	          }
	        });
	        return data;
	      }
	
	      function _updateSettings(newsettings) {
	        settings = $.extend({}, settings, newsettings);
	      }
	
	      function _buildHtml() {
	        var initval = originalinput.val(),
	            parentelement = originalinput.parent();
	
	        if (initval !== '') {
	          initval = Number(initval).toFixed(settings.decimals);
	        }
	
	        originalinput.data('initvalue', initval).val(initval);
	        originalinput.addClass('form-control');
	
	        if (parentelement.hasClass('input-group')) {
	          _advanceInputGroup(parentelement);
	        }
	        else {
	          _buildInputGroup();
	        }
	      }
	
	      function _advanceInputGroup(parentelement) {
	        parentelement.addClass('bootstrap-touchspin');
	
	        var prev = originalinput.prev(),
	            next = originalinput.next();
	
	        var downhtml,
	            uphtml,
	            prefixhtml = '<span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span>',
	            postfixhtml = '<span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span>';
	
	        if (prev.hasClass('input-group-btn')) {
	          downhtml = '<button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button>';
	          prev.append(downhtml);
	        }
	        else {
	          downhtml = '<span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span>';
	          $(downhtml).insertBefore(originalinput);
	        }
	
	        if (next.hasClass('input-group-btn')) {
	          uphtml = '<button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button>';
	          next.prepend(uphtml);
	        }
	        else {
	          uphtml = '<span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span>';
	          $(uphtml).insertAfter(originalinput);
	        }
	
	        $(prefixhtml).insertBefore(originalinput);
	        $(postfixhtml).insertAfter(originalinput);
	
	        container = parentelement;
	      }
	
	      function _buildInputGroup() {
	        var html;
	
	        if (settings.verticalbuttons) {
	          html = '<div class="input-group bootstrap-touchspin"><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn-vertical"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-up" type="button"><i class="' + settings.verticalupclass + '"></i></button><button class="' + settings.buttonup_class + ' bootstrap-touchspin-down" type="button"><i class="' + settings.verticaldownclass + '"></i></button></span></div>';
	        }
	        else {
	          html = '<div class="input-group bootstrap-touchspin"><span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span></div>';
	        }
	
	        container = $(html).insertBefore(originalinput);
	
	        $('.bootstrap-touchspin-prefix', container).after(originalinput);
	
	        if (originalinput.hasClass('input-sm')) {
	          container.addClass('input-group-sm');
	        }
	        else if (originalinput.hasClass('input-lg')) {
	          container.addClass('input-group-lg');
	        }
	      }
	
	      function _initElements() {
	        elements = {
	          down: $('.bootstrap-touchspin-down', container),
	          up: $('.bootstrap-touchspin-up', container),
	          input: $('input', container),
	          prefix: $('.bootstrap-touchspin-prefix', container).addClass(settings.prefix_extraclass),
	          postfix: $('.bootstrap-touchspin-postfix', container).addClass(settings.postfix_extraclass)
	        };
	      }
	
	      function _hideEmptyPrefixPostfix() {
	        if (settings.prefix === '') {
	          elements.prefix.hide();
	        }
	
	        if (settings.postfix === '') {
	          elements.postfix.hide();
	        }
	      }
	
	      function _bindEvents() {
	        originalinput.on('keydown', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 38) {
	            if (spinning !== 'up') {
	              upOnce();
	              startUpSpin();
	            }
	            ev.preventDefault();
	          }
	          else if (code === 40) {
	            if (spinning !== 'down') {
	              downOnce();
	              startDownSpin();
	            }
	            ev.preventDefault();
	          }
	        });
	
	        originalinput.on('keyup', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 38) {
	            stopSpin();
	          }
	          else if (code === 40) {
	            stopSpin();
	          }
	        });
	
	        originalinput.on('blur', function() {
	          _checkValue();
	        });
	
	        elements.down.on('keydown', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 32 || code === 13) {
	            if (spinning !== 'down') {
	              downOnce();
	              startDownSpin();
	            }
	            ev.preventDefault();
	          }
	        });
	
	        elements.down.on('keyup', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 32 || code === 13) {
	            stopSpin();
	          }
	        });
	
	        elements.up.on('keydown', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 32 || code === 13) {
	            if (spinning !== 'up') {
	              upOnce();
	              startUpSpin();
	            }
	            ev.preventDefault();
	          }
	        });
	
	        elements.up.on('keyup', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 32 || code === 13) {
	            stopSpin();
	          }
	        });
	
	        elements.down.on('mousedown.touchspin', function(ev) {
	          elements.down.off('touchstart.touchspin');  // android 4 workaround
	
	          if (originalinput.is(':disabled')) {
	            return;
	          }
	
	          downOnce();
	          startDownSpin();
	
	          ev.preventDefault();
	          ev.stopPropagation();
	        });
	
	        elements.down.on('touchstart.touchspin', function(ev) {
	          elements.down.off('mousedown.touchspin');  // android 4 workaround
	
	          if (originalinput.is(':disabled')) {
	            return;
	          }
	
	          downOnce();
	          startDownSpin();
	
	          ev.preventDefault();
	          ev.stopPropagation();
	        });
	
	        elements.up.on('mousedown.touchspin', function(ev) {
	          elements.up.off('touchstart.touchspin');  // android 4 workaround
	
	          if (originalinput.is(':disabled')) {
	            return;
	          }
	
	          upOnce();
	          startUpSpin();
	
	          ev.preventDefault();
	          ev.stopPropagation();
	        });
	
	        elements.up.on('touchstart.touchspin', function(ev) {
	          elements.up.off('mousedown.touchspin');  // android 4 workaround
	
	          if (originalinput.is(':disabled')) {
	            return;
	          }
	
	          upOnce();
	          startUpSpin();
	
	          ev.preventDefault();
	          ev.stopPropagation();
	        });
	
	        elements.up.on('mouseout touchleave touchend touchcancel', function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.stopPropagation();
	          stopSpin();
	        });
	
	        elements.down.on('mouseout touchleave touchend touchcancel', function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.stopPropagation();
	          stopSpin();
	        });
	
	        elements.down.on('mousemove touchmove', function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.stopPropagation();
	          ev.preventDefault();
	        });
	
	        elements.up.on('mousemove touchmove', function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.stopPropagation();
	          ev.preventDefault();
	        });
	
	        $(document).on(_scopeEventNames(['mouseup', 'touchend', 'touchcancel'], _currentSpinnerId).join(' '), function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.preventDefault();
	          stopSpin();
	        });
	
	        $(document).on(_scopeEventNames(['mousemove', 'touchmove', 'scroll', 'scrollstart'], _currentSpinnerId).join(' '), function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.preventDefault();
	          stopSpin();
	        });
	
	        originalinput.on('mousewheel DOMMouseScroll', function(ev) {
	          if (!settings.mousewheel || !originalinput.is(':focus')) {
	            return;
	          }
	
	          var delta = ev.originalEvent.wheelDelta || -ev.originalEvent.deltaY || -ev.originalEvent.detail;
	
	          ev.stopPropagation();
	          ev.preventDefault();
	
	          if (delta < 0) {
	            downOnce();
	          }
	          else {
	            upOnce();
	          }
	        });
	      }
	
	      function _bindEventsInterface() {
	        originalinput.on('touchspin.uponce', function() {
	          stopSpin();
	          upOnce();
	        });
	
	        originalinput.on('touchspin.downonce', function() {
	          stopSpin();
	          downOnce();
	        });
	
	        originalinput.on('touchspin.startupspin', function() {
	          startUpSpin();
	        });
	
	        originalinput.on('touchspin.startdownspin', function() {
	          startDownSpin();
	        });
	
	        originalinput.on('touchspin.stopspin', function() {
	          stopSpin();
	        });
	
	        originalinput.on('touchspin.updatesettings', function(e, newsettings) {
	          changeSettings(newsettings);
	        });
	      }
	
	      function _forcestepdivisibility(value) {
	        switch (settings.forcestepdivisibility) {
	          case 'round':
	            return (Math.round(value / settings.step) * settings.step).toFixed(settings.decimals);
	          case 'floor':
	            return (Math.floor(value / settings.step) * settings.step).toFixed(settings.decimals);
	          case 'ceil':
	            return (Math.ceil(value / settings.step) * settings.step).toFixed(settings.decimals);
	          default:
	            return value;
	        }
	      }
	
	      function _checkValue() {
	        var val, parsedval, returnval;
	
	        val = originalinput.val();
	
	        if (val === '') {
	          return;
	        }
	
	        if (settings.decimals > 0 && val === '.') {
	          return;
	        }
	
	        parsedval = parseFloat(val);
	
	        if (isNaN(parsedval)) {
	          parsedval = 0;
	        }
	
	        returnval = parsedval;
	
	        if (parsedval.toString() !== val) {
	          returnval = parsedval;
	        }
	
	        if (parsedval < settings.min) {
	          returnval = settings.min;
	        }
	
	        if (parsedval > settings.max) {
	          returnval = settings.max;
	        }
	
	        returnval = _forcestepdivisibility(returnval);
	
	        if (Number(val).toString() !== returnval.toString()) {
	          originalinput.val(returnval);
	          originalinput.trigger('change');
	        }
	      }
	
	      function _getBoostedStep() {
	        if (!settings.booster) {
	          return settings.step;
	        }
	        else {
	          var boosted = Math.pow(2, Math.floor(spincount / settings.boostat)) * settings.step;
	
	          if (settings.maxboostedstep) {
	            if (boosted > settings.maxboostedstep) {
	              boosted = settings.maxboostedstep;
	              value = Math.round((value / boosted)) * boosted;
	            }
	          }
	
	          return Math.max(settings.step, boosted);
	        }
	      }
	
	      function upOnce() {
	        _checkValue();
	
	        value = parseFloat(elements.input.val());
	        if (isNaN(value)) {
	          value = 0;
	        }
	
	        var initvalue = value,
	            boostedstep = _getBoostedStep();
	
	        value = value + boostedstep;
	
	        if (value > settings.max) {
	          value = settings.max;
	          originalinput.trigger('touchspin.on.max');
	          stopSpin();
	        }
	
	        elements.input.val(Number(value).toFixed(settings.decimals));
	
	        if (initvalue !== value) {
	          originalinput.trigger('change');
	        }
	      }
	
	      function downOnce() {
	        _checkValue();
	
	        value = parseFloat(elements.input.val());
	        if (isNaN(value)) {
	          value = 0;
	        }
	
	        var initvalue = value,
	            boostedstep = _getBoostedStep();
	
	        value = value - boostedstep;
	
	        if (value < settings.min) {
	          value = settings.min;
	          originalinput.trigger('touchspin.on.min');
	          stopSpin();
	        }
	
	        elements.input.val(value.toFixed(settings.decimals));
	
	        if (initvalue !== value) {
	          originalinput.trigger('change');
	        }
	      }
	
	      function startDownSpin() {
	        stopSpin();
	
	        spincount = 0;
	        spinning = 'down';
	
	        originalinput.trigger('touchspin.on.startspin');
	        originalinput.trigger('touchspin.on.startdownspin');
	
	        downDelayTimeout = setTimeout(function() {
	          downSpinTimer = setInterval(function() {
	            spincount++;
	            downOnce();
	          }, settings.stepinterval);
	        }, settings.stepintervaldelay);
	      }
	
	      function startUpSpin() {
	        stopSpin();
	
	        spincount = 0;
	        spinning = 'up';
	
	        originalinput.trigger('touchspin.on.startspin');
	        originalinput.trigger('touchspin.on.startupspin');
	
	        upDelayTimeout = setTimeout(function() {
	          upSpinTimer = setInterval(function() {
	            spincount++;
	            upOnce();
	          }, settings.stepinterval);
	        }, settings.stepintervaldelay);
	      }
	
	      function stopSpin() {
	        clearTimeout(downDelayTimeout);
	        clearTimeout(upDelayTimeout);
	        clearInterval(downSpinTimer);
	        clearInterval(upSpinTimer);
	
	        switch (spinning) {
	          case 'up':
	            originalinput.trigger('touchspin.on.stopupspin');
	            originalinput.trigger('touchspin.on.stopspin');
	            break;
	          case 'down':
	            originalinput.trigger('touchspin.on.stopdownspin');
	            originalinput.trigger('touchspin.on.stopspin');
	            break;
	        }
	
	        spincount = 0;
	        spinning = false;
	      }
	
	    });
	
	  };
	
	})(jQuery);


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __object = typescript_angular_utilities_1.services.object;
	exports.moduleName = 'rl.ui.components.stringWithWatermark';
	exports.directiveName = 'rlStringWithWatermark';
	exports.controllerName = 'StringWithWatermarkController';
	var StringWithWatermarkController = (function () {
	    function StringWithWatermarkController($scope, objectUtility) {
	        var _this = this;
	        $scope.$watch(function () { return _this.string; }, function (value) {
	            _this.hasString = objectUtility.isNullOrEmpty(value) === false;
	        });
	    }
	    StringWithWatermarkController.$inject = ['$scope', __object.serviceName];
	    return StringWithWatermarkController;
	})();
	exports.StringWithWatermarkController = StringWithWatermarkController;
	function stringWithWatermark() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<span>\n\t\t\t\t<span ng-show=\"controller.hasString\">{{controller.string}}</span>\n\t\t\t\t<span ng-hide=\"controller.hasString\" class=\"watermark\">{{controller.watermark}}</span>\n\t\t\t</span>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'controller',
	        scope: {},
	        bindToController: {
	            string: '@',
	            watermark: '@',
	        }
	    };
	}
	exports.stringWithWatermark = stringWithWatermark;
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(exports.directiveName, stringWithWatermark)
	    .controller(exports.controllerName, StringWithWatermarkController);
	//# sourceMappingURL=stringWithWatermark.js.map

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var __genericSearch = typescript_angular_utilities_1.services.genericSearchFilter;
	var __objectUtility = typescript_angular_utilities_1.services.object;
	var __arrayUtility = typescript_angular_utilities_1.services.array;
	var __promiseUtility = typescript_angular_utilities_1.services.promise;
	exports.moduleName = 'rl.ui.components.typeahead';
	exports.directiveName = 'rlTypeahead';
	exports.controllerName = 'TypeaheadController';
	var TypeaheadController = (function () {
	    function TypeaheadController($scope, $attrs, $q, parentChild, genericSearchFactory, object, array, promise) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$q = $q;
	        this.parentChild = parentChild;
	        this.array = array;
	        this.promise = promise;
	        this.loading = false;
	        this.addItem = function (item) {
	            if (_this.cachedItems != null) {
	                _this.cachedItems.push(item);
	            }
	        };
	        this.removeItem = function (item) {
	            if (_this.cachedItems != null) {
	                _this.array.remove(_this.cachedItems, item);
	            }
	        };
	        this.searchFilter = genericSearchFactory.getInstance();
	        this.loadDelay = this.useClientSearching ? 100 : 500;
	        this.selection = this.selectionBinding;
	        if (this.hasSelection == null) {
	            this.hasSelection = false;
	        }
	        if (this.placeholder == null) {
	            this.placeholder = 'Search';
	        }
	        if (this.showSearch == null) {
	            this.showSearch = true;
	        }
	        this.useScopeSelection = object.isNullOrEmpty($attrs.selection) === false;
	        this.hasTransform = object.isNullOrEmpty($attrs.transform) === false;
	        this.useApply = object.isNullOrEmpty($attrs.apply) === false;
	        this.parentChild.registerChildBehavior(this.childLink, {
	            add: this.addItem,
	            remove: this.removeItem,
	        });
	        $scope.$watch(function () { return _this.selection; }, function (value) {
	            _this.hasSelection = _.isObject(value);
	            _this.setSelection(value);
	        });
	        $scope.$watch(function () { return _this.selectionBinding; }, function (value) {
	            if (value == null) {
	                _this.selection = null;
	            }
	        });
	    }
	    TypeaheadController.prototype.setSelection = function (object) {
	        if (this.hasSelection != null) {
	            this.hasSelection = this.hasSelection;
	        }
	        if (this.useScopeSelection) {
	            this.selection = object;
	        }
	        if (_.isFunction(this.select)) {
	            this.select({ value: object, hasSelection: this.hasSelection });
	        }
	    };
	    TypeaheadController.prototype.transform = function (object) {
	        if (this.hasTransform && object != null) {
	            return this.transformInParent({
	                value: object,
	            });
	        }
	        return object;
	    };
	    TypeaheadController.prototype.getItems = function (search) {
	        var _this = this;
	        if (!this.useClientSearching) {
	            return this.getItemsInParent({
	                search: search,
	            });
	        }
	        else {
	            this.searchFilter.searchText = search;
	            if (this.cachedItems != null) {
	                return this.$q.when(this.filter(this.cachedItems));
	            }
	            else {
	                return this.$q.when(this.getItemsInParent()).then(function (data) {
	                    _this.cachedItems = data;
	                    return _this.filter(data);
	                });
	            }
	        }
	    };
	    TypeaheadController.prototype.applyItem = function () {
	        var _this = this;
	        if (this.useApply && this.hasSelection) {
	            var request = this.apply({ value: this.selection });
	            if (this.promise.isPromise(request)) {
	                return request.then(function () {
	                    _this.removeItem(_this.selection);
	                    _this.selection = null;
	                });
	            }
	            else if (!_.isUndefined(request)) {
	                this.removeItem(this.selection);
	                this.selection = null;
	            }
	        }
	        return this.$q.when();
	    };
	    TypeaheadController.prototype.filter = function (list) {
	        var _this = this;
	        return _.filter(list, function (item) { return _this.searchFilter.filter(item); });
	    };
	    TypeaheadController.$inject = ['$scope',
	        '$attrs',
	        '$q',
	        __parentChild.serviceName,
	        __genericSearch.factoryName,
	        __objectUtility.serviceName,
	        __arrayUtility.serviceName,
	        __promiseUtility.serviceName];
	    return TypeaheadController;
	})();
	exports.TypeaheadController = TypeaheadController;
	function typeahead() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(119),
	        controller: exports.controllerName,
	        controllerAs: 'typeahead',
	        scope: {},
	        bindToController: {
	            childLink: '=',
	            selectionBinding: '=selection',
	            hasSelection: '=',
	            select: '&',
	            transformInParent: '&transform',
	            getItemsInParent: '&getItems',
	            placeholder: '@',
	            useClientSearching: '=',
	            hasError: '=',
	            showSearch: '=',
	            apply: '&',
	        },
	    };
	}
	exports.typeahead = typeahead;
	angular.module(exports.moduleName, [
	    __parentChild.moduleName,
	    __genericSearch.moduleName,
	    __objectUtility.moduleName,
	    __arrayUtility.moduleName,
	    __promiseUtility.moduleName])
	    .directive(exports.directiveName, typeahead)
	    .controller(exports.controllerName, TypeaheadController);
	//# sourceMappingURL=typeahead.js.map

/***/ },
/* 119 */
/***/ function(module, exports) {

	module.exports = "<div class=\"input-group\" ng-class=\"{ 'has-error': typeahead.hasError }\">\r\n\t<input type=\"text\" ng-model=\"typeahead.selection\" class=\"form-control\"\r\n\t\tplaceholder=\"{{typeahead.placeholder}}\" typeahead=\"object as typeahead.transform(object) for object in typeahead.getItems($viewValue)\"\r\n\t\ttypeahead-loading=\"typeahead.loading\" typeahead-wait-ms=\"typeahead.loadDelay\" />\r\n\t<div class=\"input-group-addon\" ng-if=\"typeahead.showSearch\">\r\n\t\t<rl-busy loading=\"typeahead.loading\"></rl-busy>\r\n\t\t<span ng-hide=\"typeahead.loading\">\r\n\t\t\t<i class=\"fa fa-search\" ng-hide=\"typeahead.hasSelection\"></i>\r\n\t\t\t<i class=\"fa fa-check\" ng-show=\"typeahead.hasSelection\"></i>\r\n\t\t</span>\r\n\t</div>\r\n\t<div class=\"input-group-btn\" ng-if=\"typeahead.useApply\">\r\n\t\t<rl-button-async type=\"default\" action=\"typeahead.applyItem()\" right-aligned=\"true\" ng-disabled=\"!typeahead.hasSelection\">\r\n\t\t\t<i class=\"fa fa-plus new\"></i>\r\n\t\t</rl-button-async>\r\n\t</div>\r\n</div>"

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(22);
	exports.moduleName = 'rl.components.userRating';
	exports.directiveName = 'rlUserRating';
	exports.controllerName = 'UserRatingController';
	var UserRatingController = (function () {
	    function UserRatingController($scope) {
	        var _this = this;
	        this.$scope = $scope;
	        this.stars = [];
	        var rangeSize = this.$scope.range != null ? this.$scope.range : 5;
	        // css style requires the stars to show right to left. Reverse the list so the highest value is first
	        var range = _.range(1, rangeSize + 1).reverse();
	        _.each(range, function (rating) {
	            _this.stars.push({
	                value: rating,
	                filled: false,
	            });
	        });
	        var unbind = this.$scope.$watch('ngModel', function (value) {
	            _this.updateStarView(_this.$scope.ngModel.$viewValue);
	            unbind();
	        });
	    }
	    UserRatingController.prototype.setRating = function (rating) {
	        this.$scope.ngModel.$setViewValue(rating);
	        this.updateStarView(rating);
	    };
	    UserRatingController.prototype.updateStarView = function (rating) {
	        _.each(this.stars, function (star) {
	            if (star.value <= rating) {
	                star.filled = true;
	            }
	            else {
	                star.filled = false;
	            }
	        });
	    };
	    UserRatingController.$inject = ['$scope'];
	    return UserRatingController;
	})();
	exports.UserRatingController = UserRatingController;
	function userRating() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: 'ngModel',
	        template: "\n\t\t\t<span class=\"rating\">\n\t\t\t\t<span class=\"star\" ng-repeat=\"star in userRating.stars\" ng-class=\"{ 'filled': star.filled }\" ng-click=\"userRating.setRating(star.value)\"></span>\n\t\t\t</span>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'userRating',
	        scope: {
	            range: '=',
	        },
	        link: function (scope, element, attrs, ngModel) {
	            scope.ngModel = ngModel;
	        },
	    };
	}
	exports.userRating = userRating;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, userRating)
	    .controller(exports.controllerName, UserRatingController);
	//# sourceMappingURL=userRating.js.map

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var autosaveDialog = __webpack_require__(122);
	exports.autosaveDialog = autosaveDialog;
	var breakpoints = __webpack_require__(95);
	exports.breakpoints = breakpoints;
	var contentProvider = __webpack_require__(129);
	exports.contentProvider = contentProvider;
	var dialog = __webpack_require__(124);
	exports.dialog = dialog;
	var jquery = __webpack_require__(76);
	exports.jquery = jquery;
	var windowWrapper = __webpack_require__(96);
	exports.windowWrapper = windowWrapper;
	exports.moduleName = 'rl.ui.services';
	angular.module(exports.moduleName, [
	    autosaveDialog.moduleName,
	    breakpoints.moduleName,
	    contentProvider.moduleName,
	    dialog.moduleName,
	    jquery.moduleName,
	    windowWrapper.moduleName,
	]);
	//# sourceMappingURL=services.module.js.map

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __promise = typescript_angular_utilities_1.services.promise;
	var autosaveDialog_service_1 = __webpack_require__(123);
	var autosaveDialog_controller_1 = __webpack_require__(128);
	__export(__webpack_require__(123));
	__export(__webpack_require__(128));
	exports.moduleName = 'rl.ui.services.autosaveDialog';
	angular.module(exports.moduleName, [__promise.moduleName])
	    .service(autosaveDialog_service_1.serviceName, autosaveDialog_service_1.AutosaveDialogService)
	    .controller(autosaveDialog_controller_1.controllerName, autosaveDialog_controller_1.AutosaveDialogController);
	//# sourceMappingURL=autosaveDialog.module.js.map

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var dialog_service_1 = __webpack_require__(124);
	var autosaveDialog_controller_1 = __webpack_require__(128);
	exports.serviceName = 'autosaveDialog';
	var __autosave = typescript_angular_utilities_1.services.autosave;
	var __promise = typescript_angular_utilities_1.services.promise;
	var AutosaveDialogService = (function () {
	    function AutosaveDialogService($rootScope, dialog, autosaveFactory, promise) {
	        var _this = this;
	        this.$rootScope = $rootScope;
	        this.dialog = dialog;
	        this.autosaveFactory = autosaveFactory;
	        this.promise = promise;
	        this.autosaveCloseHandler = function (explicit) {
	            if (explicit) {
	                return true;
	            }
	            return _this.autosave.autosave(_this.data);
	        };
	        this.setForm = function (form) {
	            _this.autosave.contentForm = form;
	        };
	    }
	    AutosaveDialogService.prototype.open = function (options) {
	        var _this = this;
	        this.promise.resolvePromises(options.resolve).then(function (resolveData) {
	            var scope = options.scope;
	            if (scope == null) {
	                scope = _this.$rootScope.$new();
	                options.scope = scope;
	            }
	            if (options.data == null) {
	                options.data = {};
	            }
	            _this.autosave = _this.autosaveFactory.getInstance({
	                save: options.save,
	                validate: options.validate,
	            });
	            scope.form = options.form;
	            scope.formGetter = options.formGetter;
	            scope.setForm = _this.setForm;
	            _this.data = _.extend(options.data, resolveData);
	            scope.dialog = _this.data;
	            var dialogOptions = options;
	            dialogOptions.controller = autosaveDialog_controller_1.controllerName;
	            dialogOptions.controllerAs = 'controller';
	            _this.dialog.open(options, _this.autosaveCloseHandler);
	        });
	    };
	    AutosaveDialogService.$inject = ['$rootScope', dialog_service_1.serviceName, __autosave.factoryName, __promise.serviceName];
	    return AutosaveDialogService;
	})();
	exports.AutosaveDialogService = AutosaveDialogService;
	//# sourceMappingURL=autosaveDialog.service.js.map

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ng = __webpack_require__(1);
	var baseDialog = __webpack_require__(125);
	exports.baseDialog = baseDialog;
	exports.moduleName = 'rl.ui.services.dialog';
	exports.serviceName = 'dialog';
	var DialogService = (function () {
	    function DialogService(dialog) {
	        this.dialog = dialog;
	    }
	    DialogService.prototype.open = function (options, closeHandler) {
	        return this.dialog.open(options, closeHandler);
	    };
	    return DialogService;
	})();
	exports.DialogService = DialogService;
	function dialogServiceProvider() {
	    'use strict';
	    var _this = this;
	    var provider = {
	        setImplementation: function (dialogImplementation) {
	            _this.dialogImplementation = dialogImplementation;
	        },
	        $get: function (baseDialog) {
	            var dialogImplementation = _this.dialogImplementation != null
	                ? _this.dialogImplementation
	                : baseDialog;
	            return new DialogService(dialogImplementation);
	        },
	    };
	    provider.$get.$inject = [baseDialog.serviceName];
	    return provider;
	}
	exports.dialogServiceProvider = dialogServiceProvider;
	ng.module(exports.moduleName, [baseDialog.moduleName])
	    .provider(exports.serviceName, dialogServiceProvider);
	//# sourceMappingURL=dialog.service.js.map

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __promise = typescript_angular_utilities_1.services.promise;
	var baseDialog_controller_1 = __webpack_require__(126);
	var baseDialog_service_1 = __webpack_require__(127);
	__export(__webpack_require__(126));
	__export(__webpack_require__(127));
	exports.moduleName = 'rl.ui.services.dialog.baseDialog';
	angular.module(exports.moduleName, [__promise.moduleName])
	    .controller(baseDialog_controller_1.controllerName, baseDialog_controller_1.BaseDialogController)
	    .service(baseDialog_service_1.serviceName, baseDialog_service_1.BaseDialogService);
	//# sourceMappingURL=baseDialog.module.js.map

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var baseDialog_service_1 = __webpack_require__(127);
	exports.controllerName = 'BaseDialogController';
	var BaseDialogController = (function () {
	    function BaseDialogController($scope, $controller, baseDialog) {
	        var controller;
	        if ($scope.modalController != null) {
	            var locals = $scope.resolveData || {};
	            $scope.resolveData = null;
	            locals.$scope = $scope;
	            controller = $controller($scope.modalController, locals);
	        }
	        $scope.$on('modal.closing', baseDialog.modalClosing);
	        return controller;
	    }
	    BaseDialogController.$inject = ['$scope', '$controller', baseDialog_service_1.serviceName];
	    return BaseDialogController;
	})();
	exports.BaseDialogController = BaseDialogController;
	//# sourceMappingURL=baseDialog.controller.js.map

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __promise = typescript_angular_utilities_1.services.promise;
	var baseDialog_controller_1 = __webpack_require__(126);
	exports.serviceName = 'baseDialog';
	var BaseDialogService = (function () {
	    function BaseDialogService($modal, $rootScope, promise) {
	        var _this = this;
	        this.$modal = $modal;
	        this.$rootScope = $rootScope;
	        this.promise = promise;
	        this.modalClosing = function (event, reason, explicitlyClosed) {
	            var canClose = true;
	            if (_.isFunction(_this.closeHandler)) {
	                canClose = _this.closeHandler(explicitlyClosed);
	            }
	            if (!canClose) {
	                event.preventDefault();
	            }
	        };
	    }
	    BaseDialogService.prototype.open = function (options, closeHandler) {
	        var _this = this;
	        if (options == null) {
	            options = {};
	        }
	        var dialogInstance = {
	            close: function () { },
	            dismiss: function () { },
	        };
	        this.promise.resolvePromises(options.resolve).then(function (results) {
	            _this.closeHandler = closeHandler;
	            options = _this.configureModalSettings(options, results);
	            var modalInstance = _this.$modal.open(options);
	            dialogInstance.close = modalInstance.close;
	            dialogInstance.dismiss = modalInstance.dismiss;
	        });
	        return dialogInstance;
	    };
	    BaseDialogService.prototype.configureModalSettings = function (options, resolveData) {
	        var modalScope = options.scope;
	        if (modalScope == null) {
	            modalScope = this.$rootScope.$new();
	        }
	        if (options.resolveToDialog) {
	            if (options.dialogAs != null) {
	                modalScope[options.dialogAs] = resolveData;
	            }
	            else {
	                modalScope = _.extend(modalScope, resolveData);
	            }
	        }
	        else {
	            modalScope.resolveData = resolveData;
	        }
	        modalScope.modalController = options.controller;
	        options.resolve = null;
	        options.controller = baseDialog_controller_1.controllerName;
	        options.scope = modalScope;
	        return options;
	    };
	    BaseDialogService.$inject = ['$modal', '$rootScope', __promise.serviceName];
	    return BaseDialogService;
	})();
	exports.BaseDialogService = BaseDialogService;
	//# sourceMappingURL=baseDialog.service.js.map

/***/ },
/* 128 */
/***/ function(module, exports) {

	'use strict';
	exports.controllerName = 'AutosaveDialogController';
	var AutosaveDialogController = (function () {
	    function AutosaveDialogController($scope) {
	        this.$scope = $scope;
	        if ($scope.form != null) {
	            var unbind = $scope.$watch($scope.form, function (form) {
	                if (form != null) {
	                    $scope.setForm(form);
	                    unbind();
	                }
	            });
	        }
	        else if ($scope.formGetter != null) {
	            var unbind = $scope.$watch(function () { return $scope.formGetter($scope); }, function (form) {
	                if (form != null) {
	                    $scope.setForm(form);
	                    unbind();
	                }
	            });
	        }
	    }
	    AutosaveDialogController.$inject = ['$scope'];
	    return AutosaveDialogController;
	})();
	exports.AutosaveDialogController = AutosaveDialogController;
	//# sourceMappingURL=autosaveDialog.controller.js.map

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path="../../../typings/jquery/jquery.d.ts" />
	'use strict';
	var ng = __webpack_require__(1);
	var _ = __webpack_require__(22);
	var typescript_angular_utilities_1 = __webpack_require__(16);
	var __observable = typescript_angular_utilities_1.services.observable;
	exports.moduleName = 'rl.utilities.services.contentProvider';
	exports.serviceName = 'contentProviderFactory';
	var ContentProviderService = (function () {
	    function ContentProviderService(observableFactory) {
	        var _this = this;
	        this.setTranscludeContent = function (transcludeFunction) {
	            if (_.isFunction(transcludeFunction)) {
	                transcludeFunction(function (clone) {
	                    _this.setContent(clone);
	                });
	            }
	            else {
	                _this.setContent(null);
	            }
	        };
	        this.observable = observableFactory.getInstance();
	    }
	    ContentProviderService.prototype.setContent = function (content) {
	        this.content = content;
	        this.observable.fire('contentChanged');
	    };
	    ContentProviderService.prototype.register = function (action, selector) {
	        var _this = this;
	        if (this.content != null) {
	            action(this.getContent(selector));
	        }
	        return this.observable.register(function () {
	            action(_this.getContent(selector));
	        }, 'contentChanged');
	    };
	    ContentProviderService.prototype.getContent = function (selector) {
	        if (selector != null) {
	            return this.content.filter(selector);
	        }
	        return this.content;
	    };
	    return ContentProviderService;
	})();
	contentProviderServiceFactory.$inject = [__observable.factoryName];
	function contentProviderServiceFactory(observableFactory) {
	    'use strict';
	    return {
	        getInstance: function () {
	            return new ContentProviderService(observableFactory);
	        }
	    };
	}
	ng.module(exports.moduleName, [__observable.moduleName])
	    .factory(exports.serviceName, contentProviderServiceFactory);
	//# sourceMappingURL=contentProvider.service.js.map

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzA0MTU2MGM5NmI2YWRhNjE3ZDkiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3VpLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhbmd1bGFyXCIiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyLXVpLWJvb3RzdHJhcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXItdWktYm9vdHN0cmFwL3VpLWJvb3RzdHJhcC10cGxzLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhci1zYW5pdGl6ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXItc2FuaXRpemUvYW5ndWxhci1zYW5pdGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvYW5ndWxhci1ib290c3RyYXAtc2xpZGVyL3NsaWRlci5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvYW5ndWxhci1ib290c3RyYXAtc2xpZGVyL2Jvb3RzdHJhcC1zbGlkZXIubWluLmNzcz8wYzNlIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9hbmd1bGFyLWJvb3RzdHJhcC1zbGlkZXIvYm9vdHN0cmFwLXNsaWRlci5taW4uY3NzIiwid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9hbmd1bGFyLWJvb3RzdHJhcC1zbGlkZXIvYm9vdHN0cmFwLXNsaWRlci5taW4uanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiJFwiIiwid2VicGFjazovLy8uL34vc2lnbmF0dXJlX3BhZC9zaWduYXR1cmVfcGFkLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9iZWhhdmlvcnMvYmVoYXZpb3JzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvYmVoYXZpb3JzL2F1dG9zYXZlL2F1dG9zYXZlLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInJsX3V0aWxpdGllc1wiIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NvbXBvbmVudHMubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2F1dG9zYXZlRGlhbG9nRm9vdGVyL2F1dG9zYXZlRGlhbG9nRm9vdGVyLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2F1dG9zYXZlRGlhbG9nRm9vdGVyL2F1dG9zYXZlRGlhbG9nRm9vdGVyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnVzeS9idXN5LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2J1dHRvbkFzeW5jL2J1dHRvbkFzeW5jLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIl9cIiIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b25Bc3luYy9idXR0b25Bc3luYy5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2J1dHRvblRvZ2dsZS9idXR0b25Ub2dnbGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uVG9nZ2xlL2J1dHRvblRvZ2dsZS5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY2FyZENvbnRhaW5lci5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2NhcmQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2hlYWRlckNvbHVtbi9oZWFkZXJDb2x1bW4ubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY2FyZC9oZWFkZXJDb2x1bW4vaGVhZGVyQ29sdW1uLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY2FyZC9oZWFkZXJDb2x1bW4vc2l6ZUZvckJyZWFrcG9pbnRzLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9icmVha3BvaW50cy9icmVha3BvaW50LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY2FyZC9jYXJkLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkU2VhcmNoL2NhcmRTZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkU2VhcmNoL2NhcmRTZWFyY2guaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NvbHVtbkhlYWRlci9jb2x1bW5IZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9zb3J0RGlyZWN0aW9uLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvZGF0YVNvdXJjZXMubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvc29ydHMvc29ydHMubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvc29ydHMvbWVyZ2VTb3J0L21lcmdlU29ydC5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvc29ydHMvc29ydGVyL3NvcnRlci5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvc29ydHMvc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFQYWdlci9kYXRhUGFnZXIuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFTZXJ2aWNlRGF0YVNvdXJjZS9kYXRhU2VydmljZURhdGFTb3VyY2Uuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFTb3VyY2VCYXNlLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9kYXRhU291cmNlUHJvY2Vzc29yLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9zaW1wbGVEYXRhU291cmNlL3NpbXBsZURhdGFTb3VyY2Uuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL3NlcnZlclNlYXJjaERhdGFTb3VyY2Uvc2VydmVyU2VhcmNoRGF0YVNvdXJjZS5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvZGF0YVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVycy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2NvbHVtblNlYXJjaEZpbHRlci9jb2x1bW5TZWFyY2hGaWx0ZXIuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvZmlsdGVyR3JvdXAubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9maWx0ZXJPcHRpb24vZmlsdGVyT3B0aW9uLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9maWx0ZXJPcHRpb24vZmlsdGVyT3B0aW9uLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL21vZGVGaWx0ZXJHcm91cC9tb2RlRmlsdGVyR3JvdXAuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvZmlsdGVyR3JvdXAuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvcmFuZ2VGaWx0ZXJHcm91cC9yYW5nZUZpbHRlckdyb3VwLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlckdyb3VwLmRpcmVjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvZmlsdGVyR3JvdXAuZGlyZWN0aXZlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9pdGVtQ291bnQvaXRlbUNvdW50LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvaXRlbUNvdW50L2l0ZW1Db3VudC5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvcGFnZXIvcGFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlci9wYWdlci5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvcGFnZVNpemUvcGFnZVNpemUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlU2l6ZS9wYWdlU2l6ZS5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvc2VsZWN0aW9uQ29udHJvbC9zZWxlY3Rpb25Db250cm9sLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvc2VsZWN0aW9uQ29udHJvbC9zZWxlY3Rpb25Db250cm9sLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY2FyZENvbnRhaW5lci5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY2FyZENvbnRhaW5lci5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGVmYXVsdENhcmRDb250YWluZXJIZWFkZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RlZmF1bHRDYXJkQ29udGFpbmVyRm9vdGVyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jb2x1bW4uanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY29tbWFMaXN0L2NvbW1hTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9kYXRlVGltZS9kYXRlVGltZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9nZW5lcmljQ29udGFpbmVyL2dlbmVyaWNDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2pxdWVyeS9qcXVlcnkuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9sYXp5TG9hZC9sYXp5TG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9sb25nQ2xpY2tCdXR0b24vbG9uZ0NsaWNrQnV0dG9uLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2xvbmdDbGlja0J1dHRvbi9sb25nQ2xpY2tCdXR0b24uaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9tZXNzYWdlTG9nL21lc3NhZ2VMb2cubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL21lc3NhZ2VMb2cvbWVzc2FnZUxvZy5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL21lc3NhZ2VMb2cvbWVzc2FnZUxvZy5kaXJlY3RpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvbWVzc2FnZUxvZy9tZXNzYWdlTG9nLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvbWVzc2FnZUxvZy9lZGl0YWJsZU1lc3NhZ2VMb2cuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvbXVsdGlTdGVwSW5kaWNhdG9yL211bHRpU3RlcEluZGljYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9tdWx0aVN0ZXBJbmRpY2F0b3IvbXVsdGlTdGVwSW5kaWNhdG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvcmFkaW8vcmFkaW8ubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3JhZGlvL3JhZGlvR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvcmFkaW8vcmFkaW8uanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvcmF0aW5nQmFyL3JhdGluZ0Jhci5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yYXRpbmdCYXIvcmF0aW5nQmFyQmFja2dyb3VuZHMuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yYXRpbmdCYXIvcmF0aW5nQmFyQ2xhc3Muc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yZXNwb25zaXZlQ2FyZEdyaWQvcmVzcG9uc2l2ZUNhcmRHcmlkLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yZXNwb25zaXZlQ2FyZEdyaWQvcmVzcG9uc2l2ZUNhcmRHcmlkLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9icmVha3BvaW50cy9icmVha3BvaW50cy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL3dpbmRvd1dyYXBwZXIvd2luZG93V3JhcHBlci5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9icmVha3BvaW50cy92aXNpYmxlQnJlYWtwb2ludC5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9icmVha3BvaW50cy9icmVha3BvaW50cy5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3Jlc3BvbnNpdmVDYXJkR3JpZC9yZXNwb25zaXZlQ2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9yaWNoVGV4dEVkaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L25nLXdpZy9kaXN0L2Nzcy9uZy13aWcuY3NzP2JmYjQiLCJ3ZWJwYWNrOi8vLy4vfi9uZy13aWcvZGlzdC9jc3Mvbmctd2lnLmNzcyIsIndlYnBhY2s6Ly8vLi9+L25nLXdpZy9kaXN0L25nLXdpZy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9yaWNoVGV4dEVkaXRvci5jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvcmljaFRleHRFZGl0b3IvaGVhZGVyQnV0dG9uLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3JpY2hUZXh0RWRpdG9yL3BhcmFncmFwaEJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9yaWNoVGV4dEVkaXRvci5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3NpZ25hdHVyZVBhZC9zaWduYXR1cmVQYWQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvc2ltcGxlQ2FyZExpc3Qvc2ltcGxlQ2FyZExpc3QubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3NpbXBsZUNhcmRMaXN0L3NpbXBsZUNhcmQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvc2ltcGxlQ2FyZExpc3Qvc2ltcGxlQ2FyZExpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvc3Bpbm5lci9zcGlubmVyLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9ib290c3RyYXAtdG91Y2hzcGluL2luZGV4LmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9ib290c3RyYXAtdG91Y2hzcGluL2pxdWVyeS5ib290c3RyYXAtdG91Y2hzcGluLmNzcz80YzcxIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9ib290c3RyYXAtdG91Y2hzcGluL2pxdWVyeS5ib290c3RyYXAtdG91Y2hzcGluLmNzcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvYm9vdHN0cmFwLXRvdWNoc3Bpbi9qcXVlcnkuYm9vdHN0cmFwLXRvdWNoc3Bpbi5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9zdHJpbmdXaXRoV2F0ZXJtYXJrL3N0cmluZ1dpdGhXYXRlcm1hcmsuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy90eXBlYWhlYWQvdHlwZWFoZWFkLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvdXNlclJhdGluZy91c2VyUmF0aW5nLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9zZXJ2aWNlcy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2F1dG9zYXZlRGlhbG9nL2F1dG9zYXZlRGlhbG9nLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvYXV0b3NhdmVEaWFsb2cvYXV0b3NhdmVEaWFsb2cuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvZGlhbG9nL2RpYWxvZy5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9kaWFsb2cvYmFzZURpYWxvZy9iYXNlRGlhbG9nLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvZGlhbG9nL2Jhc2VEaWFsb2cvYmFzZURpYWxvZy5jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9kaWFsb2cvYmFzZURpYWxvZy9iYXNlRGlhbG9nLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2F1dG9zYXZlRGlhbG9nL2F1dG9zYXZlRGlhbG9nLmNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2NvbnRlbnRQcm92aWRlci9jb250ZW50UHJvdmlkZXIuc2VydmljZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FB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QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWlDLGdCQUFnQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBaUMsZ0JBQWdCOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsUUFBUTs7QUFFN0IsMkRBQTBELFNBQVM7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0IsaUJBQWlCO0FBQ2hEO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBb0IsZ0RBQWdEO0FBQ3BFO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFlBQVc7QUFDWDtBQUNBLDRCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLDRCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLDRCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixZQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixZQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVkseUJBQXlCLHFDQUFxQyx3QkFBd0I7QUFDbEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2YsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixnQkFBZTtBQUNmO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBVzs7QUFFWCxzQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQsUUFBUTtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSw2RUFBNkU7QUFDekY7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1oseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxnRkFBZ0Y7QUFDNUY7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLDZFQUE2RTtBQUN6RjtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1oseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSw0RkFBNEY7QUFDeEc7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLHlGQUF5RjtBQUNyRztBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIscUJBQXFCO0FBQ3hDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHO0FBQ0gsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0EsdUJBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLG9IO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXNDLE9BQU87QUFDN0MsbUNBQWtDLFdBQVcsR0FBRywwRUFBMEU7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLGFBQWE7QUFDakM7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0Esc0JBQXFCLDhCQUE4QjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFFBQU8sMkJBQTJCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxRQUFPLDJCQUEyQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrREFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksV0FBVztBQUN2QixhQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3Qix5QkFBeUIsUUFBUSxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMEUsS0FBSztBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdELEVBQUM7Ozs7Ozs7QUMxcUJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0IsK0NBQStDO0FBQ2pFLG1CQUFrQiwrQ0FBK0M7O0FBRWpFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQixpQ0FBaUM7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUEsRUFBQzs7Ozs7OztBQzlYRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDOzs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7OztBQ2hGQSxjQUFhLHVDQUF1QyxFQUFFLEk7Ozs7OztBQ0F0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLDBDOzs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0M7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDOzs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDJDOzs7Ozs7QUN6REE7QUFDQSxpQzs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEM7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRDs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxtRDs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWlELGdEQUFnRCxFQUFFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRTtBQUMxRTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0Esd0Q7Ozs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRDs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFrRSxhQUFhO0FBQy9FLGlFQUFnRSxhQUFhO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRDs7Ozs7O0FDbkdBO0FBQ0EsdUM7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RDs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQzs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7QUNwQkEsZ0VBQStELHFCQUFxQixxUEFBcVAsNENBQTRDLGFBQWEsY0FBYyxpR0FBaUcsY0FBYyx3Qjs7Ozs7O0FDQS9mO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EOzs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdEOzs7Ozs7QUNuREE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRDs7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrRDs7Ozs7O0FDM0NBLDhtQkFBNm1CLDhCQUE4QixJQUFJLDJDQUEyQyxtVzs7Ozs7O0FDQTFyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDOzs7Ozs7QUNsQkEsc0dBQXFHLDRDQUE0QyxNQUFNLG1DQUFtQyw4Qjs7Ozs7O0FDQTFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLCtCQUErQixFQUFFO0FBQ3hFLHdDQUF1Qyw2QkFBNkIsRUFBRTtBQUN0RSx3Q0FBdUMsMEJBQTBCLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7Ozs7OztBQ3pHQSw0S0FBMkssK0JBQStCLHVLQUF1SywrQkFBK0Isb0dBQW9HLFlBQVksaUdBQWlHLHNDQUFzQyxrQkFBa0IsTUFBTSxzR0FBc0csa0NBQWtDLHlKQUF5SixrQ0FBa0MscUc7Ozs7OztBQ0FsK0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsK0JBQStCLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7QUNuREEsa1E7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLDhDQUE4QyxFQUFFO0FBQ25GO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDOzs7Ozs7QUNwRUEsd0ZBQXVGLHlCQUF5Qix1bUI7Ozs7OztBQ0FoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWlFLGFBQWE7QUFDOUU7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJELHlCQUF5QixFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF3RixvQkFBb0IsRUFBRTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0M7Ozs7OztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0M7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0Esa0Q7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLHNEOzs7Ozs7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O0FBQ0E7O0FBRUE7QUFDQSwrQkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0Esb0RBQW1EOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLG1EQUFrRDs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxrREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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LGkwQjs7Ozs7O0FDQS9OO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSUFBb0ksd0JBQXdCO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEM7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRDs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxtRDs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDOzs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEM7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxrRDs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLEVBQUU7QUFDbEMsbUNBQWtDLEVBQUU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLCtDOzs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EscURBQW9ELGtDQUFrQyxFQUFFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0Esc0Q7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EIiwiZmlsZSI6ImNvbXBvbmVudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGMwNDE1NjBjOTZiNmFkYTYxN2Q5XG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0ICogYXMgYW5ndWxhciBmcm9tICdhbmd1bGFyJztcclxuXHJcbmltcG9ydCAnYW5ndWxhci11aS1ib290c3RyYXAnO1xyXG5pbXBvcnQgJ2FuZ3VsYXItc2FuaXRpemUnO1xyXG5cclxuaW1wb3J0ICcuLi9saWJyYXJpZXMvYW5ndWxhci1ib290c3RyYXAtc2xpZGVyL3NsaWRlcic7XHJcblxyXG5pbXBvcnQgJ3NpZ25hdHVyZV9wYWQnO1xyXG5cclxuaW1wb3J0ICogYXMgYmVoYXZpb3JzIGZyb20gJy4vYmVoYXZpb3JzL2JlaGF2aW9ycy5tb2R1bGUnO1xyXG5pbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4vY29tcG9uZW50cy9jb21wb25lbnRzLm1vZHVsZSc7XHJcbmltcG9ydCAqIGFzIHNlcnZpY2VzIGZyb20gJy4vc2VydmljZXMvc2VydmljZXMubW9kdWxlJztcclxuXHJcbmV4cG9ydCB7IGJlaGF2aW9ycywgY29tcG9uZW50cywgc2VydmljZXMgfTtcclxuXHJcbmV4cG9ydCB2YXIgbW9kdWxlTmFtZTogc3RyaW5nID0gJ3JsLnVpJztcclxuXHJcbmFuZ3VsYXIubW9kdWxlKG1vZHVsZU5hbWUsIFtcclxuXHQndWkuYm9vdHN0cmFwJyxcclxuXHQndWkuYm9vdHN0cmFwLXNsaWRlcicsXHJcblx0J25nU2FuaXRpemUnLFxyXG5cclxuXHRiZWhhdmlvcnMubW9kdWxlTmFtZSxcclxuXHRjb21wb25lbnRzLm1vZHVsZU5hbWUsXHJcblx0c2VydmljZXMubW9kdWxlTmFtZSxcclxuXSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc291cmNlL3VpLm1vZHVsZS50c1xuICoqLyIsIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB0aGlzW1wiYW5ndWxhclwiXTsgfSgpKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwiYW5ndWxhclwiXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi91aS1ib290c3RyYXAtdHBscycpO1xubW9kdWxlLmV4cG9ydHMgPSAndWkuYm9vdHN0cmFwJztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2FuZ3VsYXItdWktYm9vdHN0cmFwL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIGFuZ3VsYXItdWktYm9vdHN0cmFwXG4gKiBodHRwOi8vYW5ndWxhci11aS5naXRodWIuaW8vYm9vdHN0cmFwL1xuXG4gKiBWZXJzaW9uOiAwLjEzLjQgLSAyMDE1LTA5LTAzXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuYW5ndWxhci5tb2R1bGUoXCJ1aS5ib290c3RyYXBcIiwgW1widWkuYm9vdHN0cmFwLnRwbHNcIiwgXCJ1aS5ib290c3RyYXAuY29sbGFwc2VcIixcInVpLmJvb3RzdHJhcC5hY2NvcmRpb25cIixcInVpLmJvb3RzdHJhcC5hbGVydFwiLFwidWkuYm9vdHN0cmFwLmJpbmRIdG1sXCIsXCJ1aS5ib290c3RyYXAuYnV0dG9uc1wiLFwidWkuYm9vdHN0cmFwLmNhcm91c2VsXCIsXCJ1aS5ib290c3RyYXAuZGF0ZXBhcnNlclwiLFwidWkuYm9vdHN0cmFwLnBvc2l0aW9uXCIsXCJ1aS5ib290c3RyYXAuZGF0ZXBpY2tlclwiLFwidWkuYm9vdHN0cmFwLmRyb3Bkb3duXCIsXCJ1aS5ib290c3RyYXAubW9kYWxcIixcInVpLmJvb3RzdHJhcC5wYWdpbmF0aW9uXCIsXCJ1aS5ib290c3RyYXAudG9vbHRpcFwiLFwidWkuYm9vdHN0cmFwLnBvcG92ZXJcIixcInVpLmJvb3RzdHJhcC5wcm9ncmVzc2JhclwiLFwidWkuYm9vdHN0cmFwLnJhdGluZ1wiLFwidWkuYm9vdHN0cmFwLnRhYnNcIixcInVpLmJvb3RzdHJhcC50aW1lcGlja2VyXCIsXCJ1aS5ib290c3RyYXAudHJhbnNpdGlvblwiLFwidWkuYm9vdHN0cmFwLnR5cGVhaGVhZFwiXSk7XG5hbmd1bGFyLm1vZHVsZShcInVpLmJvb3RzdHJhcC50cGxzXCIsIFtcInRlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbFwiLFwidGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sXCIsXCJ0ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sXCIsXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXCIsXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sXCIsXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFwiLFwidGVtcGxhdGUvZGF0ZXBpY2tlci9kYXkuaHRtbFwiLFwidGVtcGxhdGUvZGF0ZXBpY2tlci9tb250aC5odG1sXCIsXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL3BvcHVwLmh0bWxcIixcInRlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sXCIsXCJ0ZW1wbGF0ZS9tb2RhbC9iYWNrZHJvcC5odG1sXCIsXCJ0ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbFwiLFwidGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdlci5odG1sXCIsXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbFwiLFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtcG9wdXAuaHRtbFwiLFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtdW5zYWZlLXBvcHVwLmh0bWxcIixcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1wb3B1cC5odG1sXCIsXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtdGVtcGxhdGUtcG9wdXAuaHRtbFwiLFwidGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLWh0bWwuaHRtbFwiLFwidGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLXRlbXBsYXRlLmh0bWxcIixcInRlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sXCIsXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbFwiLFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbFwiLFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuaHRtbFwiLFwidGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sXCIsXCJ0ZW1wbGF0ZS90YWJzL3RhYi5odG1sXCIsXCJ0ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sXCIsXCJ0ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbFwiLFwidGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1tYXRjaC5odG1sXCIsXCJ0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLXBvcHVwLmh0bWxcIl0pO1xuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5jb2xsYXBzZScsIFtdKVxuXG4gIC5kaXJlY3RpdmUoJ2NvbGxhcHNlJywgWyckYW5pbWF0ZScsIGZ1bmN0aW9uKCRhbmltYXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICBmdW5jdGlvbiBleHBhbmQoKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnY29sbGFwc2UnKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKTtcblxuICAgICAgICAgICRhbmltYXRlLmFkZENsYXNzKGVsZW1lbnQsICdpbicsIHtcbiAgICAgICAgICAgIHRvOiB7IGhlaWdodDogZWxlbWVudFswXS5zY3JvbGxIZWlnaHQgKyAncHgnIH1cbiAgICAgICAgICB9KS50aGVuKGV4cGFuZERvbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZXhwYW5kRG9uZSgpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCdjb2xsYXBzaW5nJyk7XG4gICAgICAgICAgZWxlbWVudC5jc3Moe2hlaWdodDogJ2F1dG8nfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb2xsYXBzZSgpIHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQ2xhc3MoJ2NvbGxhcHNlJykgJiYgIWVsZW1lbnQuaGFzQ2xhc3MoJ2luJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsYXBzZURvbmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IFRoZSBoZWlnaHQgbXVzdCBiZSBzZXQgYmVmb3JlIGFkZGluZyBcImNvbGxhcHNpbmdcIiBjbGFzcy5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIGJyb3dzZXIgYXR0ZW1wdHMgdG8gYW5pbWF0ZSBmcm9tIGhlaWdodCAwIChpblxuICAgICAgICAgICAgLy8gY29sbGFwc2luZyBjbGFzcykgdG8gdGhlIGdpdmVuIGhlaWdodCBoZXJlLlxuICAgICAgICAgICAgLmNzcyh7aGVpZ2h0OiBlbGVtZW50WzBdLnNjcm9sbEhlaWdodCArICdweCd9KVxuICAgICAgICAgICAgLy8gaW5pdGlhbGx5IGFsbCBwYW5lbCBjb2xsYXBzZSBoYXZlIHRoZSBjb2xsYXBzZSBjbGFzcywgdGhpcyByZW1vdmFsXG4gICAgICAgICAgICAvLyBwcmV2ZW50cyB0aGUgYW5pbWF0aW9uIGZyb20ganVtcGluZyB0byBjb2xsYXBzZWQgc3RhdGVcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2UnKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcblxuICAgICAgICAgICRhbmltYXRlLnJlbW92ZUNsYXNzKGVsZW1lbnQsICdpbicsIHtcbiAgICAgICAgICAgIHRvOiB7aGVpZ2h0OiAnMCd9XG4gICAgICAgICAgfSkudGhlbihjb2xsYXBzZURvbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29sbGFwc2VEb25lKCkge1xuICAgICAgICAgIGVsZW1lbnQuY3NzKHtoZWlnaHQ6ICcwJ30pOyAvLyBSZXF1aXJlZCBzbyB0aGF0IGNvbGxhcHNlIHdvcmtzIHdoZW4gYW5pbWF0aW9uIGlzIGRpc2FibGVkXG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnY29sbGFwc2luZycpO1xuICAgICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2NvbGxhcHNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzY29wZS4kd2F0Y2goYXR0cnMuY29sbGFwc2UsIGZ1bmN0aW9uKHNob3VsZENvbGxhcHNlKSB7XG4gICAgICAgICAgaWYgKHNob3VsZENvbGxhcHNlKSB7XG4gICAgICAgICAgICBjb2xsYXBzZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHBhbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1dKTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5hY2NvcmRpb24nLCBbJ3VpLmJvb3RzdHJhcC5jb2xsYXBzZSddKVxuXG4uY29uc3RhbnQoJ2FjY29yZGlvbkNvbmZpZycsIHtcbiAgY2xvc2VPdGhlcnM6IHRydWVcbn0pXG5cbi5jb250cm9sbGVyKCdBY2NvcmRpb25Db250cm9sbGVyJywgWyckc2NvcGUnLCAnJGF0dHJzJywgJ2FjY29yZGlvbkNvbmZpZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCBhY2NvcmRpb25Db25maWcpIHtcbiAgLy8gVGhpcyBhcnJheSBrZWVwcyB0cmFjayBvZiB0aGUgYWNjb3JkaW9uIGdyb3Vwc1xuICB0aGlzLmdyb3VwcyA9IFtdO1xuXG4gIC8vIEVuc3VyZSB0aGF0IGFsbCB0aGUgZ3JvdXBzIGluIHRoaXMgYWNjb3JkaW9uIGFyZSBjbG9zZWQsIHVubGVzcyBjbG9zZS1vdGhlcnMgZXhwbGljaXRseSBzYXlzIG5vdCB0b1xuICB0aGlzLmNsb3NlT3RoZXJzID0gZnVuY3Rpb24ob3Blbkdyb3VwKSB7XG4gICAgdmFyIGNsb3NlT3RoZXJzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmNsb3NlT3RoZXJzKSA/XG4gICAgICAkc2NvcGUuJGV2YWwoJGF0dHJzLmNsb3NlT3RoZXJzKSA6IGFjY29yZGlvbkNvbmZpZy5jbG9zZU90aGVycztcbiAgICBpZiAoY2xvc2VPdGhlcnMpIHtcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaCh0aGlzLmdyb3VwcywgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgaWYgKGdyb3VwICE9PSBvcGVuR3JvdXApIHtcbiAgICAgICAgICBncm91cC5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoaXMgaXMgY2FsbGVkIGZyb20gdGhlIGFjY29yZGlvbi1ncm91cCBkaXJlY3RpdmUgdG8gYWRkIGl0c2VsZiB0byB0aGUgYWNjb3JkaW9uXG4gIHRoaXMuYWRkR3JvdXAgPSBmdW5jdGlvbihncm91cFNjb3BlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMuZ3JvdXBzLnB1c2goZ3JvdXBTY29wZSk7XG5cbiAgICBncm91cFNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdGhhdC5yZW1vdmVHcm91cChncm91cFNjb3BlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIGNhbGxlZCBmcm9tIHRoZSBhY2NvcmRpb24tZ3JvdXAgZGlyZWN0aXZlIHdoZW4gdG8gcmVtb3ZlIGl0c2VsZlxuICB0aGlzLnJlbW92ZUdyb3VwID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmdyb3Vwcy5pbmRleE9mKGdyb3VwKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLmdyb3Vwcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfTtcblxufV0pXG5cbi8vIFRoZSBhY2NvcmRpb24gZGlyZWN0aXZlIHNpbXBseSBzZXRzIHVwIHRoZSBkaXJlY3RpdmUgY29udHJvbGxlclxuLy8gYW5kIGFkZHMgYW4gYWNjb3JkaW9uIENTUyBjbGFzcyB0byBpdHNlbGYgZWxlbWVudC5cbi5kaXJlY3RpdmUoJ2FjY29yZGlvbicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIGNvbnRyb2xsZXI6ICdBY2NvcmRpb25Db250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdhY2NvcmRpb24nLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgcmVwbGFjZTogZmFsc2UsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24uaHRtbCc7XG4gICAgfVxuICB9O1xufSlcblxuLy8gVGhlIGFjY29yZGlvbi1ncm91cCBkaXJlY3RpdmUgaW5kaWNhdGVzIGEgYmxvY2sgb2YgaHRtbCB0aGF0IHdpbGwgZXhwYW5kIGFuZCBjb2xsYXBzZSBpbiBhbiBhY2NvcmRpb25cbi5kaXJlY3RpdmUoJ2FjY29yZGlvbkdyb3VwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogJ15hY2NvcmRpb24nLCAgICAgICAgIC8vIFdlIG5lZWQgdGhpcyBkaXJlY3RpdmUgdG8gYmUgaW5zaWRlIGFuIGFjY29yZGlvblxuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsICAgICAgICAgICAgICAvLyBJdCB0cmFuc2NsdWRlcyB0aGUgY29udGVudHMgb2YgdGhlIGRpcmVjdGl2ZSBpbnRvIHRoZSB0ZW1wbGF0ZVxuICAgIHJlcGxhY2U6IHRydWUsICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGRpcmVjdGl2ZSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIHRlbXBsYXRlXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbCc7XG4gICAgfSxcbiAgICBzY29wZToge1xuICAgICAgaGVhZGluZzogJ0AnLCAgICAgICAgICAgICAgIC8vIEludGVycG9sYXRlIHRoZSBoZWFkaW5nIGF0dHJpYnV0ZSBvbnRvIHRoaXMgc2NvcGVcbiAgICAgIGlzT3BlbjogJz0/JyxcbiAgICAgIGlzRGlzYWJsZWQ6ICc9PydcbiAgICB9LFxuICAgIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRIZWFkaW5nID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB0aGlzLmhlYWRpbmcgPSBlbGVtZW50O1xuICAgICAgfTtcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgYWNjb3JkaW9uQ3RybCkge1xuICAgICAgYWNjb3JkaW9uQ3RybC5hZGRHcm91cChzY29wZSk7XG5cbiAgICAgIHNjb3BlLm9wZW5DbGFzcyA9IGF0dHJzLm9wZW5DbGFzcyB8fCAncGFuZWwtb3Blbic7XG4gICAgICBzY29wZS5wYW5lbENsYXNzID0gYXR0cnMucGFuZWxDbGFzcztcbiAgICAgIHNjb3BlLiR3YXRjaCgnaXNPcGVuJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgZWxlbWVudC50b2dnbGVDbGFzcyhzY29wZS5vcGVuQ2xhc3MsIHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgYWNjb3JkaW9uQ3RybC5jbG9zZU90aGVycyhzY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS50b2dnbGVPcGVuID0gZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIGlmICghc2NvcGUuaXNEaXNhYmxlZCkge1xuICAgICAgICAgIGlmICghJGV2ZW50IHx8ICRldmVudC53aGljaCA9PT0gMzIpIHtcbiAgICAgICAgICAgIHNjb3BlLmlzT3BlbiA9ICFzY29wZS5pc09wZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn0pXG5cbi8vIFVzZSBhY2NvcmRpb24taGVhZGluZyBiZWxvdyBhbiBhY2NvcmRpb24tZ3JvdXAgdG8gcHJvdmlkZSBhIGhlYWRpbmcgY29udGFpbmluZyBIVE1MXG4vLyA8YWNjb3JkaW9uLWdyb3VwPlxuLy8gICA8YWNjb3JkaW9uLWhlYWRpbmc+SGVhZGluZyBjb250YWluaW5nIEhUTUwgLSA8aW1nIHNyYz1cIi4uLlwiPjwvYWNjb3JkaW9uLWhlYWRpbmc+XG4vLyA8L2FjY29yZGlvbi1ncm91cD5cbi5kaXJlY3RpdmUoJ2FjY29yZGlvbkhlYWRpbmcnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLCAgIC8vIEdyYWIgdGhlIGNvbnRlbnRzIHRvIGJlIHVzZWQgYXMgdGhlIGhlYWRpbmdcbiAgICB0ZW1wbGF0ZTogJycsICAgICAgIC8vIEluIGVmZmVjdCByZW1vdmUgdGhpcyBlbGVtZW50IVxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgcmVxdWlyZTogJ15hY2NvcmRpb25Hcm91cCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGFjY29yZGlvbkdyb3VwQ3RybCwgdHJhbnNjbHVkZSkge1xuICAgICAgLy8gUGFzcyB0aGUgaGVhZGluZyB0byB0aGUgYWNjb3JkaW9uLWdyb3VwIGNvbnRyb2xsZXJcbiAgICAgIC8vIHNvIHRoYXQgaXQgY2FuIGJlIHRyYW5zY2x1ZGVkIGludG8gdGhlIHJpZ2h0IHBsYWNlIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgLy8gW1RoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIHRyYW5zY2x1ZGUgY2F1c2VzIHRoZSBlbGVtZW50cyB0byBiZSBjbG9uZWQgc28gdGhhdCB0aGV5IHdvcmsgaW4gbmctcmVwZWF0XVxuICAgICAgYWNjb3JkaW9uR3JvdXBDdHJsLnNldEhlYWRpbmcodHJhbnNjbHVkZShzY29wZSwgYW5ndWxhci5ub29wKSk7XG4gICAgfVxuICB9O1xufSlcblxuLy8gVXNlIGluIHRoZSBhY2NvcmRpb24tZ3JvdXAgdGVtcGxhdGUgdG8gaW5kaWNhdGUgd2hlcmUgeW91IHdhbnQgdGhlIGhlYWRpbmcgdG8gYmUgdHJhbnNjbHVkZWRcbi8vIFlvdSBtdXN0IHByb3ZpZGUgdGhlIHByb3BlcnR5IG9uIHRoZSBhY2NvcmRpb24tZ3JvdXAgY29udHJvbGxlciB0aGF0IHdpbGwgaG9sZCB0aGUgdHJhbnNjbHVkZWQgZWxlbWVudFxuLy8gPGRpdiBjbGFzcz1cImFjY29yZGlvbi1ncm91cFwiPlxuLy8gICA8ZGl2IGNsYXNzPVwiYWNjb3JkaW9uLWhlYWRpbmdcIiA+PGEgLi4uIGFjY29yZGlvbi10cmFuc2NsdWRlPVwiaGVhZGluZ1wiPi4uLjwvYT48L2Rpdj5cbi8vICAgLi4uXG4vLyA8L2Rpdj5cbi5kaXJlY3RpdmUoJ2FjY29yZGlvblRyYW5zY2x1ZGUnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiAnXmFjY29yZGlvbkdyb3VwJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0ciwgY29udHJvbGxlcikge1xuICAgICAgc2NvcGUuJHdhdGNoKGZ1bmN0aW9uKCkgeyByZXR1cm4gY29udHJvbGxlclthdHRyLmFjY29yZGlvblRyYW5zY2x1ZGVdOyB9LCBmdW5jdGlvbihoZWFkaW5nKSB7XG4gICAgICAgIGlmIChoZWFkaW5nKSB7XG4gICAgICAgICAgZWxlbWVudC5maW5kKCdzcGFuJykuaHRtbCgnJyk7XG4gICAgICAgICAgZWxlbWVudC5maW5kKCdzcGFuJykuYXBwZW5kKGhlYWRpbmcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KVxuXG47XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuYWxlcnQnLCBbXSlcblxuLmNvbnRyb2xsZXIoJ0FsZXJ0Q29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzKSB7XG4gICRzY29wZS5jbG9zZWFibGUgPSAhISRhdHRycy5jbG9zZTtcbiAgdGhpcy5jbG9zZSA9ICRzY29wZS5jbG9zZTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdhbGVydCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGNvbnRyb2xsZXI6ICdBbGVydENvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ2FsZXJ0JyxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbCc7XG4gICAgfSxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgc2NvcGU6IHtcbiAgICAgIHR5cGU6ICdAJyxcbiAgICAgIGNsb3NlOiAnJidcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCdkaXNtaXNzT25UaW1lb3V0JywgWyckdGltZW91dCcsIGZ1bmN0aW9uKCR0aW1lb3V0KSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogJ2FsZXJ0JyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGFsZXJ0Q3RybCkge1xuICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGFsZXJ0Q3RybC5jbG9zZSgpO1xuICAgICAgfSwgcGFyc2VJbnQoYXR0cnMuZGlzbWlzc09uVGltZW91dCwgMTApKTtcbiAgICB9XG4gIH07XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuYmluZEh0bWwnLCBbXSlcblxuICAudmFsdWUoJyRiaW5kSHRtbFVuc2FmZVN1cHByZXNzRGVwcmVjYXRlZCcsIGZhbHNlKVxuXG4gIC5kaXJlY3RpdmUoJ2JpbmRIdG1sVW5zYWZlJywgWyckbG9nJywgJyRiaW5kSHRtbFVuc2FmZVN1cHByZXNzRGVwcmVjYXRlZCcsIGZ1bmN0aW9uICgkbG9nLCAkYmluZEh0bWxVbnNhZmVTdXBwcmVzc0RlcHJlY2F0ZWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XG4gICAgICBpZiAoISRiaW5kSHRtbFVuc2FmZVN1cHByZXNzRGVwcmVjYXRlZCkge1xuICAgICAgICAkbG9nLndhcm4oJ2JpbmRIdG1sVW5zYWZlIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgbmdCaW5kSHRtbCBpbnN0ZWFkJyk7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFkZENsYXNzKCduZy1iaW5kaW5nJykuZGF0YSgnJGJpbmRpbmcnLCBhdHRyLmJpbmRIdG1sVW5zYWZlKTtcbiAgICAgIHNjb3BlLiR3YXRjaChhdHRyLmJpbmRIdG1sVW5zYWZlLCBmdW5jdGlvbiBiaW5kSHRtbFVuc2FmZVdhdGNoQWN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGVsZW1lbnQuaHRtbCh2YWx1ZSB8fCAnJyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XSk7XG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmJ1dHRvbnMnLCBbXSlcblxuLmNvbnN0YW50KCdidXR0b25Db25maWcnLCB7XG4gIGFjdGl2ZUNsYXNzOiAnYWN0aXZlJyxcbiAgdG9nZ2xlRXZlbnQ6ICdjbGljaydcbn0pXG5cbi5jb250cm9sbGVyKCdCdXR0b25zQ29udHJvbGxlcicsIFsnYnV0dG9uQ29uZmlnJywgZnVuY3Rpb24oYnV0dG9uQ29uZmlnKSB7XG4gIHRoaXMuYWN0aXZlQ2xhc3MgPSBidXR0b25Db25maWcuYWN0aXZlQ2xhc3MgfHwgJ2FjdGl2ZSc7XG4gIHRoaXMudG9nZ2xlRXZlbnQgPSBidXR0b25Db25maWcudG9nZ2xlRXZlbnQgfHwgJ2NsaWNrJztcbn1dKVxuXG4uZGlyZWN0aXZlKCdidG5SYWRpbycsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6IFsnYnRuUmFkaW8nLCAnbmdNb2RlbCddLFxuICAgIGNvbnRyb2xsZXI6ICdCdXR0b25zQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAnYnV0dG9ucycsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgdmFyIGJ1dHRvbnNDdHJsID0gY3RybHNbMF0sIG5nTW9kZWxDdHJsID0gY3RybHNbMV07XG5cbiAgICAgIGVsZW1lbnQuZmluZCgnaW5wdXQnKS5jc3Moe2Rpc3BsYXk6ICdub25lJ30pO1xuXG4gICAgICAvL21vZGVsIC0+IFVJXG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MsIGFuZ3VsYXIuZXF1YWxzKG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlLCBzY29wZS4kZXZhbChhdHRycy5idG5SYWRpbykpKTtcbiAgICAgIH07XG5cbiAgICAgIC8vdWktPm1vZGVsXG4gICAgICBlbGVtZW50LmJpbmQoYnV0dG9uc0N0cmwudG9nZ2xlRXZlbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoYXR0cnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNBY3RpdmUgPSBlbGVtZW50Lmhhc0NsYXNzKGJ1dHRvbnNDdHJsLmFjdGl2ZUNsYXNzKTtcblxuICAgICAgICBpZiAoIWlzQWN0aXZlIHx8IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnVuY2hlY2thYmxlKSkge1xuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoaXNBY3RpdmUgPyBudWxsIDogc2NvcGUuJGV2YWwoYXR0cnMuYnRuUmFkaW8pKTtcbiAgICAgICAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgnYnRuQ2hlY2tib3gnLCBbJyRkb2N1bWVudCcsIGZ1bmN0aW9uKCRkb2N1bWVudCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6IFsnYnRuQ2hlY2tib3gnLCAnbmdNb2RlbCddLFxuICAgIGNvbnRyb2xsZXI6ICdCdXR0b25zQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAnYnV0dG9uJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgYnV0dG9uc0N0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgZWxlbWVudC5maW5kKCdpbnB1dCcpLmNzcyh7ZGlzcGxheTogJ25vbmUnfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFRydWVWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGdldENoZWNrYm94VmFsdWUoYXR0cnMuYnRuQ2hlY2tib3hUcnVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0RmFsc2VWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGdldENoZWNrYm94VmFsdWUoYXR0cnMuYnRuQ2hlY2tib3hGYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRDaGVja2JveFZhbHVlKGF0dHJpYnV0ZVZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdmFyIHZhbCA9IHNjb3BlLiRldmFsKGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFuZ3VsYXIuaXNEZWZpbmVkKHZhbCkgPyB2YWwgOiBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8vbW9kZWwgLT4gVUlcbiAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZWxlbWVudC50b2dnbGVDbGFzcyhidXR0b25zQ3RybC5hY3RpdmVDbGFzcywgYW5ndWxhci5lcXVhbHMobmdNb2RlbEN0cmwuJG1vZGVsVmFsdWUsIGdldFRydWVWYWx1ZSgpKSk7XG4gICAgICB9O1xuXG4gICAgICAvL3VpLT5tb2RlbFxuICAgICAgZWxlbWVudC5iaW5kKGJ1dHRvbnNDdHJsLnRvZ2dsZUV2ZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGF0dHJzLmRpc2FibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoZWxlbWVudC5oYXNDbGFzcyhidXR0b25zQ3RybC5hY3RpdmVDbGFzcykgPyBnZXRGYWxzZVZhbHVlKCkgOiBnZXRUcnVlVmFsdWUoKSk7XG4gICAgICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvL2FjY2Vzc2liaWxpdHlcbiAgICAgIGVsZW1lbnQub24oJ2tleXByZXNzJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoYXR0cnMuZGlzYWJsZWQgfHwgZS53aGljaCAhPT0gMzIgfHwgJGRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQgIT09IGVsZW1lbnRbMF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShlbGVtZW50Lmhhc0NsYXNzKGJ1dHRvbnNDdHJsLmFjdGl2ZUNsYXNzKSA/IGdldEZhbHNlVmFsdWUoKSA6IGdldFRydWVWYWx1ZSgpKTtcbiAgICAgICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufV0pO1xuXG4vKipcbiogQG5nZG9jIG92ZXJ2aWV3XG4qIEBuYW1lIHVpLmJvb3RzdHJhcC5jYXJvdXNlbFxuKlxuKiBAZGVzY3JpcHRpb25cbiogQW5ndWxhckpTIHZlcnNpb24gb2YgYW4gaW1hZ2UgY2Fyb3VzZWwuXG4qXG4qL1xuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5jYXJvdXNlbCcsIFtdKVxuLmNvbnRyb2xsZXIoJ0Nhcm91c2VsQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRpbnRlcnZhbCcsICckYW5pbWF0ZScsIGZ1bmN0aW9uICgkc2NvcGUsICRlbGVtZW50LCAkaW50ZXJ2YWwsICRhbmltYXRlKSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICBzbGlkZXMgPSBzZWxmLnNsaWRlcyA9ICRzY29wZS5zbGlkZXMgPSBbXSxcbiAgICBORVdfQU5JTUFURSA9IGFuZ3VsYXIudmVyc2lvbi5taW5vciA+PSA0LFxuICAgIE5PX1RSQU5TSVRJT04gPSAndWliLW5vVHJhbnNpdGlvbicsXG4gICAgU0xJREVfRElSRUNUSU9OID0gJ3VpYi1zbGlkZURpcmVjdGlvbicsXG4gICAgY3VycmVudEluZGV4ID0gLTEsXG4gICAgY3VycmVudEludGVydmFsLCBpc1BsYXlpbmc7XG4gIHNlbGYuY3VycmVudFNsaWRlID0gbnVsbDtcblxuICB2YXIgZGVzdHJveWVkID0gZmFsc2U7XG4gIC8qIGRpcmVjdGlvbjogXCJwcmV2XCIgb3IgXCJuZXh0XCIgKi9cbiAgc2VsZi5zZWxlY3QgPSAkc2NvcGUuc2VsZWN0ID0gZnVuY3Rpb24obmV4dFNsaWRlLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gJHNjb3BlLmluZGV4T2ZTbGlkZShuZXh0U2xpZGUpO1xuICAgIC8vRGVjaWRlIGRpcmVjdGlvbiBpZiBpdCdzIG5vdCBnaXZlblxuICAgIGlmIChkaXJlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGlyZWN0aW9uID0gbmV4dEluZGV4ID4gc2VsZi5nZXRDdXJyZW50SW5kZXgoKSA/ICduZXh0JyA6ICdwcmV2JztcbiAgICB9XG4gICAgLy9QcmV2ZW50IHRoaXMgdXNlci10cmlnZ2VyZWQgdHJhbnNpdGlvbiBmcm9tIG9jY3VycmluZyBpZiB0aGVyZSBpcyBhbHJlYWR5IG9uZSBpbiBwcm9ncmVzc1xuICAgIGlmIChuZXh0U2xpZGUgJiYgbmV4dFNsaWRlICE9PSBzZWxmLmN1cnJlbnRTbGlkZSAmJiAhJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbikge1xuICAgICAgZ29OZXh0KG5leHRTbGlkZSwgbmV4dEluZGV4LCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnb05leHQoc2xpZGUsIGluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICAvLyBTY29wZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHN0b3AgaGVyZS5cbiAgICBpZiAoZGVzdHJveWVkKSB7IHJldHVybjsgfVxuXG4gICAgYW5ndWxhci5leHRlbmQoc2xpZGUsIHtkaXJlY3Rpb246IGRpcmVjdGlvbiwgYWN0aXZlOiB0cnVlfSk7XG4gICAgYW5ndWxhci5leHRlbmQoc2VsZi5jdXJyZW50U2xpZGUgfHwge30sIHtkaXJlY3Rpb246IGRpcmVjdGlvbiwgYWN0aXZlOiBmYWxzZX0pO1xuICAgIGlmICgkYW5pbWF0ZS5lbmFibGVkKCkgJiYgISRzY29wZS5ub1RyYW5zaXRpb24gJiYgISRzY29wZS4kY3VycmVudFRyYW5zaXRpb24gJiZcbiAgICAgIHNsaWRlLiRlbGVtZW50ICYmIHNlbGYuc2xpZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNsaWRlLiRlbGVtZW50LmRhdGEoU0xJREVfRElSRUNUSU9OLCBzbGlkZS5kaXJlY3Rpb24pO1xuICAgICAgaWYgKHNlbGYuY3VycmVudFNsaWRlICYmIHNlbGYuY3VycmVudFNsaWRlLiRlbGVtZW50KSB7XG4gICAgICAgIHNlbGYuY3VycmVudFNsaWRlLiRlbGVtZW50LmRhdGEoU0xJREVfRElSRUNUSU9OLCBzbGlkZS5kaXJlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICAkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgIGlmIChORVdfQU5JTUFURSkge1xuICAgICAgICAkYW5pbWF0ZS5vbignYWRkQ2xhc3MnLCBzbGlkZS4kZWxlbWVudCwgZnVuY3Rpb24gKGVsZW1lbnQsIHBoYXNlKSB7XG4gICAgICAgICAgaWYgKHBoYXNlID09PSAnY2xvc2UnKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICRhbmltYXRlLm9mZignYWRkQ2xhc3MnLCBlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xpZGUuJGVsZW1lbnQub25lKCckYW5pbWF0ZTpjbG9zZScsIGZ1bmN0aW9uIGNsb3NlRm4oKSB7XG4gICAgICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYuY3VycmVudFNsaWRlID0gc2xpZGU7XG4gICAgY3VycmVudEluZGV4ID0gaW5kZXg7XG5cbiAgICAvL2V2ZXJ5IHRpbWUgeW91IGNoYW5nZSBzbGlkZXMsIHJlc2V0IHRoZSB0aW1lclxuICAgIHJlc3RhcnRUaW1lcigpO1xuICB9XG5cbiAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZ2V0U2xpZGVCeUluZGV4KGluZGV4KSB7XG4gICAgaWYgKGFuZ3VsYXIuaXNVbmRlZmluZWQoc2xpZGVzW2luZGV4XS5pbmRleCkpIHtcbiAgICAgIHJldHVybiBzbGlkZXNbaW5kZXhdO1xuICAgIH1cbiAgICB2YXIgaSwgbGVuID0gc2xpZGVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoc2xpZGVzW2ldLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzbGlkZXNbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2VsZi5nZXRDdXJyZW50SW5kZXggPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5jdXJyZW50U2xpZGUgJiYgYW5ndWxhci5pc0RlZmluZWQoc2VsZi5jdXJyZW50U2xpZGUuaW5kZXgpKSB7XG4gICAgICByZXR1cm4gK3NlbGYuY3VycmVudFNsaWRlLmluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudEluZGV4O1xuICB9O1xuXG4gIC8qIEFsbG93IG91dHNpZGUgcGVvcGxlIHRvIGNhbGwgaW5kZXhPZiBvbiBzbGlkZXMgYXJyYXkgKi9cbiAgJHNjb3BlLmluZGV4T2ZTbGlkZSA9IGZ1bmN0aW9uKHNsaWRlKSB7XG4gICAgcmV0dXJuIGFuZ3VsYXIuaXNEZWZpbmVkKHNsaWRlLmluZGV4KSA/ICtzbGlkZS5pbmRleCA6IHNsaWRlcy5pbmRleE9mKHNsaWRlKTtcbiAgfTtcblxuICAkc2NvcGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuZXdJbmRleCA9IChzZWxmLmdldEN1cnJlbnRJbmRleCgpICsgMSkgJSBzbGlkZXMubGVuZ3RoO1xuXG4gICAgaWYgKG5ld0luZGV4ID09PSAwICYmICRzY29wZS5ub1dyYXAoKSkge1xuICAgICAgJHNjb3BlLnBhdXNlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGYuc2VsZWN0KGdldFNsaWRlQnlJbmRleChuZXdJbmRleCksICduZXh0Jyk7XG4gIH07XG5cbiAgJHNjb3BlLnByZXYgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmV3SW5kZXggPSBzZWxmLmdldEN1cnJlbnRJbmRleCgpIC0gMSA8IDAgPyBzbGlkZXMubGVuZ3RoIC0gMSA6IHNlbGYuZ2V0Q3VycmVudEluZGV4KCkgLSAxO1xuXG4gICAgaWYgKCRzY29wZS5ub1dyYXAoKSAmJiBuZXdJbmRleCA9PT0gc2xpZGVzLmxlbmd0aCAtIDEpe1xuICAgICAgJHNjb3BlLnBhdXNlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGYuc2VsZWN0KGdldFNsaWRlQnlJbmRleChuZXdJbmRleCksICdwcmV2Jyk7XG4gIH07XG5cbiAgJHNjb3BlLmlzQWN0aXZlID0gZnVuY3Rpb24oc2xpZGUpIHtcbiAgICAgcmV0dXJuIHNlbGYuY3VycmVudFNsaWRlID09PSBzbGlkZTtcbiAgfTtcblxuICAkc2NvcGUuJHdhdGNoKCdpbnRlcnZhbCcsIHJlc3RhcnRUaW1lcik7XG4gICRzY29wZS4kb24oJyRkZXN0cm95JywgcmVzZXRUaW1lcik7XG5cbiAgZnVuY3Rpb24gcmVzdGFydFRpbWVyKCkge1xuICAgIHJlc2V0VGltZXIoKTtcbiAgICB2YXIgaW50ZXJ2YWwgPSArJHNjb3BlLmludGVydmFsO1xuICAgIGlmICghaXNOYU4oaW50ZXJ2YWwpICYmIGludGVydmFsID4gMCkge1xuICAgICAgY3VycmVudEludGVydmFsID0gJGludGVydmFsKHRpbWVyRm4sIGludGVydmFsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRpbWVyKCkge1xuICAgIGlmIChjdXJyZW50SW50ZXJ2YWwpIHtcbiAgICAgICRpbnRlcnZhbC5jYW5jZWwoY3VycmVudEludGVydmFsKTtcbiAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJGbigpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSArJHNjb3BlLmludGVydmFsO1xuICAgIGlmIChpc1BsYXlpbmcgJiYgIWlzTmFOKGludGVydmFsKSAmJiBpbnRlcnZhbCA+IDAgJiYgc2xpZGVzLmxlbmd0aCkge1xuICAgICAgJHNjb3BlLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgJHNjb3BlLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWlzUGxheWluZykge1xuICAgICAgaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgIHJlc3RhcnRUaW1lcigpO1xuICAgIH1cbiAgfTtcbiAgJHNjb3BlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUubm9QYXVzZSkge1xuICAgICAgaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICByZXNldFRpbWVyKCk7XG4gICAgfVxuICB9O1xuXG4gIHNlbGYuYWRkU2xpZGUgPSBmdW5jdGlvbihzbGlkZSwgZWxlbWVudCkge1xuICAgIHNsaWRlLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICBzbGlkZXMucHVzaChzbGlkZSk7XG4gICAgLy9pZiB0aGlzIGlzIHRoZSBmaXJzdCBzbGlkZSBvciB0aGUgc2xpZGUgaXMgc2V0IHRvIGFjdGl2ZSwgc2VsZWN0IGl0XG4gICAgaWYoc2xpZGVzLmxlbmd0aCA9PT0gMSB8fCBzbGlkZS5hY3RpdmUpIHtcbiAgICAgIHNlbGYuc2VsZWN0KHNsaWRlc1tzbGlkZXMubGVuZ3RoLTFdKTtcbiAgICAgIGlmIChzbGlkZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgJHNjb3BlLnBsYXkoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2xpZGUuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHNlbGYucmVtb3ZlU2xpZGUgPSBmdW5jdGlvbihzbGlkZSkge1xuICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChzbGlkZS5pbmRleCkpIHtcbiAgICAgIHNsaWRlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICthLmluZGV4ID4gK2IuaW5kZXg7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy9nZXQgdGhlIGluZGV4IG9mIHRoZSBzbGlkZSBpbnNpZGUgdGhlIGNhcm91c2VsXG4gICAgdmFyIGluZGV4ID0gc2xpZGVzLmluZGV4T2Yoc2xpZGUpO1xuICAgIHNsaWRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGlmIChzbGlkZXMubGVuZ3RoID4gMCAmJiBzbGlkZS5hY3RpdmUpIHtcbiAgICAgIGlmIChpbmRleCA+PSBzbGlkZXMubGVuZ3RoKSB7XG4gICAgICAgIHNlbGYuc2VsZWN0KHNsaWRlc1tpbmRleC0xXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNlbGVjdChzbGlkZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRJbmRleCA+IGluZGV4KSB7XG4gICAgICBjdXJyZW50SW5kZXgtLTtcbiAgICB9XG4gICAgXG4gICAgLy9jbGVhbiB0aGUgY3VycmVudFNsaWRlIHdoZW4gbm8gbW9yZSBzbGlkZVxuICAgIGlmIChzbGlkZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZWxmLmN1cnJlbnRTbGlkZSA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS4kd2F0Y2goJ25vVHJhbnNpdGlvbicsIGZ1bmN0aW9uKG5vVHJhbnNpdGlvbikge1xuICAgICRlbGVtZW50LmRhdGEoTk9fVFJBTlNJVElPTiwgbm9UcmFuc2l0aW9uKTtcbiAgfSk7XG5cbn1dKVxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHVpLmJvb3RzdHJhcC5jYXJvdXNlbC5kaXJlY3RpdmU6Y2Fyb3VzZWxcbiAqIEByZXN0cmljdCBFQVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ2Fyb3VzZWwgaXMgdGhlIG91dGVyIGNvbnRhaW5lciBmb3IgYSBzZXQgb2YgaW1hZ2UgJ3NsaWRlcycgdG8gc2hvd2Nhc2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXI9fSBpbnRlcnZhbCBUaGUgdGltZSwgaW4gbWlsbGlzZWNvbmRzLCB0aGF0IGl0IHdpbGwgdGFrZSB0aGUgY2Fyb3VzZWwgdG8gZ28gdG8gdGhlIG5leHQgc2xpZGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBub1RyYW5zaXRpb24gV2hldGhlciB0byBkaXNhYmxlIHRyYW5zaXRpb25zIG9uIHRoZSBjYXJvdXNlbC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vUGF1c2UgV2hldGhlciB0byBkaXNhYmxlIHBhdXNpbmcgb24gdGhlIGNhcm91c2VsIChieSBkZWZhdWx0LCB0aGUgY2Fyb3VzZWwgaW50ZXJ2YWwgcGF1c2VzIG9uIGhvdmVyKS5cbiAqXG4gKiBAZXhhbXBsZVxuPGV4YW1wbGUgbW9kdWxlPVwidWkuYm9vdHN0cmFwXCI+XG4gIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgPGNhcm91c2VsPlxuICAgICAgPHNsaWRlPlxuICAgICAgICA8aW1nIHNyYz1cImh0dHA6Ly9wbGFjZWtpdHRlbi5jb20vMTUwLzE1MFwiIHN0eWxlPVwibWFyZ2luOmF1dG87XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjYXJvdXNlbC1jYXB0aW9uXCI+XG4gICAgICAgICAgPHA+QmVhdXRpZnVsITwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L3NsaWRlPlxuICAgICAgPHNsaWRlPlxuICAgICAgICA8aW1nIHNyYz1cImh0dHA6Ly9wbGFjZWtpdHRlbi5jb20vMTAwLzE1MFwiIHN0eWxlPVwibWFyZ2luOmF1dG87XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjYXJvdXNlbC1jYXB0aW9uXCI+XG4gICAgICAgICAgPHA+RCdhd3chPC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvc2xpZGU+XG4gICAgPC9jYXJvdXNlbD5cbiAgPC9maWxlPlxuICA8ZmlsZSBuYW1lPVwiZGVtby5jc3NcIj5cbiAgICAuY2Fyb3VzZWwtaW5kaWNhdG9ycyB7XG4gICAgICB0b3A6IGF1dG87XG4gICAgICBib3R0b206IDE1cHg7XG4gICAgfVxuICA8L2ZpbGU+XG48L2V4YW1wbGU+XG4gKi9cbi5kaXJlY3RpdmUoJ2Nhcm91c2VsJywgW2Z1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBjb250cm9sbGVyOiAnQ2Fyb3VzZWxDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdjYXJvdXNlbCcsXG4gICAgcmVxdWlyZTogJ2Nhcm91c2VsJyxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvY2Fyb3VzZWwvY2Fyb3VzZWwuaHRtbCc7XG4gICAgfSxcbiAgICBzY29wZToge1xuICAgICAgaW50ZXJ2YWw6ICc9JyxcbiAgICAgIG5vVHJhbnNpdGlvbjogJz0nLFxuICAgICAgbm9QYXVzZTogJz0nLFxuICAgICAgbm9XcmFwOiAnJidcbiAgICB9XG4gIH07XG59XSlcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSB1aS5ib290c3RyYXAuY2Fyb3VzZWwuZGlyZWN0aXZlOnNsaWRlXG4gKiBAcmVzdHJpY3QgRUFcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYSBzbGlkZSBpbnNpZGUgYSB7QGxpbmsgdWkuYm9vdHN0cmFwLmNhcm91c2VsLmRpcmVjdGl2ZTpjYXJvdXNlbCBjYXJvdXNlbH0uICBNdXN0IGJlIHBsYWNlZCBhcyBhIGNoaWxkIG9mIGEgY2Fyb3VzZWwgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBhY3RpdmUgTW9kZWwgYmluZGluZywgd2hldGhlciBvciBub3QgdGhpcyBzbGlkZSBpcyBjdXJyZW50bHkgYWN0aXZlLlxuICogQHBhcmFtIHtudW1iZXI9fSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHNsaWRlLiBUaGUgc2xpZGVzIHdpbGwgYmUgc29ydGVkIGJ5IHRoaXMgcGFyYW1ldGVyLlxuICpcbiAqIEBleGFtcGxlXG48ZXhhbXBsZSBtb2R1bGU9XCJ1aS5ib290c3RyYXBcIj5cbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbjxkaXYgbmctY29udHJvbGxlcj1cIkNhcm91c2VsRGVtb0N0cmxcIj5cbiAgPGNhcm91c2VsPlxuICAgIDxzbGlkZSBuZy1yZXBlYXQ9XCJzbGlkZSBpbiBzbGlkZXNcIiBhY3RpdmU9XCJzbGlkZS5hY3RpdmVcIiBpbmRleD1cIiRpbmRleFwiPlxuICAgICAgPGltZyBuZy1zcmM9XCJ7e3NsaWRlLmltYWdlfX1cIiBzdHlsZT1cIm1hcmdpbjphdXRvO1wiPlxuICAgICAgPGRpdiBjbGFzcz1cImNhcm91c2VsLWNhcHRpb25cIj5cbiAgICAgICAgPGg0PlNsaWRlIHt7JGluZGV4fX08L2g0PlxuICAgICAgICA8cD57e3NsaWRlLnRleHR9fTwvcD5cbiAgICAgIDwvZGl2PlxuICAgIDwvc2xpZGU+XG4gIDwvY2Fyb3VzZWw+XG4gIEludGVydmFsLCBpbiBtaWxsaXNlY29uZHM6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbmctbW9kZWw9XCJteUludGVydmFsXCI+XG4gIDxiciAvPkVudGVyIGEgbmVnYXRpdmUgbnVtYmVyIHRvIHN0b3AgdGhlIGludGVydmFsLlxuPC9kaXY+XG4gIDwvZmlsZT5cbiAgPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxuZnVuY3Rpb24gQ2Fyb3VzZWxEZW1vQ3RybCgkc2NvcGUpIHtcbiAgJHNjb3BlLm15SW50ZXJ2YWwgPSA1MDAwO1xufVxuICA8L2ZpbGU+XG4gIDxmaWxlIG5hbWU9XCJkZW1vLmNzc1wiPlxuICAgIC5jYXJvdXNlbC1pbmRpY2F0b3JzIHtcbiAgICAgIHRvcDogYXV0bztcbiAgICAgIGJvdHRvbTogMTVweDtcbiAgICB9XG4gIDwvZmlsZT5cbjwvZXhhbXBsZT5cbiovXG5cbi5kaXJlY3RpdmUoJ3NsaWRlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogJ15jYXJvdXNlbCcsXG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sJztcbiAgICB9LFxuICAgIHNjb3BlOiB7XG4gICAgICBhY3RpdmU6ICc9PycsXG4gICAgICBhY3R1YWw6ICc9PycsXG4gICAgICBpbmRleDogJz0/J1xuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY2Fyb3VzZWxDdHJsKSB7XG4gICAgICBjYXJvdXNlbEN0cmwuYWRkU2xpZGUoc2NvcGUsIGVsZW1lbnQpO1xuICAgICAgLy93aGVuIHRoZSBzY29wZSBpcyBkZXN0cm95ZWQgdGhlbiByZW1vdmUgdGhlIHNsaWRlIGZyb20gdGhlIGN1cnJlbnQgc2xpZGVzIGFycmF5XG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhcm91c2VsQ3RybC5yZW1vdmVTbGlkZShzY29wZSk7XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuJHdhdGNoKCdhY3RpdmUnLCBmdW5jdGlvbihhY3RpdmUpIHtcbiAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgIGNhcm91c2VsQ3RybC5zZWxlY3Qoc2NvcGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KVxuXG4uYW5pbWF0aW9uKCcuaXRlbScsIFtcbiAgICAgICAgICckaW5qZWN0b3InLCAnJGFuaW1hdGUnLFxuZnVuY3Rpb24gKCRpbmplY3RvciwgJGFuaW1hdGUpIHtcbiAgdmFyIE5PX1RSQU5TSVRJT04gPSAndWliLW5vVHJhbnNpdGlvbicsXG4gICAgU0xJREVfRElSRUNUSU9OID0gJ3VpYi1zbGlkZURpcmVjdGlvbicsXG4gICAgJGFuaW1hdGVDc3MgPSBudWxsO1xuXG4gIGlmICgkaW5qZWN0b3IuaGFzKCckYW5pbWF0ZUNzcycpKSB7XG4gICAgJGFuaW1hdGVDc3MgPSAkaW5qZWN0b3IuZ2V0KCckYW5pbWF0ZUNzcycpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCBjYWxsYmFjaykge1xuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZWZvcmVBZGRDbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSwgZG9uZSkge1xuICAgICAgLy8gRHVlIHRvIHRyYW5zY2x1c2lvbiwgbm9UcmFuc2l0aW9uIHByb3BlcnR5IGlzIG9uIHBhcmVudCdzIHNjb3BlXG4gICAgICBpZiAoY2xhc3NOYW1lID09ICdhY3RpdmUnICYmIGVsZW1lbnQucGFyZW50KCkgJiZcbiAgICAgICAgICAhZWxlbWVudC5wYXJlbnQoKS5kYXRhKE5PX1RSQU5TSVRJT04pKSB7XG4gICAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBlbGVtZW50LmRhdGEoU0xJREVfRElSRUNUSU9OKTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbkNsYXNzID0gZGlyZWN0aW9uID09ICduZXh0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgIHZhciByZW1vdmVDbGFzc0ZuID0gcmVtb3ZlQ2xhc3MuYmluZCh0aGlzLCBlbGVtZW50LFxuICAgICAgICAgIGRpcmVjdGlvbkNsYXNzICsgJyAnICsgZGlyZWN0aW9uLCBkb25lKTtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhkaXJlY3Rpb24pO1xuXG4gICAgICAgIGlmICgkYW5pbWF0ZUNzcykge1xuICAgICAgICAgICRhbmltYXRlQ3NzKGVsZW1lbnQsIHthZGRDbGFzczogZGlyZWN0aW9uQ2xhc3N9KVxuICAgICAgICAgICAgLnN0YXJ0KClcbiAgICAgICAgICAgIC5kb25lKHJlbW92ZUNsYXNzRm4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRhbmltYXRlLmFkZENsYXNzKGVsZW1lbnQsIGRpcmVjdGlvbkNsYXNzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzc0ZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZG9uZSgpO1xuICAgIH0sXG4gICAgYmVmb3JlUmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUsIGRvbmUpIHtcbiAgICAgIC8vIER1ZSB0byB0cmFuc2NsdXNpb24sIG5vVHJhbnNpdGlvbiBwcm9wZXJ0eSBpcyBvbiBwYXJlbnQncyBzY29wZVxuICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gJ2FjdGl2ZScgJiYgZWxlbWVudC5wYXJlbnQoKSAmJlxuICAgICAgICAgICFlbGVtZW50LnBhcmVudCgpLmRhdGEoTk9fVFJBTlNJVElPTikpIHtcbiAgICAgICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGVsZW1lbnQuZGF0YShTTElERV9ESVJFQ1RJT04pO1xuICAgICAgICB2YXIgZGlyZWN0aW9uQ2xhc3MgPSBkaXJlY3Rpb24gPT0gJ25leHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgdmFyIHJlbW92ZUNsYXNzRm4gPSByZW1vdmVDbGFzcy5iaW5kKHRoaXMsIGVsZW1lbnQsIGRpcmVjdGlvbkNsYXNzLCBkb25lKTtcblxuICAgICAgICBpZiAoJGFuaW1hdGVDc3MpIHtcbiAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7YWRkQ2xhc3M6IGRpcmVjdGlvbkNsYXNzfSlcbiAgICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgICAuZG9uZShyZW1vdmVDbGFzc0ZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkYW5pbWF0ZS5hZGRDbGFzcyhlbGVtZW50LCBkaXJlY3Rpb25DbGFzcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NGbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9O1xuXG59XSlcblxuXG47XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZGF0ZXBhcnNlcicsIFtdKVxuXG4uc2VydmljZSgnZGF0ZVBhcnNlcicsIFsnJGxvZycsICckbG9jYWxlJywgJ29yZGVyQnlGaWx0ZXInLCBmdW5jdGlvbigkbG9nLCAkbG9jYWxlLCBvcmRlckJ5RmlsdGVyKSB7XG4gIC8vIFB1bGxlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYm9zdG9jay9kMy9ibG9iL21hc3Rlci9zcmMvZm9ybWF0L3JlcXVvdGUuanNcbiAgdmFyIFNQRUNJQUxfQ0hBUkFDVEVSU19SRUdFWFAgPSAvW1xcXFxcXF5cXCRcXCpcXCtcXD9cXHxcXFtcXF1cXChcXClcXC5cXHtcXH1dL2c7XG5cbiAgdGhpcy5wYXJzZXJzID0ge307XG5cbiAgdmFyIGZvcm1hdENvZGVUb1JlZ2V4ID0ge1xuICAgICd5eXl5Jzoge1xuICAgICAgcmVnZXg6ICdcXFxcZHs0fScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy55ZWFyID0gK3ZhbHVlOyB9XG4gICAgfSxcbiAgICAneXknOiB7XG4gICAgICByZWdleDogJ1xcXFxkezJ9JyxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLnllYXIgPSArdmFsdWUgKyAyMDAwOyB9XG4gICAgfSxcbiAgICAneSc6IHtcbiAgICAgIHJlZ2V4OiAnXFxcXGR7MSw0fScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy55ZWFyID0gK3ZhbHVlOyB9XG4gICAgfSxcbiAgICAnTU1NTSc6IHtcbiAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuTU9OVEguam9pbignfCcpLFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubW9udGggPSAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuTU9OVEguaW5kZXhPZih2YWx1ZSk7IH1cbiAgICB9LFxuICAgICdNTU0nOiB7XG4gICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLlNIT1JUTU9OVEguam9pbignfCcpLFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubW9udGggPSAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuU0hPUlRNT05USC5pbmRleE9mKHZhbHVlKTsgfVxuICAgIH0sXG4gICAgJ01NJzoge1xuICAgICAgcmVnZXg6ICcwWzEtOV18MVswLTJdJyxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1vbnRoID0gdmFsdWUgLSAxOyB9XG4gICAgfSxcbiAgICAnTSc6IHtcbiAgICAgIHJlZ2V4OiAnWzEtOV18MVswLTJdJyxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1vbnRoID0gdmFsdWUgLSAxOyB9XG4gICAgfSxcbiAgICAnZGQnOiB7XG4gICAgICByZWdleDogJ1swLTJdWzAtOV17MX18M1swLTFdezF9JyxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmRhdGUgPSArdmFsdWU7IH1cbiAgICB9LFxuICAgICdkJzoge1xuICAgICAgcmVnZXg6ICdbMS0yXT9bMC05XXsxfXwzWzAtMV17MX0nLFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuZGF0ZSA9ICt2YWx1ZTsgfVxuICAgIH0sXG4gICAgJ0VFRUUnOiB7XG4gICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLkRBWS5qb2luKCd8JylcbiAgICB9LFxuICAgICdFRUUnOiB7XG4gICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLlNIT1JUREFZLmpvaW4oJ3wnKVxuICAgIH0sXG4gICAgJ0hIJzoge1xuICAgICAgcmVnZXg6ICcoPzowfDEpWzAtOV18MlswLTNdJyxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmhvdXJzID0gK3ZhbHVlOyB9XG4gICAgfSxcbiAgICAnaGgnOiB7XG4gICAgICByZWdleDogJzBbMC05XXwxWzAtMl0nLFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuaG91cnMgPSArdmFsdWU7IH1cbiAgICB9LFxuICAgICdIJzoge1xuICAgICAgcmVnZXg6ICcxP1swLTldfDJbMC0zXScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5ob3VycyA9ICt2YWx1ZTsgfVxuICAgIH0sXG4gICAgJ2gnOiB7XG4gICAgICByZWdleDogJ1swLTldfDFbMC0yXScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5ob3VycyA9ICt2YWx1ZTsgfVxuICAgIH0sXG4gICAgJ21tJzoge1xuICAgICAgcmVnZXg6ICdbMC01XVswLTldJyxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1pbnV0ZXMgPSArdmFsdWU7IH1cbiAgICB9LFxuICAgICdtJzoge1xuICAgICAgcmVnZXg6ICdbMC05XXxbMS01XVswLTldJyxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1pbnV0ZXMgPSArdmFsdWU7IH1cbiAgICB9LFxuICAgICdzc3MnOiB7XG4gICAgICByZWdleDogJ1swLTldWzAtOV1bMC05XScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5taWxsaXNlY29uZHMgPSArdmFsdWU7IH1cbiAgICB9LFxuICAgICdzcyc6IHtcbiAgICAgIHJlZ2V4OiAnWzAtNV1bMC05XScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5zZWNvbmRzID0gK3ZhbHVlOyB9XG4gICAgfSxcbiAgICAncyc6IHtcbiAgICAgIHJlZ2V4OiAnWzAtOV18WzEtNV1bMC05XScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5zZWNvbmRzID0gK3ZhbHVlOyB9XG4gICAgfSxcbiAgICAnYSc6IHtcbiAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuQU1QTVMuam9pbignfCcpLFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhvdXJzID09PSAxMikge1xuICAgICAgICAgIHRoaXMuaG91cnMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnUE0nKSB7XG4gICAgICAgICAgdGhpcy5ob3VycyArPSAxMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVQYXJzZXIoZm9ybWF0KSB7XG4gICAgdmFyIG1hcCA9IFtdLCByZWdleCA9IGZvcm1hdC5zcGxpdCgnJyk7XG5cbiAgICBhbmd1bGFyLmZvckVhY2goZm9ybWF0Q29kZVRvUmVnZXgsIGZ1bmN0aW9uKGRhdGEsIGNvZGUpIHtcbiAgICAgIHZhciBpbmRleCA9IGZvcm1hdC5pbmRleE9mKGNvZGUpO1xuXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQuc3BsaXQoJycpO1xuXG4gICAgICAgIHJlZ2V4W2luZGV4XSA9ICcoJyArIGRhdGEucmVnZXggKyAnKSc7XG4gICAgICAgIGZvcm1hdFtpbmRleF0gPSAnJCc7IC8vIEN1c3RvbSBzeW1ib2wgdG8gZGVmaW5lIGNvbnN1bWVkIHBhcnQgb2YgZm9ybWF0XG4gICAgICAgIGZvciAodmFyIGkgPSBpbmRleCArIDEsIG4gPSBpbmRleCArIGNvZGUubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgcmVnZXhbaV0gPSAnJztcbiAgICAgICAgICBmb3JtYXRbaV0gPSAnJCc7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LmpvaW4oJycpO1xuXG4gICAgICAgIG1hcC5wdXNoKHsgaW5kZXg6IGluZGV4LCBhcHBseTogZGF0YS5hcHBseSB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICByZWdleDogbmV3IFJlZ0V4cCgnXicgKyByZWdleC5qb2luKCcnKSArICckJyksXG4gICAgICBtYXA6IG9yZGVyQnlGaWx0ZXIobWFwLCAnaW5kZXgnKVxuICAgIH07XG4gIH1cblxuICB0aGlzLnBhcnNlID0gZnVuY3Rpb24oaW5wdXQsIGZvcm1hdCwgYmFzZURhdGUpIHtcbiAgICBpZiAoIWFuZ3VsYXIuaXNTdHJpbmcoaW5wdXQpIHx8ICFmb3JtYXQpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICBmb3JtYXQgPSAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFNbZm9ybWF0XSB8fCBmb3JtYXQ7XG4gICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoU1BFQ0lBTF9DSEFSQUNURVJTX1JFR0VYUCwgJ1xcXFwkJicpO1xuXG4gICAgaWYgKCF0aGlzLnBhcnNlcnNbZm9ybWF0XSkge1xuICAgICAgdGhpcy5wYXJzZXJzW2Zvcm1hdF0gPSBjcmVhdGVQYXJzZXIoZm9ybWF0KTtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VyID0gdGhpcy5wYXJzZXJzW2Zvcm1hdF0sXG4gICAgICAgIHJlZ2V4ID0gcGFyc2VyLnJlZ2V4LFxuICAgICAgICBtYXAgPSBwYXJzZXIubWFwLFxuICAgICAgICByZXN1bHRzID0gaW5wdXQubWF0Y2gocmVnZXgpO1xuXG4gICAgaWYgKHJlc3VsdHMgJiYgcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgIHZhciBmaWVsZHMsIGR0O1xuICAgICAgaWYgKGFuZ3VsYXIuaXNEYXRlKGJhc2VEYXRlKSAmJiAhaXNOYU4oYmFzZURhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICBmaWVsZHMgPSB7XG4gICAgICAgICAgeWVhcjogYmFzZURhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICBtb250aDogYmFzZURhdGUuZ2V0TW9udGgoKSxcbiAgICAgICAgICBkYXRlOiBiYXNlRGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgaG91cnM6IGJhc2VEYXRlLmdldEhvdXJzKCksXG4gICAgICAgICAgbWludXRlczogYmFzZURhdGUuZ2V0TWludXRlcygpLFxuICAgICAgICAgIHNlY29uZHM6IGJhc2VEYXRlLmdldFNlY29uZHMoKSxcbiAgICAgICAgICBtaWxsaXNlY29uZHM6IGJhc2VEYXRlLmdldE1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmFzZURhdGUpIHtcbiAgICAgICAgICAkbG9nLndhcm4oJ2RhdGVwYXJzZXI6JywgJ2Jhc2VEYXRlIGlzIG5vdCBhIHZhbGlkIGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHMgPSB7IHllYXI6IDE5MDAsIG1vbnRoOiAwLCBkYXRlOiAxLCBob3VyczogMCwgbWludXRlczogMCwgc2Vjb25kczogMCwgbWlsbGlzZWNvbmRzOiAwIH07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBuID0gcmVzdWx0cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIG1hcHBlciA9IG1hcFtpLTFdO1xuICAgICAgICBpZiAobWFwcGVyLmFwcGx5KSB7XG4gICAgICAgICAgbWFwcGVyLmFwcGx5LmNhbGwoZmllbGRzLCByZXN1bHRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNWYWxpZChmaWVsZHMueWVhciwgZmllbGRzLm1vbnRoLCBmaWVsZHMuZGF0ZSkpIHtcbiAgICAgICAgZHQgPSBuZXcgRGF0ZShmaWVsZHMueWVhciwgZmllbGRzLm1vbnRoLCBmaWVsZHMuZGF0ZSxcbiAgICAgICAgICBmaWVsZHMuaG91cnMsIGZpZWxkcy5taW51dGVzLCBmaWVsZHMuc2Vjb25kcyxcbiAgICAgICAgICBmaWVsZHMubWlsbGlzZWNvbmRzIHx8IDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZHQ7XG4gICAgfVxuICB9O1xuXG4gIC8vIENoZWNrIGlmIGRhdGUgaXMgdmFsaWQgZm9yIHNwZWNpZmljIG1vbnRoIChhbmQgeWVhciBmb3IgRmVicnVhcnkpLlxuICAvLyBNb250aDogMCA9IEphbiwgMSA9IEZlYiwgZXRjXG4gIGZ1bmN0aW9uIGlzVmFsaWQoeWVhciwgbW9udGgsIGRhdGUpIHtcbiAgICBpZiAoZGF0ZSA8IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobW9udGggPT09IDEgJiYgZGF0ZSA+IDI4KSB7XG4gICAgICByZXR1cm4gZGF0ZSA9PT0gMjkgJiYgKCh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwKTtcbiAgICB9XG5cbiAgICBpZiAobW9udGggPT09IDMgfHwgbW9udGggPT09IDUgfHwgbW9udGggPT09IDggfHwgbW9udGggPT09IDEwKSB7XG4gICAgICByZXR1cm4gZGF0ZSA8IDMxO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucG9zaXRpb24nLCBbXSlcblxuLyoqXG4gKiBBIHNldCBvZiB1dGlsaXR5IG1ldGhvZHMgdGhhdCBjYW4gYmUgdXNlIHRvIHJldHJpZXZlIHBvc2l0aW9uIG9mIERPTSBlbGVtZW50cy5cbiAqIEl0IGlzIG1lYW50IHRvIGJlIHVzZWQgd2hlcmUgd2UgbmVlZCB0byBhYnNvbHV0ZS1wb3NpdGlvbiBET00gZWxlbWVudHMgaW5cbiAqIHJlbGF0aW9uIHRvIG90aGVyLCBleGlzdGluZyBlbGVtZW50cyAodGhpcyBpcyB0aGUgY2FzZSBmb3IgdG9vbHRpcHMsIHBvcG92ZXJzLFxuICogdHlwZWFoZWFkIHN1Z2dlc3Rpb25zIGV0Yy4pLlxuICovXG4gIC5mYWN0b3J5KCckcG9zaXRpb24nLCBbJyRkb2N1bWVudCcsICckd2luZG93JywgZnVuY3Rpb24oJGRvY3VtZW50LCAkd2luZG93KSB7XG4gICAgZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIGNzc3Byb3ApIHtcbiAgICAgIGlmIChlbC5jdXJyZW50U3R5bGUpIHsgLy9JRVxuICAgICAgICByZXR1cm4gZWwuY3VycmVudFN0eWxlW2Nzc3Byb3BdO1xuICAgICAgfSBlbHNlIGlmICgkd2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgcmV0dXJuICR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbClbY3NzcHJvcF07XG4gICAgICB9XG4gICAgICAvLyBmaW5hbGx5IHRyeSBhbmQgZ2V0IGlubGluZSBzdHlsZVxuICAgICAgcmV0dXJuIGVsLnN0eWxlW2Nzc3Byb3BdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGdpdmVuIGVsZW1lbnQgaXMgc3RhdGljYWxseSBwb3NpdGlvbmVkXG4gICAgICogQHBhcmFtIGVsZW1lbnQgLSByYXcgRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0YXRpY1Bvc2l0aW9uZWQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIChnZXRTdHlsZShlbGVtZW50LCAncG9zaXRpb24nKSB8fCAnc3RhdGljJyApID09PSAnc3RhdGljJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBjbG9zZXN0LCBub24tc3RhdGljYWxseSBwb3NpdGlvbmVkIHBhcmVudE9mZnNldCBvZiBhIGdpdmVuIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqL1xuICAgIHZhciBwYXJlbnRPZmZzZXRFbCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBkb2NEb21FbCA9ICRkb2N1bWVudFswXTtcbiAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCB8fCBkb2NEb21FbDtcbiAgICAgIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBkb2NEb21FbCAmJiBpc1N0YXRpY1Bvc2l0aW9uZWQob2Zmc2V0UGFyZW50KSApIHtcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jRG9tRWw7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIHJlYWQtb25seSBlcXVpdmFsZW50IG9mIGpRdWVyeSdzIHBvc2l0aW9uIGZ1bmN0aW9uOlxuICAgICAgICogaHR0cDovL2FwaS5qcXVlcnkuY29tL3Bvc2l0aW9uL1xuICAgICAgICovXG4gICAgICBwb3NpdGlvbjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB2YXIgZWxCQ1IgPSB0aGlzLm9mZnNldChlbGVtZW50KTtcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudEJDUiA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gICAgICAgIHZhciBvZmZzZXRQYXJlbnRFbCA9IHBhcmVudE9mZnNldEVsKGVsZW1lbnRbMF0pO1xuICAgICAgICBpZiAob2Zmc2V0UGFyZW50RWwgIT0gJGRvY3VtZW50WzBdKSB7XG4gICAgICAgICAgb2Zmc2V0UGFyZW50QkNSID0gdGhpcy5vZmZzZXQoYW5ndWxhci5lbGVtZW50KG9mZnNldFBhcmVudEVsKSk7XG4gICAgICAgICAgb2Zmc2V0UGFyZW50QkNSLnRvcCArPSBvZmZzZXRQYXJlbnRFbC5jbGllbnRUb3AgLSBvZmZzZXRQYXJlbnRFbC5zY3JvbGxUb3A7XG4gICAgICAgICAgb2Zmc2V0UGFyZW50QkNSLmxlZnQgKz0gb2Zmc2V0UGFyZW50RWwuY2xpZW50TGVmdCAtIG9mZnNldFBhcmVudEVsLnNjcm9sbExlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm91bmRpbmdDbGllbnRSZWN0ID0gZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogYm91bmRpbmdDbGllbnRSZWN0LndpZHRoIHx8IGVsZW1lbnQucHJvcCgnb2Zmc2V0V2lkdGgnKSxcbiAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQgfHwgZWxlbWVudC5wcm9wKCdvZmZzZXRIZWlnaHQnKSxcbiAgICAgICAgICB0b3A6IGVsQkNSLnRvcCAtIG9mZnNldFBhcmVudEJDUi50b3AsXG4gICAgICAgICAgbGVmdDogZWxCQ1IubGVmdCAtIG9mZnNldFBhcmVudEJDUi5sZWZ0XG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIHJlYWQtb25seSBlcXVpdmFsZW50IG9mIGpRdWVyeSdzIG9mZnNldCBmdW5jdGlvbjpcbiAgICAgICAqIGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9vZmZzZXQvXG4gICAgICAgKi9cbiAgICAgIG9mZnNldDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB2YXIgYm91bmRpbmdDbGllbnRSZWN0ID0gZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogYm91bmRpbmdDbGllbnRSZWN0LndpZHRoIHx8IGVsZW1lbnQucHJvcCgnb2Zmc2V0V2lkdGgnKSxcbiAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQgfHwgZWxlbWVudC5wcm9wKCdvZmZzZXRIZWlnaHQnKSxcbiAgICAgICAgICB0b3A6IGJvdW5kaW5nQ2xpZW50UmVjdC50b3AgKyAoJHdpbmRvdy5wYWdlWU9mZnNldCB8fCAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCksXG4gICAgICAgICAgbGVmdDogYm91bmRpbmdDbGllbnRSZWN0LmxlZnQgKyAoJHdpbmRvdy5wYWdlWE9mZnNldCB8fCAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQpXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIGNvb3JkaW5hdGVzIGZvciB0aGUgdGFyZ2V0RWwgaW4gcmVsYXRpb24gdG8gaG9zdEVsXG4gICAgICAgKi9cbiAgICAgIHBvc2l0aW9uRWxlbWVudHM6IGZ1bmN0aW9uKGhvc3RFbCwgdGFyZ2V0RWwsIHBvc2l0aW9uU3RyLCBhcHBlbmRUb0JvZHkpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uU3RyUGFydHMgPSBwb3NpdGlvblN0ci5zcGxpdCgnLScpO1xuICAgICAgICB2YXIgcG9zMCA9IHBvc2l0aW9uU3RyUGFydHNbMF0sIHBvczEgPSBwb3NpdGlvblN0clBhcnRzWzFdIHx8ICdjZW50ZXInO1xuXG4gICAgICAgIHZhciBob3N0RWxQb3MsXG4gICAgICAgICAgdGFyZ2V0RWxXaWR0aCxcbiAgICAgICAgICB0YXJnZXRFbEhlaWdodCxcbiAgICAgICAgICB0YXJnZXRFbFBvcztcblxuICAgICAgICBob3N0RWxQb3MgPSBhcHBlbmRUb0JvZHkgPyB0aGlzLm9mZnNldChob3N0RWwpIDogdGhpcy5wb3NpdGlvbihob3N0RWwpO1xuXG4gICAgICAgIHRhcmdldEVsV2lkdGggPSB0YXJnZXRFbC5wcm9wKCdvZmZzZXRXaWR0aCcpO1xuICAgICAgICB0YXJnZXRFbEhlaWdodCA9IHRhcmdldEVsLnByb3AoJ29mZnNldEhlaWdodCcpO1xuXG4gICAgICAgIHZhciBzaGlmdFdpZHRoID0ge1xuICAgICAgICAgIGNlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9zdEVsUG9zLmxlZnQgKyBob3N0RWxQb3Mud2lkdGggLyAyIC0gdGFyZ2V0RWxXaWR0aCAvIDI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBsZWZ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBob3N0RWxQb3MubGVmdDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBob3N0RWxQb3MubGVmdCArIGhvc3RFbFBvcy53aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNoaWZ0SGVpZ2h0ID0ge1xuICAgICAgICAgIGNlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9zdEVsUG9zLnRvcCArIGhvc3RFbFBvcy5oZWlnaHQgLyAyIC0gdGFyZ2V0RWxIZWlnaHQgLyAyO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBob3N0RWxQb3MudG9wO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYm90dG9tOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBob3N0RWxQb3MudG9wICsgaG9zdEVsUG9zLmhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc3dpdGNoIChwb3MwKSB7XG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgdGFyZ2V0RWxQb3MgPSB7XG4gICAgICAgICAgICAgIHRvcDogc2hpZnRIZWlnaHRbcG9zMV0oKSxcbiAgICAgICAgICAgICAgbGVmdDogc2hpZnRXaWR0aFtwb3MwXSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICB0YXJnZXRFbFBvcyA9IHtcbiAgICAgICAgICAgICAgdG9wOiBzaGlmdEhlaWdodFtwb3MxXSgpLFxuICAgICAgICAgICAgICBsZWZ0OiBob3N0RWxQb3MubGVmdCAtIHRhcmdldEVsV2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgdGFyZ2V0RWxQb3MgPSB7XG4gICAgICAgICAgICAgIHRvcDogc2hpZnRIZWlnaHRbcG9zMF0oKSxcbiAgICAgICAgICAgICAgbGVmdDogc2hpZnRXaWR0aFtwb3MxXSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRhcmdldEVsUG9zID0ge1xuICAgICAgICAgICAgICB0b3A6IGhvc3RFbFBvcy50b3AgLSB0YXJnZXRFbEhlaWdodCxcbiAgICAgICAgICAgICAgbGVmdDogc2hpZnRXaWR0aFtwb3MxXSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0RWxQb3M7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRhdGVwaWNrZXInLCBbJ3VpLmJvb3RzdHJhcC5kYXRlcGFyc2VyJywgJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbiddKVxuXG4udmFsdWUoJyRkYXRlcGlja2VyU3VwcHJlc3NFcnJvcicsIGZhbHNlKVxuXG4uY29uc3RhbnQoJ2RhdGVwaWNrZXJDb25maWcnLCB7XG4gIGZvcm1hdERheTogJ2RkJyxcbiAgZm9ybWF0TW9udGg6ICdNTU1NJyxcbiAgZm9ybWF0WWVhcjogJ3l5eXknLFxuICBmb3JtYXREYXlIZWFkZXI6ICdFRUUnLFxuICBmb3JtYXREYXlUaXRsZTogJ01NTU0geXl5eScsXG4gIGZvcm1hdE1vbnRoVGl0bGU6ICd5eXl5JyxcbiAgZGF0ZXBpY2tlck1vZGU6ICdkYXknLFxuICBtaW5Nb2RlOiAnZGF5JyxcbiAgbWF4TW9kZTogJ3llYXInLFxuICBzaG93V2Vla3M6IHRydWUsXG4gIHN0YXJ0aW5nRGF5OiAwLFxuICB5ZWFyUmFuZ2U6IDIwLFxuICBtaW5EYXRlOiBudWxsLFxuICBtYXhEYXRlOiBudWxsLFxuICBzaG9ydGN1dFByb3BhZ2F0aW9uOiBmYWxzZVxufSlcblxuLmNvbnRyb2xsZXIoJ0RhdGVwaWNrZXJDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGF0dHJzJywgJyRwYXJzZScsICckaW50ZXJwb2xhdGUnLCAnJGxvZycsICdkYXRlRmlsdGVyJywgJ2RhdGVwaWNrZXJDb25maWcnLCAnJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsICRwYXJzZSwgJGludGVycG9sYXRlLCAkbG9nLCBkYXRlRmlsdGVyLCBkYXRlcGlja2VyQ29uZmlnLCAkZGF0ZXBpY2tlclN1cHByZXNzRXJyb3IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgbmdNb2RlbEN0cmwgPSB7ICRzZXRWaWV3VmFsdWU6IGFuZ3VsYXIubm9vcCB9OyAvLyBudWxsTW9kZWxDdHJsO1xuXG4gIC8vIE1vZGVzIGNoYWluXG4gIHRoaXMubW9kZXMgPSBbJ2RheScsICdtb250aCcsICd5ZWFyJ107XG5cbiAgLy8gQ29uZmlndXJhdGlvbiBhdHRyaWJ1dGVzXG4gIGFuZ3VsYXIuZm9yRWFjaChbJ2Zvcm1hdERheScsICdmb3JtYXRNb250aCcsICdmb3JtYXRZZWFyJywgJ2Zvcm1hdERheUhlYWRlcicsICdmb3JtYXREYXlUaXRsZScsICdmb3JtYXRNb250aFRpdGxlJyxcbiAgICAgICAgICAgICAgICAgICAnc2hvd1dlZWtzJywgJ3N0YXJ0aW5nRGF5JywgJ3llYXJSYW5nZScsICdzaG9ydGN1dFByb3BhZ2F0aW9uJ10sIGZ1bmN0aW9uKGtleSwgaW5kZXgpIHtcbiAgICBzZWxmW2tleV0gPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnNba2V5XSkgPyAoaW5kZXggPCA2ID8gJGludGVycG9sYXRlKCRhdHRyc1trZXldKSgkc2NvcGUuJHBhcmVudCkgOiAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnNba2V5XSkpIDogZGF0ZXBpY2tlckNvbmZpZ1trZXldO1xuICB9KTtcblxuICAvLyBXYXRjaGFibGUgZGF0ZSBhdHRyaWJ1dGVzXG4gIGFuZ3VsYXIuZm9yRWFjaChbJ21pbkRhdGUnLCAnbWF4RGF0ZSddLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoJGF0dHJzW2tleV0pIHtcbiAgICAgICRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzW2tleV0pLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzZWxmW2tleV0gPSB2YWx1ZSA/IG5ldyBEYXRlKHZhbHVlKSA6IG51bGw7XG4gICAgICAgIHNlbGYucmVmcmVzaFZpZXcoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmW2tleV0gPSBkYXRlcGlja2VyQ29uZmlnW2tleV0gPyBuZXcgRGF0ZShkYXRlcGlja2VyQ29uZmlnW2tleV0pIDogbnVsbDtcbiAgICB9XG4gIH0pO1xuXG4gIGFuZ3VsYXIuZm9yRWFjaChbJ21pbk1vZGUnLCAnbWF4TW9kZSddLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoJGF0dHJzW2tleV0pIHtcbiAgICAgICRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzW2tleV0pLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzZWxmW2tleV0gPSBhbmd1bGFyLmlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6ICRhdHRyc1trZXldO1xuICAgICAgICAkc2NvcGVba2V5XSA9IHNlbGZba2V5XTtcbiAgICAgICAgaWYgKChrZXkgPT0gJ21pbk1vZGUnICYmIHNlbGYubW9kZXMuaW5kZXhPZigkc2NvcGUuZGF0ZXBpY2tlck1vZGUpIDwgc2VsZi5tb2Rlcy5pbmRleE9mKHNlbGZba2V5XSkpIHx8IChrZXkgPT0gJ21heE1vZGUnICYmIHNlbGYubW9kZXMuaW5kZXhPZigkc2NvcGUuZGF0ZXBpY2tlck1vZGUpID4gc2VsZi5tb2Rlcy5pbmRleE9mKHNlbGZba2V5XSkpKSB7XG4gICAgICAgICAgJHNjb3BlLmRhdGVwaWNrZXJNb2RlID0gc2VsZltrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZltrZXldID0gZGF0ZXBpY2tlckNvbmZpZ1trZXldIHx8IG51bGw7XG4gICAgICAkc2NvcGVba2V5XSA9IHNlbGZba2V5XTtcbiAgICB9XG4gIH0pO1xuXG4gICRzY29wZS5kYXRlcGlja2VyTW9kZSA9ICRzY29wZS5kYXRlcGlja2VyTW9kZSB8fCBkYXRlcGlja2VyQ29uZmlnLmRhdGVwaWNrZXJNb2RlO1xuICAkc2NvcGUudW5pcXVlSWQgPSAnZGF0ZXBpY2tlci0nICsgJHNjb3BlLiRpZCArICctJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcblxuICBpZiAoYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmluaXREYXRlKSkge1xuICAgIHRoaXMuYWN0aXZlRGF0ZSA9ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5pbml0RGF0ZSkgfHwgbmV3IERhdGUoKTtcbiAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJGF0dHJzLmluaXREYXRlLCBmdW5jdGlvbihpbml0RGF0ZSkge1xuICAgICAgaWYgKGluaXREYXRlICYmIChuZ01vZGVsQ3RybC4kaXNFbXB0eShuZ01vZGVsQ3RybC4kbW9kZWxWYWx1ZSkgfHwgbmdNb2RlbEN0cmwuJGludmFsaWQpKSB7XG4gICAgICAgIHNlbGYuYWN0aXZlRGF0ZSA9IGluaXREYXRlO1xuICAgICAgICBzZWxmLnJlZnJlc2hWaWV3KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hY3RpdmVEYXRlID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gICRzY29wZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKGRhdGVPYmplY3QpIHtcbiAgICBpZiAoc2VsZi5jb21wYXJlKGRhdGVPYmplY3QuZGF0ZSwgc2VsZi5hY3RpdmVEYXRlKSA9PT0gMCkge1xuICAgICAgJHNjb3BlLmFjdGl2ZURhdGVJZCA9IGRhdGVPYmplY3QudWlkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbihuZ01vZGVsQ3RybF8pIHtcbiAgICBuZ01vZGVsQ3RybCA9IG5nTW9kZWxDdHJsXztcblxuICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgfTtcbiAgfTtcblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUpLFxuICAgICAgICAgIGlzVmFsaWQgPSAhaXNOYU4oZGF0ZSk7XG5cbiAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IGRhdGU7XG4gICAgICB9IGVsc2UgaWYgKCEkZGF0ZXBpY2tlclN1cHByZXNzRXJyb3IpIHtcbiAgICAgICAgJGxvZy5lcnJvcignRGF0ZXBpY2tlciBkaXJlY3RpdmU6IFwibmctbW9kZWxcIiB2YWx1ZSBtdXN0IGJlIGEgRGF0ZSBvYmplY3QsIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSAwMS4wMS4xOTcwIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBSRkMyODIyIG9yIElTTyA4NjAxIGRhdGUuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVmcmVzaFZpZXcoKTtcbiAgfTtcblxuICB0aGlzLnJlZnJlc2hWaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgdGhpcy5fcmVmcmVzaFZpZXcoKTtcblxuICAgICAgdmFyIGRhdGUgPSBuZ01vZGVsQ3RybC4kdmlld1ZhbHVlID8gbmV3IERhdGUobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSkgOiBudWxsO1xuICAgICAgbmdNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdkYXRlRGlzYWJsZWQnLCAhZGF0ZSB8fCAodGhpcy5lbGVtZW50ICYmICF0aGlzLmlzRGlzYWJsZWQoZGF0ZSkpKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5jcmVhdGVEYXRlT2JqZWN0ID0gZnVuY3Rpb24oZGF0ZSwgZm9ybWF0KSB7XG4gICAgdmFyIG1vZGVsID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA/IG5ldyBEYXRlKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUpIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgIGxhYmVsOiBkYXRlRmlsdGVyKGRhdGUsIGZvcm1hdCksXG4gICAgICBzZWxlY3RlZDogbW9kZWwgJiYgdGhpcy5jb21wYXJlKGRhdGUsIG1vZGVsKSA9PT0gMCxcbiAgICAgIGRpc2FibGVkOiB0aGlzLmlzRGlzYWJsZWQoZGF0ZSksXG4gICAgICBjdXJyZW50OiB0aGlzLmNvbXBhcmUoZGF0ZSwgbmV3IERhdGUoKSkgPT09IDAsXG4gICAgICBjdXN0b21DbGFzczogdGhpcy5jdXN0b21DbGFzcyhkYXRlKVxuICAgIH07XG4gIH07XG5cbiAgdGhpcy5pc0Rpc2FibGVkID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiAoKHRoaXMubWluRGF0ZSAmJiB0aGlzLmNvbXBhcmUoZGF0ZSwgdGhpcy5taW5EYXRlKSA8IDApIHx8ICh0aGlzLm1heERhdGUgJiYgdGhpcy5jb21wYXJlKGRhdGUsIHRoaXMubWF4RGF0ZSkgPiAwKSB8fCAoJGF0dHJzLmRhdGVEaXNhYmxlZCAmJiAkc2NvcGUuZGF0ZURpc2FibGVkKHtkYXRlOiBkYXRlLCBtb2RlOiAkc2NvcGUuZGF0ZXBpY2tlck1vZGV9KSkpO1xuICB9O1xuXG4gIHRoaXMuY3VzdG9tQ2xhc3MgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuICRzY29wZS5jdXN0b21DbGFzcyh7ZGF0ZTogZGF0ZSwgbW9kZTogJHNjb3BlLmRhdGVwaWNrZXJNb2RlfSk7XG4gIH07XG5cbiAgLy8gU3BsaXQgYXJyYXkgaW50byBzbWFsbGVyIGFycmF5c1xuICB0aGlzLnNwbGl0ID0gZnVuY3Rpb24oYXJyLCBzaXplKSB7XG4gICAgdmFyIGFycmF5cyA9IFtdO1xuICAgIHdoaWxlIChhcnIubGVuZ3RoID4gMCkge1xuICAgICAgYXJyYXlzLnB1c2goYXJyLnNwbGljZSgwLCBzaXplKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheXM7XG4gIH07XG5cbiAgLy8gRml4IGEgaGFyZC1yZXByb2R1c2libGUgYnVnIHdpdGggdGltZXpvbmVzXG4gIC8vIFRoZSBidWcgZGVwZW5kcyBvbiBPUywgYnJvd3NlciwgY3VycmVudCB0aW1lem9uZSBhbmQgY3VycmVudCBkYXRlXG4gIC8vIGkuZS5cbiAgLy8gdmFyIGRhdGUgPSBuZXcgRGF0ZSgyMDE0LCAwLCAxKTtcbiAgLy8gY29uc29sZS5sb2coZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpLCBkYXRlLmdldEhvdXJzKCkpO1xuICAvLyBjYW4gcmVzdWx0IGluIFwiMjAxMyAxMSAzMSAyM1wiIGJlY2F1c2Ugb2YgdGhlIGJ1Zy5cbiAgdGhpcy5maXhUaW1lWm9uZSA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgZGF0ZS5zZXRIb3Vycyhob3VycyA9PT0gMjMgPyBob3VycyArIDIgOiAwKTtcbiAgfTtcblxuICAkc2NvcGUuc2VsZWN0ID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIGlmICgkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPT09IHNlbGYubWluTW9kZSkge1xuICAgICAgdmFyIGR0ID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA/IG5ldyBEYXRlKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUpIDogbmV3IERhdGUoMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICBkdC5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpO1xuICAgICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShkdCk7XG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuYWN0aXZlRGF0ZSA9IGRhdGU7XG4gICAgICAkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPSBzZWxmLm1vZGVzW3NlbGYubW9kZXMuaW5kZXhPZigkc2NvcGUuZGF0ZXBpY2tlck1vZGUpIC0gMV07XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5tb3ZlID0gZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgdmFyIHllYXIgPSBzZWxmLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSArIGRpcmVjdGlvbiAqIChzZWxmLnN0ZXAueWVhcnMgfHwgMCksXG4gICAgICAgIG1vbnRoID0gc2VsZi5hY3RpdmVEYXRlLmdldE1vbnRoKCkgKyBkaXJlY3Rpb24gKiAoc2VsZi5zdGVwLm1vbnRocyB8fCAwKTtcbiAgICBzZWxmLmFjdGl2ZURhdGUuc2V0RnVsbFllYXIoeWVhciwgbW9udGgsIDEpO1xuICAgIHNlbGYucmVmcmVzaFZpZXcoKTtcbiAgfTtcblxuICAkc2NvcGUudG9nZ2xlTW9kZSA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCAxO1xuXG4gICAgaWYgKCgkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPT09IHNlbGYubWF4TW9kZSAmJiBkaXJlY3Rpb24gPT09IDEpIHx8ICgkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPT09IHNlbGYubWluTW9kZSAmJiBkaXJlY3Rpb24gPT09IC0xKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgICRzY29wZS5kYXRlcGlja2VyTW9kZSA9IHNlbGYubW9kZXNbc2VsZi5tb2Rlcy5pbmRleE9mKCRzY29wZS5kYXRlcGlja2VyTW9kZSkgKyBkaXJlY3Rpb25dO1xuICB9O1xuXG4gIC8vIEtleSBldmVudCBtYXBwZXJcbiAgJHNjb3BlLmtleXMgPSB7IDEzOiAnZW50ZXInLCAzMjogJ3NwYWNlJywgMzM6ICdwYWdldXAnLCAzNDogJ3BhZ2Vkb3duJywgMzU6ICdlbmQnLCAzNjogJ2hvbWUnLCAzNzogJ2xlZnQnLCAzODogJ3VwJywgMzk6ICdyaWdodCcsIDQwOiAnZG93bicgfTtcblxuICB2YXIgZm9jdXNFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbGVtZW50WzBdLmZvY3VzKCk7XG4gIH07XG5cbiAgLy8gTGlzdGVuIGZvciBmb2N1cyByZXF1ZXN0cyBmcm9tIHBvcHVwIGRpcmVjdGl2ZVxuICAkc2NvcGUuJG9uKCdkYXRlcGlja2VyLmZvY3VzJywgZm9jdXNFbGVtZW50KTtcblxuICAkc2NvcGUua2V5ZG93biA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIHZhciBrZXkgPSAkc2NvcGUua2V5c1tldnQud2hpY2hdO1xuXG4gICAgaWYgKCFrZXkgfHwgZXZ0LnNoaWZ0S2V5IHx8IGV2dC5hbHRLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXNlbGYuc2hvcnRjdXRQcm9wYWdhdGlvbikge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdlbnRlcicgfHwga2V5ID09PSAnc3BhY2UnKSB7XG4gICAgICBpZiAoc2VsZi5pc0Rpc2FibGVkKHNlbGYuYWN0aXZlRGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBkbyBub3RoaW5nXG4gICAgICB9XG4gICAgICAkc2NvcGUuc2VsZWN0KHNlbGYuYWN0aXZlRGF0ZSk7XG4gICAgICBmb2N1c0VsZW1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKGV2dC5jdHJsS2V5ICYmIChrZXkgPT09ICd1cCcgfHwga2V5ID09PSAnZG93bicpKSB7XG4gICAgICAkc2NvcGUudG9nZ2xlTW9kZShrZXkgPT09ICd1cCcgPyAxIDogLTEpO1xuICAgICAgZm9jdXNFbGVtZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuaGFuZGxlS2V5RG93bihrZXksIGV2dCk7XG4gICAgICBzZWxmLnJlZnJlc2hWaWV3KCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ2RhdGVwaWNrZXInLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbCc7XG4gICAgfSxcbiAgICBzY29wZToge1xuICAgICAgZGF0ZXBpY2tlck1vZGU6ICc9PycsXG4gICAgICBkYXRlRGlzYWJsZWQ6ICcmJyxcbiAgICAgIGN1c3RvbUNsYXNzOiAnJicsXG4gICAgICBzaG9ydGN1dFByb3BhZ2F0aW9uOiAnJj8nXG4gICAgfSxcbiAgICByZXF1aXJlOiBbJ2RhdGVwaWNrZXInLCAnXm5nTW9kZWwnXSxcbiAgICBjb250cm9sbGVyOiAnRGF0ZXBpY2tlckNvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ2RhdGVwaWNrZXInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBkYXRlcGlja2VyQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBkYXRlcGlja2VyQ3RybC5pbml0KG5nTW9kZWxDdHJsKTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCdkYXlwaWNrZXInLCBbJ2RhdGVGaWx0ZXInLCBmdW5jdGlvbihkYXRlRmlsdGVyKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF5Lmh0bWwnLFxuICAgIHJlcXVpcmU6ICdeZGF0ZXBpY2tlcicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJsKSB7XG4gICAgICBzY29wZS5zaG93V2Vla3MgPSBjdHJsLnNob3dXZWVrcztcblxuICAgICAgY3RybC5zdGVwID0geyBtb250aHM6IDEgfTtcbiAgICAgIGN0cmwuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgIHZhciBEQVlTX0lOX01PTlRIID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuICAgICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgcmV0dXJuICgobW9udGggPT09IDEpICYmICh5ZWFyICUgNCA9PT0gMCkgJiYgKCh5ZWFyICUgMTAwICE9PSAwKSB8fCAoeWVhciAlIDQwMCA9PT0gMCkpKSA/IDI5IDogREFZU19JTl9NT05USFttb250aF07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldERhdGVzKHN0YXJ0RGF0ZSwgbikge1xuICAgICAgICB2YXIgZGF0ZXMgPSBuZXcgQXJyYXkobiksIGN1cnJlbnQgPSBuZXcgRGF0ZShzdGFydERhdGUpLCBpID0gMCwgZGF0ZTtcbiAgICAgICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGN1cnJlbnQpO1xuICAgICAgICAgIGN0cmwuZml4VGltZVpvbmUoZGF0ZSk7XG4gICAgICAgICAgZGF0ZXNbaSsrXSA9IGRhdGU7XG4gICAgICAgICAgY3VycmVudC5zZXREYXRlKGN1cnJlbnQuZ2V0RGF0ZSgpICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVzO1xuICAgICAgfVxuXG4gICAgICBjdHJsLl9yZWZyZXNoVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeWVhciA9IGN0cmwuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgIG1vbnRoID0gY3RybC5hY3RpdmVEYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgZmlyc3REYXlPZk1vbnRoID0gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpLFxuICAgICAgICAgIGRpZmZlcmVuY2UgPSBjdHJsLnN0YXJ0aW5nRGF5IC0gZmlyc3REYXlPZk1vbnRoLmdldERheSgpLFxuICAgICAgICAgIG51bURpc3BsYXllZEZyb21QcmV2aW91c01vbnRoID0gKGRpZmZlcmVuY2UgPiAwKSA/IDcgLSBkaWZmZXJlbmNlIDogLSBkaWZmZXJlbmNlLFxuICAgICAgICAgIGZpcnN0RGF0ZSA9IG5ldyBEYXRlKGZpcnN0RGF5T2ZNb250aCk7XG5cbiAgICAgICAgaWYgKG51bURpc3BsYXllZEZyb21QcmV2aW91c01vbnRoID4gMCkge1xuICAgICAgICAgIGZpcnN0RGF0ZS5zZXREYXRlKC1udW1EaXNwbGF5ZWRGcm9tUHJldmlvdXNNb250aCArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNDIgaXMgdGhlIG51bWJlciBvZiBkYXlzIG9uIGEgc2l4LW1vbnRoIGNhbGVuZGFyXG4gICAgICAgIHZhciBkYXlzID0gZ2V0RGF0ZXMoZmlyc3REYXRlLCA0Mik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDI7IGkgKyspIHtcbiAgICAgICAgICBkYXlzW2ldID0gYW5ndWxhci5leHRlbmQoY3RybC5jcmVhdGVEYXRlT2JqZWN0KGRheXNbaV0sIGN0cmwuZm9ybWF0RGF5KSwge1xuICAgICAgICAgICAgc2Vjb25kYXJ5OiBkYXlzW2ldLmdldE1vbnRoKCkgIT09IG1vbnRoLFxuICAgICAgICAgICAgdWlkOiBzY29wZS51bmlxdWVJZCArICctJyArIGlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLmxhYmVscyA9IG5ldyBBcnJheSg3KTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgICBzY29wZS5sYWJlbHNbal0gPSB7XG4gICAgICAgICAgICBhYmJyOiBkYXRlRmlsdGVyKGRheXNbal0uZGF0ZSwgY3RybC5mb3JtYXREYXlIZWFkZXIpLFxuICAgICAgICAgICAgZnVsbDogZGF0ZUZpbHRlcihkYXlzW2pdLmRhdGUsICdFRUVFJylcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUudGl0bGUgPSBkYXRlRmlsdGVyKGN0cmwuYWN0aXZlRGF0ZSwgY3RybC5mb3JtYXREYXlUaXRsZSk7XG4gICAgICAgIHNjb3BlLnJvd3MgPSBjdHJsLnNwbGl0KGRheXMsIDcpO1xuXG4gICAgICAgIGlmIChzY29wZS5zaG93V2Vla3MpIHtcbiAgICAgICAgICBzY29wZS53ZWVrTnVtYmVycyA9IFtdO1xuICAgICAgICAgIHZhciB0aHVyc2RheUluZGV4ID0gKDQgKyA3IC0gY3RybC5zdGFydGluZ0RheSkgJSA3LFxuICAgICAgICAgICAgICBudW1XZWVrcyA9IHNjb3BlLnJvd3MubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGN1cldlZWsgPSAwOyBjdXJXZWVrIDwgbnVtV2Vla3M7IGN1cldlZWsrKykge1xuICAgICAgICAgICAgc2NvcGUud2Vla051bWJlcnMucHVzaChcbiAgICAgICAgICAgICAgZ2V0SVNPODYwMVdlZWtOdW1iZXIoc2NvcGUucm93c1tjdXJXZWVrXVt0aHVyc2RheUluZGV4XS5kYXRlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjdHJsLmNvbXBhcmUgPSBmdW5jdGlvbihkYXRlMSwgZGF0ZTIpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgRGF0ZShkYXRlMS5nZXRGdWxsWWVhcigpLCBkYXRlMS5nZXRNb250aCgpLCBkYXRlMS5nZXREYXRlKCkpIC0gbmV3IERhdGUoZGF0ZTIuZ2V0RnVsbFllYXIoKSwgZGF0ZTIuZ2V0TW9udGgoKSwgZGF0ZTIuZ2V0RGF0ZSgpKSk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBnZXRJU084NjAxV2Vla051bWJlcihkYXRlKSB7XG4gICAgICAgIHZhciBjaGVja0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgY2hlY2tEYXRlLnNldERhdGUoY2hlY2tEYXRlLmdldERhdGUoKSArIDQgLSAoY2hlY2tEYXRlLmdldERheSgpIHx8IDcpKTsgLy8gVGh1cnNkYXlcbiAgICAgICAgdmFyIHRpbWUgPSBjaGVja0RhdGUuZ2V0VGltZSgpO1xuICAgICAgICBjaGVja0RhdGUuc2V0TW9udGgoMCk7IC8vIENvbXBhcmUgd2l0aCBKYW4gMVxuICAgICAgICBjaGVja0RhdGUuc2V0RGF0ZSgxKTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yb3VuZCgodGltZSAtIGNoZWNrRGF0ZSkgLyA4NjQwMDAwMCkgLyA3KSArIDE7XG4gICAgICB9XG5cbiAgICAgIGN0cmwuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uKGtleSwgZXZ0KSB7XG4gICAgICAgIHZhciBkYXRlID0gY3RybC5hY3RpdmVEYXRlLmdldERhdGUoKTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBkYXRlID0gZGF0ZSAtIDE7ICAgLy8gdXBcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICd1cCcpIHtcbiAgICAgICAgICBkYXRlID0gZGF0ZSAtIDc7ICAgLy8gZG93blxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGRhdGUgPSBkYXRlICsgMTsgICAvLyBkb3duXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZG93bicpIHtcbiAgICAgICAgICBkYXRlID0gZGF0ZSArIDc7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncGFnZXVwJyB8fCBrZXkgPT09ICdwYWdlZG93bicpIHtcbiAgICAgICAgICB2YXIgbW9udGggPSBjdHJsLmFjdGl2ZURhdGUuZ2V0TW9udGgoKSArIChrZXkgPT09ICdwYWdldXAnID8gLSAxIDogMSk7XG4gICAgICAgICAgY3RybC5hY3RpdmVEYXRlLnNldE1vbnRoKG1vbnRoLCAxKTtcbiAgICAgICAgICBkYXRlID0gTWF0aC5taW4oZ2V0RGF5c0luTW9udGgoY3RybC5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCksIGN0cmwuYWN0aXZlRGF0ZS5nZXRNb250aCgpKSwgZGF0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaG9tZScpIHtcbiAgICAgICAgICBkYXRlID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdlbmQnKSB7XG4gICAgICAgICAgZGF0ZSA9IGdldERheXNJbk1vbnRoKGN0cmwuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLCBjdHJsLmFjdGl2ZURhdGUuZ2V0TW9udGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3RybC5hY3RpdmVEYXRlLnNldERhdGUoZGF0ZSk7XG4gICAgICB9O1xuXG4gICAgICBjdHJsLnJlZnJlc2hWaWV3KCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ21vbnRocGlja2VyJywgWydkYXRlRmlsdGVyJywgZnVuY3Rpb24oZGF0ZUZpbHRlcikge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9kYXRlcGlja2VyL21vbnRoLmh0bWwnLFxuICAgIHJlcXVpcmU6ICdeZGF0ZXBpY2tlcicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJsKSB7XG4gICAgICBjdHJsLnN0ZXAgPSB7IHllYXJzOiAxIH07XG4gICAgICBjdHJsLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICBjdHJsLl9yZWZyZXNoVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbW9udGhzID0gbmV3IEFycmF5KDEyKSxcbiAgICAgICAgICAgIHllYXIgPSBjdHJsLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgIGRhdGU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIGksIDEpO1xuICAgICAgICAgIGN0cmwuZml4VGltZVpvbmUoZGF0ZSk7XG4gICAgICAgICAgbW9udGhzW2ldID0gYW5ndWxhci5leHRlbmQoY3RybC5jcmVhdGVEYXRlT2JqZWN0KGRhdGUsIGN0cmwuZm9ybWF0TW9udGgpLCB7XG4gICAgICAgICAgICB1aWQ6IHNjb3BlLnVuaXF1ZUlkICsgJy0nICsgaVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUudGl0bGUgPSBkYXRlRmlsdGVyKGN0cmwuYWN0aXZlRGF0ZSwgY3RybC5mb3JtYXRNb250aFRpdGxlKTtcbiAgICAgICAgc2NvcGUucm93cyA9IGN0cmwuc3BsaXQobW9udGhzLCAzKTtcbiAgICAgIH07XG5cbiAgICAgIGN0cmwuY29tcGFyZSA9IGZ1bmN0aW9uKGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZTEuZ2V0RnVsbFllYXIoKSwgZGF0ZTEuZ2V0TW9udGgoKSkgLSBuZXcgRGF0ZShkYXRlMi5nZXRGdWxsWWVhcigpLCBkYXRlMi5nZXRNb250aCgpKTtcbiAgICAgIH07XG5cbiAgICAgIGN0cmwuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uKGtleSwgZXZ0KSB7XG4gICAgICAgIHZhciBkYXRlID0gY3RybC5hY3RpdmVEYXRlLmdldE1vbnRoKCk7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgZGF0ZSA9IGRhdGUgLSAxOyAgIC8vIHVwXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAndXAnKSB7XG4gICAgICAgICAgZGF0ZSA9IGRhdGUgLSAzOyAgIC8vIGRvd25cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBkYXRlID0gZGF0ZSArIDE7ICAgLy8gZG93blxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2Rvd24nKSB7XG4gICAgICAgICAgZGF0ZSA9IGRhdGUgKyAzO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3BhZ2V1cCcgfHwga2V5ID09PSAncGFnZWRvd24nKSB7XG4gICAgICAgICAgdmFyIHllYXIgPSBjdHJsLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSArIChrZXkgPT09ICdwYWdldXAnID8gLSAxIDogMSk7XG4gICAgICAgICAgY3RybC5hY3RpdmVEYXRlLnNldEZ1bGxZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2hvbWUnKSB7XG4gICAgICAgICAgZGF0ZSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZW5kJykge1xuICAgICAgICAgIGRhdGUgPSAxMTtcbiAgICAgICAgfVxuICAgICAgICBjdHJsLmFjdGl2ZURhdGUuc2V0TW9udGgoZGF0ZSk7XG4gICAgICB9O1xuXG4gICAgICBjdHJsLnJlZnJlc2hWaWV3KCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3llYXJwaWNrZXInLCBbJ2RhdGVGaWx0ZXInLCBmdW5jdGlvbihkYXRlRmlsdGVyKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sJyxcbiAgICByZXF1aXJlOiAnXmRhdGVwaWNrZXInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybCkge1xuICAgICAgdmFyIHJhbmdlID0gY3RybC55ZWFyUmFuZ2U7XG5cbiAgICAgIGN0cmwuc3RlcCA9IHsgeWVhcnM6IHJhbmdlIH07XG4gICAgICBjdHJsLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICBmdW5jdGlvbiBnZXRTdGFydGluZ1llYXIoIHllYXIgKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCgoeWVhciAtIDEpIC8gcmFuZ2UsIDEwKSAqIHJhbmdlICsgMTtcbiAgICAgIH1cblxuICAgICAgY3RybC5fcmVmcmVzaFZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHllYXJzID0gbmV3IEFycmF5KHJhbmdlKSwgZGF0ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgc3RhcnQgPSBnZXRTdGFydGluZ1llYXIoY3RybC5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkpOyBpIDwgcmFuZ2U7IGkrKykge1xuICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShzdGFydCArIGksIDAsIDEpO1xuICAgICAgICAgIGN0cmwuZml4VGltZVpvbmUoZGF0ZSk7XG4gICAgICAgICAgeWVhcnNbaV0gPSBhbmd1bGFyLmV4dGVuZChjdHJsLmNyZWF0ZURhdGVPYmplY3QoZGF0ZSwgY3RybC5mb3JtYXRZZWFyKSwge1xuICAgICAgICAgICAgdWlkOiBzY29wZS51bmlxdWVJZCArICctJyArIGlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLnRpdGxlID0gW3llYXJzWzBdLmxhYmVsLCB5ZWFyc1tyYW5nZSAtIDFdLmxhYmVsXS5qb2luKCcgLSAnKTtcbiAgICAgICAgc2NvcGUucm93cyA9IGN0cmwuc3BsaXQoeWVhcnMsIDUpO1xuICAgICAgfTtcblxuICAgICAgY3RybC5jb21wYXJlID0gZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiBkYXRlMS5nZXRGdWxsWWVhcigpIC0gZGF0ZTIuZ2V0RnVsbFllYXIoKTtcbiAgICAgIH07XG5cbiAgICAgIGN0cmwuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uKGtleSwgZXZ0KSB7XG4gICAgICAgIHZhciBkYXRlID0gY3RybC5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgZGF0ZSA9IGRhdGUgLSAxOyAgIC8vIHVwXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAndXAnKSB7XG4gICAgICAgICAgZGF0ZSA9IGRhdGUgLSA1OyAgIC8vIGRvd25cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBkYXRlID0gZGF0ZSArIDE7ICAgLy8gZG93blxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2Rvd24nKSB7XG4gICAgICAgICAgZGF0ZSA9IGRhdGUgKyA1O1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3BhZ2V1cCcgfHwga2V5ID09PSAncGFnZWRvd24nKSB7XG4gICAgICAgICAgZGF0ZSArPSAoa2V5ID09PSAncGFnZXVwJyA/IC0gMSA6IDEpICogY3RybC5zdGVwLnllYXJzO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2hvbWUnKSB7XG4gICAgICAgICAgZGF0ZSA9IGdldFN0YXJ0aW5nWWVhcihjdHJsLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZW5kJykge1xuICAgICAgICAgIGRhdGUgPSBnZXRTdGFydGluZ1llYXIoY3RybC5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkpICsgcmFuZ2UgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGN0cmwuYWN0aXZlRGF0ZS5zZXRGdWxsWWVhcihkYXRlKTtcbiAgICAgIH07XG5cbiAgICAgIGN0cmwucmVmcmVzaFZpZXcoKTtcbiAgICB9XG4gIH07XG59XSlcblxuLmNvbnN0YW50KCdkYXRlcGlja2VyUG9wdXBDb25maWcnLCB7XG4gIGRhdGVwaWNrZXJQb3B1cDogJ3l5eXktTU0tZGQnLFxuICBkYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbCcsXG4gIGRhdGVwaWNrZXJUZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sJyxcbiAgaHRtbDVUeXBlczoge1xuICAgIGRhdGU6ICd5eXl5LU1NLWRkJyxcbiAgICAnZGF0ZXRpbWUtbG9jYWwnOiAneXl5eS1NTS1kZFRISDptbTpzcy5zc3MnLFxuICAgICdtb250aCc6ICd5eXl5LU1NJ1xuICB9LFxuICBjdXJyZW50VGV4dDogJ1RvZGF5JyxcbiAgY2xlYXJUZXh0OiAnQ2xlYXInLFxuICBjbG9zZVRleHQ6ICdEb25lJyxcbiAgY2xvc2VPbkRhdGVTZWxlY3Rpb246IHRydWUsXG4gIGFwcGVuZFRvQm9keTogZmFsc2UsXG4gIHNob3dCdXR0b25CYXI6IHRydWUsXG4gIG9uT3BlbkZvY3VzOiB0cnVlXG59KVxuXG4uZGlyZWN0aXZlKCdkYXRlcGlja2VyUG9wdXAnLCBbJyRjb21waWxlJywgJyRwYXJzZScsICckZG9jdW1lbnQnLCAnJHJvb3RTY29wZScsICckcG9zaXRpb24nLCAnZGF0ZUZpbHRlcicsICdkYXRlUGFyc2VyJywgJ2RhdGVwaWNrZXJQb3B1cENvbmZpZycsICckdGltZW91dCcsXG5mdW5jdGlvbigkY29tcGlsZSwgJHBhcnNlLCAkZG9jdW1lbnQsICRyb290U2NvcGUsICRwb3NpdGlvbiwgZGF0ZUZpbHRlciwgZGF0ZVBhcnNlciwgZGF0ZXBpY2tlclBvcHVwQ29uZmlnLCAkdGltZW91dCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICBzY29wZToge1xuICAgICAgaXNPcGVuOiAnPT8nLFxuICAgICAgY3VycmVudFRleHQ6ICdAJyxcbiAgICAgIGNsZWFyVGV4dDogJ0AnLFxuICAgICAgY2xvc2VUZXh0OiAnQCcsXG4gICAgICBkYXRlRGlzYWJsZWQ6ICcmJyxcbiAgICAgIGN1c3RvbUNsYXNzOiAnJidcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbmdNb2RlbCkge1xuICAgICAgdmFyIGRhdGVGb3JtYXQsXG4gICAgICAgICAgY2xvc2VPbkRhdGVTZWxlY3Rpb24gPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5jbG9zZU9uRGF0ZVNlbGVjdGlvbikgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmNsb3NlT25EYXRlU2VsZWN0aW9uKSA6IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5jbG9zZU9uRGF0ZVNlbGVjdGlvbixcbiAgICAgICAgICBhcHBlbmRUb0JvZHkgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5kYXRlcGlja2VyQXBwZW5kVG9Cb2R5KSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMuZGF0ZXBpY2tlckFwcGVuZFRvQm9keSkgOiBkYXRlcGlja2VyUG9wdXBDb25maWcuYXBwZW5kVG9Cb2R5LFxuICAgICAgICAgIG9uT3BlbkZvY3VzID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMub25PcGVuRm9jdXMpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy5vbk9wZW5Gb2N1cykgOiBkYXRlcGlja2VyUG9wdXBDb25maWcub25PcGVuRm9jdXMsXG4gICAgICAgICAgZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmwgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5kYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybCkgPyBhdHRycy5kYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybCA6IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5kYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybCxcbiAgICAgICAgICBkYXRlcGlja2VyVGVtcGxhdGVVcmwgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5kYXRlcGlja2VyVGVtcGxhdGVVcmwpID8gYXR0cnMuZGF0ZXBpY2tlclRlbXBsYXRlVXJsIDogZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmRhdGVwaWNrZXJUZW1wbGF0ZVVybCxcbiAgICAgICAgICBjYWNoZSA9IHt9O1xuXG4gICAgICBzY29wZS5zaG93QnV0dG9uQmFyID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuc2hvd0J1dHRvbkJhcikgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLnNob3dCdXR0b25CYXIpIDogZGF0ZXBpY2tlclBvcHVwQ29uZmlnLnNob3dCdXR0b25CYXI7XG5cbiAgICAgIHNjb3BlLmdldFRleHQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlW2tleSArICdUZXh0J10gfHwgZGF0ZXBpY2tlclBvcHVwQ29uZmlnW2tleSArICdUZXh0J107XG4gICAgICB9O1xuXG4gICAgICBzY29wZS5pc0Rpc2FibGVkID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICBpZiAoZGF0ZSA9PT0gJ3RvZGF5Jykge1xuICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgoc2NvcGUud2F0Y2hEYXRhLm1pbkRhdGUgJiYgc2NvcGUuY29tcGFyZShkYXRlLCBjYWNoZS5taW5EYXRlKSA8IDApIHx8XG4gICAgICAgICAgKHNjb3BlLndhdGNoRGF0YS5tYXhEYXRlICYmIHNjb3BlLmNvbXBhcmUoZGF0ZSwgY2FjaGUubWF4RGF0ZSkgPiAwKSk7XG4gICAgICB9O1xuXG4gICAgICBzY29wZS5jb21wYXJlID0gZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiAobmV3IERhdGUoZGF0ZTEuZ2V0RnVsbFllYXIoKSwgZGF0ZTEuZ2V0TW9udGgoKSwgZGF0ZTEuZ2V0RGF0ZSgpKSAtIG5ldyBEYXRlKGRhdGUyLmdldEZ1bGxZZWFyKCksIGRhdGUyLmdldE1vbnRoKCksIGRhdGUyLmdldERhdGUoKSkpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGlzSHRtbDVEYXRlSW5wdXQgPSBmYWxzZTtcbiAgICAgIGlmIChkYXRlcGlja2VyUG9wdXBDb25maWcuaHRtbDVUeXBlc1thdHRycy50eXBlXSkge1xuICAgICAgICBkYXRlRm9ybWF0ID0gZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmh0bWw1VHlwZXNbYXR0cnMudHlwZV07XG4gICAgICAgIGlzSHRtbDVEYXRlSW5wdXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZUZvcm1hdCA9IGF0dHJzLmRhdGVwaWNrZXJQb3B1cCB8fCBkYXRlcGlja2VyUG9wdXBDb25maWcuZGF0ZXBpY2tlclBvcHVwO1xuICAgICAgICBhdHRycy4kb2JzZXJ2ZSgnZGF0ZXBpY2tlclBvcHVwJywgZnVuY3Rpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbmV3RGF0ZUZvcm1hdCA9IHZhbHVlIHx8IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5kYXRlcGlja2VyUG9wdXA7XG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIHRoZSAkbW9kZWxWYWx1ZSB0byBlbnN1cmUgdGhhdCBmb3JtYXR0ZXJzIHJlLXJ1blxuICAgICAgICAgICAgLy8gRklYTUU6IFJlZmFjdG9yIHdoZW4gUFIgaXMgbWVyZ2VkOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL3B1bGwvMTA3NjRcbiAgICAgICAgICAgIGlmIChuZXdEYXRlRm9ybWF0ICE9PSBkYXRlRm9ybWF0KSB7XG4gICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBuZXdEYXRlRm9ybWF0O1xuICAgICAgICAgICAgICBuZ01vZGVsLiRtb2RlbFZhbHVlID0gbnVsbDtcblxuICAgICAgICAgICAgICBpZiAoIWRhdGVGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGVwaWNrZXJQb3B1cCBtdXN0IGhhdmUgYSBkYXRlIGZvcm1hdCBzcGVjaWZpZWQuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0ZUZvcm1hdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGVwaWNrZXJQb3B1cCBtdXN0IGhhdmUgYSBkYXRlIGZvcm1hdCBzcGVjaWZpZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0h0bWw1RGF0ZUlucHV0ICYmIGF0dHJzLmRhdGVwaWNrZXJQb3B1cCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hUTUw1IGRhdGUgaW5wdXQgdHlwZXMgZG8gbm90IHN1cHBvcnQgY3VzdG9tIGZvcm1hdHMuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHBvcHVwIGVsZW1lbnQgdXNlZCB0byBkaXNwbGF5IGNhbGVuZGFyXG4gICAgICB2YXIgcG9wdXBFbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiBkYXRlcGlja2VyLXBvcHVwLXdyYXA+PGRpdiBkYXRlcGlja2VyPjwvZGl2PjwvZGl2PicpO1xuICAgICAgcG9wdXBFbC5hdHRyKHtcbiAgICAgICAgJ25nLW1vZGVsJzogJ2RhdGUnLFxuICAgICAgICAnbmctY2hhbmdlJzogJ2RhdGVTZWxlY3Rpb24oZGF0ZSknLFxuICAgICAgICAndGVtcGxhdGUtdXJsJzogZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmxcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBjYW1lbHRvRGFzaChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uKCQxKSB7IHJldHVybiAnLScgKyAkMS50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gZGF0ZXBpY2tlciBlbGVtZW50XG4gICAgICB2YXIgZGF0ZXBpY2tlckVsID0gYW5ndWxhci5lbGVtZW50KHBvcHVwRWwuY2hpbGRyZW4oKVswXSk7XG4gICAgICBkYXRlcGlja2VyRWwuYXR0cigndGVtcGxhdGUtdXJsJywgZGF0ZXBpY2tlclRlbXBsYXRlVXJsKTtcblxuICAgICAgaWYgKGlzSHRtbDVEYXRlSW5wdXQpIHtcbiAgICAgICAgaWYgKGF0dHJzLnR5cGUgPT09ICdtb250aCcpIHtcbiAgICAgICAgICBkYXRlcGlja2VyRWwuYXR0cignZGF0ZXBpY2tlci1tb2RlJywgJ1wibW9udGhcIicpO1xuICAgICAgICAgIGRhdGVwaWNrZXJFbC5hdHRyKCdtaW4tbW9kZScsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRycy5kYXRlcGlja2VyT3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMuZGF0ZXBpY2tlck9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmluaXREYXRlKSB7XG4gICAgICAgICAgc2NvcGUuaW5pdERhdGUgPSBvcHRpb25zLmluaXREYXRlO1xuICAgICAgICAgIGRhdGVwaWNrZXJFbC5hdHRyKCdpbml0LWRhdGUnLCAnaW5pdERhdGUnKTtcbiAgICAgICAgICBkZWxldGUgb3B0aW9ucy5pbml0RGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBhbmd1bGFyLmZvckVhY2gob3B0aW9ucywgZnVuY3Rpb24odmFsdWUsIG9wdGlvbikge1xuICAgICAgICAgIGRhdGVwaWNrZXJFbC5hdHRyKCBjYW1lbHRvRGFzaChvcHRpb24pLCB2YWx1ZSApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2NvcGUud2F0Y2hEYXRhID0ge307XG4gICAgICBhbmd1bGFyLmZvckVhY2goWydtaW5Nb2RlJywgJ21heE1vZGUnLCAnbWluRGF0ZScsICdtYXhEYXRlJywgJ2RhdGVwaWNrZXJNb2RlJywgJ2luaXREYXRlJywgJ3Nob3J0Y3V0UHJvcGFnYXRpb24nXSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChhdHRyc1trZXldKSB7XG4gICAgICAgICAgdmFyIGdldEF0dHJpYnV0ZSA9ICRwYXJzZShhdHRyc1trZXldKTtcbiAgICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaChnZXRBdHRyaWJ1dGUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBzY29wZS53YXRjaERhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ21pbkRhdGUnIHx8IGtleSA9PT0gJ21heERhdGUnKSB7XG4gICAgICAgICAgICAgIGNhY2hlW2tleV0gPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGF0ZXBpY2tlckVsLmF0dHIoY2FtZWx0b0Rhc2goa2V5KSwgJ3dhdGNoRGF0YS4nICsga2V5KTtcblxuICAgICAgICAgIC8vIFByb3BhZ2F0ZSBjaGFuZ2VzIGZyb20gZGF0ZXBpY2tlciB0byBvdXRzaWRlXG4gICAgICAgICAgaWYgKGtleSA9PT0gJ2RhdGVwaWNrZXJNb2RlJykge1xuICAgICAgICAgICAgdmFyIHNldEF0dHJpYnV0ZSA9IGdldEF0dHJpYnV0ZS5hc3NpZ247XG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goJ3dhdGNoRGF0YS4nICsga2V5LCBmdW5jdGlvbih2YWx1ZSwgb2xkdmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihzZXRBdHRyaWJ1dGUpICYmIHZhbHVlICE9PSBvbGR2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZShzY29wZS4kcGFyZW50LCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoYXR0cnMuZGF0ZURpc2FibGVkKSB7XG4gICAgICAgIGRhdGVwaWNrZXJFbC5hdHRyKCdkYXRlLWRpc2FibGVkJywgJ2RhdGVEaXNhYmxlZCh7IGRhdGU6IGRhdGUsIG1vZGU6IG1vZGUgfSknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJzLnNob3dXZWVrcykge1xuICAgICAgICBkYXRlcGlja2VyRWwuYXR0cignc2hvdy13ZWVrcycsIGF0dHJzLnNob3dXZWVrcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRycy5jdXN0b21DbGFzcykge1xuICAgICAgICBkYXRlcGlja2VyRWwuYXR0cignY3VzdG9tLWNsYXNzJywgJ2N1c3RvbUNsYXNzKHsgZGF0ZTogZGF0ZSwgbW9kZTogbW9kZSB9KScpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYXJzZURhdGUodmlld1ZhbHVlKSB7XG4gICAgICAgIGlmIChhbmd1bGFyLmlzTnVtYmVyKHZpZXdWYWx1ZSkpIHtcbiAgICAgICAgICAvLyBwcmVzdW1hYmx5IHRpbWVzdGFtcCB0byBkYXRlIG9iamVjdFxuICAgICAgICAgIHZpZXdWYWx1ZSA9IG5ldyBEYXRlKHZpZXdWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZpZXdWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNEYXRlKHZpZXdWYWx1ZSkgJiYgIWlzTmFOKHZpZXdWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmlld1ZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNTdHJpbmcodmlld1ZhbHVlKSkge1xuICAgICAgICAgIHZhciBkYXRlID0gZGF0ZVBhcnNlci5wYXJzZSh2aWV3VmFsdWUsIGRhdGVGb3JtYXQsIHNjb3BlLmRhdGUpO1xuICAgICAgICAgIGlmIChpc05hTihkYXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmFsaWRhdG9yKG1vZGVsVmFsdWUsIHZpZXdWYWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBtb2RlbFZhbHVlIHx8IHZpZXdWYWx1ZTtcblxuICAgICAgICBpZiAoIWF0dHJzLm5nUmVxdWlyZWQgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5ndWxhci5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc0RhdGUodmFsdWUpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgIHZhciBkYXRlID0gZGF0ZVBhcnNlci5wYXJzZSh2YWx1ZSwgZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0h0bWw1RGF0ZUlucHV0KSB7XG4gICAgICAgIC8vIEludGVybmFsIEFQSSB0byBtYWludGFpbiB0aGUgY29ycmVjdCBuZy1pbnZhbGlkLVtrZXldIGNsYXNzXG4gICAgICAgIG5nTW9kZWwuJCRwYXJzZXJOYW1lID0gJ2RhdGUnO1xuICAgICAgICBuZ01vZGVsLiR2YWxpZGF0b3JzLmRhdGUgPSB2YWxpZGF0b3I7XG4gICAgICAgIG5nTW9kZWwuJHBhcnNlcnMudW5zaGlmdChwYXJzZURhdGUpO1xuICAgICAgICBuZ01vZGVsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBzY29wZS5kYXRlID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIG5nTW9kZWwuJGlzRW1wdHkodmFsdWUpID8gdmFsdWUgOiBkYXRlRmlsdGVyKHZhbHVlLCBkYXRlRm9ybWF0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZ01vZGVsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBzY29wZS5kYXRlID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gSW5uZXIgY2hhbmdlXG4gICAgICBzY29wZS5kYXRlU2VsZWN0aW9uID0gZnVuY3Rpb24oZHQpIHtcbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGR0KSkge1xuICAgICAgICAgIHNjb3BlLmRhdGUgPSBkdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0ZSA9IHNjb3BlLmRhdGUgPyBkYXRlRmlsdGVyKHNjb3BlLmRhdGUsIGRhdGVGb3JtYXQpIDogbnVsbDsgLy8gU2V0dGluZyB0byBOVUxMIGlzIG5lY2Vzc2FyeSBmb3IgZm9ybSB2YWxpZGF0b3JzIHRvIGZ1bmN0aW9uXG4gICAgICAgIGVsZW1lbnQudmFsKGRhdGUpO1xuICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUoZGF0ZSk7XG5cbiAgICAgICAgaWYgKGNsb3NlT25EYXRlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgZWxlbWVudFswXS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBEZXRlY3QgY2hhbmdlcyBpbiB0aGUgdmlldyBmcm9tIHRoZSB0ZXh0IGJveFxuICAgICAgbmdNb2RlbC4kdmlld0NoYW5nZUxpc3RlbmVycy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBzY29wZS5kYXRlID0gZGF0ZVBhcnNlci5wYXJzZShuZ01vZGVsLiR2aWV3VmFsdWUsIGRhdGVGb3JtYXQsIHNjb3BlLmRhdGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBkb2N1bWVudENsaWNrQmluZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChzY29wZS5pc09wZW4gJiYgIShlbGVtZW50WzBdLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgfHwgcG9wdXBFbFswXS5jb250YWlucyhldmVudC50YXJnZXQpKSkge1xuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5wdXRLZXlkb3duQmluZCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoZXZ0LndoaWNoID09PSAyNyAmJiBzY29wZS5pc09wZW4pIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxlbWVudFswXS5mb2N1cygpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2dC53aGljaCA9PT0gNDAgJiYgIXNjb3BlLmlzT3Blbikge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzY29wZS5pc09wZW4gPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZWxlbWVudC5iaW5kKCdrZXlkb3duJywgaW5wdXRLZXlkb3duQmluZCk7XG5cbiAgICAgIHNjb3BlLmtleWRvd24gPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKGV2dC53aGljaCA9PT0gMjcpIHtcbiAgICAgICAgICBzY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICBlbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNjb3BlLiR3YXRjaCgnaXNPcGVuJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgc2NvcGUucG9zaXRpb24gPSBhcHBlbmRUb0JvZHkgPyAkcG9zaXRpb24ub2Zmc2V0KGVsZW1lbnQpIDogJHBvc2l0aW9uLnBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgICAgIHNjb3BlLnBvc2l0aW9uLnRvcCA9IHNjb3BlLnBvc2l0aW9uLnRvcCArIGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0Jyk7XG5cbiAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChvbk9wZW5Gb2N1cykge1xuICAgICAgICAgICAgICBzY29wZS4kYnJvYWRjYXN0KCdkYXRlcGlja2VyLmZvY3VzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkZG9jdW1lbnQuYmluZCgnY2xpY2snLCBkb2N1bWVudENsaWNrQmluZCk7XG4gICAgICAgICAgfSwgMCwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRkb2N1bWVudC51bmJpbmQoJ2NsaWNrJywgZG9jdW1lbnRDbGlja0JpbmQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuc2VsZWN0ID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICBpZiAoZGF0ZSA9PT0gJ3RvZGF5Jykge1xuICAgICAgICAgIHZhciB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgaWYgKGFuZ3VsYXIuaXNEYXRlKHNjb3BlLmRhdGUpKSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoc2NvcGUuZGF0ZSk7XG4gICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHRvZGF5LmdldEZ1bGxZZWFyKCksIHRvZGF5LmdldE1vbnRoKCksIHRvZGF5LmdldERhdGUoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh0b2RheS5zZXRIb3VycygwLCAwLCAwLCAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNjb3BlLmRhdGVTZWxlY3Rpb24oZGF0ZSk7XG4gICAgICB9O1xuXG4gICAgICBzY29wZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgZWxlbWVudFswXS5mb2N1cygpO1xuICAgICAgfTtcblxuICAgICAgdmFyICRwb3B1cCA9ICRjb21waWxlKHBvcHVwRWwpKHNjb3BlKTtcbiAgICAgIC8vIFByZXZlbnQgalF1ZXJ5IGNhY2hlIG1lbW9yeSBsZWFrICh0ZW1wbGF0ZSBpcyBub3cgcmVkdW5kYW50IGFmdGVyIGxpbmtpbmcpXG4gICAgICBwb3B1cEVsLnJlbW92ZSgpO1xuXG4gICAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAgICRkb2N1bWVudC5maW5kKCdib2R5JykuYXBwZW5kKCRwb3B1cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmFmdGVyKCRwb3B1cCk7XG4gICAgICB9XG5cbiAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNjb3BlLmlzT3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJHBvcHVwLnJlbW92ZSgpO1xuICAgICAgICBlbGVtZW50LnVuYmluZCgna2V5ZG93bicsIGlucHV0S2V5ZG93bkJpbmQpO1xuICAgICAgICAkZG9jdW1lbnQudW5iaW5kKCdjbGljaycsIGRvY3VtZW50Q2xpY2tCaW5kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdkYXRlcGlja2VyUG9wdXBXcmFwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6J0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbCc7XG4gICAgfVxuICB9O1xufSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZHJvcGRvd24nLCBbJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbiddKVxuXG4uY29uc3RhbnQoJ2Ryb3Bkb3duQ29uZmlnJywge1xuICBvcGVuQ2xhc3M6ICdvcGVuJ1xufSlcblxuLnNlcnZpY2UoJ2Ryb3Bkb3duU2VydmljZScsIFsnJGRvY3VtZW50JywgJyRyb290U2NvcGUnLCBmdW5jdGlvbigkZG9jdW1lbnQsICRyb290U2NvcGUpIHtcbiAgdmFyIG9wZW5TY29wZSA9IG51bGw7XG5cbiAgdGhpcy5vcGVuID0gZnVuY3Rpb24oZHJvcGRvd25TY29wZSkge1xuICAgIGlmICghb3BlblNjb3BlKSB7XG4gICAgICAkZG9jdW1lbnQuYmluZCgnY2xpY2snLCBjbG9zZURyb3Bkb3duKTtcbiAgICAgICRkb2N1bWVudC5iaW5kKCdrZXlkb3duJywga2V5YmluZEZpbHRlcik7XG4gICAgfVxuXG4gICAgaWYgKG9wZW5TY29wZSAmJiBvcGVuU2NvcGUgIT09IGRyb3Bkb3duU2NvcGUpIHtcbiAgICAgIG9wZW5TY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBvcGVuU2NvcGUgPSBkcm9wZG93blNjb3BlO1xuICB9O1xuXG4gIHRoaXMuY2xvc2UgPSBmdW5jdGlvbihkcm9wZG93blNjb3BlKSB7XG4gICAgaWYgKG9wZW5TY29wZSA9PT0gZHJvcGRvd25TY29wZSkge1xuICAgICAgb3BlblNjb3BlID0gbnVsbDtcbiAgICAgICRkb2N1bWVudC51bmJpbmQoJ2NsaWNrJywgY2xvc2VEcm9wZG93bik7XG4gICAgICAkZG9jdW1lbnQudW5iaW5kKCdrZXlkb3duJywga2V5YmluZEZpbHRlcik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjbG9zZURyb3Bkb3duID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgLy8gVGhpcyBtZXRob2QgbWF5IHN0aWxsIGJlIGNhbGxlZCBkdXJpbmcgdGhlIHNhbWUgbW91c2UgZXZlbnQgdGhhdFxuICAgIC8vIHVuYm91bmQgdGhpcyBldmVudCBoYW5kbGVyLiBTbyBjaGVjayBvcGVuU2NvcGUgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgaWYgKCFvcGVuU2NvcGUpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoZXZ0ICYmIG9wZW5TY29wZS5nZXRBdXRvQ2xvc2UoKSA9PT0gJ2Rpc2FibGVkJykgIHsgcmV0dXJuIDsgfVxuXG4gICAgdmFyIHRvZ2dsZUVsZW1lbnQgPSBvcGVuU2NvcGUuZ2V0VG9nZ2xlRWxlbWVudCgpO1xuICAgIGlmIChldnQgJiYgdG9nZ2xlRWxlbWVudCAmJiB0b2dnbGVFbGVtZW50WzBdLmNvbnRhaW5zKGV2dC50YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRyb3Bkb3duRWxlbWVudCA9IG9wZW5TY29wZS5nZXREcm9wZG93bkVsZW1lbnQoKTtcbiAgICBpZiAoZXZ0ICYmIG9wZW5TY29wZS5nZXRBdXRvQ2xvc2UoKSA9PT0gJ291dHNpZGVDbGljaycgJiZcbiAgICAgIGRyb3Bkb3duRWxlbWVudCAmJiBkcm9wZG93bkVsZW1lbnRbMF0uY29udGFpbnMoZXZ0LnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcGVuU2NvcGUuaXNPcGVuID0gZmFsc2U7XG5cbiAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgb3BlblNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIga2V5YmluZEZpbHRlciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIGlmIChldnQud2hpY2ggPT09IDI3KSB7XG4gICAgICBvcGVuU2NvcGUuZm9jdXNUb2dnbGVFbGVtZW50KCk7XG4gICAgICBjbG9zZURyb3Bkb3duKCk7XG4gICAgfSBlbHNlIGlmIChvcGVuU2NvcGUuaXNLZXluYXZFbmFibGVkKCkgJiYgLygzOHw0MCkvLnRlc3QoZXZ0LndoaWNoKSAmJiBvcGVuU2NvcGUuaXNPcGVuKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIG9wZW5TY29wZS5mb2N1c0Ryb3Bkb3duRW50cnkoZXZ0LndoaWNoKTtcbiAgICB9XG4gIH07XG59XSlcblxuLmNvbnRyb2xsZXIoJ0Ryb3Bkb3duQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICckcGFyc2UnLCAnZHJvcGRvd25Db25maWcnLCAnZHJvcGRvd25TZXJ2aWNlJywgJyRhbmltYXRlJywgJyRwb3NpdGlvbicsICckZG9jdW1lbnQnLCAnJGNvbXBpbGUnLCAnJHRlbXBsYXRlUmVxdWVzdCcsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCAkcGFyc2UsIGRyb3Bkb3duQ29uZmlnLCBkcm9wZG93blNlcnZpY2UsICRhbmltYXRlLCAkcG9zaXRpb24sICRkb2N1bWVudCwgJGNvbXBpbGUsICR0ZW1wbGF0ZVJlcXVlc3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgIHNjb3BlID0gJHNjb3BlLiRuZXcoKSwgLy8gY3JlYXRlIGEgY2hpbGQgc2NvcGUgc28gd2UgYXJlIG5vdCBwb2xsdXRpbmcgb3JpZ2luYWwgb25lXG4gICAgdGVtcGxhdGVTY29wZSxcbiAgICBvcGVuQ2xhc3MgPSBkcm9wZG93bkNvbmZpZy5vcGVuQ2xhc3MsXG4gICAgZ2V0SXNPcGVuLFxuICAgIHNldElzT3BlbiA9IGFuZ3VsYXIubm9vcCxcbiAgICB0b2dnbGVJbnZva2VyID0gJGF0dHJzLm9uVG9nZ2xlID8gJHBhcnNlKCRhdHRycy5vblRvZ2dsZSkgOiBhbmd1bGFyLm5vb3AsXG4gICAgYXBwZW5kVG9Cb2R5ID0gZmFsc2UsXG4gICAga2V5bmF2RW5hYmxlZCA9IGZhbHNlLFxuICAgIHNlbGVjdGVkT3B0aW9uID0gbnVsbCxcbiAgICBib2R5ID0gJGRvY3VtZW50LmZpbmQoJ2JvZHknKTtcblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgc2VsZi4kZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICBpZiAoJGF0dHJzLmlzT3Blbikge1xuICAgICAgZ2V0SXNPcGVuID0gJHBhcnNlKCRhdHRycy5pc09wZW4pO1xuICAgICAgc2V0SXNPcGVuID0gZ2V0SXNPcGVuLmFzc2lnbjtcblxuICAgICAgJHNjb3BlLiR3YXRjaChnZXRJc09wZW4sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHNjb3BlLmlzT3BlbiA9ICEhdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhcHBlbmRUb0JvZHkgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuZHJvcGRvd25BcHBlbmRUb0JvZHkpO1xuICAgIGtleW5hdkVuYWJsZWQgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMua2V5Ym9hcmROYXYpO1xuXG4gICAgaWYgKGFwcGVuZFRvQm9keSAmJiBzZWxmLmRyb3Bkb3duTWVudSkge1xuICAgICAgYm9keS5hcHBlbmQoc2VsZi5kcm9wZG93bk1lbnUpO1xuICAgICAgYm9keS5hZGRDbGFzcygnZHJvcGRvd24nKTtcbiAgICAgIGVsZW1lbnQub24oJyRkZXN0cm95JywgZnVuY3Rpb24gaGFuZGxlRGVzdHJveUV2ZW50KCkge1xuICAgICAgICBzZWxmLmRyb3Bkb3duTWVudS5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLnRvZ2dsZSA9IGZ1bmN0aW9uKG9wZW4pIHtcbiAgICByZXR1cm4gc2NvcGUuaXNPcGVuID0gYXJndW1lbnRzLmxlbmd0aCA/ICEhb3BlbiA6ICFzY29wZS5pc09wZW47XG4gIH07XG5cbiAgLy8gQWxsb3cgb3RoZXIgZGlyZWN0aXZlcyB0byB3YXRjaCBzdGF0dXNcbiAgdGhpcy5pc09wZW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2NvcGUuaXNPcGVuO1xuICB9O1xuXG4gIHNjb3BlLmdldFRvZ2dsZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi50b2dnbGVFbGVtZW50O1xuICB9O1xuXG4gIHNjb3BlLmdldEF1dG9DbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAkYXR0cnMuYXV0b0Nsb3NlIHx8ICdhbHdheXMnOyAvL29yICdvdXRzaWRlQ2xpY2snIG9yICdkaXNhYmxlZCdcbiAgfTtcblxuICBzY29wZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuJGVsZW1lbnQ7XG4gIH07XG5cbiAgc2NvcGUuaXNLZXluYXZFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGtleW5hdkVuYWJsZWQ7XG4gIH07XG5cbiAgc2NvcGUuZm9jdXNEcm9wZG93bkVudHJ5ID0gZnVuY3Rpb24oa2V5Q29kZSkge1xuICAgIHZhciBlbGVtcyA9IHNlbGYuZHJvcGRvd25NZW51ID8gLy9JZiBhcHBlbmQgdG8gYm9keSBpcyB1c2VkLlxuICAgICAgKGFuZ3VsYXIuZWxlbWVudChzZWxmLmRyb3Bkb3duTWVudSkuZmluZCgnYScpKSA6XG4gICAgICAoYW5ndWxhci5lbGVtZW50KHNlbGYuJGVsZW1lbnQpLmZpbmQoJ3VsJykuZXEoMCkuZmluZCgnYScpKTtcblxuICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgY2FzZSAoNDApOiB7XG4gICAgICAgIGlmICghYW5ndWxhci5pc051bWJlcihzZWxmLnNlbGVjdGVkT3B0aW9uKSkge1xuICAgICAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gPSAoc2VsZi5zZWxlY3RlZE9wdGlvbiA9PT0gZWxlbXMubGVuZ3RoIC0xID9cbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gOlxuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAoMzgpOiB7XG4gICAgICAgIGlmICghYW5ndWxhci5pc051bWJlcihzZWxmLnNlbGVjdGVkT3B0aW9uKSkge1xuICAgICAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gPSBlbGVtcy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gPSBzZWxmLnNlbGVjdGVkT3B0aW9uID09PSAwID9cbiAgICAgICAgICAgIDAgOiBzZWxmLnNlbGVjdGVkT3B0aW9uIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxlbXNbc2VsZi5zZWxlY3RlZE9wdGlvbl0uZm9jdXMoKTtcbiAgfTtcblxuICBzY29wZS5nZXREcm9wZG93bkVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5kcm9wZG93bk1lbnU7XG4gIH07XG5cbiAgc2NvcGUuZm9jdXNUb2dnbGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYudG9nZ2xlRWxlbWVudCkge1xuICAgICAgc2VsZi50b2dnbGVFbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIHNjb3BlLiR3YXRjaCgnaXNPcGVuJywgZnVuY3Rpb24oaXNPcGVuLCB3YXNPcGVuKSB7XG4gICAgaWYgKGFwcGVuZFRvQm9keSAmJiBzZWxmLmRyb3Bkb3duTWVudSkge1xuICAgICAgdmFyIHBvcyA9ICRwb3NpdGlvbi5wb3NpdGlvbkVsZW1lbnRzKHNlbGYuJGVsZW1lbnQsIHNlbGYuZHJvcGRvd25NZW51LCAnYm90dG9tLWxlZnQnLCB0cnVlKTtcbiAgICAgIHZhciBjc3MgPSB7XG4gICAgICAgIHRvcDogcG9zLnRvcCArICdweCcsXG4gICAgICAgIGRpc3BsYXk6IGlzT3BlbiA/ICdibG9jaycgOiAnbm9uZSdcbiAgICAgIH07XG5cbiAgICAgIHZhciByaWdodGFsaWduID0gc2VsZi5kcm9wZG93bk1lbnUuaGFzQ2xhc3MoJ2Ryb3Bkb3duLW1lbnUtcmlnaHQnKTtcbiAgICAgIGlmICghcmlnaHRhbGlnbikge1xuICAgICAgICBjc3MubGVmdCA9IHBvcy5sZWZ0ICsgJ3B4JztcbiAgICAgICAgY3NzLnJpZ2h0ID0gJ2F1dG8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3NzLmxlZnQgPSAnYXV0byc7XG4gICAgICAgIGNzcy5yaWdodCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIChwb3MubGVmdCArIHNlbGYuJGVsZW1lbnQucHJvcCgnb2Zmc2V0V2lkdGgnKSkpICsgJ3B4JztcbiAgICAgIH1cblxuICAgICAgc2VsZi5kcm9wZG93bk1lbnUuY3NzKGNzcyk7XG4gICAgfVxuXG4gICAgdmFyIG9wZW5Db250YWluZXIgPSBhcHBlbmRUb0JvZHkgPyBib2R5IDogc2VsZi4kZWxlbWVudDtcblxuICAgICRhbmltYXRlW2lzT3BlbiA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShvcGVuQ29udGFpbmVyLCBvcGVuQ2xhc3MpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoaXNPcGVuKSAmJiBpc09wZW4gIT09IHdhc09wZW4pIHtcbiAgICAgICAgdG9nZ2xlSW52b2tlcigkc2NvcGUsIHsgb3BlbjogISFpc09wZW4gfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoaXNPcGVuKSB7XG4gICAgICBpZiAoc2VsZi5kcm9wZG93bk1lbnVUZW1wbGF0ZVVybCkge1xuICAgICAgICAkdGVtcGxhdGVSZXF1ZXN0KHNlbGYuZHJvcGRvd25NZW51VGVtcGxhdGVVcmwpLnRoZW4oZnVuY3Rpb24odHBsQ29udGVudCkge1xuICAgICAgICAgIHRlbXBsYXRlU2NvcGUgPSBzY29wZS4kbmV3KCk7XG4gICAgICAgICAgJGNvbXBpbGUodHBsQ29udGVudC50cmltKCkpKHRlbXBsYXRlU2NvcGUsIGZ1bmN0aW9uKGRyb3Bkb3duRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIG5ld0VsID0gZHJvcGRvd25FbGVtZW50O1xuICAgICAgICAgICAgc2VsZi5kcm9wZG93bk1lbnUucmVwbGFjZVdpdGgobmV3RWwpO1xuICAgICAgICAgICAgc2VsZi5kcm9wZG93bk1lbnUgPSBuZXdFbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNjb3BlLmZvY3VzVG9nZ2xlRWxlbWVudCgpO1xuICAgICAgZHJvcGRvd25TZXJ2aWNlLm9wZW4oc2NvcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2VsZi5kcm9wZG93bk1lbnVUZW1wbGF0ZVVybCkge1xuICAgICAgICBpZiAodGVtcGxhdGVTY29wZSkge1xuICAgICAgICAgIHRlbXBsYXRlU2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3RWwgPSBhbmd1bGFyLmVsZW1lbnQoJzx1bCBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIj48L3VsPicpO1xuICAgICAgICBzZWxmLmRyb3Bkb3duTWVudS5yZXBsYWNlV2l0aChuZXdFbCk7XG4gICAgICAgIHNlbGYuZHJvcGRvd25NZW51ID0gbmV3RWw7XG4gICAgICB9XG5cbiAgICAgIGRyb3Bkb3duU2VydmljZS5jbG9zZShzY29wZSk7XG4gICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoYW5ndWxhci5pc0Z1bmN0aW9uKHNldElzT3BlbikpIHtcbiAgICAgIHNldElzT3Blbigkc2NvcGUsIGlzT3Blbik7XG4gICAgfVxuICB9KTtcblxuICAkc2NvcGUuJG9uKCckbG9jYXRpb25DaGFuZ2VTdWNjZXNzJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNjb3BlLmdldEF1dG9DbG9zZSgpICE9PSAnZGlzYWJsZWQnKSB7XG4gICAgICBzY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBvZmZEZXN0cm95ID0gJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICBzY29wZS4kZGVzdHJveSgpO1xuICB9KTtcbiAgc2NvcGUuJG9uKCckZGVzdHJveScsIG9mZkRlc3Ryb3kpO1xufV0pXG5cbi5kaXJlY3RpdmUoJ2Ryb3Bkb3duJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgY29udHJvbGxlcjogJ0Ryb3Bkb3duQ29udHJvbGxlcicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBkcm9wZG93bkN0cmwpIHtcbiAgICAgIGRyb3Bkb3duQ3RybC5pbml0KCBlbGVtZW50ICk7XG4gICAgICBlbGVtZW50LmFkZENsYXNzKCdkcm9wZG93bicpO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ2Ryb3Bkb3duTWVudScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQUMnLFxuICAgIHJlcXVpcmU6ICc/XmRyb3Bkb3duJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGRyb3Bkb3duQ3RybCkge1xuICAgICAgaWYgKCFkcm9wZG93bkN0cmwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRwbFVybCA9IGF0dHJzLnRlbXBsYXRlVXJsO1xuICAgICAgaWYgKHRwbFVybCkge1xuICAgICAgICBkcm9wZG93bkN0cmwuZHJvcGRvd25NZW51VGVtcGxhdGVVcmwgPSB0cGxVcmw7XG4gICAgICB9XG4gICAgICBpZiAoIWRyb3Bkb3duQ3RybC5kcm9wZG93bk1lbnUpIHtcbiAgICAgICAgZHJvcGRvd25DdHJsLmRyb3Bkb3duTWVudSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgna2V5Ym9hcmROYXYnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHJlcXVpcmU6ICc/XmRyb3Bkb3duJyxcbiAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBkcm9wZG93bkN0cmwpIHtcblxuICAgICAgZWxlbWVudC5iaW5kKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoWzM4LCA0MF0uaW5kZXhPZihlLndoaWNoKSAhPT0gLTEpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgIHZhciBlbGVtcyA9IGRyb3Bkb3duQ3RybC5kcm9wZG93bk1lbnUuZmluZCgnYScpO1xuXG4gICAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICAgICAgICBjYXNlICg0MCk6IHsgLy8gRG93blxuICAgICAgICAgICAgICBpZiAoIWFuZ3VsYXIuaXNOdW1iZXIoZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uID0gZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uID09PSBlbGVtcy5sZW5ndGggLTEgP1xuICAgICAgICAgICAgICAgICAgZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uIDogZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgKDM4KTogeyAvLyBVcFxuICAgICAgICAgICAgICBpZiAoIWFuZ3VsYXIuaXNOdW1iZXIoZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA9IGVsZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uID0gZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uID09PSAwID9cbiAgICAgICAgICAgICAgICAgIDAgOiBkcm9wZG93bkN0cmwuc2VsZWN0ZWRPcHRpb24gLSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtc1tkcm9wZG93bkN0cmwuc2VsZWN0ZWRPcHRpb25dLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ2Ryb3Bkb3duVG9nZ2xlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogJz9eZHJvcGRvd24nLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgZHJvcGRvd25DdHJsKSB7XG4gICAgICBpZiAoIWRyb3Bkb3duQ3RybCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2Ryb3Bkb3duLXRvZ2dsZScpO1xuXG4gICAgICBkcm9wZG93bkN0cmwudG9nZ2xlRWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgIHZhciB0b2dnbGVEcm9wZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCFlbGVtZW50Lmhhc0NsYXNzKCdkaXNhYmxlZCcpICYmICFhdHRycy5kaXNhYmxlZCkge1xuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRyb3Bkb3duQ3RybC50b2dnbGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZWxlbWVudC5iaW5kKCdjbGljaycsIHRvZ2dsZURyb3Bkb3duKTtcblxuICAgICAgLy8gV0FJLUFSSUFcbiAgICAgIGVsZW1lbnQuYXR0cih7ICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSwgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSB9KTtcbiAgICAgIHNjb3BlLiR3YXRjaChkcm9wZG93bkN0cmwuaXNPcGVuLCBmdW5jdGlvbiggaXNPcGVuICkge1xuICAgICAgICBlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAhIWlzT3Blbik7XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBlbGVtZW50LnVuYmluZCgnY2xpY2snLCB0b2dnbGVEcm9wZG93bik7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5tb2RhbCcsIFtdKVxuXG4vKipcbiAqIEEgaGVscGVyLCBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZSB0aGF0IGFjdHMgYXMgYSBtYXAgYnV0IGFsc28gYWxsb3dzIGdldHRpbmcgLyByZW1vdmluZ1xuICogZWxlbWVudHMgaW4gdGhlIExJRk8gb3JkZXJcbiAqL1xuICAuZmFjdG9yeSgnJCRzdGFja2VkTWFwJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZU5ldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFjayA9IFtdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWRkOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoa2V5ID09IHN0YWNrW2ldLmtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFja1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBrZXlzLnB1c2goc3RhY2tbaV0ua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShpZHgsIDEpWzBdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlVG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5zcGxpY2Uoc3RhY2subGVuZ3RoIC0gMSwgMSlbMF07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSlcblxuLyoqXG4gKiBBIGhlbHBlciwgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBzdG9yZXMgYWxsIHJlZmVyZW5jZXMgYXR0YWNoZWQgdG8ga2V5XG4gKi9cbiAgLmZhY3RvcnkoJyQkbXVsdGlNYXAnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlTmV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1hcCA9IHt9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZW50cmllczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobWFwKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1hcFtrZXldXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwW2tleV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYXNLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuICEhbWFwW2tleV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBrZXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcHV0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIW1hcFtrZXldKSB7XG4gICAgICAgICAgICAgIG1hcFtrZXldID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hcFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gbWFwW2tleV07XG5cbiAgICAgICAgICAgIGlmICghdmFsdWVzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlkeCA9IHZhbHVlcy5pbmRleE9mKHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG1hcFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9KVxuXG4vKipcbiAqIEEgaGVscGVyIGRpcmVjdGl2ZSBmb3IgdGhlICRtb2RhbCBzZXJ2aWNlLiBJdCBjcmVhdGVzIGEgYmFja2Ryb3AgZWxlbWVudC5cbiAqL1xuICAuZGlyZWN0aXZlKCdtb2RhbEJhY2tkcm9wJywgW1xuICAgICAgICAgICAnJGFuaW1hdGUnLCAnJGluamVjdG9yJywgJyRtb2RhbFN0YWNrJyxcbiAgZnVuY3Rpb24oJGFuaW1hdGUgLCAgJGluamVjdG9yLCAgICRtb2RhbFN0YWNrKSB7XG4gICAgdmFyICRhbmltYXRlQ3NzID0gbnVsbDtcblxuICAgIGlmICgkaW5qZWN0b3IuaGFzKCckYW5pbWF0ZUNzcycpKSB7XG4gICAgICAkYW5pbWF0ZUNzcyA9ICRpbmplY3Rvci5nZXQoJyRhbmltYXRlQ3NzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvbW9kYWwvYmFja2Ryb3AuaHRtbCcsXG4gICAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XG4gICAgICAgIHRFbGVtZW50LmFkZENsYXNzKHRBdHRycy5iYWNrZHJvcENsYXNzKTtcbiAgICAgICAgcmV0dXJuIGxpbmtGbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbGlua0ZuKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgaWYgKGF0dHJzLm1vZGFsSW5DbGFzcykge1xuICAgICAgICBpZiAoJGFuaW1hdGVDc3MpIHtcbiAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICBhZGRDbGFzczogYXR0cnMubW9kYWxJbkNsYXNzXG4gICAgICAgICAgfSkuc3RhcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkYW5pbWF0ZS5hZGRDbGFzcyhlbGVtZW50LCBhdHRycy5tb2RhbEluQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUuJG9uKCRtb2RhbFN0YWNrLk5PV19DTE9TSU5HX0VWRU5ULCBmdW5jdGlvbihlLCBzZXRJc0FzeW5jKSB7XG4gICAgICAgICAgdmFyIGRvbmUgPSBzZXRJc0FzeW5jKCk7XG4gICAgICAgICAgaWYgKCRhbmltYXRlQ3NzKSB7XG4gICAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICAgIHJlbW92ZUNsYXNzOiBhdHRycy5tb2RhbEluQ2xhc3NcbiAgICAgICAgICAgIH0pLnN0YXJ0KCkudGhlbihkb25lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGFuaW1hdGUucmVtb3ZlQ2xhc3MoZWxlbWVudCwgYXR0cnMubW9kYWxJbkNsYXNzKS50aGVuKGRvbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XSlcblxuICAuZGlyZWN0aXZlKCdtb2RhbFdpbmRvdycsIFtcbiAgICAgICAgICAgJyRtb2RhbFN0YWNrJywgJyRxJywgJyRhbmltYXRlJywgJyRpbmplY3RvcicsXG4gIGZ1bmN0aW9uKCRtb2RhbFN0YWNrICwgICRxICwgICRhbmltYXRlLCAgICRpbmplY3Rvcikge1xuICAgIHZhciAkYW5pbWF0ZUNzcyA9IG51bGw7XG5cbiAgICBpZiAoJGluamVjdG9yLmhhcygnJGFuaW1hdGVDc3MnKSkge1xuICAgICAgJGFuaW1hdGVDc3MgPSAkaW5qZWN0b3IuZ2V0KCckYW5pbWF0ZUNzcycpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0VBJyxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGluZGV4OiAnQCdcbiAgICAgIH0sXG4gICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XG4gICAgICAgIHJldHVybiB0QXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sJztcbiAgICAgIH0sXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhhdHRycy53aW5kb3dDbGFzcyB8fCAnJyk7XG4gICAgICAgIHNjb3BlLnNpemUgPSBhdHRycy5zaXplO1xuXG4gICAgICAgIHNjb3BlLmNsb3NlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgdmFyIG1vZGFsID0gJG1vZGFsU3RhY2suZ2V0VG9wKCk7XG4gICAgICAgICAgaWYgKG1vZGFsICYmIG1vZGFsLnZhbHVlLmJhY2tkcm9wICYmIG1vZGFsLnZhbHVlLmJhY2tkcm9wICE9PSAnc3RhdGljJyAmJiAoZXZ0LnRhcmdldCA9PT0gZXZ0LmN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICRtb2RhbFN0YWNrLmRpc21pc3MobW9kYWwua2V5LCAnYmFja2Ryb3AgY2xpY2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBvbmx5IGFkZGVkIHRvIHRoZSBzY29wZSBmb3IgdGhlIHB1cnBvc2Ugb2YgZGV0ZWN0aW5nIHdoZW4gdGhpcyBkaXJlY3RpdmUgaXMgcmVuZGVyZWQuXG4gICAgICAgIC8vIFdlIGNhbiBkZXRlY3QgdGhhdCBieSB1c2luZyB0aGlzIHByb3BlcnR5IGluIHRoZSB0ZW1wbGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBkaXJlY3RpdmUgYW5kIHRoZW4gdXNlXG4gICAgICAgIC8vIHtAbGluayBBdHRyaWJ1dGUjJG9ic2VydmV9IG9uIGl0LiBGb3IgbW9yZSBkZXRhaWxzIHBsZWFzZSBzZWUge0BsaW5rIFRhYmxlQ29sdW1uUmVzaXplfS5cbiAgICAgICAgc2NvcGUuJGlzUmVuZGVyZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIERlZmVycmVkIG9iamVjdCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGlzIG1vZGFsIGlzIHJlbmRlci5cbiAgICAgICAgdmFyIG1vZGFsUmVuZGVyRGVmZXJPYmogPSAkcS5kZWZlcigpO1xuICAgICAgICAvLyBPYnNlcnZlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9uIG5leHQgZGlnZXN0IGN5Y2xlIGFmdGVyIGNvbXBpbGF0aW9uLCBlbnN1cmluZyB0aGF0IHRoZSBET00gaXMgcmVhZHkuXG4gICAgICAgIC8vIEluIG9yZGVyIHRvIHVzZSB0aGlzIHdheSBvZiBmaW5kaW5nIHdoZXRoZXIgRE9NIGlzIHJlYWR5LCB3ZSBuZWVkIHRvIG9ic2VydmUgYSBzY29wZSBwcm9wZXJ0eSB1c2VkIGluIG1vZGFsJ3MgdGVtcGxhdGUuXG4gICAgICAgIGF0dHJzLiRvYnNlcnZlKCdtb2RhbFJlbmRlcicsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09ICd0cnVlJykge1xuICAgICAgICAgICAgbW9kYWxSZW5kZXJEZWZlck9iai5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtb2RhbFJlbmRlckRlZmVyT2JqLnByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYW5pbWF0aW9uUHJvbWlzZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoYXR0cnMubW9kYWxJbkNsYXNzKSB7XG4gICAgICAgICAgICBpZiAoJGFuaW1hdGVDc3MpIHtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uUHJvbWlzZSA9ICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzczogYXR0cnMubW9kYWxJbkNsYXNzXG4gICAgICAgICAgICAgIH0pLnN0YXJ0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbmltYXRpb25Qcm9taXNlID0gJGFuaW1hdGUuYWRkQ2xhc3MoZWxlbWVudCwgYXR0cnMubW9kYWxJbkNsYXNzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NvcGUuJG9uKCRtb2RhbFN0YWNrLk5PV19DTE9TSU5HX0VWRU5ULCBmdW5jdGlvbihlLCBzZXRJc0FzeW5jKSB7XG4gICAgICAgICAgICAgIHZhciBkb25lID0gc2V0SXNBc3luYygpO1xuICAgICAgICAgICAgICBpZiAoJGFuaW1hdGVDc3MpIHtcbiAgICAgICAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICByZW1vdmVDbGFzczogYXR0cnMubW9kYWxJbkNsYXNzXG4gICAgICAgICAgICAgICAgfSkuc3RhcnQoKS50aGVuKGRvbmUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRhbmltYXRlLnJlbW92ZUNsYXNzKGVsZW1lbnQsIGF0dHJzLm1vZGFsSW5DbGFzcykudGhlbihkb25lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICAkcS53aGVuKGFuaW1hdGlvblByb21pc2UpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRzV2l0aEF1dG9mb2N1cyA9IGVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnW2F1dG9mb2N1c10nKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXV0by1mb2N1c2luZyBvZiBhIGZyZXNobHktb3BlbmVkIG1vZGFsIGVsZW1lbnQgY2F1c2VzIGFueSBjaGlsZCBlbGVtZW50c1xuICAgICAgICAgICAgICogd2l0aCB0aGUgYXV0b2ZvY3VzIGF0dHJpYnV0ZSB0byBsb3NlIGZvY3VzLiBUaGlzIGlzIGFuIGlzc3VlIG9uIHRvdWNoXG4gICAgICAgICAgICAgKiBiYXNlZCBkZXZpY2VzIHdoaWNoIHdpbGwgc2hvdyBhbmQgdGhlbiBoaWRlIHRoZSBvbnNjcmVlbiBrZXlib2FyZC5cbiAgICAgICAgICAgICAqIEF0dGVtcHRzIHRvIHJlZm9jdXMgdGhlIGF1dG9mb2N1cyBlbGVtZW50IHZpYSBKYXZhU2NyaXB0IHdpbGwgbm90IHJlb3BlblxuICAgICAgICAgICAgICogdGhlIG9uc2NyZWVuIGtleWJvYXJkLiBGaXhlZCBieSB1cGRhdGVkIHRoZSBmb2N1c2luZyBsb2dpYyB0byBvbmx5IGF1dG9mb2N1c1xuICAgICAgICAgICAgICogdGhlIG1vZGFsIGVsZW1lbnQgaWYgdGhlIG1vZGFsIGRvZXMgbm90IGNvbnRhaW4gYW4gYXV0b2ZvY3VzIGVsZW1lbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpbnB1dHNXaXRoQXV0b2ZvY3VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpbnB1dHNXaXRoQXV0b2ZvY3VzWzBdLmZvY3VzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBOb3RpZnkge0BsaW5rICRtb2RhbFN0YWNrfSB0aGF0IG1vZGFsIGlzIHJlbmRlcmVkLlxuICAgICAgICAgIHZhciBtb2RhbCA9ICRtb2RhbFN0YWNrLmdldFRvcCgpO1xuICAgICAgICAgIGlmIChtb2RhbCkge1xuICAgICAgICAgICAgJG1vZGFsU3RhY2subW9kYWxSZW5kZXJlZChtb2RhbC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pXG5cbiAgLmRpcmVjdGl2ZSgnbW9kYWxBbmltYXRpb25DbGFzcycsIFtcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XG4gICAgICAgICAgaWYgKHRBdHRycy5tb2RhbEFuaW1hdGlvbikge1xuICAgICAgICAgICAgdEVsZW1lbnQuYWRkQ2xhc3ModEF0dHJzLm1vZGFsQW5pbWF0aW9uQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XSlcblxuICAuZGlyZWN0aXZlKCdtb2RhbFRyYW5zY2x1ZGUnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluazogZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzLCBjb250cm9sbGVyLCAkdHJhbnNjbHVkZSkge1xuICAgICAgICAkdHJhbnNjbHVkZSgkc2NvcGUuJHBhcmVudCwgZnVuY3Rpb24oY2xvbmUpIHtcbiAgICAgICAgICAkZWxlbWVudC5lbXB0eSgpO1xuICAgICAgICAgICRlbGVtZW50LmFwcGVuZChjbG9uZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pXG5cbiAgLmZhY3RvcnkoJyRtb2RhbFN0YWNrJywgW1xuICAgICAgICAgICAgICckYW5pbWF0ZScsICckdGltZW91dCcsICckZG9jdW1lbnQnLCAnJGNvbXBpbGUnLCAnJHJvb3RTY29wZScsXG4gICAgICAgICAgICAgJyRxJyxcbiAgICAgICAgICAgICAnJGluamVjdG9yJyxcbiAgICAgICAgICAgICAnJCRtdWx0aU1hcCcsXG4gICAgICAgICAgICAgJyQkc3RhY2tlZE1hcCcsXG4gICAgZnVuY3Rpb24oJGFuaW1hdGUgLCAgJHRpbWVvdXQgLCAgJGRvY3VtZW50ICwgICRjb21waWxlICwgICRyb290U2NvcGUgLFxuICAgICAgICAgICAgICAkcSxcbiAgICAgICAgICAgICAgJGluamVjdG9yLFxuICAgICAgICAgICAgICAkJG11bHRpTWFwLFxuICAgICAgICAgICAgICAkJHN0YWNrZWRNYXApIHtcbiAgICAgIHZhciAkYW5pbWF0ZUNzcyA9IG51bGw7XG5cbiAgICAgIGlmICgkaW5qZWN0b3IuaGFzKCckYW5pbWF0ZUNzcycpKSB7XG4gICAgICAgICRhbmltYXRlQ3NzID0gJGluamVjdG9yLmdldCgnJGFuaW1hdGVDc3MnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIE9QRU5FRF9NT0RBTF9DTEFTUyA9ICdtb2RhbC1vcGVuJztcblxuICAgICAgdmFyIGJhY2tkcm9wRG9tRWwsIGJhY2tkcm9wU2NvcGU7XG4gICAgICB2YXIgb3BlbmVkV2luZG93cyA9ICQkc3RhY2tlZE1hcC5jcmVhdGVOZXcoKTtcbiAgICAgIHZhciBvcGVuZWRDbGFzc2VzID0gJCRtdWx0aU1hcC5jcmVhdGVOZXcoKTtcbiAgICAgIHZhciAkbW9kYWxTdGFjayA9IHtcbiAgICAgICAgTk9XX0NMT1NJTkdfRVZFTlQ6ICdtb2RhbC5zdGFjay5ub3ctY2xvc2luZydcbiAgICAgIH07XG5cbiAgICAgIC8vTW9kYWwgZm9jdXMgYmVoYXZpb3JcbiAgICAgIHZhciBmb2N1c2FibGVFbGVtZW50TGlzdDtcbiAgICAgIHZhciBmb2N1c0luZGV4ID0gMDtcbiAgICAgIHZhciB0YWJhYmJsZVNlbGVjdG9yID0gJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgJyArXG4gICAgICAgICdidXR0b246bm90KFtkaXNhYmxlZF0pLHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgJyArXG4gICAgICAgICdpZnJhbWUsIG9iamVjdCwgZW1iZWQsICpbdGFiaW5kZXhdLCAqW2NvbnRlbnRlZGl0YWJsZT10cnVlXSc7XG5cbiAgICAgIGZ1bmN0aW9uIGJhY2tkcm9wSW5kZXgoKSB7XG4gICAgICAgIHZhciB0b3BCYWNrZHJvcEluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvcGVuZWQgPSBvcGVuZWRXaW5kb3dzLmtleXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcGVuZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAob3BlbmVkV2luZG93cy5nZXQob3BlbmVkW2ldKS52YWx1ZS5iYWNrZHJvcCkge1xuICAgICAgICAgICAgdG9wQmFja2Ryb3BJbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3BCYWNrZHJvcEluZGV4O1xuICAgICAgfVxuXG4gICAgICAkcm9vdFNjb3BlLiR3YXRjaChiYWNrZHJvcEluZGV4LCBmdW5jdGlvbihuZXdCYWNrZHJvcEluZGV4KSB7XG4gICAgICAgIGlmIChiYWNrZHJvcFNjb3BlKSB7XG4gICAgICAgICAgYmFja2Ryb3BTY29wZS5pbmRleCA9IG5ld0JhY2tkcm9wSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiByZW1vdmVNb2RhbFdpbmRvdyhtb2RhbEluc3RhbmNlLCBlbGVtZW50VG9SZWNlaXZlRm9jdXMpIHtcbiAgICAgICAgdmFyIGJvZHkgPSAkZG9jdW1lbnQuZmluZCgnYm9keScpLmVxKDApO1xuICAgICAgICB2YXIgbW9kYWxXaW5kb3cgPSBvcGVuZWRXaW5kb3dzLmdldChtb2RhbEluc3RhbmNlKS52YWx1ZTtcblxuICAgICAgICAvL2NsZWFuIHVwIHRoZSBzdGFja1xuICAgICAgICBvcGVuZWRXaW5kb3dzLnJlbW92ZShtb2RhbEluc3RhbmNlKTtcblxuICAgICAgICByZW1vdmVBZnRlckFuaW1hdGUobW9kYWxXaW5kb3cubW9kYWxEb21FbCwgbW9kYWxXaW5kb3cubW9kYWxTY29wZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIG1vZGFsQm9keUNsYXNzID0gbW9kYWxXaW5kb3cub3BlbmVkQ2xhc3MgfHwgT1BFTkVEX01PREFMX0NMQVNTO1xuICAgICAgICAgIG9wZW5lZENsYXNzZXMucmVtb3ZlKG1vZGFsQm9keUNsYXNzLCBtb2RhbEluc3RhbmNlKTtcbiAgICAgICAgICBib2R5LnRvZ2dsZUNsYXNzKG1vZGFsQm9keUNsYXNzLCBvcGVuZWRDbGFzc2VzLmhhc0tleShtb2RhbEJvZHlDbGFzcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hlY2tSZW1vdmVCYWNrZHJvcCgpO1xuXG4gICAgICAgIC8vbW92ZSBmb2N1cyB0byBzcGVjaWZpZWQgZWxlbWVudCBpZiBhdmFpbGFibGUsIG9yIGVsc2UgdG8gYm9keVxuICAgICAgICBpZiAoZWxlbWVudFRvUmVjZWl2ZUZvY3VzICYmIGVsZW1lbnRUb1JlY2VpdmVGb2N1cy5mb2N1cykge1xuICAgICAgICAgIGVsZW1lbnRUb1JlY2VpdmVGb2N1cy5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJvZHkuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1JlbW92ZUJhY2tkcm9wKCkge1xuICAgICAgICAgIC8vcmVtb3ZlIGJhY2tkcm9wIGlmIG5vIGxvbmdlciBuZWVkZWRcbiAgICAgICAgICBpZiAoYmFja2Ryb3BEb21FbCAmJiBiYWNrZHJvcEluZGV4KCkgPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBiYWNrZHJvcFNjb3BlUmVmID0gYmFja2Ryb3BTY29wZTtcbiAgICAgICAgICAgIHJlbW92ZUFmdGVyQW5pbWF0ZShiYWNrZHJvcERvbUVsLCBiYWNrZHJvcFNjb3BlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgYmFja2Ryb3BTY29wZVJlZiA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJhY2tkcm9wRG9tRWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBiYWNrZHJvcFNjb3BlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlQWZ0ZXJBbmltYXRlKGRvbUVsLCBzY29wZSwgZG9uZSkge1xuICAgICAgICB2YXIgYXN5bmNEZWZlcnJlZDtcbiAgICAgICAgdmFyIGFzeW5jUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHZhciBzZXRJc0FzeW5jID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCFhc3luY0RlZmVycmVkKSB7XG4gICAgICAgICAgICBhc3luY0RlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgIGFzeW5jUHJvbWlzZSA9IGFzeW5jRGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXN5bmNEb25lKCkge1xuICAgICAgICAgICAgYXN5bmNEZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NvcGUuJGJyb2FkY2FzdCgkbW9kYWxTdGFjay5OT1dfQ0xPU0lOR19FVkVOVCwgc2V0SXNBc3luYyk7XG5cbiAgICAgICAgLy8gTm90ZSB0aGF0IGl0J3MgaW50ZW50aW9uYWwgdGhhdCBhc3luY1Byb21pc2UgbWlnaHQgYmUgbnVsbC5cbiAgICAgICAgLy8gVGhhdCdzIHdoZW4gc2V0SXNBc3luYyBoYXMgbm90IGJlZW4gY2FsbGVkIGR1cmluZyB0aGVcbiAgICAgICAgLy8gTk9XX0NMT1NJTkdfRVZFTlQgYnJvYWRjYXN0LlxuICAgICAgICByZXR1cm4gJHEud2hlbihhc3luY1Byb21pc2UpLnRoZW4oYWZ0ZXJBbmltYXRpbmcpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGFmdGVyQW5pbWF0aW5nKCkge1xuICAgICAgICAgIGlmIChhZnRlckFuaW1hdGluZy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFmdGVyQW5pbWF0aW5nLmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCRhbmltYXRlQ3NzKSB7XG4gICAgICAgICAgICAkYW5pbWF0ZUNzcyhkb21FbCwge1xuICAgICAgICAgICAgICBldmVudDogJ2xlYXZlJ1xuICAgICAgICAgICAgfSkuc3RhcnQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBkb21FbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShkb21FbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgJGRvY3VtZW50LmJpbmQoJ2tleWRvd24nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKGV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybiBldnQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9kYWwgPSBvcGVuZWRXaW5kb3dzLnRvcCgpO1xuICAgICAgICBpZiAobW9kYWwgJiYgbW9kYWwudmFsdWUua2V5Ym9hcmQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGV2dC53aGljaCl7XG4gICAgICAgICAgICBjYXNlIDI3OiB7XG4gICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkbW9kYWxTdGFjay5kaXNtaXNzKG1vZGFsLmtleSwgJ2VzY2FwZSBrZXkgcHJlc3MnKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA5OiB7XG4gICAgICAgICAgICAgICRtb2RhbFN0YWNrLmxvYWRGb2N1c0VsZW1lbnRMaXN0KG1vZGFsKTtcbiAgICAgICAgICAgICAgdmFyIGZvY3VzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoZXZ0LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCRtb2RhbFN0YWNrLmlzRm9jdXNJbkZpcnN0SXRlbShldnQpKSB7XG4gICAgICAgICAgICAgICAgICBmb2N1c0NoYW5nZWQgPSAkbW9kYWxTdGFjay5mb2N1c0xhc3RGb2N1c2FibGVFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgkbW9kYWxTdGFjay5pc0ZvY3VzSW5MYXN0SXRlbShldnQpKSB7XG4gICAgICAgICAgICAgICAgICBmb2N1c0NoYW5nZWQgPSAkbW9kYWxTdGFjay5mb2N1c0ZpcnN0Rm9jdXNhYmxlRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChmb2N1c0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgJG1vZGFsU3RhY2sub3BlbiA9IGZ1bmN0aW9uKG1vZGFsSW5zdGFuY2UsIG1vZGFsKSB7XG4gICAgICAgIHZhciBtb2RhbE9wZW5lciA9ICRkb2N1bWVudFswXS5hY3RpdmVFbGVtZW50LFxuICAgICAgICAgIG1vZGFsQm9keUNsYXNzID0gbW9kYWwub3BlbmVkQ2xhc3MgfHwgT1BFTkVEX01PREFMX0NMQVNTO1xuXG4gICAgICAgIG9wZW5lZFdpbmRvd3MuYWRkKG1vZGFsSW5zdGFuY2UsIHtcbiAgICAgICAgICBkZWZlcnJlZDogbW9kYWwuZGVmZXJyZWQsXG4gICAgICAgICAgcmVuZGVyRGVmZXJyZWQ6IG1vZGFsLnJlbmRlckRlZmVycmVkLFxuICAgICAgICAgIG1vZGFsU2NvcGU6IG1vZGFsLnNjb3BlLFxuICAgICAgICAgIGJhY2tkcm9wOiBtb2RhbC5iYWNrZHJvcCxcbiAgICAgICAgICBrZXlib2FyZDogbW9kYWwua2V5Ym9hcmQsXG4gICAgICAgICAgb3BlbmVkQ2xhc3M6IG1vZGFsLm9wZW5lZENsYXNzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9wZW5lZENsYXNzZXMucHV0KG1vZGFsQm9keUNsYXNzLCBtb2RhbEluc3RhbmNlKTtcblxuICAgICAgICB2YXIgYm9keSA9ICRkb2N1bWVudC5maW5kKCdib2R5JykuZXEoMCksXG4gICAgICAgICAgICBjdXJyQmFja2Ryb3BJbmRleCA9IGJhY2tkcm9wSW5kZXgoKTtcblxuICAgICAgICBpZiAoY3VyckJhY2tkcm9wSW5kZXggPj0gMCAmJiAhYmFja2Ryb3BEb21FbCkge1xuICAgICAgICAgIGJhY2tkcm9wU2NvcGUgPSAkcm9vdFNjb3BlLiRuZXcodHJ1ZSk7XG4gICAgICAgICAgYmFja2Ryb3BTY29wZS5pbmRleCA9IGN1cnJCYWNrZHJvcEluZGV4O1xuICAgICAgICAgIHZhciBhbmd1bGFyQmFja2dyb3VuZERvbUVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IG1vZGFsLWJhY2tkcm9wPVwibW9kYWwtYmFja2Ryb3BcIj48L2Rpdj4nKTtcbiAgICAgICAgICBhbmd1bGFyQmFja2dyb3VuZERvbUVsLmF0dHIoJ2JhY2tkcm9wLWNsYXNzJywgbW9kYWwuYmFja2Ryb3BDbGFzcyk7XG4gICAgICAgICAgaWYgKG1vZGFsLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgYW5ndWxhckJhY2tncm91bmREb21FbC5hdHRyKCdtb2RhbC1hbmltYXRpb24nLCAndHJ1ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiYWNrZHJvcERvbUVsID0gJGNvbXBpbGUoYW5ndWxhckJhY2tncm91bmREb21FbCkoYmFja2Ryb3BTY29wZSk7XG4gICAgICAgICAgYm9keS5hcHBlbmQoYmFja2Ryb3BEb21FbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW5ndWxhckRvbUVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IG1vZGFsLXdpbmRvdz1cIm1vZGFsLXdpbmRvd1wiPjwvZGl2PicpO1xuICAgICAgICBhbmd1bGFyRG9tRWwuYXR0cih7XG4gICAgICAgICAgJ3RlbXBsYXRlLXVybCc6IG1vZGFsLndpbmRvd1RlbXBsYXRlVXJsLFxuICAgICAgICAgICd3aW5kb3ctY2xhc3MnOiBtb2RhbC53aW5kb3dDbGFzcyxcbiAgICAgICAgICAnc2l6ZSc6IG1vZGFsLnNpemUsXG4gICAgICAgICAgJ2luZGV4Jzogb3BlbmVkV2luZG93cy5sZW5ndGgoKSAtIDEsXG4gICAgICAgICAgJ2FuaW1hdGUnOiAnYW5pbWF0ZSdcbiAgICAgICAgfSkuaHRtbChtb2RhbC5jb250ZW50KTtcbiAgICAgICAgaWYgKG1vZGFsLmFuaW1hdGlvbikge1xuICAgICAgICAgIGFuZ3VsYXJEb21FbC5hdHRyKCdtb2RhbC1hbmltYXRpb24nLCAndHJ1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vZGFsRG9tRWwgPSAkY29tcGlsZShhbmd1bGFyRG9tRWwpKG1vZGFsLnNjb3BlKTtcbiAgICAgICAgb3BlbmVkV2luZG93cy50b3AoKS52YWx1ZS5tb2RhbERvbUVsID0gbW9kYWxEb21FbDtcbiAgICAgICAgb3BlbmVkV2luZG93cy50b3AoKS52YWx1ZS5tb2RhbE9wZW5lciA9IG1vZGFsT3BlbmVyO1xuICAgICAgICBib2R5LmFwcGVuZChtb2RhbERvbUVsKTtcbiAgICAgICAgYm9keS5hZGRDbGFzcyhtb2RhbEJvZHlDbGFzcyk7XG5cbiAgICAgICAgJG1vZGFsU3RhY2suY2xlYXJGb2N1c0xpc3RDYWNoZSgpO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gYnJvYWRjYXN0Q2xvc2luZyhtb2RhbFdpbmRvdywgcmVzdWx0T3JSZWFzb24sIGNsb3NpbmcpIHtcbiAgICAgICAgICByZXR1cm4gIW1vZGFsV2luZG93LnZhbHVlLm1vZGFsU2NvcGUuJGJyb2FkY2FzdCgnbW9kYWwuY2xvc2luZycsIHJlc3VsdE9yUmVhc29uLCBjbG9zaW5nKS5kZWZhdWx0UHJldmVudGVkO1xuICAgICAgfVxuXG4gICAgICAkbW9kYWxTdGFjay5jbG9zZSA9IGZ1bmN0aW9uKG1vZGFsSW5zdGFuY2UsIHJlc3VsdCkge1xuICAgICAgICB2YXIgbW9kYWxXaW5kb3cgPSBvcGVuZWRXaW5kb3dzLmdldChtb2RhbEluc3RhbmNlKTtcbiAgICAgICAgaWYgKG1vZGFsV2luZG93ICYmIGJyb2FkY2FzdENsb3NpbmcobW9kYWxXaW5kb3csIHJlc3VsdCwgdHJ1ZSkpIHtcbiAgICAgICAgICBtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbFNjb3BlLiQkdWliRGVzdHJ1Y3Rpb25TY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgIG1vZGFsV2luZG93LnZhbHVlLmRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICByZW1vdmVNb2RhbFdpbmRvdyhtb2RhbEluc3RhbmNlLCBtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbE9wZW5lcik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFtb2RhbFdpbmRvdztcbiAgICAgIH07XG5cbiAgICAgICRtb2RhbFN0YWNrLmRpc21pc3MgPSBmdW5jdGlvbihtb2RhbEluc3RhbmNlLCByZWFzb24pIHtcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSk7XG4gICAgICAgIGlmIChtb2RhbFdpbmRvdyAmJiBicm9hZGNhc3RDbG9zaW5nKG1vZGFsV2luZG93LCByZWFzb24sIGZhbHNlKSkge1xuICAgICAgICAgIG1vZGFsV2luZG93LnZhbHVlLm1vZGFsU2NvcGUuJCR1aWJEZXN0cnVjdGlvblNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgbW9kYWxXaW5kb3cudmFsdWUuZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgcmVtb3ZlTW9kYWxXaW5kb3cobW9kYWxJbnN0YW5jZSwgbW9kYWxXaW5kb3cudmFsdWUubW9kYWxPcGVuZXIpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhbW9kYWxXaW5kb3c7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5kaXNtaXNzQWxsID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIHZhciB0b3BNb2RhbCA9IHRoaXMuZ2V0VG9wKCk7XG4gICAgICAgIHdoaWxlICh0b3BNb2RhbCAmJiB0aGlzLmRpc21pc3ModG9wTW9kYWwua2V5LCByZWFzb24pKSB7XG4gICAgICAgICAgdG9wTW9kYWwgPSB0aGlzLmdldFRvcCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5nZXRUb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG9wZW5lZFdpbmRvd3MudG9wKCk7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5tb2RhbFJlbmRlcmVkID0gZnVuY3Rpb24obW9kYWxJbnN0YW5jZSkge1xuICAgICAgICB2YXIgbW9kYWxXaW5kb3cgPSBvcGVuZWRXaW5kb3dzLmdldChtb2RhbEluc3RhbmNlKTtcbiAgICAgICAgaWYgKG1vZGFsV2luZG93KSB7XG4gICAgICAgICAgbW9kYWxXaW5kb3cudmFsdWUucmVuZGVyRGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5mb2N1c0ZpcnN0Rm9jdXNhYmxlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZm9jdXNhYmxlRWxlbWVudExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvY3VzYWJsZUVsZW1lbnRMaXN0WzBdLmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgICRtb2RhbFN0YWNrLmZvY3VzTGFzdEZvY3VzYWJsZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb2N1c2FibGVFbGVtZW50TGlzdFtmb2N1c2FibGVFbGVtZW50TGlzdC5sZW5ndGggLSAxXS5mb2N1cygpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgICRtb2RhbFN0YWNrLmlzRm9jdXNJbkZpcnN0SXRlbSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoZm9jdXNhYmxlRWxlbWVudExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiAoZXZ0LnRhcmdldCB8fCBldnQuc3JjRWxlbWVudCkgPT0gZm9jdXNhYmxlRWxlbWVudExpc3RbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suaXNGb2N1c0luTGFzdEl0ZW0gPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gKGV2dC50YXJnZXQgfHwgZXZ0LnNyY0VsZW1lbnQpID09IGZvY3VzYWJsZUVsZW1lbnRMaXN0W2ZvY3VzYWJsZUVsZW1lbnRMaXN0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgICRtb2RhbFN0YWNrLmNsZWFyRm9jdXNMaXN0Q2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9jdXNhYmxlRWxlbWVudExpc3QgPSBbXTtcbiAgICAgICAgZm9jdXNJbmRleCA9IDA7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5sb2FkRm9jdXNFbGVtZW50TGlzdCA9IGZ1bmN0aW9uKG1vZGFsV2luZG93KSB7XG4gICAgICAgIGlmIChmb2N1c2FibGVFbGVtZW50TGlzdCA9PT0gdW5kZWZpbmVkIHx8ICFmb2N1c2FibGVFbGVtZW50TGlzdC5sZW5ndGgwKSB7XG4gICAgICAgICAgaWYgKG1vZGFsV2luZG93KSB7XG4gICAgICAgICAgICB2YXIgbW9kYWxEb21FMSA9IG1vZGFsV2luZG93LnZhbHVlLm1vZGFsRG9tRWw7XG4gICAgICAgICAgICBpZiAobW9kYWxEb21FMSAmJiBtb2RhbERvbUUxLmxlbmd0aCkge1xuICAgICAgICAgICAgICBmb2N1c2FibGVFbGVtZW50TGlzdCA9IG1vZGFsRG9tRTFbMF0ucXVlcnlTZWxlY3RvckFsbCh0YWJhYmJsZVNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiAkbW9kYWxTdGFjaztcbiAgICB9XSlcblxuICAucHJvdmlkZXIoJyRtb2RhbCcsIGZ1bmN0aW9uKCkge1xuICAgIHZhciAkbW9kYWxQcm92aWRlciA9IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBiYWNrZHJvcDogdHJ1ZSwgLy9jYW4gYWxzbyBiZSBmYWxzZSBvciAnc3RhdGljJ1xuICAgICAgICBrZXlib2FyZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgICRnZXQ6IFsnJGluamVjdG9yJywgJyRyb290U2NvcGUnLCAnJHEnLCAnJHRlbXBsYXRlUmVxdWVzdCcsICckY29udHJvbGxlcicsICckbW9kYWxTdGFjaycsXG4gICAgICAgIGZ1bmN0aW9uICgkaW5qZWN0b3IsICRyb290U2NvcGUsICRxLCAkdGVtcGxhdGVSZXF1ZXN0LCAkY29udHJvbGxlciwgJG1vZGFsU3RhY2spIHtcbiAgICAgICAgICB2YXIgJG1vZGFsID0ge307XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRUZW1wbGF0ZVByb21pc2Uob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMudGVtcGxhdGUgPyAkcS53aGVuKG9wdGlvbnMudGVtcGxhdGUpIDpcbiAgICAgICAgICAgICAgJHRlbXBsYXRlUmVxdWVzdChhbmd1bGFyLmlzRnVuY3Rpb24ob3B0aW9ucy50ZW1wbGF0ZVVybCkgPyAob3B0aW9ucy50ZW1wbGF0ZVVybCkoKSA6IG9wdGlvbnMudGVtcGxhdGVVcmwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFJlc29sdmVQcm9taXNlcyhyZXNvbHZlcykge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzQXJyID0gW107XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVzb2x2ZXMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24odmFsdWUpIHx8IGFuZ3VsYXIuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlc0Fyci5wdXNoKCRxLndoZW4oJGluamVjdG9yLmludm9rZSh2YWx1ZSkpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzQXJyLnB1c2goJHEud2hlbigkaW5qZWN0b3IuZ2V0KHZhbHVlKSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2VzQXJyLnB1c2goJHEud2hlbih2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlc0FycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcHJvbWlzZUNoYWluID0gbnVsbDtcbiAgICAgICAgICAkbW9kYWwuZ2V0UHJvbWlzZUNoYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZUNoYWluO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAkbW9kYWwub3BlbiA9IGZ1bmN0aW9uIChtb2RhbE9wdGlvbnMpIHtcblxuICAgICAgICAgICAgdmFyIG1vZGFsUmVzdWx0RGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgdmFyIG1vZGFsT3BlbmVkRGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgdmFyIG1vZGFsUmVuZGVyRGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgICAgICAvL3ByZXBhcmUgYW4gaW5zdGFuY2Ugb2YgYSBtb2RhbCB0byBiZSBpbmplY3RlZCBpbnRvIGNvbnRyb2xsZXJzIGFuZCByZXR1cm5lZCB0byBhIGNhbGxlclxuICAgICAgICAgICAgdmFyIG1vZGFsSW5zdGFuY2UgPSB7XG4gICAgICAgICAgICAgIHJlc3VsdDogbW9kYWxSZXN1bHREZWZlcnJlZC5wcm9taXNlLFxuICAgICAgICAgICAgICBvcGVuZWQ6IG1vZGFsT3BlbmVkRGVmZXJyZWQucHJvbWlzZSxcbiAgICAgICAgICAgICAgcmVuZGVyZWQ6IG1vZGFsUmVuZGVyRGVmZXJyZWQucHJvbWlzZSxcbiAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1vZGFsU3RhY2suY2xvc2UobW9kYWxJbnN0YW5jZSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZGlzbWlzczogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW9kYWxTdGFjay5kaXNtaXNzKG1vZGFsSW5zdGFuY2UsIHJlYXNvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vbWVyZ2UgYW5kIGNsZWFuIHVwIG9wdGlvbnNcbiAgICAgICAgICAgIG1vZGFsT3B0aW9ucyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCAkbW9kYWxQcm92aWRlci5vcHRpb25zLCBtb2RhbE9wdGlvbnMpO1xuICAgICAgICAgICAgbW9kYWxPcHRpb25zLnJlc29sdmUgPSBtb2RhbE9wdGlvbnMucmVzb2x2ZSB8fCB7fTtcblxuICAgICAgICAgICAgLy92ZXJpZnkgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKCFtb2RhbE9wdGlvbnMudGVtcGxhdGUgJiYgIW1vZGFsT3B0aW9ucy50ZW1wbGF0ZVVybCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09uZSBvZiB0ZW1wbGF0ZSBvciB0ZW1wbGF0ZVVybCBvcHRpb25zIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVBbmRSZXNvbHZlUHJvbWlzZSA9XG4gICAgICAgICAgICAgICRxLmFsbChbZ2V0VGVtcGxhdGVQcm9taXNlKG1vZGFsT3B0aW9ucyldLmNvbmNhdChnZXRSZXNvbHZlUHJvbWlzZXMobW9kYWxPcHRpb25zLnJlc29sdmUpKSk7XG5cbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBleGlzdGluZyBwcm9taXNlIGNoYWluLlxuICAgICAgICAgICAgLy8gVGhlbiBzd2l0Y2ggdG8gb3VyIG93biBjb21iaW5lZCBwcm9taXNlIGRlcGVuZGVuY3kgKHJlZ2FyZGxlc3Mgb2YgaG93IHRoZSBwcmV2aW91cyBtb2RhbCBmYXJlZCkuXG4gICAgICAgICAgICAvLyBUaGVuIGFkZCB0byAkbW9kYWxTdGFjayBhbmQgcmVzb2x2ZSBvcGVuZWQuXG4gICAgICAgICAgICAvLyBGaW5hbGx5IGNsZWFuIHVwIHRoZSBjaGFpbiB2YXJpYWJsZSBpZiBubyBzdWJzZXF1ZW50IG1vZGFsIGhhcyBvdmVyd3JpdHRlbiBpdC5cbiAgICAgICAgICAgIHZhciBzYW1lUHJvbWlzZTtcbiAgICAgICAgICAgIHNhbWVQcm9taXNlID0gcHJvbWlzZUNoYWluID0gJHEuYWxsKFtwcm9taXNlQ2hhaW5dKVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIHRlbXBsYXRlQW5kUmVzb2x2ZVByb21pc2U7IH0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGVtcGxhdGVBbmRSZXNvbHZlUHJvbWlzZTsgfSlcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gcmVzb2x2ZVN1Y2Nlc3ModHBsQW5kVmFycykge1xuXG4gICAgICAgICAgICAgICAgdmFyIG1vZGFsU2NvcGUgPSAobW9kYWxPcHRpb25zLnNjb3BlIHx8ICRyb290U2NvcGUpLiRuZXcoKTtcbiAgICAgICAgICAgICAgICBtb2RhbFNjb3BlLiRjbG9zZSA9IG1vZGFsSW5zdGFuY2UuY2xvc2U7XG4gICAgICAgICAgICAgICAgbW9kYWxTY29wZS4kZGlzbWlzcyA9IG1vZGFsSW5zdGFuY2UuZGlzbWlzcztcblxuICAgICAgICAgICAgICAgIG1vZGFsU2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFtb2RhbFNjb3BlLiQkdWliRGVzdHJ1Y3Rpb25TY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWxTY29wZS4kZGlzbWlzcygnJHVpYlVuc2NoZWR1bGVkRGVzdHJ1Y3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBjdHJsSW5zdGFuY2UsIGN0cmxMb2NhbHMgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZUl0ZXIgPSAxO1xuXG4gICAgICAgICAgICAgICAgLy9jb250cm9sbGVyc1xuICAgICAgICAgICAgICAgIGlmIChtb2RhbE9wdGlvbnMuY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgY3RybExvY2Fscy4kc2NvcGUgPSBtb2RhbFNjb3BlO1xuICAgICAgICAgICAgICAgICAgY3RybExvY2Fscy4kbW9kYWxJbnN0YW5jZSA9IG1vZGFsSW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gobW9kYWxPcHRpb25zLnJlc29sdmUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3RybExvY2Fsc1trZXldID0gdHBsQW5kVmFyc1tyZXNvbHZlSXRlcisrXTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBjdHJsSW5zdGFuY2UgPSAkY29udHJvbGxlcihtb2RhbE9wdGlvbnMuY29udHJvbGxlciwgY3RybExvY2Fscyk7XG4gICAgICAgICAgICAgICAgICBpZiAobW9kYWxPcHRpb25zLmNvbnRyb2xsZXJBcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kYWxPcHRpb25zLmJpbmRUb0NvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmV4dGVuZChjdHJsSW5zdGFuY2UsIG1vZGFsU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbW9kYWxTY29wZVttb2RhbE9wdGlvbnMuY29udHJvbGxlckFzXSA9IGN0cmxJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkbW9kYWxTdGFjay5vcGVuKG1vZGFsSW5zdGFuY2UsIHtcbiAgICAgICAgICAgICAgICAgIHNjb3BlOiBtb2RhbFNjb3BlLFxuICAgICAgICAgICAgICAgICAgZGVmZXJyZWQ6IG1vZGFsUmVzdWx0RGVmZXJyZWQsXG4gICAgICAgICAgICAgICAgICByZW5kZXJEZWZlcnJlZDogbW9kYWxSZW5kZXJEZWZlcnJlZCxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRwbEFuZFZhcnNbMF0sXG4gICAgICAgICAgICAgICAgICBhbmltYXRpb246IG1vZGFsT3B0aW9ucy5hbmltYXRpb24sXG4gICAgICAgICAgICAgICAgICBiYWNrZHJvcDogbW9kYWxPcHRpb25zLmJhY2tkcm9wLFxuICAgICAgICAgICAgICAgICAga2V5Ym9hcmQ6IG1vZGFsT3B0aW9ucy5rZXlib2FyZCxcbiAgICAgICAgICAgICAgICAgIGJhY2tkcm9wQ2xhc3M6IG1vZGFsT3B0aW9ucy5iYWNrZHJvcENsYXNzLFxuICAgICAgICAgICAgICAgICAgd2luZG93Q2xhc3M6IG1vZGFsT3B0aW9ucy53aW5kb3dDbGFzcyxcbiAgICAgICAgICAgICAgICAgIHdpbmRvd1RlbXBsYXRlVXJsOiBtb2RhbE9wdGlvbnMud2luZG93VGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgICBzaXplOiBtb2RhbE9wdGlvbnMuc2l6ZSxcbiAgICAgICAgICAgICAgICAgIG9wZW5lZENsYXNzOiBtb2RhbE9wdGlvbnMub3BlbmVkQ2xhc3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtb2RhbE9wZW5lZERlZmVycmVkLnJlc29sdmUodHJ1ZSk7XG5cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIHJlc29sdmVFcnJvcihyZWFzb24pIHtcbiAgICAgICAgICAgICAgbW9kYWxPcGVuZWREZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgbW9kYWxSZXN1bHREZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHByb21pc2VDaGFpbiA9PT0gc2FtZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlQ2hhaW4gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG1vZGFsSW5zdGFuY2U7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiAkbW9kYWw7XG4gICAgICAgIH1dXG4gICAgfTtcblxuICAgIHJldHVybiAkbW9kYWxQcm92aWRlcjtcbiAgfSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucGFnaW5hdGlvbicsIFtdKVxuLmNvbnRyb2xsZXIoJ1BhZ2luYXRpb25Db250cm9sbGVyJywgWyckc2NvcGUnLCAnJGF0dHJzJywgJyRwYXJzZScsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCAkcGFyc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgbmdNb2RlbEN0cmwgPSB7ICRzZXRWaWV3VmFsdWU6IGFuZ3VsYXIubm9vcCB9LCAvLyBudWxsTW9kZWxDdHJsXG4gICAgICBzZXROdW1QYWdlcyA9ICRhdHRycy5udW1QYWdlcyA/ICRwYXJzZSgkYXR0cnMubnVtUGFnZXMpLmFzc2lnbiA6IGFuZ3VsYXIubm9vcDtcblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbihuZ01vZGVsQ3RybF8sIGNvbmZpZykge1xuICAgIG5nTW9kZWxDdHJsID0gbmdNb2RlbEN0cmxfO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuXG4gICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICB9O1xuXG4gICAgaWYgKCRhdHRycy5pdGVtc1BlclBhZ2UpIHtcbiAgICAgICRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLml0ZW1zUGVyUGFnZSksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHNlbGYuaXRlbXNQZXJQYWdlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgJHNjb3BlLnRvdGFsUGFnZXMgPSBzZWxmLmNhbGN1bGF0ZVRvdGFsUGFnZXMoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLml0ZW1zUGVyUGFnZSA9IGNvbmZpZy5pdGVtc1BlclBhZ2U7XG4gICAgfVxuXG4gICAgJHNjb3BlLiR3YXRjaCgndG90YWxJdGVtcycsIGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLnRvdGFsUGFnZXMgPSBzZWxmLmNhbGN1bGF0ZVRvdGFsUGFnZXMoKTtcbiAgICB9KTtcblxuICAgICRzY29wZS4kd2F0Y2goJ3RvdGFsUGFnZXMnLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgc2V0TnVtUGFnZXMoJHNjb3BlLiRwYXJlbnQsIHZhbHVlKTsgLy8gUmVhZG9ubHkgdmFyaWFibGVcblxuICAgICAgaWYgKCAkc2NvcGUucGFnZSA+IHZhbHVlICkge1xuICAgICAgICAkc2NvcGUuc2VsZWN0UGFnZSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdGhpcy5jYWxjdWxhdGVUb3RhbFBhZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvdGFsUGFnZXMgPSB0aGlzLml0ZW1zUGVyUGFnZSA8IDEgPyAxIDogTWF0aC5jZWlsKCRzY29wZS50b3RhbEl0ZW1zIC8gdGhpcy5pdGVtc1BlclBhZ2UpO1xuICAgIHJldHVybiBNYXRoLm1heCh0b3RhbFBhZ2VzIHx8IDAsIDEpO1xuICB9O1xuXG4gIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnBhZ2UgPSBwYXJzZUludChuZ01vZGVsQ3RybC4kdmlld1ZhbHVlLCAxMCkgfHwgMTtcbiAgfTtcblxuICAkc2NvcGUuc2VsZWN0UGFnZSA9IGZ1bmN0aW9uKHBhZ2UsIGV2dCkge1xuICAgIGlmIChldnQpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHZhciBjbGlja0FsbG93ZWQgPSAhJHNjb3BlLm5nRGlzYWJsZWQgfHwgIWV2dDtcbiAgICBpZiAoY2xpY2tBbGxvd2VkICYmICRzY29wZS5wYWdlICE9PSBwYWdlICYmIHBhZ2UgPiAwICYmIHBhZ2UgPD0gJHNjb3BlLnRvdGFsUGFnZXMpIHtcbiAgICAgIGlmIChldnQgJiYgZXZ0LnRhcmdldCkge1xuICAgICAgICBldnQudGFyZ2V0LmJsdXIoKTtcbiAgICAgIH1cbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUocGFnZSk7XG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5nZXRUZXh0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuICRzY29wZVtrZXkgKyAnVGV4dCddIHx8IHNlbGYuY29uZmlnW2tleSArICdUZXh0J107XG4gIH07XG5cbiAgJHNjb3BlLm5vUHJldmlvdXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJHNjb3BlLnBhZ2UgPT09IDE7XG4gIH07XG5cbiAgJHNjb3BlLm5vTmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAkc2NvcGUucGFnZSA9PT0gJHNjb3BlLnRvdGFsUGFnZXM7XG4gIH07XG59XSlcblxuLmNvbnN0YW50KCdwYWdpbmF0aW9uQ29uZmlnJywge1xuICBpdGVtc1BlclBhZ2U6IDEwLFxuICBib3VuZGFyeUxpbmtzOiBmYWxzZSxcbiAgZGlyZWN0aW9uTGlua3M6IHRydWUsXG4gIGZpcnN0VGV4dDogJ0ZpcnN0JyxcbiAgcHJldmlvdXNUZXh0OiAnUHJldmlvdXMnLFxuICBuZXh0VGV4dDogJ05leHQnLFxuICBsYXN0VGV4dDogJ0xhc3QnLFxuICByb3RhdGU6IHRydWVcbn0pXG5cbi5kaXJlY3RpdmUoJ3BhZ2luYXRpb24nLCBbJyRwYXJzZScsICdwYWdpbmF0aW9uQ29uZmlnJywgZnVuY3Rpb24oJHBhcnNlLCBwYWdpbmF0aW9uQ29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgc2NvcGU6IHtcbiAgICAgIHRvdGFsSXRlbXM6ICc9JyxcbiAgICAgIGZpcnN0VGV4dDogJ0AnLFxuICAgICAgcHJldmlvdXNUZXh0OiAnQCcsXG4gICAgICBuZXh0VGV4dDogJ0AnLFxuICAgICAgbGFzdFRleHQ6ICdAJyxcbiAgICAgIG5nRGlzYWJsZWQ6Jz0nXG4gICAgfSxcbiAgICByZXF1aXJlOiBbJ3BhZ2luYXRpb24nLCAnP25nTW9kZWwnXSxcbiAgICBjb250cm9sbGVyOiAnUGFnaW5hdGlvbkNvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ3BhZ2luYXRpb24nLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbCc7XG4gICAgfSxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBwYWdpbmF0aW9uQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBpZiAoIW5nTW9kZWxDdHJsKSB7XG4gICAgICAgICByZXR1cm47IC8vIGRvIG5vdGhpbmcgaWYgbm8gbmctbW9kZWxcbiAgICAgIH1cblxuICAgICAgLy8gU2V0dXAgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICB2YXIgbWF4U2l6ZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLm1heFNpemUpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy5tYXhTaXplKSA6IHBhZ2luYXRpb25Db25maWcubWF4U2l6ZSxcbiAgICAgICAgICByb3RhdGUgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5yb3RhdGUpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy5yb3RhdGUpIDogcGFnaW5hdGlvbkNvbmZpZy5yb3RhdGU7XG4gICAgICBzY29wZS5ib3VuZGFyeUxpbmtzID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuYm91bmRhcnlMaW5rcykgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmJvdW5kYXJ5TGlua3MpIDogcGFnaW5hdGlvbkNvbmZpZy5ib3VuZGFyeUxpbmtzO1xuICAgICAgc2NvcGUuZGlyZWN0aW9uTGlua3MgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5kaXJlY3Rpb25MaW5rcykgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmRpcmVjdGlvbkxpbmtzKSA6IHBhZ2luYXRpb25Db25maWcuZGlyZWN0aW9uTGlua3M7XG5cbiAgICAgIHBhZ2luYXRpb25DdHJsLmluaXQobmdNb2RlbEN0cmwsIHBhZ2luYXRpb25Db25maWcpO1xuXG4gICAgICBpZiAoYXR0cnMubWF4U2l6ZSkge1xuICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoYXR0cnMubWF4U2l6ZSksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgbWF4U2l6ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICAgcGFnaW5hdGlvbkN0cmwucmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgcGFnZSBvYmplY3QgdXNlZCBpbiB0ZW1wbGF0ZVxuICAgICAgZnVuY3Rpb24gbWFrZVBhZ2UobnVtYmVyLCB0ZXh0LCBpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgYWN0aXZlOiBpc0FjdGl2ZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQYWdlcyhjdXJyZW50UGFnZSwgdG90YWxQYWdlcykge1xuICAgICAgICB2YXIgcGFnZXMgPSBbXTtcblxuICAgICAgICAvLyBEZWZhdWx0IHBhZ2UgbGltaXRzXG4gICAgICAgIHZhciBzdGFydFBhZ2UgPSAxLCBlbmRQYWdlID0gdG90YWxQYWdlcztcbiAgICAgICAgdmFyIGlzTWF4U2l6ZWQgPSBhbmd1bGFyLmlzRGVmaW5lZChtYXhTaXplKSAmJiBtYXhTaXplIDwgdG90YWxQYWdlcztcblxuICAgICAgICAvLyByZWNvbXB1dGUgaWYgbWF4U2l6ZVxuICAgICAgICBpZiAoaXNNYXhTaXplZCkge1xuICAgICAgICAgIGlmIChyb3RhdGUpIHtcbiAgICAgICAgICAgIC8vIEN1cnJlbnQgcGFnZSBpcyBkaXNwbGF5ZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdmlzaWJsZSBvbmVzXG4gICAgICAgICAgICBzdGFydFBhZ2UgPSBNYXRoLm1heChjdXJyZW50UGFnZSAtIE1hdGguZmxvb3IobWF4U2l6ZS8yKSwgMSk7XG4gICAgICAgICAgICBlbmRQYWdlICAgPSBzdGFydFBhZ2UgKyBtYXhTaXplIC0gMTtcblxuICAgICAgICAgICAgLy8gQWRqdXN0IGlmIGxpbWl0IGlzIGV4Y2VlZGVkXG4gICAgICAgICAgICBpZiAoZW5kUGFnZSA+IHRvdGFsUGFnZXMpIHtcbiAgICAgICAgICAgICAgZW5kUGFnZSAgID0gdG90YWxQYWdlcztcbiAgICAgICAgICAgICAgc3RhcnRQYWdlID0gZW5kUGFnZSAtIG1heFNpemUgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBWaXNpYmxlIHBhZ2VzIGFyZSBwYWdpbmF0ZWQgd2l0aCBtYXhTaXplXG4gICAgICAgICAgICBzdGFydFBhZ2UgPSAoKE1hdGguY2VpbChjdXJyZW50UGFnZSAvIG1heFNpemUpIC0gMSkgKiBtYXhTaXplKSArIDE7XG5cbiAgICAgICAgICAgIC8vIEFkanVzdCBsYXN0IHBhZ2UgaWYgbGltaXQgaXMgZXhjZWVkZWRcbiAgICAgICAgICAgIGVuZFBhZ2UgPSBNYXRoLm1pbihzdGFydFBhZ2UgKyBtYXhTaXplIC0gMSwgdG90YWxQYWdlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHBhZ2UgbnVtYmVyIGxpbmtzXG4gICAgICAgIGZvciAodmFyIG51bWJlciA9IHN0YXJ0UGFnZTsgbnVtYmVyIDw9IGVuZFBhZ2U7IG51bWJlcisrKSB7XG4gICAgICAgICAgdmFyIHBhZ2UgPSBtYWtlUGFnZShudW1iZXIsIG51bWJlciwgbnVtYmVyID09PSBjdXJyZW50UGFnZSk7XG4gICAgICAgICAgcGFnZXMucHVzaChwYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBsaW5rcyB0byBtb3ZlIGJldHdlZW4gcGFnZSBzZXRzXG4gICAgICAgIGlmIChpc01heFNpemVkICYmICEgcm90YXRlKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0UGFnZSA+IDEpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1BhZ2VTZXQgPSBtYWtlUGFnZShzdGFydFBhZ2UgLSAxLCAnLi4uJywgZmFsc2UpO1xuICAgICAgICAgICAgcGFnZXMudW5zaGlmdChwcmV2aW91c1BhZ2VTZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbmRQYWdlIDwgdG90YWxQYWdlcykge1xuICAgICAgICAgICAgdmFyIG5leHRQYWdlU2V0ID0gbWFrZVBhZ2UoZW5kUGFnZSArIDEsICcuLi4nLCBmYWxzZSk7XG4gICAgICAgICAgICBwYWdlcy5wdXNoKG5leHRQYWdlU2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFnZXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IHBhZ2luYXRpb25DdHJsLnJlbmRlcjtcbiAgICAgIHBhZ2luYXRpb25DdHJsLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBvcmlnaW5hbFJlbmRlcigpO1xuICAgICAgICBpZiAoc2NvcGUucGFnZSA+IDAgJiYgc2NvcGUucGFnZSA8PSBzY29wZS50b3RhbFBhZ2VzKSB7XG4gICAgICAgICAgc2NvcGUucGFnZXMgPSBnZXRQYWdlcyhzY29wZS5wYWdlLCBzY29wZS50b3RhbFBhZ2VzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XSlcblxuLmNvbnN0YW50KCdwYWdlckNvbmZpZycsIHtcbiAgaXRlbXNQZXJQYWdlOiAxMCxcbiAgcHJldmlvdXNUZXh0OiAnwqsgUHJldmlvdXMnLFxuICBuZXh0VGV4dDogJ05leHQgwrsnLFxuICBhbGlnbjogdHJ1ZVxufSlcblxuLmRpcmVjdGl2ZSgncGFnZXInLCBbJ3BhZ2VyQ29uZmlnJywgZnVuY3Rpb24ocGFnZXJDb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICBzY29wZToge1xuICAgICAgdG90YWxJdGVtczogJz0nLFxuICAgICAgcHJldmlvdXNUZXh0OiAnQCcsXG4gICAgICBuZXh0VGV4dDogJ0AnLFxuICAgICAgbmdEaXNhYmxlZDogJz0nXG4gICAgfSxcbiAgICByZXF1aXJlOiBbJ3BhZ2VyJywgJz9uZ01vZGVsJ10sXG4gICAgY29udHJvbGxlcjogJ1BhZ2luYXRpb25Db250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdwYWdpbmF0aW9uJyxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdlci5odG1sJztcbiAgICB9LFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgdmFyIHBhZ2luYXRpb25DdHJsID0gY3RybHNbMF0sIG5nTW9kZWxDdHJsID0gY3RybHNbMV07XG5cbiAgICAgIGlmICghbmdNb2RlbEN0cmwpIHtcbiAgICAgICAgIHJldHVybjsgLy8gZG8gbm90aGluZyBpZiBubyBuZy1tb2RlbFxuICAgICAgfVxuXG4gICAgICBzY29wZS5hbGlnbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmFsaWduKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMuYWxpZ24pIDogcGFnZXJDb25maWcuYWxpZ247XG4gICAgICBwYWdpbmF0aW9uQ3RybC5pbml0KG5nTW9kZWxDdHJsLCBwYWdlckNvbmZpZyk7XG4gICAgfVxuICB9O1xufV0pO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgYXJlIHN0aWxsIG91dHN0YW5kaW5nOiBhbmltYXRpb24gYXMgYVxuICogZnVuY3Rpb24sIHBsYWNlbWVudCBhcyBhIGZ1bmN0aW9uLCBpbnNpZGUsIHN1cHBvcnQgZm9yIG1vcmUgdHJpZ2dlcnMgdGhhblxuICoganVzdCBtb3VzZSBlbnRlci9sZWF2ZSwgaHRtbCB0b29sdGlwcywgYW5kIHNlbGVjdG9yIGRlbGVnYXRpb24uXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudG9vbHRpcCcsIFsndWkuYm9vdHN0cmFwLnBvc2l0aW9uJywgJ3VpLmJvb3RzdHJhcC5iaW5kSHRtbCddKVxuXG4vKipcbiAqIFRoZSAkdG9vbHRpcCBzZXJ2aWNlIGNyZWF0ZXMgdG9vbHRpcC0gYW5kIHBvcG92ZXItbGlrZSBkaXJlY3RpdmVzIGFzIHdlbGwgYXNcbiAqIGhvdXNlcyBnbG9iYWwgb3B0aW9ucyBmb3IgdGhlbS5cbiAqL1xuLnByb3ZpZGVyKCckdG9vbHRpcCcsIGZ1bmN0aW9uKCkge1xuICAvLyBUaGUgZGVmYXVsdCBvcHRpb25zIHRvb2x0aXAgYW5kIHBvcG92ZXIuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICBwb3B1cERlbGF5OiAwLFxuICAgIHVzZUNvbnRlbnRFeHA6IGZhbHNlXG4gIH07XG5cbiAgLy8gRGVmYXVsdCBoaWRlIHRyaWdnZXJzIGZvciBlYWNoIHNob3cgdHJpZ2dlclxuICB2YXIgdHJpZ2dlck1hcCA9IHtcbiAgICAnbW91c2VlbnRlcic6ICdtb3VzZWxlYXZlJyxcbiAgICAnY2xpY2snOiAnY2xpY2snLFxuICAgICdmb2N1cyc6ICdibHVyJyxcbiAgICAnbm9uZSc6ICcnXG4gIH07XG5cbiAgLy8gVGhlIG9wdGlvbnMgc3BlY2lmaWVkIHRvIHRoZSBwcm92aWRlciBnbG9iYWxseS5cbiAgdmFyIGdsb2JhbE9wdGlvbnMgPSB7fTtcblxuICAvKipcbiAgICogYG9wdGlvbnMoe30pYCBhbGxvd3MgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb2YgYWxsIHRvb2x0aXBzIGluIHRoZVxuICAgKiBhcHBsaWNhdGlvbi5cbiAgICpcbiAgICogICB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoICdBcHAnLCBbJ3VpLmJvb3RzdHJhcC50b29sdGlwJ10sIGZ1bmN0aW9uKCAkdG9vbHRpcFByb3ZpZGVyICkge1xuICAgKiAgICAgLy8gcGxhY2UgdG9vbHRpcHMgbGVmdCBpbnN0ZWFkIG9mIHRvcCBieSBkZWZhdWx0XG4gICAqICAgICAkdG9vbHRpcFByb3ZpZGVyLm9wdGlvbnMoIHsgcGxhY2VtZW50OiAnbGVmdCcgfSApO1xuICAgKiAgIH0pO1xuICAgKi9cblx0dGhpcy5vcHRpb25zID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRhbmd1bGFyLmV4dGVuZChnbG9iYWxPcHRpb25zLCB2YWx1ZSk7XG5cdH07XG5cbiAgLyoqXG4gICAqIFRoaXMgYWxsb3dzIHlvdSB0byBleHRlbmQgdGhlIHNldCBvZiB0cmlnZ2VyIG1hcHBpbmdzIGF2YWlsYWJsZS4gRS5nLjpcbiAgICpcbiAgICogICAkdG9vbHRpcFByb3ZpZGVyLnNldFRyaWdnZXJzKCAnb3BlblRyaWdnZXInOiAnY2xvc2VUcmlnZ2VyJyApO1xuICAgKi9cbiAgdGhpcy5zZXRUcmlnZ2VycyA9IGZ1bmN0aW9uIHNldFRyaWdnZXJzKHRyaWdnZXJzKSB7XG4gICAgYW5ndWxhci5leHRlbmQodHJpZ2dlck1hcCwgdHJpZ2dlcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciB0cmFuc2xhdGluZyBjYW1lbC1jYXNlIHRvIHNuYWtlLWNhc2UuXG4gICAqL1xuICBmdW5jdGlvbiBzbmFrZV9jYXNlKG5hbWUpIHtcbiAgICB2YXIgcmVnZXhwID0gL1tBLVpdL2c7XG4gICAgdmFyIHNlcGFyYXRvciA9ICctJztcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKHJlZ2V4cCwgZnVuY3Rpb24obGV0dGVyLCBwb3MpIHtcbiAgICAgIHJldHVybiAocG9zID8gc2VwYXJhdG9yIDogJycpICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWN0dWFsIGluc3RhbmNlIG9mIHRoZSAkdG9vbHRpcCBzZXJ2aWNlLlxuICAgKiBUT0RPIHN1cHBvcnQgbXVsdGlwbGUgdHJpZ2dlcnNcbiAgICovXG4gIHRoaXMuJGdldCA9IFsnJHdpbmRvdycsICckY29tcGlsZScsICckdGltZW91dCcsICckZG9jdW1lbnQnLCAnJHBvc2l0aW9uJywgJyRpbnRlcnBvbGF0ZScsICckcm9vdFNjb3BlJywgJyRwYXJzZScsIGZ1bmN0aW9uKCR3aW5kb3csICRjb21waWxlLCAkdGltZW91dCwgJGRvY3VtZW50LCAkcG9zaXRpb24sICRpbnRlcnBvbGF0ZSwgJHJvb3RTY29wZSwgJHBhcnNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICR0b29sdGlwKHR5cGUsIHByZWZpeCwgZGVmYXVsdFRyaWdnZXJTaG93LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gYW5ndWxhci5leHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBnbG9iYWxPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBzaG93IGFuZCBoaWRlIHRyaWdnZXJzLlxuICAgICAgICpcbiAgICAgICAqIElmIGEgdHJpZ2dlciBpcyBzdXBwbGllZCxcbiAgICAgICAqIGl0IGlzIHVzZWQgdG8gc2hvdyB0aGUgdG9vbHRpcDsgb3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRyaWdnZXJgXG4gICAgICAgKiBvcHRpb24gcGFzc2VkIHRvIHRoZSBgJHRvb2x0aXBQcm92aWRlci5vcHRpb25zYCBtZXRob2Q7IGVsc2UgaXQgd2lsbFxuICAgICAgICogZGVmYXVsdCB0byB0aGUgdHJpZ2dlciBzdXBwbGllZCB0byB0aGlzIGRpcmVjdGl2ZSBmYWN0b3J5LlxuICAgICAgICpcbiAgICAgICAqIFRoZSBoaWRlIHRyaWdnZXIgaXMgYmFzZWQgb24gdGhlIHNob3cgdHJpZ2dlci4gSWYgdGhlIGB0cmlnZ2VyYCBvcHRpb25cbiAgICAgICAqIHdhcyBwYXNzZWQgdG8gdGhlIGAkdG9vbHRpcFByb3ZpZGVyLm9wdGlvbnNgIG1ldGhvZCwgaXQgd2lsbCB1c2UgdGhlXG4gICAgICAgKiBtYXBwZWQgdHJpZ2dlciBmcm9tIGB0cmlnZ2VyTWFwYCBvciB0aGUgcGFzc2VkIHRyaWdnZXIgaWYgdGhlIG1hcCBpc1xuICAgICAgICogdW5kZWZpbmVkOyBvdGhlcndpc2UsIGl0IHVzZXMgdGhlIGB0cmlnZ2VyTWFwYCB2YWx1ZSBvZiB0aGUgc2hvd1xuICAgICAgICogdHJpZ2dlcjsgZWxzZSBpdCB3aWxsIGp1c3QgdXNlIHRoZSBzaG93IHRyaWdnZXIuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGdldFRyaWdnZXJzKHRyaWdnZXIpIHtcbiAgICAgICAgdmFyIHNob3cgPSAodHJpZ2dlciB8fCBvcHRpb25zLnRyaWdnZXIgfHwgZGVmYXVsdFRyaWdnZXJTaG93KS5zcGxpdCgnICcpO1xuICAgICAgICB2YXIgaGlkZSA9IHNob3cubWFwKGZ1bmN0aW9uKHRyaWdnZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJpZ2dlck1hcFt0cmlnZ2VyXSB8fCB0cmlnZ2VyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzaG93OiBzaG93LFxuICAgICAgICAgIGhpZGU6IGhpZGVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpcmVjdGl2ZU5hbWUgPSBzbmFrZV9jYXNlKHR5cGUpO1xuXG4gICAgICB2YXIgc3RhcnRTeW0gPSAkaW50ZXJwb2xhdGUuc3RhcnRTeW1ib2woKTtcbiAgICAgIHZhciBlbmRTeW0gPSAkaW50ZXJwb2xhdGUuZW5kU3ltYm9sKCk7XG4gICAgICB2YXIgdGVtcGxhdGUgPVxuICAgICAgICAnPGRpdiAnKyBkaXJlY3RpdmVOYW1lICsnLXBvcHVwICcrXG4gICAgICAgICAgJ3RpdGxlPVwiJytzdGFydFN5bSsndGl0bGUnK2VuZFN5bSsnXCIgJytcbiAgICAgICAgICAob3B0aW9ucy51c2VDb250ZW50RXhwID9cbiAgICAgICAgICAgICdjb250ZW50LWV4cD1cImNvbnRlbnRFeHAoKVwiICcgOlxuICAgICAgICAgICAgJ2NvbnRlbnQ9XCInK3N0YXJ0U3ltKydjb250ZW50JytlbmRTeW0rJ1wiICcpICtcbiAgICAgICAgICAncGxhY2VtZW50PVwiJytzdGFydFN5bSsncGxhY2VtZW50JytlbmRTeW0rJ1wiICcrXG4gICAgICAgICAgJ3BvcHVwLWNsYXNzPVwiJytzdGFydFN5bSsncG9wdXBDbGFzcycrZW5kU3ltKydcIiAnK1xuICAgICAgICAgICdhbmltYXRpb249XCJhbmltYXRpb25cIiAnK1xuICAgICAgICAgICdpcy1vcGVuPVwiaXNPcGVuXCInK1xuICAgICAgICAgICdvcmlnaW4tc2NvcGU9XCJvcmlnU2NvcGVcIiAnK1xuICAgICAgICAgICc+JytcbiAgICAgICAgJzwvZGl2Pic7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgICAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbSwgdEF0dHJzKSB7XG4gICAgICAgICAgdmFyIHRvb2x0aXBMaW5rZXIgPSAkY29tcGlsZSggdGVtcGxhdGUgKTtcblxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBsaW5rKHNjb3BlLCBlbGVtZW50LCBhdHRycywgdG9vbHRpcEN0cmwpIHtcbiAgICAgICAgICAgIHZhciB0b29sdGlwO1xuICAgICAgICAgICAgdmFyIHRvb2x0aXBMaW5rZWRTY29wZTtcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgICAgICAgIHZhciBwb3B1cFRpbWVvdXQ7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25UaW1lb3V0O1xuICAgICAgICAgICAgdmFyIGFwcGVuZFRvQm9keSA9IGFuZ3VsYXIuaXNEZWZpbmVkKG9wdGlvbnMuYXBwZW5kVG9Cb2R5KSA/IG9wdGlvbnMuYXBwZW5kVG9Cb2R5IDogZmFsc2U7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlcnMgPSBnZXRUcmlnZ2Vycyh1bmRlZmluZWQpO1xuICAgICAgICAgICAgdmFyIGhhc0VuYWJsZUV4cCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzW3ByZWZpeCArICdFbmFibGUnXSk7XG4gICAgICAgICAgICB2YXIgdHRTY29wZSA9IHNjb3BlLiRuZXcodHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcmVwb3NpdGlvblNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGlzT3BlbkV4cCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzW3ByZWZpeCArICdJc09wZW4nXSkgPyAkcGFyc2UoYXR0cnNbcHJlZml4ICsgJ0lzT3BlbiddKSA6IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25Ub29sdGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmICghdG9vbHRpcCkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICBpZiAoIXBvc2l0aW9uVGltZW91dCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uVGltZW91dCA9ICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHBvc2l0aW9uaW5nIGFuZCBib3ggc2l6ZSBmb3IgY29ycmVjdCB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgIHRvb2x0aXAuY3NzKHsgdG9wOiAwLCBsZWZ0OiAwLCB3aWR0aDogJ2F1dG8nLCBoZWlnaHQ6ICdhdXRvJyB9KTtcblxuICAgICAgICAgICAgICAgICAgdmFyIHR0Qm94ID0gJHBvc2l0aW9uLnBvc2l0aW9uKHRvb2x0aXApO1xuICAgICAgICAgICAgICAgICAgdmFyIHR0Q3NzID0gJHBvc2l0aW9uLnBvc2l0aW9uRWxlbWVudHMoZWxlbWVudCwgdG9vbHRpcCwgdHRTY29wZS5wbGFjZW1lbnQsIGFwcGVuZFRvQm9keSk7XG4gICAgICAgICAgICAgICAgICB0dENzcy50b3AgKz0gJ3B4JztcbiAgICAgICAgICAgICAgICAgIHR0Q3NzLmxlZnQgKz0gJ3B4JztcblxuICAgICAgICAgICAgICAgICAgdHRDc3Mud2lkdGggPSB0dEJveC53aWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICB0dENzcy5oZWlnaHQgPSB0dEJveC5oZWlnaHQgKyAncHgnO1xuXG4gICAgICAgICAgICAgICAgICAvLyBOb3cgc2V0IHRoZSBjYWxjdWxhdGVkIHBvc2l0aW9uaW5nIGFuZCBzaXplLlxuICAgICAgICAgICAgICAgICAgdG9vbHRpcC5jc3ModHRDc3MpO1xuXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvblRpbWVvdXQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgfSwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTZXQgdXAgdGhlIGNvcnJlY3Qgc2NvcGUgdG8gYWxsb3cgdHJhbnNjbHVzaW9uIGxhdGVyXG4gICAgICAgICAgICB0dFNjb3BlLm9yaWdTY29wZSA9IHNjb3BlO1xuXG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCB0aGUgdG9vbHRpcCBpcyBub3Qgb3Blbi5cbiAgICAgICAgICAgIC8vIFRPRE8gYWRkIGFiaWxpdHkgdG8gc3RhcnQgdG9vbHRpcCBvcGVuZWRcbiAgICAgICAgICAgIHR0U2NvcGUuaXNPcGVuID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRvZ2dsZVRvb2x0aXBCaW5kKCkge1xuICAgICAgICAgICAgICBpZiAoIXR0U2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXBCaW5kKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGlkZVRvb2x0aXBCaW5kKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2hvdyB0aGUgdG9vbHRpcCB3aXRoIGRlbGF5IGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNob3cgaXQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwQmluZCgpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc0VuYWJsZUV4cCAmJiAhc2NvcGUuJGV2YWwoYXR0cnNbcHJlZml4ICsgJ0VuYWJsZSddKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHByZXBhcmVUb29sdGlwKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHR0U2NvcGUucG9wdXBEZWxheSkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIHRvb2x0aXAgd2FzIGFscmVhZHkgc2NoZWR1bGVkIHRvIHBvcC11cC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGhhcHBlbnMgaWYgc2hvdyBpcyB0cmlnZ2VyZWQgbXVsdGlwbGUgdGltZXMgYmVmb3JlIGFueSBoaWRlIGlzIHRyaWdnZXJlZC5cbiAgICAgICAgICAgICAgICBpZiAoIXBvcHVwVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgcG9wdXBUaW1lb3V0ID0gJHRpbWVvdXQoc2hvdywgdHRTY29wZS5wb3B1cERlbGF5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNob3coKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBoaWRlVG9vbHRpcEJpbmQgKCkge1xuICAgICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kZGlnZXN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2hvdyB0aGUgdG9vbHRpcCBwb3B1cCBlbGVtZW50LlxuICAgICAgICAgICAgZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgICAgICAgcG9wdXBUaW1lb3V0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgcmVtb3ZlIHRyYW5zaXRpb24sIHdlIG11c3QgY2FuY2VsIGl0LCBsZXN0IHRoZVxuICAgICAgICAgICAgICAvLyB0b29sdGlwIGJlIG15c3RlcmlvdXNseSByZW1vdmVkLlxuICAgICAgICAgICAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwodHJhbnNpdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIERvbid0IHNob3cgZW1wdHkgdG9vbHRpcHMuXG4gICAgICAgICAgICAgIGlmICghKG9wdGlvbnMudXNlQ29udGVudEV4cCA/IHR0U2NvcGUuY29udGVudEV4cCgpIDogdHRTY29wZS5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbmd1bGFyLm5vb3A7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjcmVhdGVUb29sdGlwKCk7XG5cbiAgICAgICAgICAgICAgLy8gQW5kIHNob3cgdGhlIHRvb2x0aXAuXG4gICAgICAgICAgICAgIHR0U2NvcGUuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGlzT3BlbkV4cCkge1xuICAgICAgICAgICAgICAgIGlzT3BlbkV4cC5hc3NpZ24odHRTY29wZS5vcmlnU2NvcGUsIHR0U2NvcGUuaXNPcGVuKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICAgdHRTY29wZS4kYXBwbHkoKTsgLy8gZGlnZXN0IHJlcXVpcmVkIGFzICRhcHBseSBpcyBub3QgY2FsbGVkXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0b29sdGlwLmNzcyh7IGRpc3BsYXk6ICdibG9jaycgfSk7XG5cbiAgICAgICAgICAgICAgcG9zaXRpb25Ub29sdGlwKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhpZGUgdGhlIHRvb2x0aXAgcG9wdXAgZWxlbWVudC5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgICAgICAgIC8vIEZpcnN0IHRoaW5ncyBmaXJzdDogd2UgZG9uJ3Qgc2hvdyBpdCBhbnltb3JlLlxuICAgICAgICAgICAgICB0dFNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoaXNPcGVuRXhwKSB7XG4gICAgICAgICAgICAgICAgaXNPcGVuRXhwLmFzc2lnbih0dFNjb3BlLm9yaWdTY29wZSwgdHRTY29wZS5pc09wZW4pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy9pZiB0b29sdGlwIGlzIGdvaW5nIHRvIGJlIHNob3duIGFmdGVyIGRlbGF5LCB3ZSBtdXN0IGNhbmNlbCB0aGlzXG4gICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbChwb3B1cFRpbWVvdXQpO1xuICAgICAgICAgICAgICBwb3B1cFRpbWVvdXQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbChwb3NpdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgICBwb3NpdGlvblRpbWVvdXQgPSBudWxsO1xuXG4gICAgICAgICAgICAgIC8vIEFuZCBub3cgd2UgcmVtb3ZlIGl0IGZyb20gdGhlIERPTS4gSG93ZXZlciwgaWYgd2UgaGF2ZSBhbmltYXRpb24sIHdlXG4gICAgICAgICAgICAgIC8vIG5lZWQgdG8gd2FpdCBmb3IgaXQgdG8gZXhwaXJlIGJlZm9yZWhhbmQuXG4gICAgICAgICAgICAgIC8vIEZJWE1FOiB0aGlzIGlzIGEgcGxhY2Vob2xkZXIgZm9yIGEgcG9ydCBvZiB0aGUgdHJhbnNpdGlvbnMgbGlicmFyeS5cbiAgICAgICAgICAgICAgaWYgKHR0U2NvcGUuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc2l0aW9uVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvblRpbWVvdXQgPSAkdGltZW91dChyZW1vdmVUb29sdGlwLCA1MDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVUb29sdGlwKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlVG9vbHRpcCgpIHtcbiAgICAgICAgICAgICAgLy8gVGhlcmUgY2FuIG9ubHkgYmUgb25lIHRvb2x0aXAgZWxlbWVudCBwZXIgZGlyZWN0aXZlIHNob3duIGF0IG9uY2UuXG4gICAgICAgICAgICAgIGlmICh0b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvb2x0aXBMaW5rZWRTY29wZSA9IHR0U2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgICB0b29sdGlwID0gdG9vbHRpcExpbmtlcih0b29sdGlwTGlua2VkU2NvcGUsIGZ1bmN0aW9uKHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAgICAgICAgICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLmFwcGVuZCh0b29sdGlwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZnRlcih0b29sdGlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnVzZUNvbnRlbnRFeHApIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwTGlua2VkU2NvcGUuJHdhdGNoKCdjb250ZW50RXhwKCknLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghdmFsICYmIHR0U2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRvb2x0aXBMaW5rZWRTY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXJlcG9zaXRpb25TY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwb3NpdGlvblNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBMaW5rZWRTY29wZS4kJHBvc3REaWdlc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVwb3NpdGlvblNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Ub29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZVRvb2x0aXAoKSB7XG4gICAgICAgICAgICAgIHRyYW5zaXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXAgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0b29sdGlwTGlua2VkU2NvcGUpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwTGlua2VkU2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0b29sdGlwTGlua2VkU2NvcGUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBhcmVUb29sdGlwKCkge1xuICAgICAgICAgICAgICBwcmVwUG9wdXBDbGFzcygpO1xuICAgICAgICAgICAgICBwcmVwUGxhY2VtZW50KCk7XG4gICAgICAgICAgICAgIHByZXBQb3B1cERlbGF5KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHR0U2NvcGUuY29udGVudEV4cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuJGV2YWwoYXR0cnNbdHlwZV0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPYnNlcnZlIHRoZSByZWxldmFudCBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudXNlQ29udGVudEV4cCkge1xuICAgICAgICAgICAgICBhdHRycy4kb2JzZXJ2ZSh0eXBlLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICB0dFNjb3BlLmNvbnRlbnQgPSB2YWw7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXZhbCAmJiB0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvblRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdHRycy4kb2JzZXJ2ZSgnZGlzYWJsZWQnLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgaWYgKHBvcHVwVGltZW91dCAmJiB2YWwpIHtcbiAgICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwocG9wdXBUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBwb3B1cFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHZhbCAmJiB0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKHByZWZpeCArICdUaXRsZScsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICB0dFNjb3BlLnRpdGxlID0gdmFsO1xuICAgICAgICAgICAgICBwb3NpdGlvblRvb2x0aXAoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhdHRycy4kb2JzZXJ2ZShwcmVmaXggKyAnUGxhY2VtZW50JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmICh0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIHByZXBQbGFjZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChpc09wZW5FeHApIHtcbiAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKGlzT3BlbkV4cCwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCAhPT0gdHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgIHRvZ2dsZVRvb2x0aXBCaW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcHJlcFBvcHVwQ2xhc3MoKSB7XG4gICAgICAgICAgICAgIHR0U2NvcGUucG9wdXBDbGFzcyA9IGF0dHJzW3ByZWZpeCArICdDbGFzcyddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwcmVwUGxhY2VtZW50KCkge1xuICAgICAgICAgICAgICB2YXIgdmFsID0gYXR0cnNbcHJlZml4ICsgJ1BsYWNlbWVudCddO1xuICAgICAgICAgICAgICB0dFNjb3BlLnBsYWNlbWVudCA9IGFuZ3VsYXIuaXNEZWZpbmVkKHZhbCkgPyB2YWwgOiBvcHRpb25zLnBsYWNlbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcHJlcFBvcHVwRGVsYXkoKSB7XG4gICAgICAgICAgICAgIHZhciB2YWwgPSBhdHRyc1twcmVmaXggKyAnUG9wdXBEZWxheSddO1xuICAgICAgICAgICAgICB2YXIgZGVsYXkgPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgICAgICAgICAgdHRTY29wZS5wb3B1cERlbGF5ID0gIWlzTmFOKGRlbGF5KSA/IGRlbGF5IDogb3B0aW9ucy5wb3B1cERlbGF5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdW5yZWdpc3RlclRyaWdnZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXJzLnNob3cuZm9yRWFjaChmdW5jdGlvbih0cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC51bmJpbmQodHJpZ2dlciwgc2hvd1Rvb2x0aXBCaW5kKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRyaWdnZXJzLmhpZGUuZm9yRWFjaChmdW5jdGlvbih0cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC51bmJpbmQodHJpZ2dlciwgaGlkZVRvb2x0aXBCaW5kKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBwcmVwVHJpZ2dlcnMoKSB7XG4gICAgICAgICAgICAgIHZhciB2YWwgPSBhdHRyc1twcmVmaXggKyAnVHJpZ2dlciddO1xuICAgICAgICAgICAgICB1bnJlZ2lzdGVyVHJpZ2dlcnMoKTtcblxuICAgICAgICAgICAgICB0cmlnZ2VycyA9IGdldFRyaWdnZXJzKHZhbCk7XG5cbiAgICAgICAgICAgICAgaWYgKHRyaWdnZXJzLnNob3cgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJzLnNob3cuZm9yRWFjaChmdW5jdGlvbih0cmlnZ2VyLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIHJhdyBhZGRFdmVudExpc3RlbmVyIGR1ZSB0byBqcUxpdGUvalF1ZXJ5IGJ1ZyAtICM0MDYwXG4gICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlciA9PT0gdHJpZ2dlcnMuaGlkZVtpZHhdKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcih0cmlnZ2VyLCB0b2dnbGVUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFswXS5hZGRFdmVudExpc3RlbmVyKHRyaWdnZXIsIHNob3dUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcih0cmlnZ2Vycy5oaWRlW2lkeF0sIGhpZGVUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXBUcmlnZ2VycygpO1xuXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gc2NvcGUuJGV2YWwoYXR0cnNbcHJlZml4ICsgJ0FuaW1hdGlvbiddKTtcbiAgICAgICAgICAgIHR0U2NvcGUuYW5pbWF0aW9uID0gYW5ndWxhci5pc0RlZmluZWQoYW5pbWF0aW9uKSA/ICEhYW5pbWF0aW9uIDogb3B0aW9ucy5hbmltYXRpb247XG5cbiAgICAgICAgICAgIHZhciBhcHBlbmRUb0JvZHlWYWwgPSBzY29wZS4kZXZhbChhdHRyc1twcmVmaXggKyAnQXBwZW5kVG9Cb2R5J10pO1xuICAgICAgICAgICAgYXBwZW5kVG9Cb2R5ID0gYW5ndWxhci5pc0RlZmluZWQoYXBwZW5kVG9Cb2R5VmFsKSA/IGFwcGVuZFRvQm9keVZhbCA6IGFwcGVuZFRvQm9keTtcblxuICAgICAgICAgICAgLy8gaWYgYSB0b29sdGlwIGlzIGF0dGFjaGVkIHRvIDxib2R5PiB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBvblxuICAgICAgICAgICAgLy8gbG9jYXRpb24gY2hhbmdlIGFzIGl0cyBwYXJlbnQgc2NvcGUgd2lsbCBwcm9iYWJseSBub3QgYmUgZGVzdHJveWVkXG4gICAgICAgICAgICAvLyBieSB0aGUgY2hhbmdlLlxuICAgICAgICAgICAgaWYgKGFwcGVuZFRvQm9keSkge1xuICAgICAgICAgICAgICBzY29wZS4kb24oJyRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3MnLCBmdW5jdGlvbiBjbG9zZVRvb2x0aXBPbkxvY2F0aW9uQ2hhbmdlU3VjY2VzcygpIHtcbiAgICAgICAgICAgICAgICBpZiAodHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdG9vbHRpcCBpcyBkZXN0cm95ZWQgYW5kIHJlbW92ZWQuXG4gICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gb25EZXN0cm95VG9vbHRpcCgpIHtcbiAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHRyYW5zaXRpb25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHBvcHVwVGltZW91dCk7XG4gICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbChwb3NpdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgICB1bnJlZ2lzdGVyVHJpZ2dlcnMoKTtcbiAgICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICB0dFNjb3BlID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfV07XG59KVxuXG4vLyBUaGlzIGlzIG1vc3RseSBuZ0luY2x1ZGUgY29kZSBidXQgd2l0aCBhIGN1c3RvbSBzY29wZVxuLmRpcmVjdGl2ZSgndG9vbHRpcFRlbXBsYXRlVHJhbnNjbHVkZScsIFtcbiAgICAgICAgICckYW5pbWF0ZScsICckc2NlJywgJyRjb21waWxlJywgJyR0ZW1wbGF0ZVJlcXVlc3QnLFxuZnVuY3Rpb24gKCRhbmltYXRlICwgICRzY2UgLCAgJGNvbXBpbGUgLCAgJHRlbXBsYXRlUmVxdWVzdCkge1xuICByZXR1cm4ge1xuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtLCBhdHRycykge1xuICAgICAgdmFyIG9yaWdTY29wZSA9IHNjb3BlLiRldmFsKGF0dHJzLnRvb2x0aXBUZW1wbGF0ZVRyYW5zY2x1ZGVTY29wZSk7XG5cbiAgICAgIHZhciBjaGFuZ2VDb3VudGVyID0gMCxcbiAgICAgICAgY3VycmVudFNjb3BlLFxuICAgICAgICBwcmV2aW91c0VsZW1lbnQsXG4gICAgICAgIGN1cnJlbnRFbGVtZW50O1xuXG4gICAgICB2YXIgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocHJldmlvdXNFbGVtZW50KSB7XG4gICAgICAgICAgcHJldmlvdXNFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgIHByZXZpb3VzRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRTY29wZSkge1xuICAgICAgICAgIGN1cnJlbnRTY29wZS4kZGVzdHJveSgpO1xuICAgICAgICAgIGN1cnJlbnRTY29wZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgJGFuaW1hdGUubGVhdmUoY3VycmVudEVsZW1lbnQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwcmV2aW91c0VsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHByZXZpb3VzRWxlbWVudCA9IGN1cnJlbnRFbGVtZW50O1xuICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2NvcGUuJHdhdGNoKCRzY2UucGFyc2VBc1Jlc291cmNlVXJsKGF0dHJzLnRvb2x0aXBUZW1wbGF0ZVRyYW5zY2x1ZGUpLCBmdW5jdGlvbihzcmMpIHtcbiAgICAgICAgdmFyIHRoaXNDaGFuZ2VJZCA9ICsrY2hhbmdlQ291bnRlcjtcblxuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgLy9zZXQgdGhlIDJuZCBwYXJhbSB0byB0cnVlIHRvIGlnbm9yZSB0aGUgdGVtcGxhdGUgcmVxdWVzdCBlcnJvciBzbyB0aGF0IHRoZSBpbm5lclxuICAgICAgICAgIC8vY29udGVudHMgYW5kIHNjb3BlIGNhbiBiZSBjbGVhbmVkIHVwLlxuICAgICAgICAgICR0ZW1wbGF0ZVJlcXVlc3Qoc3JjLCB0cnVlKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAodGhpc0NoYW5nZUlkICE9PSBjaGFuZ2VDb3VudGVyKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgdmFyIG5ld1Njb3BlID0gb3JpZ1Njb3BlLiRuZXcoKTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IHJlc3BvbnNlO1xuXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSAkY29tcGlsZSh0ZW1wbGF0ZSkobmV3U2NvcGUsIGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICAgICAgICAgIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQoKTtcbiAgICAgICAgICAgICAgJGFuaW1hdGUuZW50ZXIoY2xvbmUsIGVsZW0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRTY29wZSA9IG5ld1Njb3BlO1xuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBjbG9uZTtcblxuICAgICAgICAgICAgY3VycmVudFNjb3BlLiRlbWl0KCckaW5jbHVkZUNvbnRlbnRMb2FkZWQnLCBzcmMpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXNDaGFuZ2VJZCA9PT0gY2hhbmdlQ291bnRlcikge1xuICAgICAgICAgICAgICBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KCk7XG4gICAgICAgICAgICAgIHNjb3BlLiRlbWl0KCckaW5jbHVkZUNvbnRlbnRFcnJvcicsIHNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2NvcGUuJGVtaXQoJyRpbmNsdWRlQ29udGVudFJlcXVlc3RlZCcsIHNyYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQpO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4vKipcbiAqIE5vdGUgdGhhdCBpdCdzIGludGVudGlvbmFsIHRoYXQgdGhlc2UgY2xhc3NlcyBhcmUgKm5vdCogYXBwbGllZCB0aHJvdWdoICRhbmltYXRlLlxuICogVGhleSBtdXN0IG5vdCBiZSBhbmltYXRlZCBhcyB0aGV5J3JlIGV4cGVjdGVkIHRvIGJlIHByZXNlbnQgb24gdGhlIHRvb2x0aXAgb25cbiAqIGluaXRpYWxpemF0aW9uLlxuICovXG4uZGlyZWN0aXZlKCd0b29sdGlwQ2xhc3NlcycsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICBpZiAoc2NvcGUucGxhY2VtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3Moc2NvcGUucGxhY2VtZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChzY29wZS5wb3B1cENsYXNzKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3Moc2NvcGUucG9wdXBDbGFzcyk7XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGUuYW5pbWF0aW9uKCkpIHtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhhdHRycy50b29sdGlwQW5pbWF0aW9uQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3Rvb2x0aXBQb3B1cCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgc2NvcGU6IHsgY29udGVudDogJ0AnLCBwbGFjZW1lbnQ6ICdAJywgcG9wdXBDbGFzczogJ0AnLCBhbmltYXRpb246ICcmJywgaXNPcGVuOiAnJicgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1wb3B1cC5odG1sJ1xuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndG9vbHRpcCcsIFsgJyR0b29sdGlwJywgZnVuY3Rpb24oJHRvb2x0aXApIHtcbiAgcmV0dXJuICR0b29sdGlwKCd0b29sdGlwJywgJ3Rvb2x0aXAnLCAnbW91c2VlbnRlcicpO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3Rvb2x0aXBUZW1wbGF0ZVBvcHVwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBzY29wZTogeyBjb250ZW50RXhwOiAnJicsIHBsYWNlbWVudDogJ0AnLCBwb3B1cENsYXNzOiAnQCcsIGFuaW1hdGlvbjogJyYnLCBpc09wZW46ICcmJyxcbiAgICAgIG9yaWdpblNjb3BlOiAnJicgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cC5odG1sJ1xuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndG9vbHRpcFRlbXBsYXRlJywgWyckdG9vbHRpcCcsIGZ1bmN0aW9uKCR0b29sdGlwKSB7XG4gIHJldHVybiAkdG9vbHRpcCgndG9vbHRpcFRlbXBsYXRlJywgJ3Rvb2x0aXAnLCAnbW91c2VlbnRlcicsIHtcbiAgICB1c2VDb250ZW50RXhwOiB0cnVlXG4gIH0pO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3Rvb2x0aXBIdG1sUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IGNvbnRlbnRFeHA6ICcmJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC1wb3B1cC5odG1sJ1xuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndG9vbHRpcEh0bWwnLCBbJyR0b29sdGlwJywgZnVuY3Rpb24oJHRvb2x0aXApIHtcbiAgcmV0dXJuICR0b29sdGlwKCd0b29sdGlwSHRtbCcsICd0b29sdGlwJywgJ21vdXNlZW50ZXInLCB7XG4gICAgdXNlQ29udGVudEV4cDogdHJ1ZVxuICB9KTtcbn1dKVxuXG4vKlxuRGVwcmVjYXRlZFxuKi9cbi5kaXJlY3RpdmUoJ3Rvb2x0aXBIdG1sVW5zYWZlUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IGNvbnRlbnQ6ICdAJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC11bnNhZmUtcG9wdXAuaHRtbCdcbiAgfTtcbn0pXG5cbi52YWx1ZSgndG9vbHRpcEh0bWxVbnNhZmVTdXBwcmVzc0RlcHJlY2F0ZWQnLCBmYWxzZSlcbi5kaXJlY3RpdmUoJ3Rvb2x0aXBIdG1sVW5zYWZlJywgW1xuICAgICAgICAgICckdG9vbHRpcCcsICd0b29sdGlwSHRtbFVuc2FmZVN1cHByZXNzRGVwcmVjYXRlZCcsICckbG9nJyxcbmZ1bmN0aW9uKCR0b29sdGlwICwgIHRvb2x0aXBIdG1sVW5zYWZlU3VwcHJlc3NEZXByZWNhdGVkICwgICRsb2cpIHtcbiAgaWYgKCF0b29sdGlwSHRtbFVuc2FmZVN1cHByZXNzRGVwcmVjYXRlZCkge1xuICAgICRsb2cud2FybigndG9vbHRpcC1odG1sLXVuc2FmZSBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHRvb2x0aXAtaHRtbCBvciB0b29sdGlwLXRlbXBsYXRlIGluc3RlYWQuJyk7XG4gIH1cbiAgcmV0dXJuICR0b29sdGlwKCd0b29sdGlwSHRtbFVuc2FmZScsICd0b29sdGlwJywgJ21vdXNlZW50ZXInKTtcbn1dKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZlYXR1cmVzIGFyZSBzdGlsbCBvdXRzdGFuZGluZzogcG9wdXAgZGVsYXksIGFuaW1hdGlvbiBhcyBhXG4gKiBmdW5jdGlvbiwgcGxhY2VtZW50IGFzIGEgZnVuY3Rpb24sIGluc2lkZSwgc3VwcG9ydCBmb3IgbW9yZSB0cmlnZ2VycyB0aGFuXG4gKiBqdXN0IG1vdXNlIGVudGVyL2xlYXZlLCBhbmQgc2VsZWN0b3IgZGVsZWdhdGF0aW9uLlxuICovXG5hbmd1bGFyLm1vZHVsZSggJ3VpLmJvb3RzdHJhcC5wb3BvdmVyJywgWyd1aS5ib290c3RyYXAudG9vbHRpcCddKVxuXG4uZGlyZWN0aXZlKCdwb3BvdmVyVGVtcGxhdGVQb3B1cCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgc2NvcGU6IHsgdGl0bGU6ICdAJywgY29udGVudEV4cDogJyYnLCBwbGFjZW1lbnQ6ICdAJywgcG9wdXBDbGFzczogJ0AnLCBhbmltYXRpb246ICcmJywgaXNPcGVuOiAnJicsXG4gICAgICBvcmlnaW5TY29wZTogJyYnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUuaHRtbCdcbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3BvcG92ZXJUZW1wbGF0ZScsIFsnJHRvb2x0aXAnLCBmdW5jdGlvbigkdG9vbHRpcCkge1xuICByZXR1cm4gJHRvb2x0aXAoJ3BvcG92ZXJUZW1wbGF0ZScsICdwb3BvdmVyJywgJ2NsaWNrJywge1xuICAgIHVzZUNvbnRlbnRFeHA6IHRydWVcbiAgfSk7XG59XSlcblxuLmRpcmVjdGl2ZSgncG9wb3Zlckh0bWxQb3B1cCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgc2NvcGU6IHsgY29udGVudEV4cDogJyYnLCB0aXRsZTogJ0AnLCBwbGFjZW1lbnQ6ICdAJywgcG9wdXBDbGFzczogJ0AnLCBhbmltYXRpb246ICcmJywgaXNPcGVuOiAnJicgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci1odG1sLmh0bWwnXG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCdwb3BvdmVySHRtbCcsIFsnJHRvb2x0aXAnLCBmdW5jdGlvbigkdG9vbHRpcCkge1xuICByZXR1cm4gJHRvb2x0aXAoICdwb3BvdmVySHRtbCcsICdwb3BvdmVyJywgJ2NsaWNrJywge1xuICAgIHVzZUNvbnRlbnRFeHA6IHRydWVcbiAgfSk7XG59XSlcblxuLmRpcmVjdGl2ZSgncG9wb3ZlclBvcHVwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBzY29wZTogeyB0aXRsZTogJ0AnLCBjb250ZW50OiAnQCcsIHBsYWNlbWVudDogJ0AnLCBwb3B1cENsYXNzOiAnQCcsIGFuaW1hdGlvbjogJyYnLCBpc09wZW46ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWwnXG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCdwb3BvdmVyJywgWyckdG9vbHRpcCcsIGZ1bmN0aW9uKCR0b29sdGlwKSB7XG4gIHJldHVybiAkdG9vbHRpcCggJ3BvcG92ZXInLCAncG9wb3ZlcicsICdjbGljaycgKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5wcm9ncmVzc2JhcicsIFtdKVxuXG4uY29uc3RhbnQoJ3Byb2dyZXNzQ29uZmlnJywge1xuICBhbmltYXRlOiB0cnVlLFxuICBtYXg6IDEwMFxufSlcblxuLnZhbHVlKCckcHJvZ3Jlc3NTdXBwcmVzc1dhcm5pbmcnLCBmYWxzZSlcblxuLmNvbnRyb2xsZXIoJ1Byb2dyZXNzQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICdwcm9ncmVzc0NvbmZpZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCBwcm9ncmVzc0NvbmZpZykge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBhbmltYXRlID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmFuaW1hdGUpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLmFuaW1hdGUpIDogcHJvZ3Jlc3NDb25maWcuYW5pbWF0ZTtcblxuICB0aGlzLmJhcnMgPSBbXTtcbiAgJHNjb3BlLm1heCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRzY29wZS5tYXgpID8gJHNjb3BlLm1heCA6IHByb2dyZXNzQ29uZmlnLm1heDtcblxuICB0aGlzLmFkZEJhciA9IGZ1bmN0aW9uKGJhciwgZWxlbWVudCkge1xuICAgIGlmICghYW5pbWF0ZSkge1xuICAgICAgZWxlbWVudC5jc3Moeyd0cmFuc2l0aW9uJzogJ25vbmUnfSk7XG4gICAgfVxuXG4gICAgdGhpcy5iYXJzLnB1c2goYmFyKTtcblxuICAgIGJhci5tYXggPSAkc2NvcGUubWF4O1xuXG4gICAgYmFyLiR3YXRjaCgndmFsdWUnLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgYmFyLnJlY2FsY3VsYXRlUGVyY2VudGFnZSgpO1xuICAgIH0pO1xuXG4gICAgYmFyLnJlY2FsY3VsYXRlUGVyY2VudGFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgYmFyLnBlcmNlbnQgPSArKDEwMCAqIGJhci52YWx1ZSAvIGJhci5tYXgpLnRvRml4ZWQoMik7XG5cbiAgICAgIHZhciB0b3RhbFBlcmNlbnRhZ2UgPSBzZWxmLmJhcnMucmVkdWNlKGZ1bmN0aW9uKHRvdGFsLCBiYXIpIHtcbiAgICAgICAgcmV0dXJuIHRvdGFsICsgYmFyLnBlcmNlbnQ7XG4gICAgICB9LCAwKTtcblxuICAgICAgaWYgKHRvdGFsUGVyY2VudGFnZSA+IDEwMCkge1xuICAgICAgICBiYXIucGVyY2VudCAtPSB0b3RhbFBlcmNlbnRhZ2UgLSAxMDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGJhci4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgIHNlbGYucmVtb3ZlQmFyKGJhcik7XG4gICAgfSk7XG4gIH07XG5cbiAgdGhpcy5yZW1vdmVCYXIgPSBmdW5jdGlvbihiYXIpIHtcbiAgICAgIHRoaXMuYmFycy5zcGxpY2UodGhpcy5iYXJzLmluZGV4T2YoYmFyKSwgMSk7XG4gIH07XG5cbiAgJHNjb3BlLiR3YXRjaCgnbWF4JywgZnVuY3Rpb24obWF4KSB7XG4gICAgc2VsZi5iYXJzLmZvckVhY2goZnVuY3Rpb24oYmFyKSB7XG4gICAgICBiYXIubWF4ID0gJHNjb3BlLm1heDtcbiAgICAgIGJhci5yZWNhbGN1bGF0ZVBlcmNlbnRhZ2UoKTtcbiAgICB9KTtcbiAgfSk7XG59XSlcblxuLmRpcmVjdGl2ZSgndWliUHJvZ3Jlc3MnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgY29udHJvbGxlcjogJ1Byb2dyZXNzQ29udHJvbGxlcicsXG4gICAgcmVxdWlyZTogJ3VpYlByb2dyZXNzJyxcbiAgICBzY29wZToge1xuICAgICAgbWF4OiAnPT8nXG4gICAgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzLmh0bWwnXG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCdwcm9ncmVzcycsIFsnJGxvZycsICckcHJvZ3Jlc3NTdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkbG9nLCAkcHJvZ3Jlc3NTdXBwcmVzc1dhcm5pbmcpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgY29udHJvbGxlcjogJ1Byb2dyZXNzQ29udHJvbGxlcicsXG4gICAgcmVxdWlyZTogJ3Byb2dyZXNzJyxcbiAgICBzY29wZToge1xuICAgICAgbWF4OiAnPT8nXG4gICAgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzLmh0bWwnLFxuICAgIGxpbms6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCRwcm9ncmVzc1N1cHByZXNzV2FybmluZykge1xuICAgICAgICAkbG9nLndhcm4oJ3Byb2dyZXNzIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLXByb2dyZXNzIGluc3RlYWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgndWliQmFyJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHJlcXVpcmU6ICdedWliUHJvZ3Jlc3MnLFxuICAgIHNjb3BlOiB7XG4gICAgICB2YWx1ZTogJz0nLFxuICAgICAgdHlwZTogJ0AnXG4gICAgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3Byb2dyZXNzYmFyL2Jhci5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIHByb2dyZXNzQ3RybCkge1xuICAgICAgcHJvZ3Jlc3NDdHJsLmFkZEJhcihzY29wZSwgZWxlbWVudCk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgnYmFyJywgWyckbG9nJywgJyRwcm9ncmVzc1N1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRsb2csICRwcm9ncmVzc1N1cHByZXNzV2FybmluZykge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXF1aXJlOiAnXnByb2dyZXNzJyxcbiAgICBzY29wZToge1xuICAgICAgdmFsdWU6ICc9JyxcbiAgICAgIHR5cGU6ICdAJ1xuICAgIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBwcm9ncmVzc0N0cmwpIHtcbiAgICAgIGlmICgkcHJvZ3Jlc3NTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgJGxvZy53YXJuKCdiYXIgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWItYmFyIGluc3RlYWQnKTtcbiAgICAgIH1cbiAgICAgIHByb2dyZXNzQ3RybC5hZGRCYXIoc2NvcGUsIGVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdwcm9ncmVzc2JhcicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICBjb250cm9sbGVyOiAnUHJvZ3Jlc3NDb250cm9sbGVyJyxcbiAgICBzY29wZToge1xuICAgICAgdmFsdWU6ICc9JyxcbiAgICAgIG1heDogJz0/JyxcbiAgICAgIHR5cGU6ICdAJ1xuICAgIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIHByb2dyZXNzQ3RybCkge1xuICAgICAgcHJvZ3Jlc3NDdHJsLmFkZEJhcihzY29wZSwgYW5ndWxhci5lbGVtZW50KGVsZW1lbnQuY2hpbGRyZW4oKVswXSkpO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnJhdGluZycsIFtdKVxuXG4uY29uc3RhbnQoJ3JhdGluZ0NvbmZpZycsIHtcbiAgbWF4OiA1LFxuICBzdGF0ZU9uOiBudWxsLFxuICBzdGF0ZU9mZjogbnVsbCxcbiAgdGl0bGVzIDogWydvbmUnLCAndHdvJywgJ3RocmVlJywgJ2ZvdXInLCAnZml2ZSddXG59KVxuXG4uY29udHJvbGxlcignUmF0aW5nQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICdyYXRpbmdDb25maWcnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgcmF0aW5nQ29uZmlnKSB7XG4gIHZhciBuZ01vZGVsQ3RybCAgPSB7ICRzZXRWaWV3VmFsdWU6IGFuZ3VsYXIubm9vcCB9O1xuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKG5nTW9kZWxDdHJsXykge1xuICAgIG5nTW9kZWxDdHJsID0gbmdNb2RlbEN0cmxfO1xuICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSB0aGlzLnJlbmRlcjtcblxuICAgIG5nTW9kZWxDdHJsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChhbmd1bGFyLmlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSA8PCAwICE9PSB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zdGF0ZU9uID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnN0YXRlT24pID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnN0YXRlT24pIDogcmF0aW5nQ29uZmlnLnN0YXRlT247XG4gICAgdGhpcy5zdGF0ZU9mZiA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5zdGF0ZU9mZikgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuc3RhdGVPZmYpIDogcmF0aW5nQ29uZmlnLnN0YXRlT2ZmO1xuICAgIHZhciB0bXBUaXRsZXMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMudGl0bGVzKSAgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMudGl0bGVzKSA6IHJhdGluZ0NvbmZpZy50aXRsZXMgOyAgICBcbiAgICB0aGlzLnRpdGxlcyA9IGFuZ3VsYXIuaXNBcnJheSh0bXBUaXRsZXMpICYmIHRtcFRpdGxlcy5sZW5ndGggPiAwID9cbiAgICAgIHRtcFRpdGxlcyA6IHJhdGluZ0NvbmZpZy50aXRsZXM7XG4gICAgXG4gICAgdmFyIHJhdGluZ1N0YXRlcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5yYXRpbmdTdGF0ZXMpID9cbiAgICAgICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5yYXRpbmdTdGF0ZXMpIDpcbiAgICAgIG5ldyBBcnJheShhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMubWF4KSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5tYXgpIDogcmF0aW5nQ29uZmlnLm1heCk7XG4gICAgJHNjb3BlLnJhbmdlID0gdGhpcy5idWlsZFRlbXBsYXRlT2JqZWN0cyhyYXRpbmdTdGF0ZXMpO1xuICB9O1xuXG4gIHRoaXMuYnVpbGRUZW1wbGF0ZU9iamVjdHMgPSBmdW5jdGlvbihzdGF0ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHN0YXRlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHN0YXRlc1tpXSA9IGFuZ3VsYXIuZXh0ZW5kKHsgaW5kZXg6IGkgfSwgeyBzdGF0ZU9uOiB0aGlzLnN0YXRlT24sIHN0YXRlT2ZmOiB0aGlzLnN0YXRlT2ZmLCB0aXRsZTogdGhpcy5nZXRUaXRsZShpKSB9LCBzdGF0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGVzO1xuICB9O1xuICBcbiAgdGhpcy5nZXRUaXRsZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHRoaXMudGl0bGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGluZGV4ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudGl0bGVzW2luZGV4XTtcbiAgICB9XG4gIH07XG4gIFxuICAkc2NvcGUucmF0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCEkc2NvcGUucmVhZG9ubHkgJiYgdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAkc2NvcGUucmFuZ2UubGVuZ3RoKSB7XG4gICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUgPT09IHZhbHVlID8gMCA6IHZhbHVlKTtcbiAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIoKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLmVudGVyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoISRzY29wZS5yZWFkb25seSkge1xuICAgICAgJHNjb3BlLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgICRzY29wZS5vbkhvdmVyKHt2YWx1ZTogdmFsdWV9KTtcbiAgfTtcblxuICAkc2NvcGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUudmFsdWUgPSBuZ01vZGVsQ3RybC4kdmlld1ZhbHVlO1xuICAgICRzY29wZS5vbkxlYXZlKCk7XG4gIH07XG5cbiAgJHNjb3BlLm9uS2V5ZG93biA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIGlmICgvKDM3fDM4fDM5fDQwKS8udGVzdChldnQud2hpY2gpKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICRzY29wZS5yYXRlKCRzY29wZS52YWx1ZSArIChldnQud2hpY2ggPT09IDM4IHx8IGV2dC53aGljaCA9PT0gMzkgPyAxIDogLTEpKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUudmFsdWUgPSBuZ01vZGVsQ3RybC4kdmlld1ZhbHVlO1xuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3JhdGluZycsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcXVpcmU6IFsncmF0aW5nJywgJ25nTW9kZWwnXSxcbiAgICBzY29wZToge1xuICAgICAgcmVhZG9ubHk6ICc9PycsXG4gICAgICBvbkhvdmVyOiAnJicsXG4gICAgICBvbkxlYXZlOiAnJidcbiAgICB9LFxuICAgIGNvbnRyb2xsZXI6ICdSYXRpbmdDb250cm9sbGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbCcsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgcmF0aW5nQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuICAgICAgcmF0aW5nQ3RybC5pbml0KCBuZ01vZGVsQ3RybCApO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5cbi8qKlxuICogQG5nZG9jIG92ZXJ2aWV3XG4gKiBAbmFtZSB1aS5ib290c3RyYXAudGFic1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQW5ndWxhckpTIHZlcnNpb24gb2YgdGhlIHRhYnMgZGlyZWN0aXZlLlxuICovXG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudGFicycsIFtdKVxuXG4uY29udHJvbGxlcignVGFic2V0Q29udHJvbGxlcicsIFsnJHNjb3BlJywgZnVuY3Rpb24gVGFic2V0Q3RybCgkc2NvcGUpIHtcbiAgdmFyIGN0cmwgPSB0aGlzLFxuICAgICAgdGFicyA9IGN0cmwudGFicyA9ICRzY29wZS50YWJzID0gW107XG5cbiAgY3RybC5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3RlZFRhYikge1xuICAgIGFuZ3VsYXIuZm9yRWFjaCh0YWJzLCBmdW5jdGlvbih0YWIpIHtcbiAgICAgIGlmICh0YWIuYWN0aXZlICYmIHRhYiAhPT0gc2VsZWN0ZWRUYWIpIHtcbiAgICAgICAgdGFiLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0YWIub25EZXNlbGVjdCgpO1xuICAgICAgICBzZWxlY3RlZFRhYi5zZWxlY3RDYWxsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZWxlY3RlZFRhYi5hY3RpdmUgPSB0cnVlO1xuICAgIC8vIG9ubHkgY2FsbCBzZWxlY3QgaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gY2FsbGVkXG4gICAgaWYgKCFzZWxlY3RlZFRhYi5zZWxlY3RDYWxsZWQpIHtcbiAgICAgIHNlbGVjdGVkVGFiLm9uU2VsZWN0KCk7XG4gICAgICBzZWxlY3RlZFRhYi5zZWxlY3RDYWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBjdHJsLmFkZFRhYiA9IGZ1bmN0aW9uIGFkZFRhYih0YWIpIHtcbiAgICB0YWJzLnB1c2godGFiKTtcbiAgICAvLyB3ZSBjYW4ndCBydW4gdGhlIHNlbGVjdCBmdW5jdGlvbiBvbiB0aGUgZmlyc3QgdGFiXG4gICAgLy8gc2luY2UgdGhhdCB3b3VsZCBzZWxlY3QgaXQgdHdpY2VcbiAgICBpZiAodGFicy5sZW5ndGggPT09IDEgJiYgdGFiLmFjdGl2ZSAhPT0gZmFsc2UpIHtcbiAgICAgIHRhYi5hY3RpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGFiLmFjdGl2ZSkge1xuICAgICAgY3RybC5zZWxlY3QodGFiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFiLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBjdHJsLnJlbW92ZVRhYiA9IGZ1bmN0aW9uIHJlbW92ZVRhYih0YWIpIHtcbiAgICB2YXIgaW5kZXggPSB0YWJzLmluZGV4T2YodGFiKTtcbiAgICAvL1NlbGVjdCBhIG5ldyB0YWIgaWYgdGhlIHRhYiB0byBiZSByZW1vdmVkIGlzIHNlbGVjdGVkIGFuZCBub3QgZGVzdHJveWVkXG4gICAgaWYgKHRhYi5hY3RpdmUgJiYgdGFicy5sZW5ndGggPiAxICYmICFkZXN0cm95ZWQpIHtcbiAgICAgIC8vSWYgdGhpcyBpcyB0aGUgbGFzdCB0YWIsIHNlbGVjdCB0aGUgcHJldmlvdXMgdGFiLiBlbHNlLCB0aGUgbmV4dCB0YWIuXG4gICAgICB2YXIgbmV3QWN0aXZlSW5kZXggPSBpbmRleCA9PSB0YWJzLmxlbmd0aCAtIDEgPyBpbmRleCAtIDEgOiBpbmRleCArIDE7XG4gICAgICBjdHJsLnNlbGVjdCh0YWJzW25ld0FjdGl2ZUluZGV4XSk7XG4gICAgfVxuICAgIHRhYnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfTtcblxuICB2YXIgZGVzdHJveWVkO1xuICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gIH0pO1xufV0pXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgdWkuYm9vdHN0cmFwLnRhYnMuZGlyZWN0aXZlOnRhYnNldFxuICogQHJlc3RyaWN0IEVBXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUYWJzZXQgaXMgdGhlIG91dGVyIGNvbnRhaW5lciBmb3IgdGhlIHRhYnMgZGlyZWN0aXZlXG4gKlxuICogQHBhcmFtIHtib29sZWFuPX0gdmVydGljYWwgV2hldGhlciBvciBub3QgdG8gdXNlIHZlcnRpY2FsIHN0eWxpbmcgZm9yIHRoZSB0YWJzLlxuICogQHBhcmFtIHtib29sZWFuPX0ganVzdGlmaWVkIFdoZXRoZXIgb3Igbm90IHRvIHVzZSBqdXN0aWZpZWQgc3R5bGluZyBmb3IgdGhlIHRhYnMuXG4gKlxuICogQGV4YW1wbGVcbjxleGFtcGxlIG1vZHVsZT1cInVpLmJvb3RzdHJhcFwiPlxuICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgIDx0YWJzZXQ+XG4gICAgICA8dGFiIGhlYWRpbmc9XCJUYWIgMVwiPjxiPkZpcnN0PC9iPiBDb250ZW50ITwvdGFiPlxuICAgICAgPHRhYiBoZWFkaW5nPVwiVGFiIDJcIj48aT5TZWNvbmQ8L2k+IENvbnRlbnQhPC90YWI+XG4gICAgPC90YWJzZXQ+XG4gICAgPGhyIC8+XG4gICAgPHRhYnNldCB2ZXJ0aWNhbD1cInRydWVcIj5cbiAgICAgIDx0YWIgaGVhZGluZz1cIlZlcnRpY2FsIFRhYiAxXCI+PGI+Rmlyc3Q8L2I+IFZlcnRpY2FsIENvbnRlbnQhPC90YWI+XG4gICAgICA8dGFiIGhlYWRpbmc9XCJWZXJ0aWNhbCBUYWIgMlwiPjxpPlNlY29uZDwvaT4gVmVydGljYWwgQ29udGVudCE8L3RhYj5cbiAgICA8L3RhYnNldD5cbiAgICA8dGFic2V0IGp1c3RpZmllZD1cInRydWVcIj5cbiAgICAgIDx0YWIgaGVhZGluZz1cIkp1c3RpZmllZCBUYWIgMVwiPjxiPkZpcnN0PC9iPiBKdXN0aWZpZWQgQ29udGVudCE8L3RhYj5cbiAgICAgIDx0YWIgaGVhZGluZz1cIkp1c3RpZmllZCBUYWIgMlwiPjxpPlNlY29uZDwvaT4gSnVzdGlmaWVkIENvbnRlbnQhPC90YWI+XG4gICAgPC90YWJzZXQ+XG4gIDwvZmlsZT5cbjwvZXhhbXBsZT5cbiAqL1xuLmRpcmVjdGl2ZSgndGFic2V0JywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7XG4gICAgICB0eXBlOiAnQCdcbiAgICB9LFxuICAgIGNvbnRyb2xsZXI6ICdUYWJzZXRDb250cm9sbGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3RhYnMvdGFic2V0Lmh0bWwnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgc2NvcGUudmVydGljYWwgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy52ZXJ0aWNhbCkgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLnZlcnRpY2FsKSA6IGZhbHNlO1xuICAgICAgc2NvcGUuanVzdGlmaWVkID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuanVzdGlmaWVkKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMuanVzdGlmaWVkKSA6IGZhbHNlO1xuICAgIH1cbiAgfTtcbn0pXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgdWkuYm9vdHN0cmFwLnRhYnMuZGlyZWN0aXZlOnRhYlxuICogQHJlc3RyaWN0IEVBXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBoZWFkaW5nIFRoZSB2aXNpYmxlIGhlYWRpbmcsIG9yIHRpdGxlLCBvZiB0aGUgdGFiLiBTZXQgSFRNTCBoZWFkaW5ncyB3aXRoIHtAbGluayB1aS5ib290c3RyYXAudGFicy5kaXJlY3RpdmU6dGFiSGVhZGluZyB0YWJIZWFkaW5nfS5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gc2VsZWN0IEFuIGV4cHJlc3Npb24gdG8gZXZhbHVhdGUgd2hlbiB0aGUgdGFiIGlzIHNlbGVjdGVkLlxuICogQHBhcmFtIHtib29sZWFuPX0gYWN0aXZlIEEgYmluZGluZywgdGVsbGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRhYiBpcyBzZWxlY3RlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGRpc2FibGVkIEEgYmluZGluZywgdGVsbGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRhYiBpcyBkaXNhYmxlZC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYSB0YWIgd2l0aCBhIGhlYWRpbmcgYW5kIGNvbnRlbnQuIE11c3QgYmUgcGxhY2VkIHdpdGhpbiBhIHtAbGluayB1aS5ib290c3RyYXAudGFicy5kaXJlY3RpdmU6dGFic2V0IHRhYnNldH0uXG4gKlxuICogQGV4YW1wbGVcbjxleGFtcGxlIG1vZHVsZT1cInVpLmJvb3RzdHJhcFwiPlxuICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgIDxkaXYgbmctY29udHJvbGxlcj1cIlRhYnNEZW1vQ3RybFwiPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc21hbGxcIiBuZy1jbGljaz1cIml0ZW1zWzBdLmFjdGl2ZSA9IHRydWVcIj5cbiAgICAgICAgU2VsZWN0IGl0ZW0gMSwgdXNpbmcgYWN0aXZlIGJpbmRpbmdcbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc21hbGxcIiBuZy1jbGljaz1cIml0ZW1zWzFdLmRpc2FibGVkID0gIWl0ZW1zWzFdLmRpc2FibGVkXCI+XG4gICAgICAgIEVuYWJsZS9kaXNhYmxlIGl0ZW0gMiwgdXNpbmcgZGlzYWJsZWQgYmluZGluZ1xuICAgICAgPC9idXR0b24+XG4gICAgICA8YnIgLz5cbiAgICAgIDx0YWJzZXQ+XG4gICAgICAgIDx0YWIgaGVhZGluZz1cIlRhYiAxXCI+Rmlyc3QgVGFiPC90YWI+XG4gICAgICAgIDx0YWIgc2VsZWN0PVwiYWxlcnRNZSgpXCI+XG4gICAgICAgICAgPHRhYi1oZWFkaW5nPjxpIGNsYXNzPVwiaWNvbi1iZWxsXCI+PC9pPiBBbGVydCBtZSE8L3RhYi1oZWFkaW5nPlxuICAgICAgICAgIFNlY29uZCBUYWIsIHdpdGggYWxlcnQgY2FsbGJhY2sgYW5kIGh0bWwgaGVhZGluZyFcbiAgICAgICAgPC90YWI+XG4gICAgICAgIDx0YWIgbmctcmVwZWF0PVwiaXRlbSBpbiBpdGVtc1wiXG4gICAgICAgICAgaGVhZGluZz1cInt7aXRlbS50aXRsZX19XCJcbiAgICAgICAgICBkaXNhYmxlZD1cIml0ZW0uZGlzYWJsZWRcIlxuICAgICAgICAgIGFjdGl2ZT1cIml0ZW0uYWN0aXZlXCI+XG4gICAgICAgICAge3tpdGVtLmNvbnRlbnR9fVxuICAgICAgICA8L3RhYj5cbiAgICAgIDwvdGFic2V0PlxuICAgIDwvZGl2PlxuICA8L2ZpbGU+XG4gIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cbiAgICBmdW5jdGlvbiBUYWJzRGVtb0N0cmwoJHNjb3BlKSB7XG4gICAgICAkc2NvcGUuaXRlbXMgPSBbXG4gICAgICAgIHsgdGl0bGU6XCJEeW5hbWljIFRpdGxlIDFcIiwgY29udGVudDpcIkR5bmFtaWMgSXRlbSAwXCIgfSxcbiAgICAgICAgeyB0aXRsZTpcIkR5bmFtaWMgVGl0bGUgMlwiLCBjb250ZW50OlwiRHluYW1pYyBJdGVtIDFcIiwgZGlzYWJsZWQ6IHRydWUgfVxuICAgICAgXTtcblxuICAgICAgJHNjb3BlLmFsZXJ0TWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBhbGVydChcIllvdSd2ZSBzZWxlY3RlZCB0aGUgYWxlcnQgdGFiIVwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH07XG4gIDwvZmlsZT5cbjwvZXhhbXBsZT5cbiAqL1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHVpLmJvb3RzdHJhcC50YWJzLmRpcmVjdGl2ZTp0YWJIZWFkaW5nXG4gKiBAcmVzdHJpY3QgRUFcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYW4gSFRNTCBoZWFkaW5nIGZvciBhIHtAbGluayB1aS5ib290c3RyYXAudGFicy5kaXJlY3RpdmU6dGFiIHRhYn0uIE11c3QgYmUgcGxhY2VkIGFzIGEgY2hpbGQgb2YgYSB0YWIgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuPGV4YW1wbGUgbW9kdWxlPVwidWkuYm9vdHN0cmFwXCI+XG4gIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgPHRhYnNldD5cbiAgICAgIDx0YWI+XG4gICAgICAgIDx0YWItaGVhZGluZz48Yj5IVE1MPC9iPiBpbiBteSB0aXRsZXM/ITwvdGFiLWhlYWRpbmc+XG4gICAgICAgIEFuZCBzb21lIGNvbnRlbnQsIHRvbyFcbiAgICAgIDwvdGFiPlxuICAgICAgPHRhYj5cbiAgICAgICAgPHRhYi1oZWFkaW5nPjxpIGNsYXNzPVwiaWNvbi1oZWFydFwiPjwvaT4gSWNvbiBoZWFkaW5nPyE/PC90YWItaGVhZGluZz5cbiAgICAgICAgVGhhdCdzIHJpZ2h0LlxuICAgICAgPC90YWI+XG4gICAgPC90YWJzZXQ+XG4gIDwvZmlsZT5cbjwvZXhhbXBsZT5cbiAqL1xuLmRpcmVjdGl2ZSgndGFiJywgWyckcGFyc2UnLCAnJGxvZycsIGZ1bmN0aW9uKCRwYXJzZSwgJGxvZykge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICdedGFic2V0JyxcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvdGFicy90YWIuaHRtbCcsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICBzY29wZToge1xuICAgICAgYWN0aXZlOiAnPT8nLFxuICAgICAgaGVhZGluZzogJ0AnLFxuICAgICAgb25TZWxlY3Q6ICcmc2VsZWN0JywgLy9UaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCBpbiBjb250ZW50SGVhZGluZ1RyYW5zY2x1ZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vbmNlIGl0IGluc2VydHMgdGhlIHRhYidzIGNvbnRlbnQgaW50byB0aGUgZG9tXG4gICAgICBvbkRlc2VsZWN0OiAnJmRlc2VsZWN0J1xuICAgIH0sXG4gICAgY29udHJvbGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAvL0VtcHR5IGNvbnRyb2xsZXIgc28gb3RoZXIgZGlyZWN0aXZlcyBjYW4gcmVxdWlyZSBiZWluZyAndW5kZXInIGEgdGFiXG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxtLCBhdHRycywgdGFic2V0Q3RybCwgdHJhbnNjbHVkZSkge1xuICAgICAgc2NvcGUuJHdhdGNoKCdhY3RpdmUnLCBmdW5jdGlvbihhY3RpdmUpIHtcbiAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgIHRhYnNldEN0cmwuc2VsZWN0KHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICBpZiAoYXR0cnMuZGlzYWJsZSkge1xuICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoYXR0cnMuZGlzYWJsZSksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgc2NvcGUuZGlzYWJsZWQgPSAhISB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlcHJlY2F0aW9uIHN1cHBvcnQgb2YgXCJkaXNhYmxlZFwiIHBhcmFtZXRlclxuICAgICAgLy8gZml4KHRhYik6IElFOSBkaXNhYmxlZCBhdHRyIHJlbmRlcnMgZ3JleSB0ZXh0IG9uIGVuYWJsZWQgdGFiICMyNjc3XG4gICAgICAvLyBUaGlzIGNvZGUgaXMgZHVwbGljYXRlZCBmcm9tIHRoZSBsaW5lcyBhYm92ZSB0byBtYWtlIGl0IGVhc3kgdG8gcmVtb3ZlIG9uY2VcbiAgICAgIC8vIHRoZSBmZWF0dXJlIGhhcyBiZWVuIGNvbXBsZXRlbHkgZGVwcmVjYXRlZFxuICAgICAgaWYgKGF0dHJzLmRpc2FibGVkKSB7XG4gICAgICAgICRsb2cud2FybignVXNlIG9mIFwiZGlzYWJsZWRcIiBhdHRyaWJ1dGUgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBcImRpc2FibGVcIicpO1xuICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoYXR0cnMuZGlzYWJsZWQpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHNjb3BlLmRpc2FibGVkID0gISEgdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzY29wZS5zZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzY29wZS5kaXNhYmxlZCkge1xuICAgICAgICAgIHNjb3BlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRhYnNldEN0cmwuYWRkVGFiKHNjb3BlKTtcbiAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGFic2V0Q3RybC5yZW1vdmVUYWIoc2NvcGUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vV2UgbmVlZCB0byB0cmFuc2NsdWRlIGxhdGVyLCBvbmNlIHRoZSBjb250ZW50IGNvbnRhaW5lciBpcyByZWFkeS5cbiAgICAgIC8vd2hlbiB0aGlzIGxpbmsgaGFwcGVucywgd2UncmUgaW5zaWRlIGEgdGFiIGhlYWRpbmcuXG4gICAgICBzY29wZS4kdHJhbnNjbHVkZUZuID0gdHJhbnNjbHVkZTtcbiAgICB9XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgndGFiSGVhZGluZ1RyYW5zY2x1ZGUnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHJlcXVpcmU6ICdedGFiJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxtLCBhdHRycywgdGFiQ3RybCkge1xuICAgICAgc2NvcGUuJHdhdGNoKCdoZWFkaW5nRWxlbWVudCcsIGZ1bmN0aW9uIHVwZGF0ZUhlYWRpbmdFbGVtZW50KGhlYWRpbmcpIHtcbiAgICAgICAgaWYgKGhlYWRpbmcpIHtcbiAgICAgICAgICBlbG0uaHRtbCgnJyk7XG4gICAgICAgICAgZWxtLmFwcGVuZChoZWFkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndGFiQ29udGVudFRyYW5zY2x1ZGUnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHJlcXVpcmU6ICdedGFic2V0JyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxtLCBhdHRycykge1xuICAgICAgdmFyIHRhYiA9IHNjb3BlLiRldmFsKGF0dHJzLnRhYkNvbnRlbnRUcmFuc2NsdWRlKTtcblxuICAgICAgLy9Ob3cgb3VyIHRhYiBpcyByZWFkeSB0byBiZSB0cmFuc2NsdWRlZDogYm90aCB0aGUgdGFiIGhlYWRpbmcgYXJlYVxuICAgICAgLy9hbmQgdGhlIHRhYiBjb250ZW50IGFyZWEgYXJlIGxvYWRlZC4gIFRyYW5zY2x1ZGUgJ2VtIGJvdGguXG4gICAgICB0YWIuJHRyYW5zY2x1ZGVGbih0YWIuJHBhcmVudCwgZnVuY3Rpb24oY29udGVudHMpIHtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbnRlbnRzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKGlzVGFiSGVhZGluZyhub2RlKSkge1xuICAgICAgICAgICAgLy9MZXQgdGFiSGVhZGluZ1RyYW5zY2x1ZGUga25vdy5cbiAgICAgICAgICAgIHRhYi5oZWFkaW5nRWxlbWVudCA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsbS5hcHBlbmQobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc1RhYkhlYWRpbmcobm9kZSkge1xuICAgIHJldHVybiBub2RlLnRhZ05hbWUgJiYgKFxuICAgICAgbm9kZS5oYXNBdHRyaWJ1dGUoJ3RhYi1oZWFkaW5nJykgfHxcbiAgICAgIG5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXRhYi1oZWFkaW5nJykgfHxcbiAgICAgIG5vZGUuaGFzQXR0cmlidXRlKCd4LXRhYi1oZWFkaW5nJykgfHxcbiAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGFiLWhlYWRpbmcnIHx8XG4gICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2RhdGEtdGFiLWhlYWRpbmcnIHx8XG4gICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3gtdGFiLWhlYWRpbmcnXG4gICAgKTtcbiAgfVxufSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudGltZXBpY2tlcicsIFtdKVxuXG4uY29uc3RhbnQoJ3RpbWVwaWNrZXJDb25maWcnLCB7XG4gIGhvdXJTdGVwOiAxLFxuICBtaW51dGVTdGVwOiAxLFxuICBzaG93TWVyaWRpYW46IHRydWUsXG4gIG1lcmlkaWFuczogbnVsbCxcbiAgcmVhZG9ubHlJbnB1dDogZmFsc2UsXG4gIG1vdXNld2hlZWw6IHRydWUsXG4gIGFycm93a2V5czogdHJ1ZSxcbiAgc2hvd1NwaW5uZXJzOiB0cnVlXG59KVxuXG4uY29udHJvbGxlcignVGltZXBpY2tlckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAnJHBhcnNlJywgJyRsb2cnLCAnJGxvY2FsZScsICd0aW1lcGlja2VyQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsICRwYXJzZSwgJGxvZywgJGxvY2FsZSwgdGltZXBpY2tlckNvbmZpZykge1xuICB2YXIgc2VsZWN0ZWQgPSBuZXcgRGF0ZSgpLFxuICAgICAgbmdNb2RlbEN0cmwgPSB7ICRzZXRWaWV3VmFsdWU6IGFuZ3VsYXIubm9vcCB9LCAvLyBudWxsTW9kZWxDdHJsXG4gICAgICBtZXJpZGlhbnMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMubWVyaWRpYW5zKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5tZXJpZGlhbnMpIDogdGltZXBpY2tlckNvbmZpZy5tZXJpZGlhbnMgfHwgJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLkFNUE1TO1xuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKG5nTW9kZWxDdHJsXywgaW5wdXRzKSB7XG4gICAgbmdNb2RlbEN0cmwgPSBuZ01vZGVsQ3RybF87XG4gICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IHRoaXMucmVuZGVyO1xuXG4gICAgbmdNb2RlbEN0cmwuJGZvcm1hdHRlcnMudW5zaGlmdChmdW5jdGlvbihtb2RlbFZhbHVlKSB7XG4gICAgICByZXR1cm4gbW9kZWxWYWx1ZSA/IG5ldyBEYXRlKG1vZGVsVmFsdWUpIDogbnVsbDtcbiAgICB9KTtcblxuICAgIHZhciBob3Vyc0lucHV0RWwgPSBpbnB1dHMuZXEoMCksXG4gICAgICAgIG1pbnV0ZXNJbnB1dEVsID0gaW5wdXRzLmVxKDEpO1xuXG4gICAgdmFyIG1vdXNld2hlZWwgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMubW91c2V3aGVlbCkgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMubW91c2V3aGVlbCkgOiB0aW1lcGlja2VyQ29uZmlnLm1vdXNld2hlZWw7XG4gICAgaWYgKG1vdXNld2hlZWwpIHtcbiAgICAgIHRoaXMuc2V0dXBNb3VzZXdoZWVsRXZlbnRzKGhvdXJzSW5wdXRFbCwgbWludXRlc0lucHV0RWwpO1xuICAgIH1cblxuICAgIHZhciBhcnJvd2tleXMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuYXJyb3drZXlzKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5hcnJvd2tleXMpIDogdGltZXBpY2tlckNvbmZpZy5hcnJvd2tleXM7XG4gICAgaWYgKGFycm93a2V5cykge1xuICAgICAgdGhpcy5zZXR1cEFycm93a2V5RXZlbnRzKGhvdXJzSW5wdXRFbCwgbWludXRlc0lucHV0RWwpO1xuICAgIH1cblxuICAgICRzY29wZS5yZWFkb25seUlucHV0ID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnJlYWRvbmx5SW5wdXQpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnJlYWRvbmx5SW5wdXQpIDogdGltZXBpY2tlckNvbmZpZy5yZWFkb25seUlucHV0O1xuICAgIHRoaXMuc2V0dXBJbnB1dEV2ZW50cyhob3Vyc0lucHV0RWwsIG1pbnV0ZXNJbnB1dEVsKTtcbiAgfTtcblxuICB2YXIgaG91clN0ZXAgPSB0aW1lcGlja2VyQ29uZmlnLmhvdXJTdGVwO1xuICBpZiAoJGF0dHJzLmhvdXJTdGVwKSB7XG4gICAgJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMuaG91clN0ZXApLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaG91clN0ZXAgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIG1pbnV0ZVN0ZXAgPSB0aW1lcGlja2VyQ29uZmlnLm1pbnV0ZVN0ZXA7XG4gIGlmICgkYXR0cnMubWludXRlU3RlcCkge1xuICAgICRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLm1pbnV0ZVN0ZXApLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgbWludXRlU3RlcCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgbWluO1xuICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5taW4pLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBkdCA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICBtaW4gPSBpc05hTihkdCkgPyB1bmRlZmluZWQgOiBkdDtcbiAgfSk7XG5cbiAgdmFyIG1heDtcbiAgJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMubWF4KSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgZHQgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgbWF4ID0gaXNOYU4oZHQpID8gdW5kZWZpbmVkIDogZHQ7XG4gIH0pO1xuXG4gICRzY29wZS5ub0luY3JlbWVudEhvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluY3JlbWVudGVkU2VsZWN0ZWQgPSBhZGRNaW51dGVzKHNlbGVjdGVkLCBob3VyU3RlcCAqIDYwKTtcbiAgICByZXR1cm4gaW5jcmVtZW50ZWRTZWxlY3RlZCA+IG1heCB8fFxuICAgICAgKGluY3JlbWVudGVkU2VsZWN0ZWQgPCBzZWxlY3RlZCAmJiBpbmNyZW1lbnRlZFNlbGVjdGVkIDwgbWluKTtcbiAgfTtcblxuICAkc2NvcGUubm9EZWNyZW1lbnRIb3VycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWNyZW1lbnRlZFNlbGVjdGVkID0gYWRkTWludXRlcyhzZWxlY3RlZCwgLWhvdXJTdGVwICogNjApO1xuICAgIHJldHVybiBkZWNyZW1lbnRlZFNlbGVjdGVkIDwgbWluIHx8XG4gICAgICAoZGVjcmVtZW50ZWRTZWxlY3RlZCA+IHNlbGVjdGVkICYmIGRlY3JlbWVudGVkU2VsZWN0ZWQgPiBtYXgpO1xuICB9O1xuXG4gICRzY29wZS5ub0luY3JlbWVudE1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5jcmVtZW50ZWRTZWxlY3RlZCA9IGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIG1pbnV0ZVN0ZXApO1xuICAgIHJldHVybiBpbmNyZW1lbnRlZFNlbGVjdGVkID4gbWF4IHx8XG4gICAgICAoaW5jcmVtZW50ZWRTZWxlY3RlZCA8IHNlbGVjdGVkICYmIGluY3JlbWVudGVkU2VsZWN0ZWQgPCBtaW4pO1xuICB9O1xuXG4gICRzY29wZS5ub0RlY3JlbWVudE1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVjcmVtZW50ZWRTZWxlY3RlZCA9IGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIC1taW51dGVTdGVwKTtcbiAgICByZXR1cm4gZGVjcmVtZW50ZWRTZWxlY3RlZCA8IG1pbiB8fFxuICAgICAgKGRlY3JlbWVudGVkU2VsZWN0ZWQgPiBzZWxlY3RlZCAmJiBkZWNyZW1lbnRlZFNlbGVjdGVkID4gbWF4KTtcbiAgfTtcblxuICAkc2NvcGUubm9Ub2dnbGVNZXJpZGlhbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxlY3RlZC5nZXRIb3VycygpIDwgMTMpIHtcbiAgICAgIHJldHVybiBhZGRNaW51dGVzKHNlbGVjdGVkLCAxMiAqIDYwKSA+IG1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIC0xMiAqIDYwKSA8IG1pbjtcbiAgICB9XG4gIH07XG5cbiAgLy8gMTJIIC8gMjRIIG1vZGVcbiAgJHNjb3BlLnNob3dNZXJpZGlhbiA9IHRpbWVwaWNrZXJDb25maWcuc2hvd01lcmlkaWFuO1xuICBpZiAoJGF0dHJzLnNob3dNZXJpZGlhbikge1xuICAgICRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLnNob3dNZXJpZGlhbiksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAkc2NvcGUuc2hvd01lcmlkaWFuID0gISF2YWx1ZTtcblxuICAgICAgaWYgKG5nTW9kZWxDdHJsLiRlcnJvci50aW1lKSB7XG4gICAgICAgIC8vIEV2YWx1YXRlIGZyb20gdGVtcGxhdGVcbiAgICAgICAgdmFyIGhvdXJzID0gZ2V0SG91cnNGcm9tVGVtcGxhdGUoKSwgbWludXRlcyA9IGdldE1pbnV0ZXNGcm9tVGVtcGxhdGUoKTtcbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGhvdXJzKSAmJiBhbmd1bGFyLmlzRGVmaW5lZChtaW51dGVzKSkge1xuICAgICAgICAgIHNlbGVjdGVkLnNldEhvdXJzKGhvdXJzKTtcbiAgICAgICAgICByZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZVRlbXBsYXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBHZXQgJHNjb3BlLmhvdXJzIGluIDI0SCBtb2RlIGlmIHZhbGlkXG4gIGZ1bmN0aW9uIGdldEhvdXJzRnJvbVRlbXBsYXRlKCkge1xuICAgIHZhciBob3VycyA9IHBhcnNlSW50KCRzY29wZS5ob3VycywgMTApO1xuICAgIHZhciB2YWxpZCA9ICRzY29wZS5zaG93TWVyaWRpYW4gPyAoaG91cnMgPiAwICYmIGhvdXJzIDwgMTMpIDogKGhvdXJzID49IDAgJiYgaG91cnMgPCAyNCk7XG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoJHNjb3BlLnNob3dNZXJpZGlhbikge1xuICAgICAgaWYgKGhvdXJzID09PSAxMikge1xuICAgICAgICBob3VycyA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoJHNjb3BlLm1lcmlkaWFuID09PSBtZXJpZGlhbnNbMV0pIHtcbiAgICAgICAgaG91cnMgPSBob3VycyArIDEyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaG91cnM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNaW51dGVzRnJvbVRlbXBsYXRlKCkge1xuICAgIHZhciBtaW51dGVzID0gcGFyc2VJbnQoJHNjb3BlLm1pbnV0ZXMsIDEwKTtcbiAgICByZXR1cm4gKG1pbnV0ZXMgPj0gMCAmJiBtaW51dGVzIDwgNjApID8gbWludXRlcyA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhZCh2YWx1ZSkge1xuICAgIHJldHVybiAoYW5ndWxhci5pc0RlZmluZWQodmFsdWUpICYmIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoIDwgMikgPyAnMCcgKyB2YWx1ZSA6IHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvLyBSZXNwb25kIG9uIG1vdXNld2hlZWwgc3BpblxuICB0aGlzLnNldHVwTW91c2V3aGVlbEV2ZW50cyA9IGZ1bmN0aW9uKGhvdXJzSW5wdXRFbCwgbWludXRlc0lucHV0RWwpIHtcbiAgICB2YXIgaXNTY3JvbGxpbmdVcCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLm9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgZSA9IGUub3JpZ2luYWxFdmVudDtcbiAgICAgIH1cbiAgICAgIC8vcGljayBjb3JyZWN0IGRlbHRhIHZhcmlhYmxlIGRlcGVuZGluZyBvbiBldmVudFxuICAgICAgdmFyIGRlbHRhID0gKGUud2hlZWxEZWx0YSkgPyBlLndoZWVsRGVsdGEgOiAtZS5kZWx0YVk7XG4gICAgICByZXR1cm4gKGUuZGV0YWlsIHx8IGRlbHRhID4gMCk7XG4gICAgfTtcblxuICAgIGhvdXJzSW5wdXRFbC5iaW5kKCdtb3VzZXdoZWVsIHdoZWVsJywgZnVuY3Rpb24oZSkge1xuICAgICAgJHNjb3BlLiRhcHBseShpc1Njcm9sbGluZ1VwKGUpID8gJHNjb3BlLmluY3JlbWVudEhvdXJzKCkgOiAkc2NvcGUuZGVjcmVtZW50SG91cnMoKSk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG5cbiAgICBtaW51dGVzSW5wdXRFbC5iaW5kKCdtb3VzZXdoZWVsIHdoZWVsJywgZnVuY3Rpb24oZSkge1xuICAgICAgJHNjb3BlLiRhcHBseShpc1Njcm9sbGluZ1VwKGUpID8gJHNjb3BlLmluY3JlbWVudE1pbnV0ZXMoKSA6ICRzY29wZS5kZWNyZW1lbnRNaW51dGVzKCkpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gIH07XG5cbiAgLy8gUmVzcG9uZCBvbiB1cC9kb3duIGFycm93a2V5c1xuICB0aGlzLnNldHVwQXJyb3drZXlFdmVudHMgPSBmdW5jdGlvbihob3Vyc0lucHV0RWwsIG1pbnV0ZXNJbnB1dEVsKSB7XG4gICAgaG91cnNJbnB1dEVsLmJpbmQoJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS53aGljaCA9PT0gMzgpIHsgLy8gdXBcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAkc2NvcGUuaW5jcmVtZW50SG91cnMoKTtcbiAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09PSA0MCkgeyAvLyBkb3duXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgJHNjb3BlLmRlY3JlbWVudEhvdXJzKCk7XG4gICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIG1pbnV0ZXNJbnB1dEVsLmJpbmQoJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS53aGljaCA9PT0gMzgpIHsgLy8gdXBcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAkc2NvcGUuaW5jcmVtZW50TWludXRlcygpO1xuICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT09IDQwKSB7IC8vIGRvd25cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAkc2NvcGUuZGVjcmVtZW50TWludXRlcygpO1xuICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdGhpcy5zZXR1cElucHV0RXZlbnRzID0gZnVuY3Rpb24oaG91cnNJbnB1dEVsLCBtaW51dGVzSW5wdXRFbCkge1xuICAgIGlmICgkc2NvcGUucmVhZG9ubHlJbnB1dCkge1xuICAgICAgJHNjb3BlLnVwZGF0ZUhvdXJzID0gYW5ndWxhci5ub29wO1xuICAgICAgJHNjb3BlLnVwZGF0ZU1pbnV0ZXMgPSBhbmd1bGFyLm5vb3A7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRhdGUgPSBmdW5jdGlvbihpbnZhbGlkSG91cnMsIGludmFsaWRNaW51dGVzKSB7XG4gICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKG51bGwpO1xuICAgICAgbmdNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCd0aW1lJywgZmFsc2UpO1xuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGludmFsaWRIb3VycykpIHtcbiAgICAgICAgJHNjb3BlLmludmFsaWRIb3VycyA9IGludmFsaWRIb3VycztcbiAgICAgIH1cbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChpbnZhbGlkTWludXRlcykpIHtcbiAgICAgICAgJHNjb3BlLmludmFsaWRNaW51dGVzID0gaW52YWxpZE1pbnV0ZXM7XG4gICAgICB9XG4gICAgfTtcblxuICAgICRzY29wZS51cGRhdGVIb3VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhvdXJzID0gZ2V0SG91cnNGcm9tVGVtcGxhdGUoKSxcbiAgICAgICAgbWludXRlcyA9IGdldE1pbnV0ZXNGcm9tVGVtcGxhdGUoKTtcblxuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGhvdXJzKSAmJiBhbmd1bGFyLmlzRGVmaW5lZChtaW51dGVzKSkge1xuICAgICAgICBzZWxlY3RlZC5zZXRIb3Vycyhob3Vycyk7XG4gICAgICAgIGlmIChzZWxlY3RlZCA8IG1pbiB8fCBzZWxlY3RlZCA+IG1heCkge1xuICAgICAgICAgIGludmFsaWRhdGUodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmcmVzaCgnaCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhbGlkYXRlKHRydWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBob3Vyc0lucHV0RWwuYmluZCgnYmx1cicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghJHNjb3BlLmludmFsaWRIb3VycyAmJiAkc2NvcGUuaG91cnMgPCAxMCkge1xuICAgICAgICAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRzY29wZS5ob3VycyA9IHBhZCgkc2NvcGUuaG91cnMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgICRzY29wZS51cGRhdGVNaW51dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWludXRlcyA9IGdldE1pbnV0ZXNGcm9tVGVtcGxhdGUoKSxcbiAgICAgICAgaG91cnMgPSBnZXRIb3Vyc0Zyb21UZW1wbGF0ZSgpO1xuXG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQobWludXRlcykgJiYgYW5ndWxhci5pc0RlZmluZWQoaG91cnMpKSB7XG4gICAgICAgIHNlbGVjdGVkLnNldE1pbnV0ZXMobWludXRlcyk7XG4gICAgICAgIGlmIChzZWxlY3RlZCA8IG1pbiB8fCBzZWxlY3RlZCA+IG1heCkge1xuICAgICAgICAgIGludmFsaWRhdGUodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZyZXNoKCdtJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFsaWRhdGUodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbWludXRlc0lucHV0RWwuYmluZCgnYmx1cicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghJHNjb3BlLmludmFsaWRNaW51dGVzICYmICRzY29wZS5taW51dGVzIDwgMTApIHtcbiAgICAgICAgJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAkc2NvcGUubWludXRlcyA9IHBhZCgkc2NvcGUubWludXRlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH07XG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0ZSA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWU7XG5cbiAgICBpZiAoaXNOYU4oZGF0ZSkpIHtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgndGltZScsIGZhbHNlKTtcbiAgICAgICRsb2cuZXJyb3IoJ1RpbWVwaWNrZXIgZGlyZWN0aXZlOiBcIm5nLW1vZGVsXCIgdmFsdWUgbXVzdCBiZSBhIERhdGUgb2JqZWN0LCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMDEuMDEuMTk3MCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gUkZDMjgyMiBvciBJU08gODYwMSBkYXRlLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGF0ZSkge1xuICAgICAgICBzZWxlY3RlZCA9IGRhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZCA8IG1pbiB8fCBzZWxlY3RlZCA+IG1heCkge1xuICAgICAgICBuZ01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ3RpbWUnLCBmYWxzZSk7XG4gICAgICAgICRzY29wZS5pbnZhbGlkSG91cnMgPSB0cnVlO1xuICAgICAgICAkc2NvcGUuaW52YWxpZE1pbnV0ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFrZVZhbGlkKCk7XG4gICAgICB9XG4gICAgICB1cGRhdGVUZW1wbGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDYWxsIGludGVybmFsbHkgd2hlbiB3ZSBrbm93IHRoYXQgbW9kZWwgaXMgdmFsaWQuXG4gIGZ1bmN0aW9uIHJlZnJlc2goa2V5Ym9hcmRDaGFuZ2UpIHtcbiAgICBtYWtlVmFsaWQoKTtcbiAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKG5ldyBEYXRlKHNlbGVjdGVkKSk7XG4gICAgdXBkYXRlVGVtcGxhdGUoa2V5Ym9hcmRDaGFuZ2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVZhbGlkKCkge1xuICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgndGltZScsIHRydWUpO1xuICAgICRzY29wZS5pbnZhbGlkSG91cnMgPSBmYWxzZTtcbiAgICAkc2NvcGUuaW52YWxpZE1pbnV0ZXMgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRlbXBsYXRlKGtleWJvYXJkQ2hhbmdlKSB7XG4gICAgdmFyIGhvdXJzID0gc2VsZWN0ZWQuZ2V0SG91cnMoKSwgbWludXRlcyA9IHNlbGVjdGVkLmdldE1pbnV0ZXMoKTtcblxuICAgIGlmICgkc2NvcGUuc2hvd01lcmlkaWFuKSB7XG4gICAgICBob3VycyA9IChob3VycyA9PT0gMCB8fCBob3VycyA9PT0gMTIpID8gMTIgOiBob3VycyAlIDEyOyAvLyBDb252ZXJ0IDI0IHRvIDEyIGhvdXIgc3lzdGVtXG4gICAgfVxuXG4gICAgJHNjb3BlLmhvdXJzID0ga2V5Ym9hcmRDaGFuZ2UgPT09ICdoJyA/IGhvdXJzIDogcGFkKGhvdXJzKTtcbiAgICBpZiAoa2V5Ym9hcmRDaGFuZ2UgIT09ICdtJykge1xuICAgICAgJHNjb3BlLm1pbnV0ZXMgPSBwYWQobWludXRlcyk7XG4gICAgfVxuICAgICRzY29wZS5tZXJpZGlhbiA9IHNlbGVjdGVkLmdldEhvdXJzKCkgPCAxMiA/IG1lcmlkaWFuc1swXSA6IG1lcmlkaWFuc1sxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE1pbnV0ZXMoZGF0ZSwgbWludXRlcykge1xuICAgIHZhciBkdCA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgbWludXRlcyAqIDYwMDAwKTtcbiAgICB2YXIgbmV3RGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgIG5ld0RhdGUuc2V0SG91cnMoZHQuZ2V0SG91cnMoKSwgZHQuZ2V0TWludXRlcygpKTtcbiAgICByZXR1cm4gbmV3RGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE1pbnV0ZXNUb1NlbGVjdGVkKG1pbnV0ZXMpIHtcbiAgICBzZWxlY3RlZCA9IGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIG1pbnV0ZXMpO1xuICAgIHJlZnJlc2goKTtcbiAgfVxuXG4gICRzY29wZS5zaG93U3Bpbm5lcnMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuc2hvd1NwaW5uZXJzKSA/XG4gICAgJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnNob3dTcGlubmVycykgOiB0aW1lcGlja2VyQ29uZmlnLnNob3dTcGlubmVycztcblxuICAkc2NvcGUuaW5jcmVtZW50SG91cnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoISRzY29wZS5ub0luY3JlbWVudEhvdXJzKCkpIHtcbiAgICAgIGFkZE1pbnV0ZXNUb1NlbGVjdGVkKGhvdXJTdGVwICogNjApO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuZGVjcmVtZW50SG91cnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoISRzY29wZS5ub0RlY3JlbWVudEhvdXJzKCkpIHtcbiAgICAgIGFkZE1pbnV0ZXNUb1NlbGVjdGVkKC1ob3VyU3RlcCAqIDYwKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLmluY3JlbWVudE1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoISRzY29wZS5ub0luY3JlbWVudE1pbnV0ZXMoKSkge1xuICAgICAgYWRkTWludXRlc1RvU2VsZWN0ZWQobWludXRlU3RlcCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5kZWNyZW1lbnRNaW51dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUubm9EZWNyZW1lbnRNaW51dGVzKCkpIHtcbiAgICAgIGFkZE1pbnV0ZXNUb1NlbGVjdGVkKC1taW51dGVTdGVwKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLnRvZ2dsZU1lcmlkaWFuID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUubm9Ub2dnbGVNZXJpZGlhbigpKSB7XG4gICAgICBhZGRNaW51dGVzVG9TZWxlY3RlZCgxMiAqIDYwICogKHNlbGVjdGVkLmdldEhvdXJzKCkgPCAxMiA/IDEgOiAtMSkpO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd0aW1lcGlja2VyJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVxdWlyZTogWyd0aW1lcGlja2VyJywgJz9ebmdNb2RlbCddLFxuICAgIGNvbnRyb2xsZXI6J1RpbWVwaWNrZXJDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICd0aW1lcGlja2VyJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7fSxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWwnO1xuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgdmFyIHRpbWVwaWNrZXJDdHJsID0gY3RybHNbMF0sIG5nTW9kZWxDdHJsID0gY3RybHNbMV07XG5cbiAgICAgIGlmIChuZ01vZGVsQ3RybCkge1xuICAgICAgICB0aW1lcGlja2VyQ3RybC5pbml0KG5nTW9kZWxDdHJsLCBlbGVtZW50LmZpbmQoJ2lucHV0JykpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRyYW5zaXRpb24nLCBbXSlcblxuLnZhbHVlKCckdHJhbnNpdGlvblN1cHByZXNzRGVwcmVjYXRlZCcsIGZhbHNlKVxuLyoqXG4gKiAkdHJhbnNpdGlvbiBzZXJ2aWNlIHByb3ZpZGVzIGEgY29uc2lzdGVudCBpbnRlcmZhY2UgdG8gdHJpZ2dlciBDU1MgMyB0cmFuc2l0aW9ucyBhbmQgdG8gYmUgaW5mb3JtZWQgd2hlbiB0aGV5IGNvbXBsZXRlLlxuICogQHBhcmFtICB7RE9NRWxlbWVudH0gZWxlbWVudCAgVGhlIERPTUVsZW1lbnQgdGhhdCB3aWxsIGJlIGFuaW1hdGVkLlxuICogQHBhcmFtICB7c3RyaW5nfG9iamVjdHxmdW5jdGlvbn0gdHJpZ2dlciAgVGhlIHRoaW5nIHRoYXQgd2lsbCBjYXVzZSB0aGUgdHJhbnNpdGlvbiB0byBzdGFydDpcbiAqICAgLSBBcyBhIHN0cmluZywgaXQgcmVwcmVzZW50cyB0aGUgY3NzIGNsYXNzIHRvIGJlIGFkZGVkIHRvIHRoZSBlbGVtZW50LlxuICogICAtIEFzIGFuIG9iamVjdCwgaXQgcmVwcmVzZW50cyBhIGhhc2ggb2Ygc3R5bGUgYXR0cmlidXRlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxuICogICAtIEFzIGEgZnVuY3Rpb24sIGl0IHJlcHJlc2VudHMgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgdGhhdCB3aWxsIGNhdXNlIHRoZSB0cmFuc2l0aW9uIHRvIG9jY3VyLlxuICogQHJldHVybiB7UHJvbWlzZX0gIEEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIHRyYW5zaXRpb24gZmluaXNoZXMuXG4gKi9cbi5mYWN0b3J5KCckdHJhbnNpdGlvbicsIFtcbiAgICAgICAgJyRxJywgJyR0aW1lb3V0JywgJyRyb290U2NvcGUnLCAnJGxvZycsICckdHJhbnNpdGlvblN1cHByZXNzRGVwcmVjYXRlZCcsXG5mdW5jdGlvbigkcSAsICAkdGltZW91dCAsICAkcm9vdFNjb3BlICwgICRsb2cgLCAgJHRyYW5zaXRpb25TdXBwcmVzc0RlcHJlY2F0ZWQpIHtcblxuICBpZiAoISR0cmFuc2l0aW9uU3VwcHJlc3NEZXByZWNhdGVkKSB7XG4gICAgJGxvZy53YXJuKCckdHJhbnNpdGlvbiBpcyBub3cgZGVwcmVjYXRlZC4gVXNlICRhbmltYXRlIGZyb20gbmdBbmltYXRlIGluc3RlYWQuJyk7XG4gIH1cblxuICB2YXIgJHRyYW5zaXRpb24gPSBmdW5jdGlvbihlbGVtZW50LCB0cmlnZ2VyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICB2YXIgZW5kRXZlbnROYW1lID0gJHRyYW5zaXRpb25bb3B0aW9ucy5hbmltYXRpb24gPyAnYW5pbWF0aW9uRW5kRXZlbnROYW1lJyA6ICd0cmFuc2l0aW9uRW5kRXZlbnROYW1lJ107XG5cbiAgICB2YXIgdHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgJHJvb3RTY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgIGVsZW1lbnQudW5iaW5kKGVuZEV2ZW50TmFtZSwgdHJhbnNpdGlvbkVuZEhhbmRsZXIpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChlbmRFdmVudE5hbWUpIHtcbiAgICAgIGVsZW1lbnQuYmluZChlbmRFdmVudE5hbWUsIHRyYW5zaXRpb25FbmRIYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvLyBXcmFwIGluIGEgdGltZW91dCB0byBhbGxvdyB0aGUgYnJvd3NlciB0aW1lIHRvIHVwZGF0ZSB0aGUgRE9NIGJlZm9yZSB0aGUgdHJhbnNpdGlvbiBpcyB0byBvY2N1clxuICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCBhbmd1bGFyLmlzU3RyaW5nKHRyaWdnZXIpICkge1xuICAgICAgICBlbGVtZW50LmFkZENsYXNzKHRyaWdnZXIpO1xuICAgICAgfSBlbHNlIGlmICggYW5ndWxhci5pc0Z1bmN0aW9uKHRyaWdnZXIpICkge1xuICAgICAgICB0cmlnZ2VyKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICggYW5ndWxhci5pc09iamVjdCh0cmlnZ2VyKSApIHtcbiAgICAgICAgZWxlbWVudC5jc3ModHJpZ2dlcik7XG4gICAgICB9XG4gICAgICAvL0lmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0cmFuc2l0aW9ucywgaW5zdGFudGx5IHJlc29sdmVcbiAgICAgIGlmICggIWVuZEV2ZW50TmFtZSApIHtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEFkZCBvdXIgY3VzdG9tIGNhbmNlbCBmdW5jdGlvbiB0byB0aGUgcHJvbWlzZSB0aGF0IGlzIHJldHVybmVkXG4gICAgLy8gV2UgY2FuIGNhbGwgdGhpcyBpZiB3ZSBhcmUgYWJvdXQgdG8gcnVuIGEgbmV3IHRyYW5zaXRpb24sIHdoaWNoIHdlIGtub3cgd2lsbCBwcmV2ZW50IHRoaXMgdHJhbnNpdGlvbiBmcm9tIGVuZGluZyxcbiAgICAvLyBpLmUuIGl0IHdpbGwgdGhlcmVmb3JlIG5ldmVyIHJhaXNlIGEgdHJhbnNpdGlvbkVuZCBldmVudCBmb3IgdGhhdCB0cmFuc2l0aW9uXG4gICAgZGVmZXJyZWQucHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICggZW5kRXZlbnROYW1lICkge1xuICAgICAgICBlbGVtZW50LnVuYmluZChlbmRFdmVudE5hbWUsIHRyYW5zaXRpb25FbmRIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIGRlZmVycmVkLnJlamVjdCgnVHJhbnNpdGlvbiBjYW5jZWxsZWQnKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH07XG5cbiAgLy8gV29yayBvdXQgdGhlIG5hbWUgb2YgdGhlIHRyYW5zaXRpb25FbmQgZXZlbnRcbiAgdmFyIHRyYW5zRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyYW5zJyk7XG4gIHZhciB0cmFuc2l0aW9uRW5kRXZlbnROYW1lcyA9IHtcbiAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAnTW96VHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAnT1RyYW5zaXRpb24nOiAnb1RyYW5zaXRpb25FbmQnLFxuICAgICd0cmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnXG4gIH07XG4gIHZhciBhbmltYXRpb25FbmRFdmVudE5hbWVzID0ge1xuICAgICdXZWJraXRUcmFuc2l0aW9uJzogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG4gICAgJ01velRyYW5zaXRpb24nOiAnYW5pbWF0aW9uZW5kJyxcbiAgICAnT1RyYW5zaXRpb24nOiAnb0FuaW1hdGlvbkVuZCcsXG4gICAgJ3RyYW5zaXRpb24nOiAnYW5pbWF0aW9uZW5kJ1xuICB9O1xuICBmdW5jdGlvbiBmaW5kRW5kRXZlbnROYW1lKGVuZEV2ZW50TmFtZXMpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIGVuZEV2ZW50TmFtZXMpe1xuICAgICAgaWYgKHRyYW5zRWxlbWVudC5zdHlsZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlbmRFdmVudE5hbWVzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAkdHJhbnNpdGlvbi50cmFuc2l0aW9uRW5kRXZlbnROYW1lID0gZmluZEVuZEV2ZW50TmFtZSh0cmFuc2l0aW9uRW5kRXZlbnROYW1lcyk7XG4gICR0cmFuc2l0aW9uLmFuaW1hdGlvbkVuZEV2ZW50TmFtZSA9IGZpbmRFbmRFdmVudE5hbWUoYW5pbWF0aW9uRW5kRXZlbnROYW1lcyk7XG4gIHJldHVybiAkdHJhbnNpdGlvbjtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50eXBlYWhlYWQnLCBbJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbiddKVxuXG4vKipcbiAqIEEgaGVscGVyIHNlcnZpY2UgdGhhdCBjYW4gcGFyc2UgdHlwZWFoZWFkJ3Mgc3ludGF4IChzdHJpbmcgcHJvdmlkZWQgYnkgdXNlcnMpXG4gKiBFeHRyYWN0ZWQgdG8gYSBzZXBhcmF0ZSBzZXJ2aWNlIGZvciBlYXNlIG9mIHVuaXQgdGVzdGluZ1xuICovXG4gIC5mYWN0b3J5KCd0eXBlYWhlYWRQYXJzZXInLCBbJyRwYXJzZScsIGZ1bmN0aW9uKCRwYXJzZSkge1xuXG4gIC8vICAgICAgICAgICAgICAgICAgICAgIDAwMDAwMTExMDAwMDAwMDAwMDAwMDIyMjAwMDAwMDAwMDAwMDAwMDAzMzMzMzMzMzMzMzMzMzMwMDAwMDAwMDAwMDQ0MDAwXG4gIHZhciBUWVBFQUhFQURfUkVHRVhQID0gL15cXHMqKFtcXHNcXFNdKz8pKD86XFxzK2FzXFxzKyhbXFxzXFxTXSs/KSk/XFxzK2ZvclxccysoPzooW1xcJFxcd11bXFwkXFx3XFxkXSopKVxccytpblxccysoW1xcc1xcU10rPykkLztcblxuICByZXR1cm4ge1xuICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgdmFyIG1hdGNoID0gaW5wdXQubWF0Y2goVFlQRUFIRUFEX1JFR0VYUCk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRXhwZWN0ZWQgdHlwZWFoZWFkIHNwZWNpZmljYXRpb24gaW4gZm9ybSBvZiBcIl9tb2RlbFZhbHVlXyAoYXMgX2xhYmVsXyk/IGZvciBfaXRlbV8gaW4gX2NvbGxlY3Rpb25fXCInICtcbiAgICAgICAgICAgICcgYnV0IGdvdCBcIicgKyBpbnB1dCArICdcIi4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbU5hbWU6bWF0Y2hbM10sXG4gICAgICAgIHNvdXJjZTokcGFyc2UobWF0Y2hbNF0pLFxuICAgICAgICB2aWV3TWFwcGVyOiRwYXJzZShtYXRjaFsyXSB8fCBtYXRjaFsxXSksXG4gICAgICAgIG1vZGVsTWFwcGVyOiRwYXJzZShtYXRjaFsxXSlcbiAgICAgIH07XG4gICAgfVxuICB9O1xufV0pXG5cbiAgLmRpcmVjdGl2ZSgndHlwZWFoZWFkJywgWyckY29tcGlsZScsICckcGFyc2UnLCAnJHEnLCAnJHRpbWVvdXQnLCAnJGRvY3VtZW50JywgJyR3aW5kb3cnLCAnJHJvb3RTY29wZScsICckcG9zaXRpb24nLCAndHlwZWFoZWFkUGFyc2VyJyxcbiAgICBmdW5jdGlvbigkY29tcGlsZSwgJHBhcnNlLCAkcSwgJHRpbWVvdXQsICRkb2N1bWVudCwgJHdpbmRvdywgJHJvb3RTY29wZSwgJHBvc2l0aW9uLCB0eXBlYWhlYWRQYXJzZXIpIHtcbiAgICB2YXIgSE9UX0tFWVMgPSBbOSwgMTMsIDI3LCAzOCwgNDBdO1xuICAgIHZhciBldmVudERlYm91bmNlVGltZSA9IDIwMDtcblxuICAgIHJldHVybiB7XG4gICAgICByZXF1aXJlOiBbJ25nTW9kZWwnLCAnXj9uZ01vZGVsT3B0aW9ucyddLFxuICAgICAgbGluazogZnVuY3Rpb24ob3JpZ2luYWxTY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICAgIHZhciBtb2RlbEN0cmwgPSBjdHJsc1swXTtcbiAgICAgICAgdmFyIG5nTW9kZWxPcHRpb25zID0gY3RybHNbMV07XG4gICAgICAgIC8vU1VQUE9SVEVEIEFUVFJJQlVURVMgKE9QVElPTlMpXG5cbiAgICAgICAgLy9taW5pbWFsIG5vIG9mIGNoYXJhY3RlcnMgdGhhdCBuZWVkcyB0byBiZSBlbnRlcmVkIGJlZm9yZSB0eXBlYWhlYWQga2lja3MtaW5cbiAgICAgICAgdmFyIG1pbkxlbmd0aCA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkTWluTGVuZ3RoKTtcbiAgICAgICAgaWYgKCFtaW5MZW5ndGggJiYgbWluTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgbWluTGVuZ3RoID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbWluaW1hbCB3YWl0IHRpbWUgYWZ0ZXIgbGFzdCBjaGFyYWN0ZXIgdHlwZWQgYmVmb3JlIHR5cGVhaGVhZCBraWNrcy1pblxuICAgICAgICB2YXIgd2FpdFRpbWUgPSBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZFdhaXRNcykgfHwgMDtcblxuICAgICAgICAvL3Nob3VsZCBpdCByZXN0cmljdCBtb2RlbCB2YWx1ZXMgdG8gdGhlIG9uZXMgc2VsZWN0ZWQgZnJvbSB0aGUgcG9wdXAgb25seT9cbiAgICAgICAgdmFyIGlzRWRpdGFibGUgPSBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZEVkaXRhYmxlKSAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy9iaW5kaW5nIHRvIGEgdmFyaWFibGUgdGhhdCBpbmRpY2F0ZXMgaWYgbWF0Y2hlcyBhcmUgYmVpbmcgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5XG4gICAgICAgIHZhciBpc0xvYWRpbmdTZXR0ZXIgPSAkcGFyc2UoYXR0cnMudHlwZWFoZWFkTG9hZGluZykuYXNzaWduIHx8IGFuZ3VsYXIubm9vcDtcblxuICAgICAgICAvL2EgY2FsbGJhY2sgZXhlY3V0ZWQgd2hlbiBhIG1hdGNoIGlzIHNlbGVjdGVkXG4gICAgICAgIHZhciBvblNlbGVjdENhbGxiYWNrID0gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZE9uU2VsZWN0KTtcblxuICAgICAgICAvL3Nob3VsZCBpdCBzZWxlY3QgaGlnaGxpZ2h0ZWQgcG9wdXAgdmFsdWUgd2hlbiBsb3NpbmcgZm9jdXM/XG4gICAgICAgIHZhciBpc1NlbGVjdE9uQmx1ciA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnR5cGVhaGVhZFNlbGVjdE9uQmx1cikgPyBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZFNlbGVjdE9uQmx1cikgOiBmYWxzZTtcblxuICAgICAgICAvL2JpbmRpbmcgdG8gYSB2YXJpYWJsZSB0aGF0IGluZGljYXRlcyBpZiB0aGVyZSB3ZXJlIG5vIHJlc3VsdHMgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIGNvbXBsZXRlZFxuICAgICAgICB2YXIgaXNOb1Jlc3VsdHNTZXR0ZXIgPSAkcGFyc2UoYXR0cnMudHlwZWFoZWFkTm9SZXN1bHRzKS5hc3NpZ24gfHwgYW5ndWxhci5ub29wO1xuXG4gICAgICAgIHZhciBpbnB1dEZvcm1hdHRlciA9IGF0dHJzLnR5cGVhaGVhZElucHV0Rm9ybWF0dGVyID8gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZElucHV0Rm9ybWF0dGVyKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgYXBwZW5kVG9Cb2R5ID0gIGF0dHJzLnR5cGVhaGVhZEFwcGVuZFRvQm9keSA/IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkQXBwZW5kVG9Cb2R5KSA6IGZhbHNlO1xuXG4gICAgICAgIHZhciBmb2N1c0ZpcnN0ID0gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRGb2N1c0ZpcnN0KSAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy9JZiBpbnB1dCBtYXRjaGVzIGFuIGl0ZW0gb2YgdGhlIGxpc3QgZXhhY3RseSwgc2VsZWN0IGl0IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgdmFyIHNlbGVjdE9uRXhhY3QgPSBhdHRycy50eXBlYWhlYWRTZWxlY3RPbkV4YWN0ID8gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRTZWxlY3RPbkV4YWN0KSA6IGZhbHNlO1xuXG4gICAgICAgIC8vSU5URVJOQUwgVkFSSUFCTEVTXG5cbiAgICAgICAgLy9tb2RlbCBzZXR0ZXIgZXhlY3V0ZWQgdXBvbiBtYXRjaCBzZWxlY3Rpb25cbiAgICAgICAgdmFyIHBhcnNlZE1vZGVsID0gJHBhcnNlKGF0dHJzLm5nTW9kZWwpO1xuICAgICAgICB2YXIgaW52b2tlTW9kZWxTZXR0ZXIgPSAkcGFyc2UoYXR0cnMubmdNb2RlbCArICcoJCQkcCknKTtcbiAgICAgICAgdmFyICRzZXRNb2RlbFZhbHVlID0gZnVuY3Rpb24oc2NvcGUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihwYXJzZWRNb2RlbChvcmlnaW5hbFNjb3BlKSkgJiZcbiAgICAgICAgICAgIG5nTW9kZWxPcHRpb25zICYmIG5nTW9kZWxPcHRpb25zLiRvcHRpb25zICYmIG5nTW9kZWxPcHRpb25zLiRvcHRpb25zLmdldHRlclNldHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZU1vZGVsU2V0dGVyKHNjb3BlLCB7JCQkcDogbmV3VmFsdWV9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZE1vZGVsLmFzc2lnbihzY29wZSwgbmV3VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvL2V4cHJlc3Npb25zIHVzZWQgYnkgdHlwZWFoZWFkXG4gICAgICAgIHZhciBwYXJzZXJSZXN1bHQgPSB0eXBlYWhlYWRQYXJzZXIucGFyc2UoYXR0cnMudHlwZWFoZWFkKTtcblxuICAgICAgICB2YXIgaGFzRm9jdXM7XG5cbiAgICAgICAgLy9Vc2VkIHRvIGF2b2lkIGJ1ZyBpbiBpT1Mgd2VidmlldyB3aGVyZSBpT1Mga2V5Ym9hcmQgZG9lcyBub3QgZmlyZVxuICAgICAgICAvL21vdXNlZG93biAmIG1vdXNldXAgZXZlbnRzXG4gICAgICAgIC8vSXNzdWUgIzM2OTlcbiAgICAgICAgdmFyIHNlbGVjdGVkO1xuXG4gICAgICAgIC8vY3JlYXRlIGEgY2hpbGQgc2NvcGUgZm9yIHRoZSB0eXBlYWhlYWQgZGlyZWN0aXZlIHNvIHdlIGFyZSBub3QgcG9sbHV0aW5nIG9yaWdpbmFsIHNjb3BlXG4gICAgICAgIC8vd2l0aCB0eXBlYWhlYWQtc3BlY2lmaWMgZGF0YSAobWF0Y2hlcywgcXVlcnkgZXRjLilcbiAgICAgICAgdmFyIHNjb3BlID0gb3JpZ2luYWxTY29wZS4kbmV3KCk7XG4gICAgICAgIHZhciBvZmZEZXN0cm95ID0gb3JpZ2luYWxTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG5cdFx0XHQgICAgc2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBvZmZEZXN0cm95KTtcblxuICAgICAgICAvLyBXQUktQVJJQVxuICAgICAgICB2YXIgcG9wdXBJZCA9ICd0eXBlYWhlYWQtJyArIHNjb3BlLiRpZCArICctJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbiAgICAgICAgZWxlbWVudC5hdHRyKHtcbiAgICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbGlzdCcsXG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSxcbiAgICAgICAgICAnYXJpYS1vd25zJzogcG9wdXBJZFxuICAgICAgICB9KTtcblxuICAgICAgICAvL3BvcC11cCBlbGVtZW50IHVzZWQgdG8gZGlzcGxheSBtYXRjaGVzXG4gICAgICAgIHZhciBwb3BVcEVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IHR5cGVhaGVhZC1wb3B1cD48L2Rpdj4nKTtcbiAgICAgICAgcG9wVXBFbC5hdHRyKHtcbiAgICAgICAgICBpZDogcG9wdXBJZCxcbiAgICAgICAgICBtYXRjaGVzOiAnbWF0Y2hlcycsXG4gICAgICAgICAgYWN0aXZlOiAnYWN0aXZlSWR4JyxcbiAgICAgICAgICBzZWxlY3Q6ICdzZWxlY3QoYWN0aXZlSWR4KScsXG4gICAgICAgICAgJ21vdmUtaW4tcHJvZ3Jlc3MnOiAnbW92ZUluUHJvZ3Jlc3MnLFxuICAgICAgICAgIHF1ZXJ5OiAncXVlcnknLFxuICAgICAgICAgIHBvc2l0aW9uOiAncG9zaXRpb24nXG4gICAgICAgIH0pO1xuICAgICAgICAvL2N1c3RvbSBpdGVtIHRlbXBsYXRlXG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50eXBlYWhlYWRUZW1wbGF0ZVVybCkpIHtcbiAgICAgICAgICBwb3BVcEVsLmF0dHIoJ3RlbXBsYXRlLXVybCcsIGF0dHJzLnR5cGVhaGVhZFRlbXBsYXRlVXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50eXBlYWhlYWRQb3B1cFRlbXBsYXRlVXJsKSkge1xuICAgICAgICAgIHBvcFVwRWwuYXR0cigncG9wdXAtdGVtcGxhdGUtdXJsJywgYXR0cnMudHlwZWFoZWFkUG9wdXBUZW1wbGF0ZVVybCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzZXRNYXRjaGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2NvcGUubWF0Y2hlcyA9IFtdO1xuICAgICAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IC0xO1xuICAgICAgICAgIGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0TWF0Y2hJZCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHBvcHVwSWQgKyAnLW9wdGlvbi0nICsgaW5kZXg7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW5kaWNhdGUgdGhhdCB0aGUgc3BlY2lmaWVkIG1hdGNoIGlzIHRoZSBhY3RpdmUgKHByZS1zZWxlY3RlZCkgaXRlbSBpbiB0aGUgbGlzdCBvd25lZCBieSB0aGlzIHR5cGVhaGVhZC5cbiAgICAgICAgLy8gVGhpcyBhdHRyaWJ1dGUgaXMgYWRkZWQgb3IgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIGBhY3RpdmVJZHhgIGNoYW5nZXMuXG4gICAgICAgIHNjb3BlLiR3YXRjaCgnYWN0aXZlSWR4JywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIGdldE1hdGNoSWQoaW5kZXgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBpbnB1dElzRXhhY3RNYXRjaCA9IGZ1bmN0aW9uKGlucHV0VmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKHNjb3BlLm1hdGNoZXMubGVuZ3RoID4gaW5kZXggJiYgaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0VmFsdWUudG9VcHBlckNhc2UoKSA9PT0gc2NvcGUubWF0Y2hlc1tpbmRleF0ubGFiZWwudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldE1hdGNoZXNBc3luYyA9IGZ1bmN0aW9uKGlucHV0VmFsdWUpIHtcbiAgICAgICAgICB2YXIgbG9jYWxzID0geyR2aWV3VmFsdWU6IGlucHV0VmFsdWV9O1xuICAgICAgICAgIGlzTG9hZGluZ1NldHRlcihvcmlnaW5hbFNjb3BlLCB0cnVlKTtcbiAgICAgICAgICBpc05vUmVzdWx0c1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgJHEud2hlbihwYXJzZXJSZXN1bHQuc291cmNlKG9yaWdpbmFsU2NvcGUsIGxvY2FscykpLnRoZW4oZnVuY3Rpb24obWF0Y2hlcykge1xuICAgICAgICAgICAgLy9pdCBtaWdodCBoYXBwZW4gdGhhdCBzZXZlcmFsIGFzeW5jIHF1ZXJpZXMgd2VyZSBpbiBwcm9ncmVzcyBpZiBhIHVzZXIgd2VyZSB0eXBpbmcgZmFzdFxuICAgICAgICAgICAgLy9idXQgd2UgYXJlIGludGVyZXN0ZWQgb25seSBpbiByZXNwb25zZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBjdXJyZW50IHZpZXcgdmFsdWVcbiAgICAgICAgICAgIHZhciBvbkN1cnJlbnRSZXF1ZXN0ID0gKGlucHV0VmFsdWUgPT09IG1vZGVsQ3RybC4kdmlld1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChvbkN1cnJlbnRSZXF1ZXN0ICYmIGhhc0ZvY3VzKSB7XG4gICAgICAgICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuYWN0aXZlSWR4ID0gZm9jdXNGaXJzdCA/IDAgOiAtMTtcbiAgICAgICAgICAgICAgICBpc05vUmVzdWx0c1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2NvcGUubWF0Y2hlcy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgLy90cmFuc2Zvcm0gbGFiZWxzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBsb2NhbHNbcGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IG1hdGNoZXNbaV07XG4gICAgICAgICAgICAgICAgICBzY29wZS5tYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogZ2V0TWF0Y2hJZChpKSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHBhcnNlclJlc3VsdC52aWV3TWFwcGVyKHNjb3BlLCBsb2NhbHMpLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbDogbWF0Y2hlc1tpXVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2NvcGUucXVlcnkgPSBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgICAgIC8vcG9zaXRpb24gcG9wLXVwIHdpdGggbWF0Y2hlcyAtIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlIGl0cyBwb3NpdGlvbiBlYWNoIHRpbWUgd2UgYXJlIG9wZW5pbmcgYSB3aW5kb3dcbiAgICAgICAgICAgICAgICAvL3dpdGggbWF0Y2hlcyBhcyBhIHBvcC11cCBtaWdodCBiZSBhYnNvbHV0ZS1wb3NpdGlvbmVkIGFuZCBwb3NpdGlvbiBvZiBhbiBpbnB1dCBtaWdodCBoYXZlIGNoYW5nZWQgb24gYSBwYWdlXG4gICAgICAgICAgICAgICAgLy9kdWUgdG8gb3RoZXIgZWxlbWVudHMgYmVpbmcgcmVuZGVyZWRcbiAgICAgICAgICAgICAgICByZWNhbGN1bGF0ZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIC8vU2VsZWN0IHRoZSBzaW5nbGUgcmVtYWluaW5nIG9wdGlvbiBpZiB1c2VyIGlucHV0IG1hdGNoZXNcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0T25FeGFjdCAmJiBzY29wZS5tYXRjaGVzLmxlbmd0aCA9PT0gMSAmJiBpbnB1dElzRXhhY3RNYXRjaChpbnB1dFZhbHVlLCAwKSkge1xuICAgICAgICAgICAgICAgICAgc2NvcGUuc2VsZWN0KDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNldE1hdGNoZXMoKTtcbiAgICAgICAgICAgICAgICBpc05vUmVzdWx0c1NldHRlcihvcmlnaW5hbFNjb3BlLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uQ3VycmVudFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgaXNMb2FkaW5nU2V0dGVyKG9yaWdpbmFsU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgICAgaXNMb2FkaW5nU2V0dGVyKG9yaWdpbmFsU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlzTm9SZXN1bHRzU2V0dGVyKG9yaWdpbmFsU2NvcGUsIHRydWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGJpbmQgZXZlbnRzIG9ubHkgaWYgYXBwZW5kVG9Cb2R5IHBhcmFtcyBleGlzdCAtIHBlcmZvcm1hbmNlIGZlYXR1cmVcbiAgICAgICAgaWYgKGFwcGVuZFRvQm9keSkge1xuICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudCgkd2luZG93KS5iaW5kKCdyZXNpemUnLCBmaXJlUmVjYWxjdWxhdGluZyk7XG4gICAgICAgICAgJGRvY3VtZW50LmZpbmQoJ2JvZHknKS5iaW5kKCdzY3JvbGwnLCBmaXJlUmVjYWxjdWxhdGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNsYXJlIHRoZSB0aW1lb3V0IHByb21pc2UgdmFyIG91dHNpZGUgdGhlIGZ1bmN0aW9uIHNjb3BlIHNvIHRoYXQgc3RhY2tlZCBjYWxscyBjYW4gYmUgY2FuY2VsbGVkIGxhdGVyXG4gICAgICAgIHZhciB0aW1lb3V0RXZlbnRQcm9taXNlO1xuXG4gICAgICAgIC8vIERlZmF1bHQgcHJvZ3Jlc3MgdHlwZVxuICAgICAgICBzY29wZS5tb3ZlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpcmVSZWNhbGN1bGF0aW5nKCkge1xuICAgICAgICAgIGlmICghc2NvcGUubW92ZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHNjb3BlLm1vdmVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYW5jZWwgcHJldmlvdXMgdGltZW91dFxuICAgICAgICAgIGlmICh0aW1lb3V0RXZlbnRQcm9taXNlKSB7XG4gICAgICAgICAgICAkdGltZW91dC5jYW5jZWwodGltZW91dEV2ZW50UHJvbWlzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVib3VuY2VkIGV4ZWN1dGluZyByZWNhbGN1bGF0ZSBhZnRlciBldmVudHMgZmlyZWRcbiAgICAgICAgICB0aW1lb3V0RXZlbnRQcm9taXNlID0gJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBpZiBwb3B1cCBpcyB2aXNpYmxlXG4gICAgICAgICAgICBpZiAoc2NvcGUubWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVjYWxjdWxhdGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY29wZS5tb3ZlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgIH0sIGV2ZW50RGVib3VuY2VUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY2FsY3VsYXRlIGFjdHVhbCBwb3NpdGlvbiBhbmQgc2V0IG5ldyB2YWx1ZXMgdG8gc2NvcGVcbiAgICAgICAgLy8gYWZ0ZXIgZGlnZXN0IGxvb3AgaXMgcG9wdXAgaW4gcmlnaHQgcG9zaXRpb25cbiAgICAgICAgZnVuY3Rpb24gcmVjYWxjdWxhdGVQb3NpdGlvbigpIHtcbiAgICAgICAgICBzY29wZS5wb3NpdGlvbiA9IGFwcGVuZFRvQm9keSA/ICRwb3NpdGlvbi5vZmZzZXQoZWxlbWVudCkgOiAkcG9zaXRpb24ucG9zaXRpb24oZWxlbWVudCk7XG4gICAgICAgICAgc2NvcGUucG9zaXRpb24udG9wICs9IGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNldE1hdGNoZXMoKTtcblxuICAgICAgICAvL3dlIG5lZWQgdG8gcHJvcGFnYXRlIHVzZXIncyBxdWVyeSBzbyB3ZSBjYW4gaGlnbGlnaHQgbWF0Y2hlc1xuICAgICAgICBzY29wZS5xdWVyeSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvL0RlY2xhcmUgdGhlIHRpbWVvdXQgcHJvbWlzZSB2YXIgb3V0c2lkZSB0aGUgZnVuY3Rpb24gc2NvcGUgc28gdGhhdCBzdGFja2VkIGNhbGxzIGNhbiBiZSBjYW5jZWxsZWQgbGF0ZXJcbiAgICAgICAgdmFyIHRpbWVvdXRQcm9taXNlO1xuXG4gICAgICAgIHZhciBzY2hlZHVsZVNlYXJjaFdpdGhUaW1lb3V0ID0gZnVuY3Rpb24oaW5wdXRWYWx1ZSkge1xuICAgICAgICAgIHRpbWVvdXRQcm9taXNlID0gJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBnZXRNYXRjaGVzQXN5bmMoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgfSwgd2FpdFRpbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjYW5jZWxQcmV2aW91c1RpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGltZW91dFByb21pc2UpIHtcbiAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0aW1lb3V0UHJvbWlzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vcGx1ZyBpbnRvICRwYXJzZXJzIHBpcGVsaW5lIHRvIG9wZW4gYSB0eXBlYWhlYWQgb24gdmlldyBjaGFuZ2VzIGluaXRpYXRlZCBmcm9tIERPTVxuICAgICAgICAvLyRwYXJzZXJzIGtpY2staW4gb24gYWxsIHRoZSBjaGFuZ2VzIGNvbWluZyBmcm9tIHRoZSB2aWV3IGFzIHdlbGwgYXMgbWFudWFsbHkgdHJpZ2dlcmVkIGJ5ICRzZXRWaWV3VmFsdWVcbiAgICAgICAgbW9kZWxDdHJsLiRwYXJzZXJzLnVuc2hpZnQoZnVuY3Rpb24oaW5wdXRWYWx1ZSkge1xuICAgICAgICAgIGhhc0ZvY3VzID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChtaW5MZW5ndGggPT09IDAgfHwgaW5wdXRWYWx1ZSAmJiBpbnB1dFZhbHVlLmxlbmd0aCA+PSBtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh3YWl0VGltZSA+IDApIHtcbiAgICAgICAgICAgICAgY2FuY2VsUHJldmlvdXNUaW1lb3V0KCk7XG4gICAgICAgICAgICAgIHNjaGVkdWxlU2VhcmNoV2l0aFRpbWVvdXQoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBnZXRNYXRjaGVzQXN5bmMoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzTG9hZGluZ1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICBjYW5jZWxQcmV2aW91c1RpbWVvdXQoKTtcbiAgICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICAgIC8vIFJlc2V0IGluIGNhc2UgdXNlciBoYWQgdHlwZWQgc29tZXRoaW5nIHByZXZpb3VzbHkuXG4gICAgICAgICAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2VkaXRhYmxlJywgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZWRpdGFibGUnLCBmYWxzZSk7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtb2RlbEN0cmwuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbihtb2RlbFZhbHVlKSB7XG4gICAgICAgICAgdmFyIGNhbmRpZGF0ZVZpZXdWYWx1ZSwgZW1wdHlWaWV3VmFsdWU7XG4gICAgICAgICAgdmFyIGxvY2FscyA9IHt9O1xuXG4gICAgICAgICAgLy8gVGhlIHZhbGlkaXR5IG1heSBiZSBzZXQgdG8gZmFsc2UgdmlhICRwYXJzZXJzIChzZWUgYWJvdmUpIGlmXG4gICAgICAgICAgLy8gdGhlIG1vZGVsIGlzIHJlc3RyaWN0ZWQgdG8gc2VsZWN0ZWQgdmFsdWVzLiBJZiB0aGUgbW9kZWxcbiAgICAgICAgICAvLyBpcyBzZXQgbWFudWFsbHkgaXQgaXMgY29uc2lkZXJlZCB0byBiZSB2YWxpZC5cbiAgICAgICAgICBpZiAoIWlzRWRpdGFibGUpIHtcbiAgICAgICAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2VkaXRhYmxlJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlucHV0Rm9ybWF0dGVyKSB7XG4gICAgICAgICAgICBsb2NhbHMuJG1vZGVsID0gbW9kZWxWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dEZvcm1hdHRlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2l0IG1pZ2h0IGhhcHBlbiB0aGF0IHdlIGRvbid0IGhhdmUgZW5vdWdoIGluZm8gdG8gcHJvcGVybHkgcmVuZGVyIGlucHV0IHZhbHVlXG4gICAgICAgICAgICAvL3dlIG5lZWQgdG8gY2hlY2sgZm9yIHRoaXMgc2l0dWF0aW9uIGFuZCBzaW1wbHkgcmV0dXJuIG1vZGVsIHZhbHVlIGlmIHdlIGNhbid0IGFwcGx5IGN1c3RvbSBmb3JtYXR0aW5nXG4gICAgICAgICAgICBsb2NhbHNbcGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IG1vZGVsVmFsdWU7XG4gICAgICAgICAgICBjYW5kaWRhdGVWaWV3VmFsdWUgPSBwYXJzZXJSZXN1bHQudmlld01hcHBlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpO1xuICAgICAgICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBlbXB0eVZpZXdWYWx1ZSA9IHBhcnNlclJlc3VsdC52aWV3TWFwcGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XG5cbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVWaWV3VmFsdWUhPT0gZW1wdHlWaWV3VmFsdWUgPyBjYW5kaWRhdGVWaWV3VmFsdWUgOiBtb2RlbFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2NvcGUuc2VsZWN0ID0gZnVuY3Rpb24oYWN0aXZlSWR4KSB7XG4gICAgICAgICAgLy9jYWxsZWQgZnJvbSB3aXRoaW4gdGhlICRkaWdlc3QoKSBjeWNsZVxuICAgICAgICAgIHZhciBsb2NhbHMgPSB7fTtcbiAgICAgICAgICB2YXIgbW9kZWwsIGl0ZW07XG5cbiAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSBpdGVtID0gc2NvcGUubWF0Y2hlc1thY3RpdmVJZHhdLm1vZGVsO1xuICAgICAgICAgIG1vZGVsID0gcGFyc2VyUmVzdWx0Lm1vZGVsTWFwcGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XG4gICAgICAgICAgJHNldE1vZGVsVmFsdWUob3JpZ2luYWxTY29wZSwgbW9kZWwpO1xuICAgICAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2VkaXRhYmxlJywgdHJ1ZSk7XG4gICAgICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgncGFyc2UnLCB0cnVlKTtcblxuICAgICAgICAgIG9uU2VsZWN0Q2FsbGJhY2sob3JpZ2luYWxTY29wZSwge1xuICAgICAgICAgICAgJGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAkbW9kZWw6IG1vZGVsLFxuICAgICAgICAgICAgJGxhYmVsOiBwYXJzZXJSZXN1bHQudmlld01hcHBlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXNldE1hdGNoZXMoKTtcblxuICAgICAgICAgIC8vcmV0dXJuIGZvY3VzIHRvIHRoZSBpbnB1dCBlbGVtZW50IGlmIGEgbWF0Y2ggd2FzIHNlbGVjdGVkIHZpYSBhIG1vdXNlIGNsaWNrIGV2ZW50XG4gICAgICAgICAgLy8gdXNlIHRpbWVvdXQgdG8gYXZvaWQgJHJvb3RTY29wZTppbnByb2cgZXJyb3JcbiAgICAgICAgICBpZiAoc2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkRm9jdXNPblNlbGVjdCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHsgZWxlbWVudFswXS5mb2N1cygpOyB9LCAwLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vYmluZCBrZXlib2FyZCBldmVudHM6IGFycm93cyB1cCgzOCkgLyBkb3duKDQwKSwgZW50ZXIoMTMpIGFuZCB0YWIoOSksIGVzYygyNylcbiAgICAgICAgZWxlbWVudC5iaW5kKCdrZXlkb3duJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgLy90eXBlYWhlYWQgaXMgb3BlbiBhbmQgYW4gXCJpbnRlcmVzdGluZ1wiIGtleSB3YXMgcHJlc3NlZFxuICAgICAgICAgIGlmIChzY29wZS5tYXRjaGVzLmxlbmd0aCA9PT0gMCB8fCBIT1RfS0VZUy5pbmRleE9mKGV2dC53aGljaCkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlcmUncyBub3RoaW5nIHNlbGVjdGVkIChpLmUuIGZvY3VzRmlyc3QpIGFuZCBlbnRlciBvciB0YWIgaXMgaGl0LCBjbGVhciB0aGUgcmVzdWx0c1xuICAgICAgICAgIGlmIChzY29wZS5hY3RpdmVJZHggPT09IC0xICYmIChldnQud2hpY2ggPT09IDkgfHwgZXZ0LndoaWNoID09PSAxMykpIHtcbiAgICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKGV2dC53aGljaCA9PT0gNDApIHtcbiAgICAgICAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IChzY29wZS5hY3RpdmVJZHggKyAxKSAlIHNjb3BlLm1hdGNoZXMubGVuZ3RoO1xuICAgICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuXG4gICAgICAgICAgfSBlbHNlIGlmIChldnQud2hpY2ggPT09IDM4KSB7XG4gICAgICAgICAgICBzY29wZS5hY3RpdmVJZHggPSAoc2NvcGUuYWN0aXZlSWR4ID4gMCA/IHNjb3BlLmFjdGl2ZUlkeCA6IHNjb3BlLm1hdGNoZXMubGVuZ3RoKSAtIDE7XG4gICAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGV2dC53aGljaCA9PT0gMTMgfHwgZXZ0LndoaWNoID09PSA5KSB7XG4gICAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzY29wZS5zZWxlY3Qoc2NvcGUuYWN0aXZlSWR4KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgfSBlbHNlIGlmIChldnQud2hpY2ggPT09IDI3KSB7XG4gICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWxlbWVudC5iaW5kKCdibHVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlzU2VsZWN0T25CbHVyICYmIHNjb3BlLm1hdGNoZXMubGVuZ3RoICYmIHNjb3BlLmFjdGl2ZUlkeCAhPT0gLTEgJiYgIXNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNjb3BlLnNlbGVjdChzY29wZS5hY3RpdmVJZHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gS2VlcCByZWZlcmVuY2UgdG8gY2xpY2sgaGFuZGxlciB0byB1bmJpbmQgaXQuXG4gICAgICAgIHZhciBkaXNtaXNzQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgLy8gSXNzdWUgIzM5NzNcbiAgICAgICAgICAvLyBGaXJlZm94IHRyZWF0cyByaWdodCBjbGljayBhcyBhIGNsaWNrIG9uIGRvY3VtZW50XG4gICAgICAgICAgaWYgKGVsZW1lbnRbMF0gIT09IGV2dC50YXJnZXQgJiYgZXZ0LndoaWNoICE9PSAzICYmIHNjb3BlLm1hdGNoZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICByZXNldE1hdGNoZXMoKTtcbiAgICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgJGRvY3VtZW50LmJpbmQoJ2NsaWNrJywgZGlzbWlzc0NsaWNrSGFuZGxlcik7XG5cbiAgICAgICAgb3JpZ2luYWxTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJGRvY3VtZW50LnVuYmluZCgnY2xpY2snLCBkaXNtaXNzQ2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAgICAgICAkcG9wdXAucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFByZXZlbnQgalF1ZXJ5IGNhY2hlIG1lbW9yeSBsZWFrXG4gICAgICAgICAgcG9wVXBFbC5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyICRwb3B1cCA9ICRjb21waWxlKHBvcFVwRWwpKHNjb3BlKTtcblxuICAgICAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAgICAgJGRvY3VtZW50LmZpbmQoJ2JvZHknKS5hcHBlbmQoJHBvcHVwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LmFmdGVyKCRwb3B1cCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIH1dKVxuXG4gIC5kaXJlY3RpdmUoJ3R5cGVhaGVhZFBvcHVwJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgICAgc2NvcGU6IHtcbiAgICAgICAgbWF0Y2hlczogJz0nLFxuICAgICAgICBxdWVyeTogJz0nLFxuICAgICAgICBhY3RpdmU6ICc9JyxcbiAgICAgICAgcG9zaXRpb246ICcmJyxcbiAgICAgICAgbW92ZUluUHJvZ3Jlc3M6ICc9JyxcbiAgICAgICAgc2VsZWN0OiAnJidcbiAgICAgIH0sXG4gICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIHJldHVybiBhdHRycy5wb3B1cFRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLXBvcHVwLmh0bWwnO1xuICAgICAgfSxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICBzY29wZS50ZW1wbGF0ZVVybCA9IGF0dHJzLnRlbXBsYXRlVXJsO1xuXG4gICAgICAgIHNjb3BlLmlzT3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzY29wZS5tYXRjaGVzLmxlbmd0aCA+IDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NvcGUuaXNBY3RpdmUgPSBmdW5jdGlvbihtYXRjaElkeCkge1xuICAgICAgICAgIHJldHVybiBzY29wZS5hY3RpdmUgPT0gbWF0Y2hJZHg7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NvcGUuc2VsZWN0QWN0aXZlID0gZnVuY3Rpb24obWF0Y2hJZHgpIHtcbiAgICAgICAgICBzY29wZS5hY3RpdmUgPSBtYXRjaElkeDtcbiAgICAgICAgfTtcblxuICAgICAgICBzY29wZS5zZWxlY3RNYXRjaCA9IGZ1bmN0aW9uKGFjdGl2ZUlkeCkge1xuICAgICAgICAgIHNjb3BlLnNlbGVjdCh7YWN0aXZlSWR4OmFjdGl2ZUlkeH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH0pXG5cbiAgLmRpcmVjdGl2ZSgndHlwZWFoZWFkTWF0Y2gnLCBbJyR0ZW1wbGF0ZVJlcXVlc3QnLCAnJGNvbXBpbGUnLCAnJHBhcnNlJywgZnVuY3Rpb24oJHRlbXBsYXRlUmVxdWVzdCwgJGNvbXBpbGUsICRwYXJzZSkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0VBJyxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGluZGV4OiAnPScsXG4gICAgICAgIG1hdGNoOiAnPScsXG4gICAgICAgIHF1ZXJ5OiAnPSdcbiAgICAgIH0sXG4gICAgICBsaW5rOmZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICB2YXIgdHBsVXJsID0gJHBhcnNlKGF0dHJzLnRlbXBsYXRlVXJsKShzY29wZS4kcGFyZW50KSB8fCAndGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1tYXRjaC5odG1sJztcbiAgICAgICAgJHRlbXBsYXRlUmVxdWVzdCh0cGxVcmwpLnRoZW4oZnVuY3Rpb24odHBsQ29udGVudCkge1xuICAgICAgICAgICRjb21waWxlKHRwbENvbnRlbnQudHJpbSgpKShzY29wZSwgZnVuY3Rpb24oY2xvbmVkRWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aChjbG9uZWRFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pXG5cbiAgLmZpbHRlcigndHlwZWFoZWFkSGlnaGxpZ2h0JywgWyckc2NlJywgJyRpbmplY3RvcicsICckbG9nJywgZnVuY3Rpb24oJHNjZSwgJGluamVjdG9yLCAkbG9nKSB7XG4gICAgdmFyIGlzU2FuaXRpemVQcmVzZW50O1xuICAgIGlzU2FuaXRpemVQcmVzZW50ID0gJGluamVjdG9yLmhhcygnJHNhbml0aXplJyk7XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdleHAocXVlcnlUb0VzY2FwZSkge1xuICAgICAgLy8gUmVnZXg6IGNhcHR1cmUgdGhlIHdob2xlIHF1ZXJ5IHN0cmluZyBhbmQgcmVwbGFjZSBpdCB3aXRoIHRoZSBzdHJpbmcgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbWF0Y2hcbiAgICAgIC8vIHRoZSByZXN1bHRzLCBmb3IgZXhhbXBsZSBpZiB0aGUgY2FwdHVyZSBpcyBcImFcIiB0aGUgcmVzdWx0IHdpbGwgYmUgXFxhXG4gICAgICByZXR1cm4gcXVlcnlUb0VzY2FwZS5yZXBsYWNlKC8oWy4/KiteJFtcXF1cXFxcKCl7fXwtXSkvZywgJ1xcXFwkMScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zSHRtbChtYXRjaEl0ZW0pIHtcbiAgICAgIHJldHVybiAvPC4qPi9nLnRlc3QobWF0Y2hJdGVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24obWF0Y2hJdGVtLCBxdWVyeSkge1xuICAgICAgaWYgKCFpc1Nhbml0aXplUHJlc2VudCAmJiBjb250YWluc0h0bWwobWF0Y2hJdGVtKSkge1xuICAgICAgICAkbG9nLndhcm4oJ1Vuc2FmZSB1c2Ugb2YgdHlwZWFoZWFkIHBsZWFzZSB1c2UgbmdTYW5pdGl6ZScpOyAvLyBXYXJuIHRoZSB1c2VyIGFib3V0IHRoZSBkYW5nZXJcbiAgICAgIH1cbiAgICAgIG1hdGNoSXRlbSA9IHF1ZXJ5PyAoJycgKyBtYXRjaEl0ZW0pLnJlcGxhY2UobmV3IFJlZ0V4cChlc2NhcGVSZWdleHAocXVlcnkpLCAnZ2knKSwgJzxzdHJvbmc+JCY8L3N0cm9uZz4nKSA6IG1hdGNoSXRlbTsgLy8gUmVwbGFjZXMgdGhlIGNhcHR1cmUgc3RyaW5nIHdpdGggYSB0aGUgc2FtZSBzdHJpbmcgaW5zaWRlIG9mIGEgXCJzdHJvbmdcIiB0YWdcbiAgICAgIGlmICghaXNTYW5pdGl6ZVByZXNlbnQpIHtcbiAgICAgICAgbWF0Y2hJdGVtID0gJHNjZS50cnVzdEFzSHRtbChtYXRjaEl0ZW0pOyAvLyBJZiAkc2FuaXRpemUgaXMgbm90IHByZXNlbnQgd2UgcGFjayB0aGUgc3RyaW5nIGluIGEgJHNjZSBvYmplY3QgZm9yIHRoZSBuZy1iaW5kLWh0bWwgZGlyZWN0aXZlXG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hJdGVtO1xuICAgIH07XG4gIH1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInBhbmVsIHt7cGFuZWxDbGFzcyB8fCAncGFuZWwtZGVmYXVsdCd9fVxcXCI+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIiBuZy1rZXlwcmVzcz1cXFwidG9nZ2xlT3BlbigkZXZlbnQpXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGg0IGNsYXNzPVxcXCJwYW5lbC10aXRsZVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPGEgaHJlZiB0YWJpbmRleD1cXFwiMFxcXCIgY2xhc3M9XFxcImFjY29yZGlvbi10b2dnbGVcXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVPcGVuKClcXFwiIGFjY29yZGlvbi10cmFuc2NsdWRlPVxcXCJoZWFkaW5nXFxcIj48c3BhbiBuZy1jbGFzcz1cXFwieyd0ZXh0LW11dGVkJzogaXNEaXNhYmxlZH1cXFwiPnt7aGVhZGluZ319PC9zcGFuPjwvYT5cXG5cIiArXG4gICAgXCIgICAgPC9oND5cXG5cIiArXG4gICAgXCIgIDwvZGl2PlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwicGFuZWwtY29sbGFwc2UgY29sbGFwc2VcXFwiIGNvbGxhcHNlPVxcXCIhaXNPcGVuXFxcIj5cXG5cIiArXG4gICAgXCJcdCAgPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXG4gICAgXCIgIDwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInBhbmVsLWdyb3VwXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwiYWxlcnRcXFwiIG5nLWNsYXNzPVxcXCJbJ2FsZXJ0LScgKyAodHlwZSB8fCAnd2FybmluZycpLCBjbG9zZWFibGUgPyAnYWxlcnQtZGlzbWlzc2libGUnIDogbnVsbF1cXFwiIHJvbGU9XFxcImFsZXJ0XFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGJ1dHRvbiBuZy1zaG93PVxcXCJjbG9zZWFibGVcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlXFxcIiBuZy1jbGljaz1cXFwiY2xvc2UoJGV2ZW50KVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvc3Bhbj5cXG5cIiArXG4gICAgXCIgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5DbG9zZTwvc3Bhbj5cXG5cIiArXG4gICAgXCIgICAgPC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgIDxkaXYgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvY2Fyb3VzZWwvY2Fyb3VzZWwuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2Nhcm91c2VsL2Nhcm91c2VsLmh0bWxcIixcbiAgICBcIjxkaXYgbmctbW91c2VlbnRlcj1cXFwicGF1c2UoKVxcXCIgbmctbW91c2VsZWF2ZT1cXFwicGxheSgpXFxcIiBjbGFzcz1cXFwiY2Fyb3VzZWxcXFwiIG5nLXN3aXBlLXJpZ2h0PVxcXCJwcmV2KClcXFwiIG5nLXN3aXBlLWxlZnQ9XFxcIm5leHQoKVxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxvbCBjbGFzcz1cXFwiY2Fyb3VzZWwtaW5kaWNhdG9yc1xcXCIgbmctc2hvdz1cXFwic2xpZGVzLmxlbmd0aCA+IDFcXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGxpIG5nLXJlcGVhdD1cXFwic2xpZGUgaW4gc2xpZGVzIHwgb3JkZXJCeTppbmRleE9mU2xpZGUgdHJhY2sgYnkgJGluZGV4XFxcIiBuZy1jbGFzcz1cXFwie2FjdGl2ZTogaXNBY3RpdmUoc2xpZGUpfVxcXCIgbmctY2xpY2s9XFxcInNlbGVjdChzbGlkZSlcXFwiPjwvbGk+XFxuXCIgK1xuICAgIFwiICAgIDwvb2w+XFxuXCIgK1xuICAgIFwiICAgIDxkaXYgY2xhc3M9XFxcImNhcm91c2VsLWlubmVyXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcbiAgICBcIiAgICA8YSBjbGFzcz1cXFwibGVmdCBjYXJvdXNlbC1jb250cm9sXFxcIiBuZy1jbGljaz1cXFwicHJldigpXFxcIiBuZy1zaG93PVxcXCJzbGlkZXMubGVuZ3RoID4gMVxcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1sZWZ0XFxcIj48L3NwYW4+PC9hPlxcblwiICtcbiAgICBcIiAgICA8YSBjbGFzcz1cXFwicmlnaHQgY2Fyb3VzZWwtY29udHJvbFxcXCIgbmctY2xpY2s9XFxcIm5leHQoKVxcXCIgbmctc2hvdz1cXFwic2xpZGVzLmxlbmd0aCA+IDFcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tcmlnaHRcXFwiPjwvc3Bhbj48L2E+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL2Nhcm91c2VsL3NsaWRlLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sXCIsXG4gICAgXCI8ZGl2IG5nLWNsYXNzPVxcXCJ7XFxuXCIgK1xuICAgIFwiICAgICdhY3RpdmUnOiBhY3RpdmVcXG5cIiArXG4gICAgXCIgIH1cXFwiIGNsYXNzPVxcXCJpdGVtIHRleHQtY2VudGVyXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sXCIsXG4gICAgXCI8ZGl2IG5nLXN3aXRjaD1cXFwiZGF0ZXBpY2tlck1vZGVcXFwiIHJvbGU9XFxcImFwcGxpY2F0aW9uXFxcIiBuZy1rZXlkb3duPVxcXCJrZXlkb3duKCRldmVudClcXFwiPlxcblwiICtcbiAgICBcIiAgPGRheXBpY2tlciBuZy1zd2l0Y2gtd2hlbj1cXFwiZGF5XFxcIiB0YWJpbmRleD1cXFwiMFxcXCI+PC9kYXlwaWNrZXI+XFxuXCIgK1xuICAgIFwiICA8bW9udGhwaWNrZXIgbmctc3dpdGNoLXdoZW49XFxcIm1vbnRoXFxcIiB0YWJpbmRleD1cXFwiMFxcXCI+PC9tb250aHBpY2tlcj5cXG5cIiArXG4gICAgXCIgIDx5ZWFycGlja2VyIG5nLXN3aXRjaC13aGVuPVxcXCJ5ZWFyXFxcIiB0YWJpbmRleD1cXFwiMFxcXCI+PC95ZWFycGlja2VyPlxcblwiICtcbiAgICBcIjwvZGl2PlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL2RheS5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvZGF0ZXBpY2tlci9kYXkuaHRtbFwiLFxuICAgIFwiPHRhYmxlIHJvbGU9XFxcImdyaWRcXFwiIGFyaWEtbGFiZWxsZWRieT1cXFwie3s6OnVuaXF1ZUlkfX0tdGl0bGVcXFwiIGFyaWEtYWN0aXZlZGVzY2VuZGFudD1cXFwie3thY3RpdmVEYXRlSWR9fVxcXCI+XFxuXCIgK1xuICAgIFwiICA8dGhlYWQ+XFxuXCIgK1xuICAgIFwiICAgIDx0cj5cXG5cIiArXG4gICAgXCIgICAgICA8dGg+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIHB1bGwtbGVmdFxcXCIgbmctY2xpY2s9XFxcIm1vdmUoLTEpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxpIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tbGVmdFxcXCI+PC9pPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoIGNvbHNwYW49XFxcInt7Ojo1ICsgc2hvd1dlZWtzfX1cXFwiPjxidXR0b24gaWQ9XFxcInt7Ojp1bmlxdWVJZH19LXRpdGxlXFxcIiByb2xlPVxcXCJoZWFkaW5nXFxcIiBhcmlhLWxpdmU9XFxcImFzc2VydGl2ZVxcXCIgYXJpYS1hdG9taWM9XFxcInRydWVcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc21cXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVNb2RlKClcXFwiIG5nLWRpc2FibGVkPVxcXCJkYXRlcGlja2VyTW9kZSA9PT0gbWF4TW9kZVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBzdHlsZT1cXFwid2lkdGg6MTAwJTtcXFwiPjxzdHJvbmc+e3t0aXRsZX19PC9zdHJvbmc+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgICA8dGg+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIHB1bGwtcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKDEpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxpIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tcmlnaHRcXFwiPjwvaT48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgICA8dHI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoIG5nLWlmPVxcXCJzaG93V2Vla3NcXFwiIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCI+PC90aD5cXG5cIiArXG4gICAgXCIgICAgICA8dGggbmctcmVwZWF0PVxcXCJsYWJlbCBpbiA6OmxhYmVscyB0cmFjayBieSAkaW5kZXhcXFwiIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCI+PHNtYWxsIGFyaWEtbGFiZWw9XFxcInt7OjpsYWJlbC5mdWxsfX1cXFwiPnt7OjpsYWJlbC5hYmJyfX08L3NtYWxsPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICA8L3RoZWFkPlxcblwiICtcbiAgICBcIiAgPHRib2R5PlxcblwiICtcbiAgICBcIiAgICA8dHIgbmctcmVwZWF0PVxcXCJyb3cgaW4gcm93cyB0cmFjayBieSAkaW5kZXhcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1pZj1cXFwic2hvd1dlZWtzXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXIgaDZcXFwiPjxlbT57eyB3ZWVrTnVtYmVyc1skaW5kZXhdIH19PC9lbT48L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1yZXBlYXQ9XFxcImR0IGluIHJvdyB0cmFjayBieSBkdC5kYXRlXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiIHJvbGU9XFxcImdyaWRjZWxsXFxcIiBpZD1cXFwie3s6OmR0LnVpZH19XFxcIiBuZy1jbGFzcz1cXFwiOjpkdC5jdXN0b21DbGFzc1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgc3R5bGU9XFxcIm1pbi13aWR0aDoxMDAlO1xcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc21cXFwiIG5nLWNsYXNzPVxcXCJ7J2J0bi1pbmZvJzogZHQuc2VsZWN0ZWQsIGFjdGl2ZTogaXNBY3RpdmUoZHQpfVxcXCIgbmctY2xpY2s9XFxcInNlbGVjdChkdC5kYXRlKVxcXCIgbmctZGlzYWJsZWQ9XFxcImR0LmRpc2FibGVkXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxzcGFuIG5nLWNsYXNzPVxcXCI6OnsndGV4dC1tdXRlZCc6IGR0LnNlY29uZGFyeSwgJ3RleHQtaW5mbyc6IGR0LmN1cnJlbnR9XFxcIj57ezo6ZHQubGFiZWx9fTwvc3Bhbj48L2J1dHRvbj5cXG5cIiArXG4gICAgXCIgICAgICA8L3RkPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgPC90Ym9keT5cXG5cIiArXG4gICAgXCI8L3RhYmxlPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL21vbnRoLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL21vbnRoLmh0bWxcIixcbiAgICBcIjx0YWJsZSByb2xlPVxcXCJncmlkXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcInt7Ojp1bmlxdWVJZH19LXRpdGxlXFxcIiBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9XFxcInt7YWN0aXZlRGF0ZUlkfX1cXFwiPlxcblwiICtcbiAgICBcIiAgPHRoZWFkPlxcblwiICtcbiAgICBcIiAgICA8dHI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLWxlZnRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKC0xKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWxlZnRcXFwiPjwvaT48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIGlkPVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgcm9sZT1cXFwiaGVhZGluZ1xcXCIgYXJpYS1saXZlPVxcXCJhc3NlcnRpdmVcXFwiIGFyaWEtYXRvbWljPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlTW9kZSgpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZGF0ZXBpY2tlck1vZGUgPT09IG1heE1vZGVcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgc3R5bGU9XFxcIndpZHRoOjEwMCU7XFxcIj48c3Ryb25nPnt7dGl0bGV9fTwvc3Ryb25nPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLXJpZ2h0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgxKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGhlYWQ+XFxuXCIgK1xuICAgIFwiICA8dGJvZHk+XFxuXCIgK1xuICAgIFwiICAgIDx0ciBuZy1yZXBlYXQ9XFxcInJvdyBpbiByb3dzIHRyYWNrIGJ5ICRpbmRleFxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIG5nLXJlcGVhdD1cXFwiZHQgaW4gcm93IHRyYWNrIGJ5IGR0LmRhdGVcXFwiIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCIgcm9sZT1cXFwiZ3JpZGNlbGxcXFwiIGlkPVxcXCJ7ezo6ZHQudWlkfX1cXFwiIG5nLWNsYXNzPVxcXCI6OmR0LmN1c3RvbUNsYXNzXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBzdHlsZT1cXFwibWluLXdpZHRoOjEwMCU7XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiBuZy1jbGFzcz1cXFwieydidG4taW5mbyc6IGR0LnNlbGVjdGVkLCBhY3RpdmU6IGlzQWN0aXZlKGR0KX1cXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3QoZHQuZGF0ZSlcXFwiIG5nLWRpc2FibGVkPVxcXCJkdC5kaXNhYmxlZFxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBuZy1jbGFzcz1cXFwiOjp7J3RleHQtaW5mbyc6IGR0LmN1cnJlbnR9XFxcIj57ezo6ZHQubGFiZWx9fTwvc3Bhbj48L2J1dHRvbj5cXG5cIiArXG4gICAgXCIgICAgICA8L3RkPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgPC90Ym9keT5cXG5cIiArXG4gICAgXCI8L3RhYmxlPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL3BvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL3BvcHVwLmh0bWxcIixcbiAgICBcIjx1bCBjbGFzcz1cXFwiZHJvcGRvd24tbWVudVxcXCIgbmctaWY9XFxcImlzT3BlblxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IGJsb2NrXFxcIiBuZy1zdHlsZT1cXFwie3RvcDogcG9zaXRpb24udG9wKydweCcsIGxlZnQ6IHBvc2l0aW9uLmxlZnQrJ3B4J31cXFwiIG5nLWtleWRvd249XFxcImtleWRvd24oJGV2ZW50KVxcXCIgbmctY2xpY2s9XFxcIiRldmVudC5zdG9wUHJvcGFnYXRpb24oKVxcXCI+XFxuXCIgK1xuICAgIFwiXHQ8bGkgbmctdHJhbnNjbHVkZT48L2xpPlxcblwiICtcbiAgICBcIlx0PGxpIG5nLWlmPVxcXCJzaG93QnV0dG9uQmFyXFxcIiBzdHlsZT1cXFwicGFkZGluZzoxMHB4IDlweCAycHhcXFwiPlxcblwiICtcbiAgICBcIlx0XHQ8c3BhbiBjbGFzcz1cXFwiYnRuLWdyb3VwIHB1bGwtbGVmdFxcXCI+XFxuXCIgK1xuICAgIFwiXHRcdFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1pbmZvXFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KCd0b2RheScpXFxcIiBuZy1kaXNhYmxlZD1cXFwiaXNEaXNhYmxlZCgndG9kYXknKVxcXCI+e3sgZ2V0VGV4dCgnY3VycmVudCcpIH19PC9idXR0b24+XFxuXCIgK1xuICAgIFwiXHRcdFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1kYW5nZXJcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3QobnVsbClcXFwiPnt7IGdldFRleHQoJ2NsZWFyJykgfX08L2J1dHRvbj5cXG5cIiArXG4gICAgXCJcdFx0PC9zcGFuPlxcblwiICtcbiAgICBcIlx0XHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLXN1Y2Nlc3MgcHVsbC1yaWdodFxcXCIgbmctY2xpY2s9XFxcImNsb3NlKClcXFwiPnt7IGdldFRleHQoJ2Nsb3NlJykgfX08L2J1dHRvbj5cXG5cIiArXG4gICAgXCJcdDwvbGk+XFxuXCIgK1xuICAgIFwiPC91bD5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvZGF0ZXBpY2tlci95ZWFyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL3llYXIuaHRtbFwiLFxuICAgIFwiPHRhYmxlIHJvbGU9XFxcImdyaWRcXFwiIGFyaWEtbGFiZWxsZWRieT1cXFwie3s6OnVuaXF1ZUlkfX0tdGl0bGVcXFwiIGFyaWEtYWN0aXZlZGVzY2VuZGFudD1cXFwie3thY3RpdmVEYXRlSWR9fVxcXCI+XFxuXCIgK1xuICAgIFwiICA8dGhlYWQ+XFxuXCIgK1xuICAgIFwiICAgIDx0cj5cXG5cIiArXG4gICAgXCIgICAgICA8dGg+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIHB1bGwtbGVmdFxcXCIgbmctY2xpY2s9XFxcIm1vdmUoLTEpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxpIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tbGVmdFxcXCI+PC9pPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoIGNvbHNwYW49XFxcIjNcXFwiPjxidXR0b24gaWQ9XFxcInt7Ojp1bmlxdWVJZH19LXRpdGxlXFxcIiByb2xlPVxcXCJoZWFkaW5nXFxcIiBhcmlhLWxpdmU9XFxcImFzc2VydGl2ZVxcXCIgYXJpYS1hdG9taWM9XFxcInRydWVcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc21cXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVNb2RlKClcXFwiIG5nLWRpc2FibGVkPVxcXCJkYXRlcGlja2VyTW9kZSA9PT0gbWF4TW9kZVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBzdHlsZT1cXFwid2lkdGg6MTAwJTtcXFwiPjxzdHJvbmc+e3t0aXRsZX19PC9zdHJvbmc+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgICA8dGg+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIHB1bGwtcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKDEpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxpIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tcmlnaHRcXFwiPjwvaT48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgPC90aGVhZD5cXG5cIiArXG4gICAgXCIgIDx0Ym9keT5cXG5cIiArXG4gICAgXCIgICAgPHRyIG5nLXJlcGVhdD1cXFwicm93IGluIHJvd3MgdHJhY2sgYnkgJGluZGV4XFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctcmVwZWF0PVxcXCJkdCBpbiByb3cgdHJhY2sgYnkgZHQuZGF0ZVxcXCIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIiByb2xlPVxcXCJncmlkY2VsbFxcXCIgaWQ9XFxcInt7OjpkdC51aWR9fVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgc3R5bGU9XFxcIm1pbi13aWR0aDoxMDAlO1xcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgbmctY2xhc3M9XFxcInsnYnRuLWluZm8nOiBkdC5zZWxlY3RlZCwgYWN0aXZlOiBpc0FjdGl2ZShkdCl9XFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KGR0LmRhdGUpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZHQuZGlzYWJsZWRcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gbmctY2xhc3M9XFxcIjo6eyd0ZXh0LWluZm8nOiBkdC5jdXJyZW50fVxcXCI+e3s6OmR0LmxhYmVsfX08L3NwYW4+PC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgICAgPC90ZD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGJvZHk+XFxuXCIgK1xuICAgIFwiPC90YWJsZT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvbW9kYWwvYmFja2Ryb3AuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL21vZGFsL2JhY2tkcm9wLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcIm1vZGFsLWJhY2tkcm9wXFxcIlxcblwiICtcbiAgICBcIiAgICAgbW9kYWwtYW5pbWF0aW9uLWNsYXNzPVxcXCJmYWRlXFxcIlxcblwiICtcbiAgICBcIiAgICAgbW9kYWwtaW4tY2xhc3M9XFxcImluXFxcIlxcblwiICtcbiAgICBcIiAgICAgbmctc3R5bGU9XFxcInsnei1pbmRleCc6IDEwNDAgKyAoaW5kZXggJiYgMSB8fCAwKSArIGluZGV4KjEwfVxcXCJcXG5cIiArXG4gICAgXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvbW9kYWwvd2luZG93Lmh0bWxcIixcbiAgICBcIjxkaXYgbW9kYWwtcmVuZGVyPVxcXCJ7eyRpc1JlbmRlcmVkfX1cXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwiZGlhbG9nXFxcIiBjbGFzcz1cXFwibW9kYWxcXFwiXFxuXCIgK1xuICAgIFwiICAgIG1vZGFsLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXG5cIiArXG4gICAgXCIgICAgbW9kYWwtaW4tY2xhc3M9XFxcImluXFxcIlxcblwiICtcbiAgICBcIlx0bmctc3R5bGU9XFxcInsnei1pbmRleCc6IDEwNTAgKyBpbmRleCoxMCwgZGlzcGxheTogJ2Jsb2NrJ31cXFwiIG5nLWNsaWNrPVxcXCJjbG9zZSgkZXZlbnQpXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZGlhbG9nXFxcIiBuZy1jbGFzcz1cXFwic2l6ZSA/ICdtb2RhbC0nICsgc2l6ZSA6ICcnXFxcIj48ZGl2IGNsYXNzPVxcXCJtb2RhbC1jb250ZW50XFxcIiBtb2RhbC10cmFuc2NsdWRlPjwvZGl2PjwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2VyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2VyLmh0bWxcIixcbiAgICBcIjx1bCBjbGFzcz1cXFwicGFnZXJcXFwiPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vUHJldmlvdXMoKXx8bmdEaXNhYmxlZCwgcHJldmlvdXM6IGFsaWdufVxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlIC0gMSwgJGV2ZW50KVxcXCI+e3s6OmdldFRleHQoJ3ByZXZpb3VzJyl9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vTmV4dCgpfHxuZ0Rpc2FibGVkLCBuZXh0OiBhbGlnbn1cXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UocGFnZSArIDEsICRldmVudClcXFwiPnt7OjpnZXRUZXh0KCduZXh0Jyl9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIjwvdWw+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmh0bWxcIixcbiAgICBcIjx1bCBjbGFzcz1cXFwicGFnaW5hdGlvblxcXCI+XFxuXCIgK1xuICAgIFwiICA8bGkgbmctaWY9XFxcIjo6Ym91bmRhcnlMaW5rc1xcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9QcmV2aW91cygpfHxuZ0Rpc2FibGVkfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tZmlyc3RcXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UoMSwgJGV2ZW50KVxcXCI+e3s6OmdldFRleHQoJ2ZpcnN0Jyl9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLWlmPVxcXCI6OmRpcmVjdGlvbkxpbmtzXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub1ByZXZpb3VzKCl8fG5nRGlzYWJsZWR9XFxcIiBjbGFzcz1cXFwicGFnaW5hdGlvbi1wcmV2XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHBhZ2UgLSAxLCAkZXZlbnQpXFxcIj57ezo6Z2V0VGV4dCgncHJldmlvdXMnKX19PC9hPjwvbGk+XFxuXCIgK1xuICAgIFwiICA8bGkgbmctcmVwZWF0PVxcXCJwYWdlIGluIHBhZ2VzIHRyYWNrIGJ5ICRpbmRleFxcXCIgbmctY2xhc3M9XFxcInthY3RpdmU6IHBhZ2UuYWN0aXZlLGRpc2FibGVkOiBuZ0Rpc2FibGVkJiYhcGFnZS5hY3RpdmV9XFxcIiBjbGFzcz1cXFwicGFnaW5hdGlvbi1wYWdlXFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHBhZ2UubnVtYmVyLCAkZXZlbnQpXFxcIj57e3BhZ2UudGV4dH19PC9hPjwvbGk+XFxuXCIgK1xuICAgIFwiICA8bGkgbmctaWY9XFxcIjo6ZGlyZWN0aW9uTGlua3NcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vTmV4dCgpfHxuZ0Rpc2FibGVkfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tbmV4dFxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlICsgMSwgJGV2ZW50KVxcXCI+e3s6OmdldFRleHQoJ25leHQnKX19PC9hPjwvbGk+XFxuXCIgK1xuICAgIFwiICA8bGkgbmctaWY9XFxcIjo6Ym91bmRhcnlMaW5rc1xcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9OZXh0KCl8fG5nRGlzYWJsZWR9XFxcIiBjbGFzcz1cXFwicGFnaW5hdGlvbi1sYXN0XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHRvdGFsUGFnZXMsICRldmVudClcXFwiPnt7OjpnZXRUZXh0KCdsYXN0Jyl9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIjwvdWw+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1odG1sLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC1wb3B1cC5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwXFxcIlxcblwiICtcbiAgICBcIiAgdG9vbHRpcC1hbmltYXRpb24tY2xhc3M9XFxcImZhZGVcXFwiXFxuXCIgK1xuICAgIFwiICB0b29sdGlwLWNsYXNzZXNcXG5cIiArXG4gICAgXCIgIG5nLWNsYXNzPVxcXCJ7IGluOiBpc09wZW4oKSB9XFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1pbm5lclxcXCIgbmctYmluZC1odG1sPVxcXCJjb250ZW50RXhwKClcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC11bnNhZmUtcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1odG1sLXVuc2FmZS1wb3B1cC5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwXFxcIlxcblwiICtcbiAgICBcIiAgdG9vbHRpcC1hbmltYXRpb24tY2xhc3M9XFxcImZhZGVcXFwiXFxuXCIgK1xuICAgIFwiICB0b29sdGlwLWNsYXNzZXNcXG5cIiArXG4gICAgXCIgIG5nLWNsYXNzPVxcXCJ7IGluOiBpc09wZW4oKSB9XFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1pbm5lclxcXCIgYmluZC1odG1sLXVuc2FmZT1cXFwiY29udGVudFxcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInRvb2x0aXBcXFwiXFxuXCIgK1xuICAgIFwiICB0b29sdGlwLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXG5cIiArXG4gICAgXCIgIHRvb2x0aXAtY2xhc3Nlc1xcblwiICtcbiAgICBcIiAgbmctY2xhc3M9XFxcInsgaW46IGlzT3BlbigpIH1cXFwiPlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1hcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWlubmVyXFxcIiBuZy1iaW5kPVxcXCJjb250ZW50XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXRlbXBsYXRlLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtdGVtcGxhdGUtcG9wdXAuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwidG9vbHRpcFxcXCJcXG5cIiArXG4gICAgXCIgIHRvb2x0aXAtYW5pbWF0aW9uLWNsYXNzPVxcXCJmYWRlXFxcIlxcblwiICtcbiAgICBcIiAgdG9vbHRpcC1jbGFzc2VzXFxuXCIgK1xuICAgIFwiICBuZy1jbGFzcz1cXFwieyBpbjogaXNPcGVuKCkgfVxcXCI+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWFycm93XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtaW5uZXJcXFwiXFxuXCIgK1xuICAgIFwiICAgIHRvb2x0aXAtdGVtcGxhdGUtdHJhbnNjbHVkZT1cXFwiY29udGVudEV4cCgpXFxcIlxcblwiICtcbiAgICBcIiAgICB0b29sdGlwLXRlbXBsYXRlLXRyYW5zY2x1ZGUtc2NvcGU9XFxcIm9yaWdpblNjb3BlKClcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItaHRtbC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLWh0bWwuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwicG9wb3ZlclxcXCJcXG5cIiArXG4gICAgXCIgIHRvb2x0aXAtYW5pbWF0aW9uLWNsYXNzPVxcXCJmYWRlXFxcIlxcblwiICtcbiAgICBcIiAgdG9vbHRpcC1jbGFzc2VzXFxuXCIgK1xuICAgIFwiICBuZy1jbGFzcz1cXFwieyBpbjogaXNPcGVuKCkgfVxcXCI+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJhcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiXFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWlubmVyXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8aDMgY2xhc3M9XFxcInBvcG92ZXItdGl0bGVcXFwiIG5nLWJpbmQ9XFxcInRpdGxlXFxcIiBuZy1pZj1cXFwidGl0bGVcXFwiPjwvaDM+XFxuXCIgK1xuICAgIFwiICAgICAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1jb250ZW50XFxcIiBuZy1iaW5kLWh0bWw9XFxcImNvbnRlbnRFeHAoKVxcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiICA8L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLXRlbXBsYXRlLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwicG9wb3ZlclxcXCJcXG5cIiArXG4gICAgXCIgIHRvb2x0aXAtYW5pbWF0aW9uLWNsYXNzPVxcXCJmYWRlXFxcIlxcblwiICtcbiAgICBcIiAgdG9vbHRpcC1jbGFzc2VzXFxuXCIgK1xuICAgIFwiICBuZy1jbGFzcz1cXFwieyBpbjogaXNPcGVuKCkgfVxcXCI+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJhcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiXFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWlubmVyXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8aDMgY2xhc3M9XFxcInBvcG92ZXItdGl0bGVcXFwiIG5nLWJpbmQ9XFxcInRpdGxlXFxcIiBuZy1pZj1cXFwidGl0bGVcXFwiPjwvaDM+XFxuXCIgK1xuICAgIFwiICAgICAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1jb250ZW50XFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgdG9vbHRpcC10ZW1wbGF0ZS10cmFuc2NsdWRlPVxcXCJjb250ZW50RXhwKClcXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICB0b29sdGlwLXRlbXBsYXRlLXRyYW5zY2x1ZGUtc2NvcGU9XFxcIm9yaWdpblNjb3BlKClcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgPC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInBvcG92ZXJcXFwiXFxuXCIgK1xuICAgIFwiICB0b29sdGlwLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXG5cIiArXG4gICAgXCIgIHRvb2x0aXAtY2xhc3Nlc1xcblwiICtcbiAgICBcIiAgbmctY2xhc3M9XFxcInsgaW46IGlzT3BlbigpIH1cXFwiPlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwiYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1pbm5lclxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPGgzIGNsYXNzPVxcXCJwb3BvdmVyLXRpdGxlXFxcIiBuZy1iaW5kPVxcXCJ0aXRsZVxcXCIgbmctaWY9XFxcInRpdGxlXFxcIj48L2gzPlxcblwiICtcbiAgICBcIiAgICAgIDxkaXYgY2xhc3M9XFxcInBvcG92ZXItY29udGVudFxcXCIgbmctYmluZD1cXFwiY29udGVudFxcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiICA8L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwicHJvZ3Jlc3MtYmFyXFxcIiBuZy1jbGFzcz1cXFwidHlwZSAmJiAncHJvZ3Jlc3MtYmFyLScgKyB0eXBlXFxcIiByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgYXJpYS12YWx1ZW5vdz1cXFwie3t2YWx1ZX19XFxcIiBhcmlhLXZhbHVlbWluPVxcXCIwXFxcIiBhcmlhLXZhbHVlbWF4PVxcXCJ7e21heH19XFxcIiBuZy1zdHlsZT1cXFwie3dpZHRoOiAocGVyY2VudCA8IDEwMCA/IHBlcmNlbnQgOiAxMDApICsgJyUnfVxcXCIgYXJpYS12YWx1ZXRleHQ9XFxcInt7cGVyY2VudCB8IG51bWJlcjowfX0lXFxcIiBzdHlsZT1cXFwibWluLXdpZHRoOiAwO1xcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInByb2dyZXNzXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwicHJvZ3Jlc3NcXFwiPlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwicHJvZ3Jlc3MtYmFyXFxcIiBuZy1jbGFzcz1cXFwidHlwZSAmJiAncHJvZ3Jlc3MtYmFyLScgKyB0eXBlXFxcIiByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgYXJpYS12YWx1ZW5vdz1cXFwie3t2YWx1ZX19XFxcIiBhcmlhLXZhbHVlbWluPVxcXCIwXFxcIiBhcmlhLXZhbHVlbWF4PVxcXCJ7e21heH19XFxcIiBuZy1zdHlsZT1cXFwie3dpZHRoOiAocGVyY2VudCA8IDEwMCA/IHBlcmNlbnQgOiAxMDApICsgJyUnfVxcXCIgYXJpYS12YWx1ZXRleHQ9XFxcInt7cGVyY2VudCB8IG51bWJlcjowfX0lXFxcIiBzdHlsZT1cXFwibWluLXdpZHRoOiAwO1xcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sXCIsXG4gICAgXCI8c3BhbiBuZy1tb3VzZWxlYXZlPVxcXCJyZXNldCgpXFxcIiBuZy1rZXlkb3duPVxcXCJvbktleWRvd24oJGV2ZW50KVxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiIHJvbGU9XFxcInNsaWRlclxcXCIgYXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgYXJpYS12YWx1ZW1heD1cXFwie3tyYW5nZS5sZW5ndGh9fVxcXCIgYXJpYS12YWx1ZW5vdz1cXFwie3t2YWx1ZX19XFxcIj5cXG5cIiArXG4gICAgXCIgICAgPHNwYW4gbmctcmVwZWF0LXN0YXJ0PVxcXCJyIGluIHJhbmdlIHRyYWNrIGJ5ICRpbmRleFxcXCIgY2xhc3M9XFxcInNyLW9ubHlcXFwiPih7eyAkaW5kZXggPCB2YWx1ZSA/ICcqJyA6ICcgJyB9fSk8L3NwYW4+XFxuXCIgK1xuICAgIFwiICAgIDxpIG5nLXJlcGVhdC1lbmQgbmctbW91c2VlbnRlcj1cXFwiZW50ZXIoJGluZGV4ICsgMSlcXFwiIG5nLWNsaWNrPVxcXCJyYXRlKCRpbmRleCArIDEpXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uXFxcIiBuZy1jbGFzcz1cXFwiJGluZGV4IDwgdmFsdWUgJiYgKHIuc3RhdGVPbiB8fCAnZ2x5cGhpY29uLXN0YXInKSB8fCAoci5zdGF0ZU9mZiB8fCAnZ2x5cGhpY29uLXN0YXItZW1wdHknKVxcXCIgbmctYXR0ci10aXRsZT1cXFwie3tyLnRpdGxlfX1cXFwiID48L2k+XFxuXCIgK1xuICAgIFwiPC9zcGFuPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90YWJzL3RhYi5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvdGFicy90YWIuaHRtbFwiLFxuICAgIFwiPGxpIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBhY3RpdmUsIGRpc2FibGVkOiBkaXNhYmxlZH1cXFwiPlxcblwiICtcbiAgICBcIiAgPGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0KClcXFwiIHRhYi1oZWFkaW5nLXRyYW5zY2x1ZGU+e3toZWFkaW5nfX08L2E+XFxuXCIgK1xuICAgIFwiPC9saT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3RhYnMvdGFic2V0Lmh0bWxcIixcbiAgICBcIjxkaXY+XFxuXCIgK1xuICAgIFwiICA8dWwgY2xhc3M9XFxcIm5hdiBuYXYte3t0eXBlIHx8ICd0YWJzJ319XFxcIiBuZy1jbGFzcz1cXFwieyduYXYtc3RhY2tlZCc6IHZlcnRpY2FsLCAnbmF2LWp1c3RpZmllZCc6IGp1c3RpZmllZH1cXFwiIG5nLXRyYW5zY2x1ZGU+PC91bD5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50XFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwidGFiLXBhbmVcXFwiIFxcblwiICtcbiAgICBcIiAgICAgICAgIG5nLXJlcGVhdD1cXFwidGFiIGluIHRhYnNcXFwiIFxcblwiICtcbiAgICBcIiAgICAgICAgIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiB0YWIuYWN0aXZlfVxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICB0YWItY29udGVudC10cmFuc2NsdWRlPVxcXCJ0YWJcXFwiPlxcblwiICtcbiAgICBcIiAgICA8L2Rpdj5cXG5cIiArXG4gICAgXCIgIDwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3RpbWVwaWNrZXIvdGltZXBpY2tlci5odG1sXCIsXG4gICAgXCI8dGFibGU+XFxuXCIgK1xuICAgIFwiICA8dGJvZHk+XFxuXCIgK1xuICAgIFwiICAgIDx0ciBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiIG5nLXNob3c9XFxcIjo6c2hvd1NwaW5uZXJzXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8dGQ+PGEgbmctY2xpY2s9XFxcImluY3JlbWVudEhvdXJzKClcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vSW5jcmVtZW50SG91cnMoKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tdXBcXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQ+Jm5ic3A7PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQ+PGEgbmctY2xpY2s9XFxcImluY3JlbWVudE1pbnV0ZXMoKVxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9JbmNyZW1lbnRNaW51dGVzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXVwXFxcIj48L3NwYW4+PC9hPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dNZXJpZGlhblxcXCI+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgICAgPHRyPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCIgbmctY2xhc3M9XFxcInsnaGFzLWVycm9yJzogaW52YWxpZEhvdXJzfVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8aW5wdXQgc3R5bGU9XFxcIndpZHRoOjUwcHg7XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwiaG91cnNcXFwiIG5nLWNoYW5nZT1cXFwidXBkYXRlSG91cnMoKVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCB0ZXh0LWNlbnRlclxcXCIgbmctcmVhZG9ubHk9XFxcIjo6cmVhZG9ubHlJbnB1dFxcXCIgbWF4bGVuZ3RoPVxcXCIyXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZD46PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiIG5nLWNsYXNzPVxcXCJ7J2hhcy1lcnJvcic6IGludmFsaWRNaW51dGVzfVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8aW5wdXQgc3R5bGU9XFxcIndpZHRoOjUwcHg7XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwibWludXRlc1xcXCIgbmctY2hhbmdlPVxcXCJ1cGRhdGVNaW51dGVzKClcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgdGV4dC1jZW50ZXJcXFwiIG5nLXJlYWRvbmx5PVxcXCI6OnJlYWRvbmx5SW5wdXRcXFwiIG1heGxlbmd0aD1cXFwiMlxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctc2hvdz1cXFwic2hvd01lcmlkaWFuXFxcIj48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9Ub2dnbGVNZXJpZGlhbigpfVxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCB0ZXh0LWNlbnRlclxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU1lcmlkaWFuKClcXFwiPnt7bWVyaWRpYW59fTwvYnV0dG9uPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICAgIDx0ciBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiIG5nLXNob3c9XFxcIjo6c2hvd1NwaW5uZXJzXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8dGQ+PGEgbmctY2xpY2s9XFxcImRlY3JlbWVudEhvdXJzKClcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vRGVjcmVtZW50SG91cnMoKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tZG93blxcXCI+PC9zcGFuPjwvYT48L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZD4mbmJzcDs8L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZD48YSBuZy1jbGljaz1cXFwiZGVjcmVtZW50TWludXRlcygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0RlY3JlbWVudE1pbnV0ZXMoKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tZG93blxcXCI+PC9zcGFuPjwvYT48L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93TWVyaWRpYW5cXFwiPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICA8L3Rib2R5PlxcblwiICtcbiAgICBcIjwvdGFibGU+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbFwiLFxuICAgIFwiPGEgaHJlZiB0YWJpbmRleD1cXFwiLTFcXFwiIG5nLWJpbmQtaHRtbD1cXFwibWF0Y2gubGFiZWwgfCB0eXBlYWhlYWRIaWdobGlnaHQ6cXVlcnlcXFwiPjwvYT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1wb3B1cC5odG1sXCIsXG4gICAgXCI8dWwgY2xhc3M9XFxcImRyb3Bkb3duLW1lbnVcXFwiIG5nLXNob3c9XFxcImlzT3BlbigpICYmICFtb3ZlSW5Qcm9ncmVzc1xcXCIgbmctc3R5bGU9XFxcInt0b3A6IHBvc2l0aW9uKCkudG9wKydweCcsIGxlZnQ6IHBvc2l0aW9uKCkubGVmdCsncHgnfVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IGJsb2NrO1xcXCIgcm9sZT1cXFwibGlzdGJveFxcXCIgYXJpYS1oaWRkZW49XFxcInt7IWlzT3BlbigpfX1cXFwiPlxcblwiICtcbiAgICBcIiAgICA8bGkgbmctcmVwZWF0PVxcXCJtYXRjaCBpbiBtYXRjaGVzIHRyYWNrIGJ5ICRpbmRleFxcXCIgbmctY2xhc3M9XFxcInthY3RpdmU6IGlzQWN0aXZlKCRpbmRleCkgfVxcXCIgbmctbW91c2VlbnRlcj1cXFwic2VsZWN0QWN0aXZlKCRpbmRleClcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3RNYXRjaCgkaW5kZXgpXFxcIiByb2xlPVxcXCJvcHRpb25cXFwiIGlkPVxcXCJ7ezo6bWF0Y2guaWR9fVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8ZGl2IHR5cGVhaGVhZC1tYXRjaCBpbmRleD1cXFwiJGluZGV4XFxcIiBtYXRjaD1cXFwibWF0Y2hcXFwiIHF1ZXJ5PVxcXCJxdWVyeVxcXCIgdGVtcGxhdGUtdXJsPVxcXCJ0ZW1wbGF0ZVVybFxcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiICAgIDwvbGk+XFxuXCIgK1xuICAgIFwiPC91bD5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG4hYW5ndWxhci4kJGNzcCgpICYmIGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudCkuZmluZCgnaGVhZCcpLnByZXBlbmQoJzxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj4ubmctYW5pbWF0ZS5pdGVtOm5vdCgubGVmdCk6bm90KC5yaWdodCl7LXdlYmtpdC10cmFuc2l0aW9uOjBzIGVhc2UtaW4tb3V0IGxlZnQ7dHJhbnNpdGlvbjowcyBlYXNlLWluLW91dCBsZWZ0fTwvc3R5bGU+Jyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYW5ndWxhci11aS1ib290c3RyYXAvdWktYm9vdHN0cmFwLXRwbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL2FuZ3VsYXItc2FuaXRpemUnKTtcbm1vZHVsZS5leHBvcnRzID0gJ25nU2FuaXRpemUnO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYW5ndWxhci1zYW5pdGl6ZS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhckpTIHYxLjQuN1xuICogKGMpIDIwMTAtMjAxNSBHb29nbGUsIEluYy4gaHR0cDovL2FuZ3VsYXJqcy5vcmdcbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24od2luZG93LCBhbmd1bGFyLCB1bmRlZmluZWQpIHsndXNlIHN0cmljdCc7XG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICBBbnkgY29tbWl0cyB0byB0aGlzIGZpbGUgc2hvdWxkIGJlIHJldmlld2VkIHdpdGggc2VjdXJpdHkgaW4gbWluZC4gICpcbiAqICAgQ2hhbmdlcyB0byB0aGlzIGZpbGUgY2FuIHBvdGVudGlhbGx5IGNyZWF0ZSBzZWN1cml0eSB2dWxuZXJhYmlsaXRpZXMuICpcbiAqICAgICAgICAgIEFuIGFwcHJvdmFsIGZyb20gMiBDb3JlIG1lbWJlcnMgd2l0aCBoaXN0b3J5IG9mIG1vZGlmeWluZyAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgZmlsZSBpcyByZXF1aXJlZC4gICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICBEb2VzIHRoZSBjaGFuZ2Ugc29tZWhvdyBhbGxvdyBmb3IgYXJiaXRyYXJ5IGphdmFzY3JpcHQgdG8gYmUgZXhlY3V0ZWQ/ICpcbiAqICAgIE9yIGFsbG93cyBmb3Igc29tZW9uZSB0byBjaGFuZ2UgdGhlIHByb3RvdHlwZSBvZiBidWlsdC1pbiBvYmplY3RzPyAgICpcbiAqICAgICBPciBnaXZlcyB1bmRlc2lyZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyBsaWtlcyBkb2N1bWVudCBvciB3aW5kb3c/ICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbnZhciAkc2FuaXRpemVNaW5FcnIgPSBhbmd1bGFyLiQkbWluRXJyKCckc2FuaXRpemUnKTtcblxuLyoqXG4gKiBAbmdkb2MgbW9kdWxlXG4gKiBAbmFtZSBuZ1Nhbml0aXplXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiAjIG5nU2FuaXRpemVcbiAqXG4gKiBUaGUgYG5nU2FuaXRpemVgIG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IHRvIHNhbml0aXplIEhUTUwuXG4gKlxuICpcbiAqIDxkaXYgZG9jLW1vZHVsZS1jb21wb25lbnRzPVwibmdTYW5pdGl6ZVwiPjwvZGl2PlxuICpcbiAqIFNlZSB7QGxpbmsgbmdTYW5pdGl6ZS4kc2FuaXRpemUgYCRzYW5pdGl6ZWB9IGZvciB1c2FnZS5cbiAqL1xuXG4vKlxuICogSFRNTCBQYXJzZXIgQnkgTWlza28gSGV2ZXJ5IChtaXNrb0BoZXZlcnkuY29tKVxuICogYmFzZWQgb246ICBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBPcmlnaW5hbCBjb2RlIGJ5IEVyaWsgQXJ2aWRzc29uLCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlXG4gKiBodHRwOi8vZXJpay5lYWUubmV0L3NpbXBsZWh0bWxwYXJzZXIvc2ltcGxlaHRtbHBhcnNlci5qc1xuICpcbiAqIC8vIFVzZSBsaWtlIHNvOlxuICogaHRtbFBhcnNlcihodG1sU3RyaW5nLCB7XG4gKiAgICAgc3RhcnQ6IGZ1bmN0aW9uKHRhZywgYXR0cnMsIHVuYXJ5KSB7fSxcbiAqICAgICBlbmQ6IGZ1bmN0aW9uKHRhZykge30sXG4gKiAgICAgY2hhcnM6IGZ1bmN0aW9uKHRleHQpIHt9LFxuICogICAgIGNvbW1lbnQ6IGZ1bmN0aW9uKHRleHQpIHt9XG4gKiB9KTtcbiAqXG4gKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkc2FuaXRpemVcbiAqIEBraW5kIGZ1bmN0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFRoZSBpbnB1dCBpcyBzYW5pdGl6ZWQgYnkgcGFyc2luZyB0aGUgSFRNTCBpbnRvIHRva2Vucy4gQWxsIHNhZmUgdG9rZW5zIChmcm9tIGEgd2hpdGVsaXN0KSBhcmVcbiAqICAgdGhlbiBzZXJpYWxpemVkIGJhY2sgdG8gcHJvcGVybHkgZXNjYXBlZCBodG1sIHN0cmluZy4gVGhpcyBtZWFucyB0aGF0IG5vIHVuc2FmZSBpbnB1dCBjYW4gbWFrZVxuICogICBpdCBpbnRvIHRoZSByZXR1cm5lZCBzdHJpbmcsIGhvd2V2ZXIsIHNpbmNlIG91ciBwYXJzZXIgaXMgbW9yZSBzdHJpY3QgdGhhbiBhIHR5cGljYWwgYnJvd3NlclxuICogICBwYXJzZXIsIGl0J3MgcG9zc2libGUgdGhhdCBzb21lIG9ic2N1cmUgaW5wdXQsIHdoaWNoIHdvdWxkIGJlIHJlY29nbml6ZWQgYXMgdmFsaWQgSFRNTCBieSBhXG4gKiAgIGJyb3dzZXIsIHdvbid0IG1ha2UgaXQgdGhyb3VnaCB0aGUgc2FuaXRpemVyLiBUaGUgaW5wdXQgbWF5IGFsc28gY29udGFpbiBTVkcgbWFya3VwLlxuICogICBUaGUgd2hpdGVsaXN0IGlzIGNvbmZpZ3VyZWQgdXNpbmcgdGhlIGZ1bmN0aW9ucyBgYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3RgIGFuZFxuICogICBgaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0YCBvZiB7QGxpbmsgbmcuJGNvbXBpbGVQcm92aWRlciBgJGNvbXBpbGVQcm92aWRlcmB9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIEhUTUwgaW5wdXQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTYW5pdGl6ZWQgSFRNTC5cbiAqXG4gKiBAZXhhbXBsZVxuICAgPGV4YW1wbGUgbW9kdWxlPVwic2FuaXRpemVFeGFtcGxlXCIgZGVwcz1cImFuZ3VsYXItc2FuaXRpemUuanNcIj5cbiAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgIDxzY3JpcHQ+XG4gICAgICAgICBhbmd1bGFyLm1vZHVsZSgnc2FuaXRpemVFeGFtcGxlJywgWyduZ1Nhbml0aXplJ10pXG4gICAgICAgICAgIC5jb250cm9sbGVyKCdFeGFtcGxlQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRzY2UnLCBmdW5jdGlvbigkc2NvcGUsICRzY2UpIHtcbiAgICAgICAgICAgICAkc2NvcGUuc25pcHBldCA9XG4gICAgICAgICAgICAgICAnPHAgc3R5bGU9XCJjb2xvcjpibHVlXCI+YW4gaHRtbFxcbicgK1xuICAgICAgICAgICAgICAgJzxlbSBvbm1vdXNlb3Zlcj1cInRoaXMudGV4dENvbnRlbnQ9XFwnUFdOM0QhXFwnXCI+Y2xpY2sgaGVyZTwvZW0+XFxuJyArXG4gICAgICAgICAgICAgICAnc25pcHBldDwvcD4nO1xuICAgICAgICAgICAgICRzY29wZS5kZWxpYmVyYXRlbHlUcnVzdERhbmdlcm91c1NuaXBwZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgIHJldHVybiAkc2NlLnRydXN0QXNIdG1sKCRzY29wZS5zbmlwcGV0KTtcbiAgICAgICAgICAgICB9O1xuICAgICAgICAgICB9XSk7XG4gICAgIDwvc2NyaXB0PlxuICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJFeGFtcGxlQ29udHJvbGxlclwiPlxuICAgICAgICBTbmlwcGV0OiA8dGV4dGFyZWEgbmctbW9kZWw9XCJzbmlwcGV0XCIgY29scz1cIjYwXCIgcm93cz1cIjNcIj48L3RleHRhcmVhPlxuICAgICAgIDx0YWJsZT5cbiAgICAgICAgIDx0cj5cbiAgICAgICAgICAgPHRkPkRpcmVjdGl2ZTwvdGQ+XG4gICAgICAgICAgIDx0ZD5Ib3c8L3RkPlxuICAgICAgICAgICA8dGQ+U291cmNlPC90ZD5cbiAgICAgICAgICAgPHRkPlJlbmRlcmVkPC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJiaW5kLWh0bWwtd2l0aC1zYW5pdGl6ZVwiPlxuICAgICAgICAgICA8dGQ+bmctYmluZC1odG1sPC90ZD5cbiAgICAgICAgICAgPHRkPkF1dG9tYXRpY2FsbHkgdXNlcyAkc2FuaXRpemU8L3RkPlxuICAgICAgICAgICA8dGQ+PHByZT4mbHQ7ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRcIiZndDs8YnIvPiZsdDsvZGl2Jmd0OzwvcHJlPjwvdGQ+XG4gICAgICAgICAgIDx0ZD48ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRcIj48L2Rpdj48L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICAgIDx0ciBpZD1cImJpbmQtaHRtbC13aXRoLXRydXN0XCI+XG4gICAgICAgICAgIDx0ZD5uZy1iaW5kLWh0bWw8L3RkPlxuICAgICAgICAgICA8dGQ+QnlwYXNzICRzYW5pdGl6ZSBieSBleHBsaWNpdGx5IHRydXN0aW5nIHRoZSBkYW5nZXJvdXMgdmFsdWU8L3RkPlxuICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgIDxwcmU+Jmx0O2RpdiBuZy1iaW5kLWh0bWw9XCJkZWxpYmVyYXRlbHlUcnVzdERhbmdlcm91c1NuaXBwZXQoKVwiJmd0O1xuJmx0Oy9kaXYmZ3Q7PC9wcmU+XG4gICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgIDx0ZD48ZGl2IG5nLWJpbmQtaHRtbD1cImRlbGliZXJhdGVseVRydXN0RGFuZ2Vyb3VzU25pcHBldCgpXCI+PC9kaXY+PC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJiaW5kLWRlZmF1bHRcIj5cbiAgICAgICAgICAgPHRkPm5nLWJpbmQ8L3RkPlxuICAgICAgICAgICA8dGQ+QXV0b21hdGljYWxseSBlc2NhcGVzPC90ZD5cbiAgICAgICAgICAgPHRkPjxwcmU+Jmx0O2RpdiBuZy1iaW5kPVwic25pcHBldFwiJmd0Ozxici8+Jmx0Oy9kaXYmZ3Q7PC9wcmU+PC90ZD5cbiAgICAgICAgICAgPHRkPjxkaXYgbmctYmluZD1cInNuaXBwZXRcIj48L2Rpdj48L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICA8L3RhYmxlPlxuICAgICAgIDwvZGl2PlxuICAgPC9maWxlPlxuICAgPGZpbGUgbmFtZT1cInByb3RyYWN0b3IuanNcIiB0eXBlPVwicHJvdHJhY3RvclwiPlxuICAgICBpdCgnc2hvdWxkIHNhbml0aXplIHRoZSBodG1sIHNuaXBwZXQgYnkgZGVmYXVsdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtaHRtbC13aXRoLXNhbml0aXplIGRpdicpKS5nZXRJbm5lckh0bWwoKSkuXG4gICAgICAgICB0b0JlKCc8cD5hbiBodG1sXFxuPGVtPmNsaWNrIGhlcmU8L2VtPlxcbnNuaXBwZXQ8L3A+Jyk7XG4gICAgIH0pO1xuXG4gICAgIGl0KCdzaG91bGQgaW5saW5lIHJhdyBzbmlwcGV0IGlmIGJvdW5kIHRvIGEgdHJ1c3RlZCB2YWx1ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtaHRtbC13aXRoLXRydXN0IGRpdicpKS5nZXRJbm5lckh0bWwoKSkuXG4gICAgICAgICB0b0JlKFwiPHAgc3R5bGU9XFxcImNvbG9yOmJsdWVcXFwiPmFuIGh0bWxcXG5cIiArXG4gICAgICAgICAgICAgIFwiPGVtIG9ubW91c2VvdmVyPVxcXCJ0aGlzLnRleHRDb250ZW50PSdQV04zRCEnXFxcIj5jbGljayBoZXJlPC9lbT5cXG5cIiArXG4gICAgICAgICAgICAgIFwic25pcHBldDwvcD5cIik7XG4gICAgIH0pO1xuXG4gICAgIGl0KCdzaG91bGQgZXNjYXBlIHNuaXBwZXQgd2l0aG91dCBhbnkgZmlsdGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjYmluZC1kZWZhdWx0IGRpdicpKS5nZXRJbm5lckh0bWwoKSkuXG4gICAgICAgICB0b0JlKFwiJmx0O3Agc3R5bGU9XFxcImNvbG9yOmJsdWVcXFwiJmd0O2FuIGh0bWxcXG5cIiArXG4gICAgICAgICAgICAgIFwiJmx0O2VtIG9ubW91c2VvdmVyPVxcXCJ0aGlzLnRleHRDb250ZW50PSdQV04zRCEnXFxcIiZndDtjbGljayBoZXJlJmx0Oy9lbSZndDtcXG5cIiArXG4gICAgICAgICAgICAgIFwic25pcHBldCZsdDsvcCZndDtcIik7XG4gICAgIH0pO1xuXG4gICAgIGl0KCdzaG91bGQgdXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgZWxlbWVudChieS5tb2RlbCgnc25pcHBldCcpKS5jbGVhcigpO1xuICAgICAgIGVsZW1lbnQoYnkubW9kZWwoJ3NuaXBwZXQnKSkuc2VuZEtleXMoJ25ldyA8YiBvbmNsaWNrPVwiYWxlcnQoMSlcIj50ZXh0PC9iPicpO1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtaHRtbC13aXRoLXNhbml0aXplIGRpdicpKS5nZXRJbm5lckh0bWwoKSkuXG4gICAgICAgICB0b0JlKCduZXcgPGI+dGV4dDwvYj4nKTtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWh0bWwtd2l0aC10cnVzdCBkaXYnKSkuZ2V0SW5uZXJIdG1sKCkpLnRvQmUoXG4gICAgICAgICAnbmV3IDxiIG9uY2xpY2s9XCJhbGVydCgxKVwiPnRleHQ8L2I+Jyk7XG4gICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjYmluZC1kZWZhdWx0IGRpdicpKS5nZXRJbm5lckh0bWwoKSkudG9CZShcbiAgICAgICAgIFwibmV3ICZsdDtiIG9uY2xpY2s9XFxcImFsZXJ0KDEpXFxcIiZndDt0ZXh0Jmx0Oy9iJmd0O1wiKTtcbiAgICAgfSk7XG4gICA8L2ZpbGU+XG4gICA8L2V4YW1wbGU+XG4gKi9cbmZ1bmN0aW9uICRTYW5pdGl6ZVByb3ZpZGVyKCkge1xuICB0aGlzLiRnZXQgPSBbJyQkc2FuaXRpemVVcmknLCBmdW5jdGlvbigkJHNhbml0aXplVXJpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgIHZhciBidWYgPSBbXTtcbiAgICAgIGh0bWxQYXJzZXIoaHRtbCwgaHRtbFNhbml0aXplV3JpdGVyKGJ1ZiwgZnVuY3Rpb24odXJpLCBpc0ltYWdlKSB7XG4gICAgICAgIHJldHVybiAhL151bnNhZmUvLnRlc3QoJCRzYW5pdGl6ZVVyaSh1cmksIGlzSW1hZ2UpKTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBidWYuam9pbignJyk7XG4gICAgfTtcbiAgfV07XG59XG5cbmZ1bmN0aW9uIHNhbml0aXplVGV4dChjaGFycykge1xuICB2YXIgYnVmID0gW107XG4gIHZhciB3cml0ZXIgPSBodG1sU2FuaXRpemVXcml0ZXIoYnVmLCBhbmd1bGFyLm5vb3ApO1xuICB3cml0ZXIuY2hhcnMoY2hhcnMpO1xuICByZXR1cm4gYnVmLmpvaW4oJycpO1xufVxuXG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xudmFyIFNUQVJUX1RBR19SRUdFWFAgPVxuICAgICAgIC9ePCgoPzpbYS16QS1aXSlbXFx3Oi1dKikoKD86XFxzK1tcXHc6LV0rKD86XFxzKj1cXHMqKD86KD86XCJbXlwiXSpcIil8KD86J1teJ10qJyl8W14+XFxzXSspKT8pKilcXHMqKFxcLz8pXFxzKig+PykvLFxuICBFTkRfVEFHX1JFR0VYUCA9IC9ePFxcL1xccyooW1xcdzotXSspW14+XSo+LyxcbiAgQVRUUl9SRUdFWFAgPSAvKFtcXHc6LV0rKSg/Olxccyo9XFxzKig/Oig/OlwiKCg/OlteXCJdKSopXCIpfCg/OicoKD86W14nXSkqKScpfChbXj5cXHNdKykpKT8vZyxcbiAgQkVHSU5fVEFHX1JFR0VYUCA9IC9ePC8sXG4gIEJFR0lOR19FTkRfVEFHRV9SRUdFWFAgPSAvXjxcXC8vLFxuICBDT01NRU5UX1JFR0VYUCA9IC88IS0tKC4qPyktLT4vZyxcbiAgRE9DVFlQRV9SRUdFWFAgPSAvPCFET0NUWVBFKFtePl0qPyk+L2ksXG4gIENEQVRBX1JFR0VYUCA9IC88IVxcW0NEQVRBXFxbKC4qPyldXT4vZyxcbiAgU1VSUk9HQVRFX1BBSVJfUkVHRVhQID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZyxcbiAgLy8gTWF0Y2ggZXZlcnl0aGluZyBvdXRzaWRlIG9mIG5vcm1hbCBjaGFycyBhbmQgXCIgKHF1b3RlIGNoYXJhY3RlcilcbiAgTk9OX0FMUEhBTlVNRVJJQ19SRUdFWFAgPSAvKFteXFwjLX58IHwhXSkvZztcblxuXG4vLyBHb29kIHNvdXJjZSBvZiBpbmZvIGFib3V0IGVsZW1lbnRzIGFuZCBhdHRyaWJ1dGVzXG4vLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjc2VtYW50aWNzXG4vLyBodHRwOi8vc2ltb24uaHRtbDUub3JnL2h0bWwtZWxlbWVudHNcblxuLy8gU2FmZSBWb2lkIEVsZW1lbnRzIC0gSFRNTDVcbi8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCN2b2lkLWVsZW1lbnRzXG52YXIgdm9pZEVsZW1lbnRzID0gbWFrZU1hcChcImFyZWEsYnIsY29sLGhyLGltZyx3YnJcIik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlbiAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG4vLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjb3B0aW9uYWwtdGFnc1xudmFyIG9wdGlvbmFsRW5kVGFnQmxvY2tFbGVtZW50cyA9IG1ha2VNYXAoXCJjb2xncm91cCxkZCxkdCxsaSxwLHRib2R5LHRkLHRmb290LHRoLHRoZWFkLHRyXCIpLFxuICAgIG9wdGlvbmFsRW5kVGFnSW5saW5lRWxlbWVudHMgPSBtYWtlTWFwKFwicnAscnRcIiksXG4gICAgb3B0aW9uYWxFbmRUYWdFbGVtZW50cyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbEVuZFRhZ0lubGluZUVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbEVuZFRhZ0Jsb2NrRWxlbWVudHMpO1xuXG4vLyBTYWZlIEJsb2NrIEVsZW1lbnRzIC0gSFRNTDVcbnZhciBibG9ja0VsZW1lbnRzID0gYW5ndWxhci5leHRlbmQoe30sIG9wdGlvbmFsRW5kVGFnQmxvY2tFbGVtZW50cywgbWFrZU1hcChcImFkZHJlc3MsYXJ0aWNsZSxcIiArXG4gICAgICAgIFwiYXNpZGUsYmxvY2txdW90ZSxjYXB0aW9uLGNlbnRlcixkZWwsZGlyLGRpdixkbCxmaWd1cmUsZmlnY2FwdGlvbixmb290ZXIsaDEsaDIsaDMsaDQsaDUsXCIgK1xuICAgICAgICBcImg2LGhlYWRlcixoZ3JvdXAsaHIsaW5zLG1hcCxtZW51LG5hdixvbCxwcmUsc2NyaXB0LHNlY3Rpb24sdGFibGUsdWxcIikpO1xuXG4vLyBJbmxpbmUgRWxlbWVudHMgLSBIVE1MNVxudmFyIGlubGluZUVsZW1lbnRzID0gYW5ndWxhci5leHRlbmQoe30sIG9wdGlvbmFsRW5kVGFnSW5saW5lRWxlbWVudHMsIG1ha2VNYXAoXCJhLGFiYnIsYWNyb255bSxiLFwiICtcbiAgICAgICAgXCJiZGksYmRvLGJpZyxicixjaXRlLGNvZGUsZGVsLGRmbixlbSxmb250LGksaW1nLGlucyxrYmQsbGFiZWwsbWFwLG1hcmsscSxydWJ5LHJwLHJ0LHMsXCIgK1xuICAgICAgICBcInNhbXAsc21hbGwsc3BhbixzdHJpa2Usc3Ryb25nLHN1YixzdXAsdGltZSx0dCx1LHZhclwiKSk7XG5cbi8vIFNWRyBFbGVtZW50c1xuLy8gaHR0cHM6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9TYW5pdGl6YXRpb25fcnVsZXMjc3ZnX0VsZW1lbnRzXG4vLyBOb3RlOiB0aGUgZWxlbWVudHMgYW5pbWF0ZSxhbmltYXRlQ29sb3IsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLHNldCBhcmUgaW50ZW50aW9uYWxseSBvbWl0dGVkLlxuLy8gVGhleSBjYW4gcG90ZW50aWFsbHkgYWxsb3cgZm9yIGFyYml0cmFyeSBqYXZhc2NyaXB0IHRvIGJlIGV4ZWN1dGVkLiBTZWUgIzExMjkwXG52YXIgc3ZnRWxlbWVudHMgPSBtYWtlTWFwKFwiY2lyY2xlLGRlZnMsZGVzYyxlbGxpcHNlLGZvbnQtZmFjZSxmb250LWZhY2UtbmFtZSxmb250LWZhY2Utc3JjLGcsZ2x5cGgsXCIgK1xuICAgICAgICBcImhrZXJuLGltYWdlLGxpbmVhckdyYWRpZW50LGxpbmUsbWFya2VyLG1ldGFkYXRhLG1pc3NpbmctZ2x5cGgsbXBhdGgscGF0aCxwb2x5Z29uLHBvbHlsaW5lLFwiICtcbiAgICAgICAgXCJyYWRpYWxHcmFkaWVudCxyZWN0LHN0b3Asc3ZnLHN3aXRjaCx0ZXh0LHRpdGxlLHRzcGFuLHVzZVwiKTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgc3BlY2lhbEVsZW1lbnRzID0gbWFrZU1hcChcInNjcmlwdCxzdHlsZVwiKTtcblxudmFyIHZhbGlkRWxlbWVudHMgPSBhbmd1bGFyLmV4dGVuZCh7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZEVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0VsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmxpbmVFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxFbmRUYWdFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnRWxlbWVudHMpO1xuXG4vL0F0dHJpYnV0ZXMgdGhhdCBoYXZlIGhyZWYgYW5kIGhlbmNlIG5lZWQgdG8gYmUgc2FuaXRpemVkXG52YXIgdXJpQXR0cnMgPSBtYWtlTWFwKFwiYmFja2dyb3VuZCxjaXRlLGhyZWYsbG9uZ2Rlc2Msc3JjLHVzZW1hcCx4bGluazpocmVmXCIpO1xuXG52YXIgaHRtbEF0dHJzID0gbWFrZU1hcCgnYWJicixhbGlnbixhbHQsYXhpcyxiZ2NvbG9yLGJvcmRlcixjZWxscGFkZGluZyxjZWxsc3BhY2luZyxjbGFzcyxjbGVhciwnICtcbiAgICAnY29sb3IsY29scyxjb2xzcGFuLGNvbXBhY3QsY29vcmRzLGRpcixmYWNlLGhlYWRlcnMsaGVpZ2h0LGhyZWZsYW5nLGhzcGFjZSwnICtcbiAgICAnaXNtYXAsbGFuZyxsYW5ndWFnZSxub2hyZWYsbm93cmFwLHJlbCxyZXYscm93cyxyb3dzcGFuLHJ1bGVzLCcgK1xuICAgICdzY29wZSxzY3JvbGxpbmcsc2hhcGUsc2l6ZSxzcGFuLHN0YXJ0LHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHR5cGUsJyArXG4gICAgJ3ZhbGlnbix2YWx1ZSx2c3BhY2Usd2lkdGgnKTtcblxuLy8gU1ZHIGF0dHJpYnV0ZXMgKHdpdGhvdXQgXCJpZFwiIGFuZCBcIm5hbWVcIiBhdHRyaWJ1dGVzKVxuLy8gaHR0cHM6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9TYW5pdGl6YXRpb25fcnVsZXMjc3ZnX0F0dHJpYnV0ZXNcbnZhciBzdmdBdHRycyA9IG1ha2VNYXAoJ2FjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbHBoYWJldGljLGFyYWJpYy1mb3JtLGFzY2VudCwnICtcbiAgICAnYmFzZVByb2ZpbGUsYmJveCxiZWdpbixieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGNvbG9yLGNvbG9yLXJlbmRlcmluZyxjb250ZW50LCcgK1xuICAgICdjeCxjeSxkLGR4LGR5LGRlc2NlbnQsZGlzcGxheSxkdXIsZW5kLGZpbGwsZmlsbC1ydWxlLGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXN0cmV0Y2gsJyArXG4gICAgJ2ZvbnQtc3R5bGUsZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZyb20sZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxncmFkaWVudFVuaXRzLGhhbmdpbmcsJyArXG4gICAgJ2hlaWdodCxob3Jpei1hZHYteCxob3Jpei1vcmlnaW4teCxpZGVvZ3JhcGhpYyxrLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGxhbmcsJyArXG4gICAgJ21hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLG1hdGhlbWF0aWNhbCwnICtcbiAgICAnbWF4LG1pbixvZmZzZXQsb3BhY2l0eSxvcmllbnQsb3JpZ2luLG92ZXJsaW5lLXBvc2l0aW9uLG92ZXJsaW5lLXRoaWNrbmVzcyxwYW5vc2UtMSwnICtcbiAgICAncGF0aCxwYXRoTGVuZ3RoLHBvaW50cyxwcmVzZXJ2ZUFzcGVjdFJhdGlvLHIscmVmWCxyZWZZLHJlcGVhdENvdW50LHJlcGVhdER1ciwnICtcbiAgICAncmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMscmVzdGFydCxyb3RhdGUscngscnksc2xvcGUsc3RlbWgsc3RlbXYsc3RvcC1jb2xvciwnICtcbiAgICAnc3RvcC1vcGFjaXR5LHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3Ryb2tlLHN0cm9rZS1kYXNoYXJyYXksJyArXG4gICAgJ3N0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSwnICtcbiAgICAnc3Ryb2tlLXdpZHRoLHN5c3RlbUxhbmd1YWdlLHRhcmdldCx0ZXh0LWFuY2hvcix0byx0cmFuc2Zvcm0sdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sJyArXG4gICAgJ3VuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2YWx1ZXMsdmVyc2lvbix2aWV3Qm94LHZpc2liaWxpdHksJyArXG4gICAgJ3dpZHRoLHdpZHRocyx4LHgtaGVpZ2h0LHgxLHgyLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSx4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUsJyArXG4gICAgJ3hsaW5rOnR5cGUseG1sOmJhc2UseG1sOmxhbmcseG1sOnNwYWNlLHhtbG5zLHhtbG5zOnhsaW5rLHkseTEseTIsem9vbUFuZFBhbicsIHRydWUpO1xuXG52YXIgdmFsaWRBdHRycyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmlBdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnQXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxBdHRycyk7XG5cbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBsb3dlcmNhc2VLZXlzKSB7XG4gIHZhciBvYmogPSB7fSwgaXRlbXMgPSBzdHIuc3BsaXQoJywnKSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgb2JqW2xvd2VyY2FzZUtleXMgPyBhbmd1bGFyLmxvd2VyY2FzZShpdGVtc1tpXSkgOiBpdGVtc1tpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cblxuLyoqXG4gKiBAZXhhbXBsZVxuICogaHRtbFBhcnNlcihodG1sU3RyaW5nLCB7XG4gKiAgICAgc3RhcnQ6IGZ1bmN0aW9uKHRhZywgYXR0cnMsIHVuYXJ5KSB7fSxcbiAqICAgICBlbmQ6IGZ1bmN0aW9uKHRhZykge30sXG4gKiAgICAgY2hhcnM6IGZ1bmN0aW9uKHRleHQpIHt9LFxuICogICAgIGNvbW1lbnQ6IGZ1bmN0aW9uKHRleHQpIHt9XG4gKiB9KTtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbCBzdHJpbmdcbiAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIGh0bWxQYXJzZXIoaHRtbCwgaGFuZGxlcikge1xuICBpZiAodHlwZW9mIGh0bWwgIT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGh0bWwgPT09IG51bGwgfHwgdHlwZW9mIGh0bWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBodG1sID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh0bWwgPSAnJyArIGh0bWw7XG4gICAgfVxuICB9XG4gIHZhciBpbmRleCwgY2hhcnMsIG1hdGNoLCBzdGFjayA9IFtdLCBsYXN0ID0gaHRtbCwgdGV4dDtcbiAgc3RhY2subGFzdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07IH07XG5cbiAgd2hpbGUgKGh0bWwpIHtcbiAgICB0ZXh0ID0gJyc7XG4gICAgY2hhcnMgPSB0cnVlO1xuXG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHNjcmlwdCBvciBzdHlsZSBlbGVtZW50XG4gICAgaWYgKCFzdGFjay5sYXN0KCkgfHwgIXNwZWNpYWxFbGVtZW50c1tzdGFjay5sYXN0KCldKSB7XG5cbiAgICAgIC8vIENvbW1lbnRcbiAgICAgIGlmIChodG1sLmluZGV4T2YoXCI8IS0tXCIpID09PSAwKSB7XG4gICAgICAgIC8vIGNvbW1lbnRzIGNvbnRhaW5pbmcgLS0gYXJlIG5vdCBhbGxvd2VkIHVubGVzcyB0aGV5IHRlcm1pbmF0ZSB0aGUgY29tbWVudFxuICAgICAgICBpbmRleCA9IGh0bWwuaW5kZXhPZihcIi0tXCIsIDQpO1xuXG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGh0bWwubGFzdEluZGV4T2YoXCItLT5cIiwgaW5kZXgpID09PSBpbmRleCkge1xuICAgICAgICAgIGlmIChoYW5kbGVyLmNvbW1lbnQpIGhhbmRsZXIuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBpbmRleCkpO1xuICAgICAgICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhpbmRleCArIDMpO1xuICAgICAgICAgIGNoYXJzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIC8vIERPQ1RZUEVcbiAgICAgIH0gZWxzZSBpZiAoRE9DVFlQRV9SRUdFWFAudGVzdChodG1sKSkge1xuICAgICAgICBtYXRjaCA9IGh0bWwubWF0Y2goRE9DVFlQRV9SRUdFWFApO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UobWF0Y2hbMF0sICcnKTtcbiAgICAgICAgICBjaGFycyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAvLyBlbmQgdGFnXG4gICAgICB9IGVsc2UgaWYgKEJFR0lOR19FTkRfVEFHRV9SRUdFWFAudGVzdChodG1sKSkge1xuICAgICAgICBtYXRjaCA9IGh0bWwubWF0Y2goRU5EX1RBR19SRUdFWFApO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2UoRU5EX1RBR19SRUdFWFAsIHBhcnNlRW5kVGFnKTtcbiAgICAgICAgICBjaGFycyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIC8vIHN0YXJ0IHRhZ1xuICAgICAgfSBlbHNlIGlmIChCRUdJTl9UQUdfUkVHRVhQLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgbWF0Y2ggPSBodG1sLm1hdGNoKFNUQVJUX1RBR19SRUdFWFApO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIC8vIFdlIG9ubHkgaGF2ZSBhIHZhbGlkIHN0YXJ0LXRhZyBpZiB0aGVyZSBpcyBhICc+Jy5cbiAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShTVEFSVF9UQUdfUkVHRVhQLCBwYXJzZVN0YXJ0VGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhcnMgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBlbmRpbmcgdGFnIGZvdW5kIC0tLSB0aGlzIHBpZWNlIHNob3VsZCBiZSBlbmNvZGVkIGFzIGFuIGVudGl0eS5cbiAgICAgICAgICB0ZXh0ICs9ICc8JztcbiAgICAgICAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXJzKSB7XG4gICAgICAgIGluZGV4ID0gaHRtbC5pbmRleE9mKFwiPFwiKTtcblxuICAgICAgICB0ZXh0ICs9IGluZGV4IDwgMCA/IGh0bWwgOiBodG1sLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgIGh0bWwgPSBpbmRleCA8IDAgPyBcIlwiIDogaHRtbC5zdWJzdHJpbmcoaW5kZXgpO1xuXG4gICAgICAgIGlmIChoYW5kbGVyLmNoYXJzKSBoYW5kbGVyLmNoYXJzKGRlY29kZUVudGl0aWVzKHRleHQpKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSB2ZXJzaW9ucyA5IGFuZCAxMCBkbyBub3QgdW5kZXJzdGFuZCB0aGUgcmVnZXggJ1teXScsIHNvIHVzaW5nIGEgd29ya2Fyb3VuZCB3aXRoIFtcXFdcXHddLlxuICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZShuZXcgUmVnRXhwKFwiKFtcXFxcV1xcXFx3XSopPFxcXFxzKlxcXFwvXFxcXHMqXCIgKyBzdGFjay5sYXN0KCkgKyBcIltePl0qPlwiLCAnaScpLFxuICAgICAgICBmdW5jdGlvbihhbGwsIHRleHQpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKENPTU1FTlRfUkVHRVhQLCBcIiQxXCIpLnJlcGxhY2UoQ0RBVEFfUkVHRVhQLCBcIiQxXCIpO1xuXG4gICAgICAgICAgaWYgKGhhbmRsZXIuY2hhcnMpIGhhbmRsZXIuY2hhcnMoZGVjb2RlRW50aXRpZXModGV4dCkpO1xuXG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9KTtcblxuICAgICAgcGFyc2VFbmRUYWcoXCJcIiwgc3RhY2subGFzdCgpKTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PSBsYXN0KSB7XG4gICAgICB0aHJvdyAkc2FuaXRpemVNaW5FcnIoJ2JhZHBhcnNlJywgXCJUaGUgc2FuaXRpemVyIHdhcyB1bmFibGUgdG8gcGFyc2UgdGhlIGZvbGxvd2luZyBibG9jayBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvZiBodG1sOiB7MH1cIiwgaHRtbCk7XG4gICAgfVxuICAgIGxhc3QgPSBodG1sO1xuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyh0YWcsIHRhZ05hbWUsIHJlc3QsIHVuYXJ5KSB7XG4gICAgdGFnTmFtZSA9IGFuZ3VsYXIubG93ZXJjYXNlKHRhZ05hbWUpO1xuICAgIGlmIChibG9ja0VsZW1lbnRzW3RhZ05hbWVdKSB7XG4gICAgICB3aGlsZSAoc3RhY2subGFzdCgpICYmIGlubGluZUVsZW1lbnRzW3N0YWNrLmxhc3QoKV0pIHtcbiAgICAgICAgcGFyc2VFbmRUYWcoXCJcIiwgc3RhY2subGFzdCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9uYWxFbmRUYWdFbGVtZW50c1t0YWdOYW1lXSAmJiBzdGFjay5sYXN0KCkgPT0gdGFnTmFtZSkge1xuICAgICAgcGFyc2VFbmRUYWcoXCJcIiwgdGFnTmFtZSk7XG4gICAgfVxuXG4gICAgdW5hcnkgPSB2b2lkRWxlbWVudHNbdGFnTmFtZV0gfHwgISF1bmFyeTtcblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2godGFnTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGF0dHJzID0ge307XG5cbiAgICByZXN0LnJlcGxhY2UoQVRUUl9SRUdFWFAsXG4gICAgICBmdW5jdGlvbihtYXRjaCwgbmFtZSwgZG91YmxlUXVvdGVkVmFsdWUsIHNpbmdsZVF1b3RlZFZhbHVlLCB1bnF1b3RlZFZhbHVlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRvdWJsZVF1b3RlZFZhbHVlXG4gICAgICAgICAgfHwgc2luZ2xlUXVvdGVkVmFsdWVcbiAgICAgICAgICB8fCB1bnF1b3RlZFZhbHVlXG4gICAgICAgICAgfHwgJyc7XG5cbiAgICAgICAgYXR0cnNbbmFtZV0gPSBkZWNvZGVFbnRpdGllcyh2YWx1ZSk7XG4gICAgfSk7XG4gICAgaWYgKGhhbmRsZXIuc3RhcnQpIGhhbmRsZXIuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnKHRhZywgdGFnTmFtZSkge1xuICAgIHZhciBwb3MgPSAwLCBpO1xuICAgIHRhZ05hbWUgPSBhbmd1bGFyLmxvd2VyY2FzZSh0YWdOYW1lKTtcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdID09IHRhZ05hbWUpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAoaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pXG4gICAgICAgIGlmIChoYW5kbGVyLmVuZCkgaGFuZGxlci5lbmQoc3RhY2tbaV0pO1xuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICB9XG4gIH1cbn1cblxudmFyIGhpZGRlblByZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xuLyoqXG4gKiBkZWNvZGVzIGFsbCBlbnRpdGllcyBpbnRvIHJlZ3VsYXIgc3RyaW5nXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIHdpdGggZGVjb2RlZCBlbnRpdGllcy5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlRW50aXRpZXModmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkgeyByZXR1cm4gJyc7IH1cblxuICBoaWRkZW5QcmUuaW5uZXJIVE1MID0gdmFsdWUucmVwbGFjZSgvPC9nLFwiJmx0O1wiKTtcbiAgLy8gaW5uZXJUZXh0IGRlcGVuZHMgb24gc3R5bGluZyBhcyBpdCBkb2Vzbid0IGRpc3BsYXkgaGlkZGVuIGVsZW1lbnRzLlxuICAvLyBUaGVyZWZvcmUsIGl0J3MgYmV0dGVyIHRvIHVzZSB0ZXh0Q29udGVudCBub3QgdG8gY2F1c2UgdW5uZWNlc3NhcnkgcmVmbG93cy5cbiAgcmV0dXJuIGhpZGRlblByZS50ZXh0Q29udGVudDtcbn1cblxuLyoqXG4gKiBFc2NhcGVzIGFsbCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgY2hhcmFjdGVycywgc28gdGhhdCB0aGVcbiAqIHJlc3VsdGluZyBzdHJpbmcgY2FuIGJlIHNhZmVseSBpbnNlcnRlZCBpbnRvIGF0dHJpYnV0ZSBvclxuICogZWxlbWVudCB0ZXh0LlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBlc2NhcGVkIHRleHRcbiAqL1xuZnVuY3Rpb24gZW5jb2RlRW50aXRpZXModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLlxuICAgIHJlcGxhY2UoLyYvZywgJyZhbXA7JykuXG4gICAgcmVwbGFjZShTVVJST0dBVEVfUEFJUl9SRUdFWFAsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgaGkgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICAgICAgdmFyIGxvdyA9IHZhbHVlLmNoYXJDb2RlQXQoMSk7XG4gICAgICByZXR1cm4gJyYjJyArICgoKGhpIC0gMHhEODAwKSAqIDB4NDAwKSArIChsb3cgLSAweERDMDApICsgMHgxMDAwMCkgKyAnOyc7XG4gICAgfSkuXG4gICAgcmVwbGFjZShOT05fQUxQSEFOVU1FUklDX1JFR0VYUCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAnJiMnICsgdmFsdWUuY2hhckNvZGVBdCgwKSArICc7JztcbiAgICB9KS5cbiAgICByZXBsYWNlKC88L2csICcmbHQ7JykuXG4gICAgcmVwbGFjZSgvPi9nLCAnJmd0OycpO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhbiBIVE1ML1hNTCB3cml0ZXIgd2hpY2ggd3JpdGVzIHRvIGJ1ZmZlclxuICogQHBhcmFtIHtBcnJheX0gYnVmIHVzZSBidWYuamFpbignJykgdG8gZ2V0IG91dCBzYW5pdGl6ZWQgaHRtbCBzdHJpbmdcbiAqIEByZXR1cm5zIHtvYmplY3R9IGluIHRoZSBmb3JtIG9mIHtcbiAqICAgICBzdGFydDogZnVuY3Rpb24odGFnLCBhdHRycywgdW5hcnkpIHt9LFxuICogICAgIGVuZDogZnVuY3Rpb24odGFnKSB7fSxcbiAqICAgICBjaGFyczogZnVuY3Rpb24odGV4dCkge30sXG4gKiAgICAgY29tbWVudDogZnVuY3Rpb24odGV4dCkge31cbiAqIH1cbiAqL1xuZnVuY3Rpb24gaHRtbFNhbml0aXplV3JpdGVyKGJ1ZiwgdXJpVmFsaWRhdG9yKSB7XG4gIHZhciBpZ25vcmUgPSBmYWxzZTtcbiAgdmFyIG91dCA9IGFuZ3VsYXIuYmluZChidWYsIGJ1Zi5wdXNoKTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogZnVuY3Rpb24odGFnLCBhdHRycywgdW5hcnkpIHtcbiAgICAgIHRhZyA9IGFuZ3VsYXIubG93ZXJjYXNlKHRhZyk7XG4gICAgICBpZiAoIWlnbm9yZSAmJiBzcGVjaWFsRWxlbWVudHNbdGFnXSkge1xuICAgICAgICBpZ25vcmUgPSB0YWc7XG4gICAgICB9XG4gICAgICBpZiAoIWlnbm9yZSAmJiB2YWxpZEVsZW1lbnRzW3RhZ10gPT09IHRydWUpIHtcbiAgICAgICAgb3V0KCc8Jyk7XG4gICAgICAgIG91dCh0YWcpO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goYXR0cnMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICB2YXIgbGtleT1hbmd1bGFyLmxvd2VyY2FzZShrZXkpO1xuICAgICAgICAgIHZhciBpc0ltYWdlID0gKHRhZyA9PT0gJ2ltZycgJiYgbGtleSA9PT0gJ3NyYycpIHx8IChsa2V5ID09PSAnYmFja2dyb3VuZCcpO1xuICAgICAgICAgIGlmICh2YWxpZEF0dHJzW2xrZXldID09PSB0cnVlICYmXG4gICAgICAgICAgICAodXJpQXR0cnNbbGtleV0gIT09IHRydWUgfHwgdXJpVmFsaWRhdG9yKHZhbHVlLCBpc0ltYWdlKSkpIHtcbiAgICAgICAgICAgIG91dCgnICcpO1xuICAgICAgICAgICAgb3V0KGtleSk7XG4gICAgICAgICAgICBvdXQoJz1cIicpO1xuICAgICAgICAgICAgb3V0KGVuY29kZUVudGl0aWVzKHZhbHVlKSk7XG4gICAgICAgICAgICBvdXQoJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb3V0KHVuYXJ5ID8gJy8+JyA6ICc+Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKHRhZykge1xuICAgICAgICB0YWcgPSBhbmd1bGFyLmxvd2VyY2FzZSh0YWcpO1xuICAgICAgICBpZiAoIWlnbm9yZSAmJiB2YWxpZEVsZW1lbnRzW3RhZ10gPT09IHRydWUpIHtcbiAgICAgICAgICBvdXQoJzwvJyk7XG4gICAgICAgICAgb3V0KHRhZyk7XG4gICAgICAgICAgb3V0KCc+Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBpZ25vcmUpIHtcbiAgICAgICAgICBpZ25vcmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICBjaGFyczogZnVuY3Rpb24oY2hhcnMpIHtcbiAgICAgICAgaWYgKCFpZ25vcmUpIHtcbiAgICAgICAgICBvdXQoZW5jb2RlRW50aXRpZXMoY2hhcnMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9O1xufVxuXG5cbi8vIGRlZmluZSBuZ1Nhbml0aXplIG1vZHVsZSBhbmQgcmVnaXN0ZXIgJHNhbml0aXplIHNlcnZpY2VcbmFuZ3VsYXIubW9kdWxlKCduZ1Nhbml0aXplJywgW10pLnByb3ZpZGVyKCckc2FuaXRpemUnLCAkU2FuaXRpemVQcm92aWRlcik7XG5cbi8qIGdsb2JhbCBzYW5pdGl6ZVRleHQ6IGZhbHNlICovXG5cbi8qKlxuICogQG5nZG9jIGZpbHRlclxuICogQG5hbWUgbGlua3lcbiAqIEBraW5kIGZ1bmN0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBGaW5kcyBsaW5rcyBpbiB0ZXh0IGlucHV0IGFuZCB0dXJucyB0aGVtIGludG8gaHRtbCBsaW5rcy4gU3VwcG9ydHMgaHR0cC9odHRwcy9mdHAvbWFpbHRvIGFuZFxuICogcGxhaW4gZW1haWwgYWRkcmVzcyBsaW5rcy5cbiAqXG4gKiBSZXF1aXJlcyB0aGUge0BsaW5rIG5nU2FuaXRpemUgYG5nU2FuaXRpemVgfSBtb2R1bGUgdG8gYmUgaW5zdGFsbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IElucHV0IHRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IFdpbmRvdyAoX2JsYW5rfF9zZWxmfF9wYXJlbnR8X3RvcCkgb3IgbmFtZWQgZnJhbWUgdG8gb3BlbiBsaW5rcyBpbi5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEh0bWwtbGlua2lmaWVkIHRleHQuXG4gKlxuICogQHVzYWdlXG4gICA8c3BhbiBuZy1iaW5kLWh0bWw9XCJsaW5reV9leHByZXNzaW9uIHwgbGlua3lcIj48L3NwYW4+XG4gKlxuICogQGV4YW1wbGVcbiAgIDxleGFtcGxlIG1vZHVsZT1cImxpbmt5RXhhbXBsZVwiIGRlcHM9XCJhbmd1bGFyLXNhbml0aXplLmpzXCI+XG4gICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgICAgPHNjcmlwdD5cbiAgICAgICAgIGFuZ3VsYXIubW9kdWxlKCdsaW5reUV4YW1wbGUnLCBbJ25nU2FuaXRpemUnXSlcbiAgICAgICAgICAgLmNvbnRyb2xsZXIoJ0V4YW1wbGVDb250cm9sbGVyJywgWyckc2NvcGUnLCBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgICAgICAkc2NvcGUuc25pcHBldCA9XG4gICAgICAgICAgICAgICAnUHJldHR5IHRleHQgd2l0aCBzb21lIGxpbmtzOlxcbicrXG4gICAgICAgICAgICAgICAnaHR0cDovL2FuZ3VsYXJqcy5vcmcvLFxcbicrXG4gICAgICAgICAgICAgICAnbWFpbHRvOnVzQHNvbWV3aGVyZS5vcmcsXFxuJytcbiAgICAgICAgICAgICAgICdhbm90aGVyQHNvbWV3aGVyZS5vcmcsXFxuJytcbiAgICAgICAgICAgICAgICdhbmQgb25lIG1vcmU6IGZ0cDovLzEyNy4wLjAuMS8uJztcbiAgICAgICAgICAgICAkc2NvcGUuc25pcHBldFdpdGhUYXJnZXQgPSAnaHR0cDovL2FuZ3VsYXJqcy5vcmcvJztcbiAgICAgICAgICAgfV0pO1xuICAgICAgIDwvc2NyaXB0PlxuICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkV4YW1wbGVDb250cm9sbGVyXCI+XG4gICAgICAgU25pcHBldDogPHRleHRhcmVhIG5nLW1vZGVsPVwic25pcHBldFwiIGNvbHM9XCI2MFwiIHJvd3M9XCIzXCI+PC90ZXh0YXJlYT5cbiAgICAgICA8dGFibGU+XG4gICAgICAgICA8dHI+XG4gICAgICAgICAgIDx0ZD5GaWx0ZXI8L3RkPlxuICAgICAgICAgICA8dGQ+U291cmNlPC90ZD5cbiAgICAgICAgICAgPHRkPlJlbmRlcmVkPC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJsaW5reS1maWx0ZXJcIj5cbiAgICAgICAgICAgPHRkPmxpbmt5IGZpbHRlcjwvdGQ+XG4gICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICA8cHJlPiZsdDtkaXYgbmctYmluZC1odG1sPVwic25pcHBldCB8IGxpbmt5XCImZ3Q7PGJyPiZsdDsvZGl2Jmd0OzwvcHJlPlxuICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgPGRpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0IHwgbGlua3lcIj48L2Rpdj5cbiAgICAgICAgICAgPC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJsaW5reS10YXJnZXRcIj5cbiAgICAgICAgICA8dGQ+bGlua3kgdGFyZ2V0PC90ZD5cbiAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICA8cHJlPiZsdDtkaXYgbmctYmluZC1odG1sPVwic25pcHBldFdpdGhUYXJnZXQgfCBsaW5reTonX2JsYW5rJ1wiJmd0Ozxicj4mbHQ7L2RpdiZndDs8L3ByZT5cbiAgICAgICAgICA8L3RkPlxuICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgIDxkaXYgbmctYmluZC1odG1sPVwic25pcHBldFdpdGhUYXJnZXQgfCBsaW5reTonX2JsYW5rJ1wiPjwvZGl2PlxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwiZXNjYXBlZC1odG1sXCI+XG4gICAgICAgICAgIDx0ZD5ubyBmaWx0ZXI8L3RkPlxuICAgICAgICAgICA8dGQ+PHByZT4mbHQ7ZGl2IG5nLWJpbmQ9XCJzbmlwcGV0XCImZ3Q7PGJyPiZsdDsvZGl2Jmd0OzwvcHJlPjwvdGQ+XG4gICAgICAgICAgIDx0ZD48ZGl2IG5nLWJpbmQ9XCJzbmlwcGV0XCI+PC9kaXY+PC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgPC90YWJsZT5cbiAgICAgPC9maWxlPlxuICAgICA8ZmlsZSBuYW1lPVwicHJvdHJhY3Rvci5qc1wiIHR5cGU9XCJwcm90cmFjdG9yXCI+XG4gICAgICAgaXQoJ3Nob3VsZCBsaW5raWZ5IHRoZSBzbmlwcGV0IHdpdGggdXJscycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2xpbmt5LWZpbHRlcicpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQgfCBsaW5reScpKS5nZXRUZXh0KCkpLlxuICAgICAgICAgICAgIHRvQmUoJ1ByZXR0eSB0ZXh0IHdpdGggc29tZSBsaW5rczogaHR0cDovL2FuZ3VsYXJqcy5vcmcvLCB1c0Bzb21ld2hlcmUub3JnLCAnICtcbiAgICAgICAgICAgICAgICAgICdhbm90aGVyQHNvbWV3aGVyZS5vcmcsIGFuZCBvbmUgbW9yZTogZnRwOi8vMTI3LjAuMC4xLy4nKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50LmFsbChieS5jc3MoJyNsaW5reS1maWx0ZXIgYScpKS5jb3VudCgpKS50b0VxdWFsKDQpO1xuICAgICAgIH0pO1xuXG4gICAgICAgaXQoJ3Nob3VsZCBub3QgbGlua2lmeSBzbmlwcGV0IHdpdGhvdXQgdGhlIGxpbmt5IGZpbHRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2VzY2FwZWQtaHRtbCcpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQnKSkuZ2V0VGV4dCgpKS5cbiAgICAgICAgICAgICB0b0JlKCdQcmV0dHkgdGV4dCB3aXRoIHNvbWUgbGlua3M6IGh0dHA6Ly9hbmd1bGFyanMub3JnLywgbWFpbHRvOnVzQHNvbWV3aGVyZS5vcmcsICcgK1xuICAgICAgICAgICAgICAgICAgJ2Fub3RoZXJAc29tZXdoZXJlLm9yZywgYW5kIG9uZSBtb3JlOiBmdHA6Ly8xMjcuMC4wLjEvLicpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQuYWxsKGJ5LmNzcygnI2VzY2FwZWQtaHRtbCBhJykpLmNvdW50KCkpLnRvRXF1YWwoMCk7XG4gICAgICAgfSk7XG5cbiAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZWxlbWVudChieS5tb2RlbCgnc25pcHBldCcpKS5jbGVhcigpO1xuICAgICAgICAgZWxlbWVudChieS5tb2RlbCgnc25pcHBldCcpKS5zZW5kS2V5cygnbmV3IGh0dHA6Ly9saW5rLicpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2xpbmt5LWZpbHRlcicpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQgfCBsaW5reScpKS5nZXRUZXh0KCkpLlxuICAgICAgICAgICAgIHRvQmUoJ25ldyBodHRwOi8vbGluay4nKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50LmFsbChieS5jc3MoJyNsaW5reS1maWx0ZXIgYScpKS5jb3VudCgpKS50b0VxdWFsKDEpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2VzY2FwZWQtaHRtbCcpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQnKSkuZ2V0VGV4dCgpKVxuICAgICAgICAgICAgIC50b0JlKCduZXcgaHR0cDovL2xpbmsuJyk7XG4gICAgICAgfSk7XG5cbiAgICAgICBpdCgnc2hvdWxkIHdvcmsgd2l0aCB0aGUgdGFyZ2V0IHByb3BlcnR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmlkKCdsaW5reS10YXJnZXQnKSkuXG4gICAgICAgICAgICBlbGVtZW50KGJ5LmJpbmRpbmcoXCJzbmlwcGV0V2l0aFRhcmdldCB8IGxpbmt5OidfYmxhbmsnXCIpKS5nZXRUZXh0KCkpLlxuICAgICAgICAgICAgdG9CZSgnaHR0cDovL2FuZ3VsYXJqcy5vcmcvJyk7XG4gICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2xpbmt5LXRhcmdldCBhJykpLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykpLnRvRXF1YWwoJ19ibGFuaycpO1xuICAgICAgIH0pO1xuICAgICA8L2ZpbGU+XG4gICA8L2V4YW1wbGU+XG4gKi9cbmFuZ3VsYXIubW9kdWxlKCduZ1Nhbml0aXplJykuZmlsdGVyKCdsaW5reScsIFsnJHNhbml0aXplJywgZnVuY3Rpb24oJHNhbml0aXplKSB7XG4gIHZhciBMSU5LWV9VUkxfUkVHRVhQID1cbiAgICAgICAgLygoZnRwfGh0dHBzPyk6XFwvXFwvfCh3d3dcXC4pfChtYWlsdG86KT9bQS1aYS16MC05Ll8lKy1dK0ApXFxTKlteXFxzLjssKCl7fTw+XCJcXHUyMDFkXFx1MjAxOV0vaSxcbiAgICAgIE1BSUxUT19SRUdFWFAgPSAvXm1haWx0bzovaTtcblxuICByZXR1cm4gZnVuY3Rpb24odGV4dCwgdGFyZ2V0KSB7XG4gICAgaWYgKCF0ZXh0KSByZXR1cm4gdGV4dDtcbiAgICB2YXIgbWF0Y2g7XG4gICAgdmFyIHJhdyA9IHRleHQ7XG4gICAgdmFyIGh0bWwgPSBbXTtcbiAgICB2YXIgdXJsO1xuICAgIHZhciBpO1xuICAgIHdoaWxlICgobWF0Y2ggPSByYXcubWF0Y2goTElOS1lfVVJMX1JFR0VYUCkpKSB7XG4gICAgICAvLyBXZSBjYW4gbm90IGVuZCBpbiB0aGVzZSBhcyB0aGV5IGFyZSBzb21ldGltZXMgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgc2VudGVuY2VcbiAgICAgIHVybCA9IG1hdGNoWzBdO1xuICAgICAgLy8gaWYgd2UgZGlkIG5vdCBtYXRjaCBmdHAvaHR0cC93d3cvbWFpbHRvIHRoZW4gYXNzdW1lIG1haWx0b1xuICAgICAgaWYgKCFtYXRjaFsyXSAmJiAhbWF0Y2hbNF0pIHtcbiAgICAgICAgdXJsID0gKG1hdGNoWzNdID8gJ2h0dHA6Ly8nIDogJ21haWx0bzonKSArIHVybDtcbiAgICAgIH1cbiAgICAgIGkgPSBtYXRjaC5pbmRleDtcbiAgICAgIGFkZFRleHQocmF3LnN1YnN0cigwLCBpKSk7XG4gICAgICBhZGRMaW5rKHVybCwgbWF0Y2hbMF0ucmVwbGFjZShNQUlMVE9fUkVHRVhQLCAnJykpO1xuICAgICAgcmF3ID0gcmF3LnN1YnN0cmluZyhpICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICB9XG4gICAgYWRkVGV4dChyYXcpO1xuICAgIHJldHVybiAkc2FuaXRpemUoaHRtbC5qb2luKCcnKSk7XG5cbiAgICBmdW5jdGlvbiBhZGRUZXh0KHRleHQpIHtcbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBodG1sLnB1c2goc2FuaXRpemVUZXh0KHRleHQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRMaW5rKHVybCwgdGV4dCkge1xuICAgICAgaHRtbC5wdXNoKCc8YSAnKTtcbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZCh0YXJnZXQpKSB7XG4gICAgICAgIGh0bWwucHVzaCgndGFyZ2V0PVwiJyxcbiAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICdcIiAnKTtcbiAgICAgIH1cbiAgICAgIGh0bWwucHVzaCgnaHJlZj1cIicsXG4gICAgICAgICAgICAgICAgdXJsLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKSxcbiAgICAgICAgICAgICAgICAnXCI+Jyk7XG4gICAgICBhZGRUZXh0KHRleHQpO1xuICAgICAgaHRtbC5wdXNoKCc8L2E+Jyk7XG4gICAgfVxuICB9O1xufV0pO1xuXG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYW5ndWxhci1zYW5pdGl6ZS9hbmd1bGFyLXNhbml0aXplLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9ib290c3RyYXAtc2xpZGVyLm1pbi5jc3MnKTtcclxudmFyIFNsaWRlciA9IHJlcXVpcmUoJy4vYm9vdHN0cmFwLXNsaWRlci5taW4nKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAtc2xpZGVyJywgW10pXHJcbiAgICAuZGlyZWN0aXZlKCdzbGlkZXInLCBbJyRwYXJzZScsICckdGltZW91dCcsICckcm9vdFNjb3BlJywgZnVuY3Rpb24gKCRwYXJzZSwgJHRpbWVvdXQsICRyb290U2NvcGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZXN0cmljdDogJ0FFJyxcclxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8ZGl2PjxpbnB1dCBjbGFzcz1cInNsaWRlci1pbnB1dFwiIHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJ3aWR0aDoxMDAlXCIgLz48L2Rpdj4nLFxyXG4gICAgICAgICAgICByZXF1aXJlOiAnbmdNb2RlbCcsXHJcbiAgICAgICAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgICAgICAgICBtYXg6IFwiPVwiLFxyXG4gICAgICAgICAgICAgICAgbWluOiBcIj1cIixcclxuICAgICAgICAgICAgICAgIHN0ZXA6IFwiPVwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiPVwiLFxyXG4gICAgICAgICAgICAgICAgbmdNb2RlbDogJz0nLFxyXG4gICAgICAgICAgICAgICAgbmdEaXNhYmxlZDogJz0nLFxyXG4gICAgICAgICAgICAgICAgcmFuZ2U6ICc9JyxcclxuICAgICAgICAgICAgICAgIHNsaWRlcmlkOiAnPScsXHJcbiAgICAgICAgICAgICAgICB0aWNrczogJz0nLFxyXG4gICAgICAgICAgICAgICAgdGlja3NMYWJlbHM6ICc9JyxcclxuICAgICAgICAgICAgICAgIHRpY2tzU25hcEJvdW5kczogJz0nLFxyXG4gICAgICAgICAgICAgICAgdGlja3NQb3NpdGlvbnM6ICc9JyxcclxuICAgICAgICAgICAgICAgIHNjYWxlOiAnPScsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6ICcmJyxcclxuICAgICAgICAgICAgICAgIG9uU3RhcnRTbGlkZTogJyYnLFxyXG4gICAgICAgICAgICAgICAgb25TdG9wU2xpZGU6ICcmJyxcclxuICAgICAgICAgICAgICAgIG9uU2xpZGU6ICcmJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbiAoJHNjb3BlLCBlbGVtZW50LCBhdHRycywgbmdNb2RlbEN0cmwsICRjb21waWxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmdNb2RlbERlcmVnaXN0ZXJGbiwgbmdEaXNhYmxlZERlcmVnaXN0ZXJGbjtcclxuXHJcbiAgICAgICAgICAgICAgICBpbml0U2xpZGVyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaW5pdFNsaWRlcigpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRPcHRpb24oa2V5LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldEZsb2F0T3B0aW9uKGtleSwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IHBhcnNlRmxvYXQodmFsdWUpIDogZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0Qm9vbGVhbk9wdGlvbihrZXksIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gdmFsdWUgPyB2YWx1ZSArICcnID09PSAndHJ1ZScgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRBcnJheU9yVmFsdWUodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhbmd1bGFyLmlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5pbmRleE9mKFwiW1wiKSA9PT0gMCkgPyBhbmd1bGFyLmZyb21Kc29uKHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKCdpZCcsICRzY29wZS5zbGlkZXJpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKCdvcmllbnRhdGlvbicsIGF0dHJzLm9yaWVudGF0aW9uLCAnaG9yaXpvbnRhbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbignc2VsZWN0aW9uJywgYXR0cnMuc2VsZWN0aW9uLCAnYmVmb3JlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKCdoYW5kbGUnLCBhdHRycy5oYW5kbGUsICdyb3VuZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbigndG9vbHRpcCcsIGF0dHJzLnNsaWRlclRvb2x0aXAgfHwgYXR0cnMudG9vbHRpcCwgJ3Nob3cnKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3Rvb2x0aXBfcG9zaXRpb24nLCBhdHRycy5zbGlkZXJUb29sdGlwUG9zaXRpb24sICd0b3AnKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3Rvb2x0aXBzZXBhcmF0b3InLCBhdHRycy50b29sdGlwc2VwYXJhdG9yLCAnOicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbigndGlja3MnLCAkc2NvcGUudGlja3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbigndGlja3NfbGFiZWxzJywgJHNjb3BlLnRpY2tzTGFiZWxzKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3RpY2tzX3NuYXBfYm91bmRzJywgJHNjb3BlLnRpY2tzU25hcEJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKCd0aWNrc19wb3NpdGlvbnMnLCAkc2NvcGUudGlja3NQb3NpdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbignc2NhbGUnLCAkc2NvcGUuc2NhbGUsICdsaW5lYXInKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RmxvYXRPcHRpb24oJ21pbicsICRzY29wZS5taW4sIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEZsb2F0T3B0aW9uKCdtYXgnLCAkc2NvcGUubWF4LCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RmxvYXRPcHRpb24oJ3N0ZXAnLCAkc2NvcGUuc3RlcCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ck5iciA9IG9wdGlvbnMuc3RlcCArICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNpbWFscyA9IHN0ck5ici5zdWJzdHJpbmcoc3RyTmJyLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRGbG9hdE9wdGlvbigncHJlY2lzaW9uJywgYXR0cnMucHJlY2lzaW9uLCBkZWNpbWFscyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldEJvb2xlYW5PcHRpb24oJ3Rvb2x0aXBfc3BsaXQnLCBhdHRycy50b29sdGlwc3BsaXQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRCb29sZWFuT3B0aW9uKCdlbmFibGVkJywgYXR0cnMuZW5hYmxlZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Qm9vbGVhbk9wdGlvbignbmF0dXJhbGFycm93a2V5cycsIGF0dHJzLm5hdHVyYWxhcnJvd2tleXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRCb29sZWFuT3B0aW9uKCdyZXZlcnNlZCcsIGF0dHJzLnJldmVyc2VkLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldEJvb2xlYW5PcHRpb24oJ3JhbmdlJywgJHNjb3BlLnJhbmdlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNBcnJheSgkc2NvcGUudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnZhbHVlID0gJHNjb3BlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFuZ3VsYXIuaXNTdHJpbmcoJHNjb3BlLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IGdldEFycmF5T3JWYWx1ZSgkc2NvcGUudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmd1bGFyLmlzQXJyYXkob3B0aW9ucy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KCRzY29wZS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkgdmFsdWUgPSA1O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAkc2NvcGUubWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHNjb3BlLm1pbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IFt2YWx1ZSwgb3B0aW9ucy5tYXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA+ICRzY29wZS5tYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkc2NvcGUubWF4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnZhbHVlID0gW29wdGlvbnMubWluLCB2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnZhbHVlID0gW29wdGlvbnMubWluLCBvcHRpb25zLm1heF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IFtvcHRpb25zLm1pbiwgb3B0aW9ucy5tYXhdOyAvLyBUaGlzIGlzIG5lZWRlZCwgYmVjYXVzZSBvZiB2YWx1ZSBkZWZpbmVkIGF0ICQuZm4uc2xpZGVyLmRlZmF1bHRzIC0gZGVmYXVsdCB2YWx1ZSA1IHByZXZlbnRzIGNyZWF0aW5nIHJhbmdlIHNsaWRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5uZ01vZGVsID0gb3B0aW9ucy52YWx1ZTsgLy8gbmVlZGVkLCBvdGhlcndpc2UgdHVybnMgdmFsdWUgaW50byBbbnVsbCwgIyNdXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRGbG9hdE9wdGlvbigndmFsdWUnLCAkc2NvcGUudmFsdWUsIDUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5mb3JtYXR0ZXIpIG9wdGlvbnMuZm9ybWF0dGVyID0gJHNjb3BlLiRldmFsKCRzY29wZS5mb3JtYXR0ZXIpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgc2xpZGVyIGpRdWVyeSBwbHVnaW4gZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCckJyBpbiB3aW5kb3cgJiYgJC5mbi5zbGlkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkaW5nIG1ldGhvZHMgdG8galF1ZXJ5IHNsaWRlciBwbHVnaW4gcHJvdG90eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZm4uc2xpZGVyLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5waWNrZXIub2ZmKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZm4uc2xpZGVyLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBpY2tlci5vbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVzdHJveSBwcmV2aW91cyBzbGlkZXIgdG8gcmVzZXQgYWxsIG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFswXS5fX3NsaWRlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFswXS5fX3NsaWRlci5kZXN0cm95KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGlkZXIgPSBuZXcgU2xpZGVyKGVsZW1lbnRbMF0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc2xpZGVyLWlucHV0JylbMF0sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbMF0uX19zbGlkZXIgPSBzbGlkZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgdGhhdCBuZWVkcyBzbGlkZXIgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVFdmVudCA9IGdldEFycmF5T3JWYWx1ZShhdHRycy51cGRhdGVldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNTdHJpbmcodXBkYXRlRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG9ubHkgc2luZ2xlIGV2ZW50IG5hbWUgaW4gc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUV2ZW50ID0gW3VwZGF0ZUV2ZW50XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gc2xpZGUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRXZlbnQgPSBbJ3NsaWRlJ107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh1cGRhdGVFdmVudCwgZnVuY3Rpb24gKHNsaWRlckV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlci5vbihzbGlkZXJFdmVudCwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVyLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShldi5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGlkZXJFdmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlU3RhcnQ6ICdvblN0YXJ0U2xpZGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbGlkZTogJ29uU2xpZGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbGlkZVN0b3A6ICdvblN0b3BTbGlkZSdcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzbGlkZXJFdmVudHMsIGZ1bmN0aW9uIChzbGlkZXJFdmVudEF0dHIsIHNsaWRlckV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbiA9ICRwYXJzZShhdHRyc1tzbGlkZXJFdmVudEF0dHJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVyLm9uKHNsaWRlckV2ZW50LCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2NvcGVbc2xpZGVyRXZlbnRBdHRyXSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKCRzY29wZS4kcGFyZW50LCB7ICRldmVudDogZXYsIHZhbHVlOiBldiB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiQkcGhhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRldmFsQXN5bmMoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlcmVnaXN0ZXIgbmdEaXNhYmxlZCB3YXRjaGVyIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihuZ0Rpc2FibGVkRGVyZWdpc3RlckZuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZ0Rpc2FibGVkRGVyZWdpc3RlckZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5nRGlzYWJsZWREZXJlZ2lzdGVyRm4gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbmdEaXNhYmxlZERlcmVnaXN0ZXJGbiA9ICRzY29wZS4kd2F0Y2goJ25nRGlzYWJsZWQnLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGlkZXIuZGlzYWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVyLmVuYWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlcmVnaXN0ZXIgbmdNb2RlbCB3YXRjaGVyIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihuZ01vZGVsRGVyZWdpc3RlckZuKSkgbmdNb2RlbERlcmVnaXN0ZXJGbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5nTW9kZWxEZXJlZ2lzdGVyRm4gPSAkc2NvcGUuJHdhdGNoKCduZ01vZGVsJywgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCRzY29wZS5yYW5nZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGlkZXIuc2V0VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlci5zZXRWYWx1ZShwYXJzZUZsb2F0KHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHdhdGNoZXJzID0gWydtaW4nLCAnbWF4JywgJ3N0ZXAnLCAncmFuZ2UnLCAnc2NhbGUnXTtcclxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh3YXRjaGVycywgZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKHByb3AsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdFNsaWRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfV0pXHJcbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGlicmFyaWVzL2FuZ3VsYXItYm9vdHN0cmFwLXNsaWRlci9zbGlkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC1zbGlkZXIubWluLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ib290c3RyYXAtc2xpZGVyLm1pbi5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ib290c3RyYXAtc2xpZGVyLm1pbi5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWJyYXJpZXMvYW5ndWxhci1ib290c3RyYXAtc2xpZGVyL2Jvb3RzdHJhcC1zbGlkZXIubWluLmNzc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyohID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgVkVSU0lPTiAgNS4xLjFcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXHJcXG4vKiEgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuICogYm9vdHN0cmFwLXNsaWRlci5qc1xcclxcbiAqXFxyXFxuICogTWFpbnRhaW5lcnM6XFxyXFxuICpcXHRcXHRLeWxlIEtlbXBcXHJcXG4gKlxcdFxcdFxcdC0gVHdpdHRlcjogQHNlaXlyaWFcXHJcXG4gKlxcdFxcdFxcdC0gR2l0aHViOiAgc2VpeXJpYVxcclxcbiAqXFx0XFx0Um9oaXQgS2Fsa3VyXFxyXFxuICpcXHRcXHRcXHQtIFR3aXR0ZXI6IEBSb3ZvbHV0aW9uYXJ5XFxyXFxuICpcXHRcXHRcXHQtIEdpdGh1YjogIHJvdm9sdXRpb25cXHJcXG4gKlxcclxcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiAqXFxyXFxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFxcXCJMaWNlbnNlXFxcIik7XFxyXFxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxcclxcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxcclxcbiAqXFxyXFxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXFxyXFxuICpcXHJcXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXFxyXFxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXFxcIkFTIElTXFxcIiBCQVNJUyxcXHJcXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cXHJcXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXFxyXFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXFxyXFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovLnNsaWRlcntkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7cG9zaXRpb246cmVsYXRpdmV9LnNsaWRlci5zbGlkZXItaG9yaXpvbnRhbHt3aWR0aDoyMTBweDtoZWlnaHQ6MjBweH0uc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItdHJhY2t7aGVpZ2h0OjEwcHg7d2lkdGg6MTAwJTttYXJnaW4tdG9wOi01cHg7dG9wOjUwJTtsZWZ0OjB9LnNsaWRlci5zbGlkZXItaG9yaXpvbnRhbCAuc2xpZGVyLXNlbGVjdGlvbiwuc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItdHJhY2stbG93LC5zbGlkZXIuc2xpZGVyLWhvcml6b250YWwgLnNsaWRlci10cmFjay1oaWdoe2hlaWdodDoxMDAlO3RvcDowO2JvdHRvbTowfS5zbGlkZXIuc2xpZGVyLWhvcml6b250YWwgLnNsaWRlci10aWNrLC5zbGlkZXIuc2xpZGVyLWhvcml6b250YWwgLnNsaWRlci1oYW5kbGV7bWFyZ2luLWxlZnQ6LTEwcHg7bWFyZ2luLXRvcDotNXB4fS5zbGlkZXIuc2xpZGVyLWhvcml6b250YWwgLnNsaWRlci10aWNrLnRyaWFuZ2xlLC5zbGlkZXIuc2xpZGVyLWhvcml6b250YWwgLnNsaWRlci1oYW5kbGUudHJpYW5nbGV7Ym9yZGVyLXdpZHRoOjAgMTBweCAxMHB4IDEwcHg7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXItYm90dG9tLWNvbG9yOiMwNDgwYmU7bWFyZ2luLXRvcDowfS5zbGlkZXIuc2xpZGVyLWhvcml6b250YWwgLnNsaWRlci10aWNrLWxhYmVsLWNvbnRhaW5lcnt3aGl0ZS1zcGFjZTpub3dyYXA7bWFyZ2luLXRvcDoyMHB4fS5zbGlkZXIuc2xpZGVyLWhvcml6b250YWwgLnNsaWRlci10aWNrLWxhYmVsLWNvbnRhaW5lciAuc2xpZGVyLXRpY2stbGFiZWx7cGFkZGluZy10b3A6NHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrO3RleHQtYWxpZ246Y2VudGVyfS5zbGlkZXIuc2xpZGVyLXZlcnRpY2Fse2hlaWdodDoyMTBweDt3aWR0aDoyMHB4fS5zbGlkZXIuc2xpZGVyLXZlcnRpY2FsIC5zbGlkZXItdHJhY2t7d2lkdGg6MTBweDtoZWlnaHQ6MTAwJTttYXJnaW4tbGVmdDotNXB4O2xlZnQ6NTAlO3RvcDowfS5zbGlkZXIuc2xpZGVyLXZlcnRpY2FsIC5zbGlkZXItc2VsZWN0aW9ue3dpZHRoOjEwMCU7bGVmdDowO3RvcDowO2JvdHRvbTowfS5zbGlkZXIuc2xpZGVyLXZlcnRpY2FsIC5zbGlkZXItdHJhY2stbG93LC5zbGlkZXIuc2xpZGVyLXZlcnRpY2FsIC5zbGlkZXItdHJhY2staGlnaHt3aWR0aDoxMDAlO2xlZnQ6MDtyaWdodDowfS5zbGlkZXIuc2xpZGVyLXZlcnRpY2FsIC5zbGlkZXItdGljaywuc2xpZGVyLnNsaWRlci12ZXJ0aWNhbCAuc2xpZGVyLWhhbmRsZXttYXJnaW4tbGVmdDotNXB4O21hcmdpbi10b3A6LTEwcHh9LnNsaWRlci5zbGlkZXItdmVydGljYWwgLnNsaWRlci10aWNrLnRyaWFuZ2xlLC5zbGlkZXIuc2xpZGVyLXZlcnRpY2FsIC5zbGlkZXItaGFuZGxlLnRyaWFuZ2xle2JvcmRlci13aWR0aDoxMHB4IDAgMTBweCAxMHB4O3dpZHRoOjFweDtoZWlnaHQ6MXB4O2JvcmRlci1sZWZ0LWNvbG9yOiMwNDgwYmU7bWFyZ2luLWxlZnQ6MH0uc2xpZGVyLnNsaWRlci1kaXNhYmxlZCAuc2xpZGVyLWhhbmRsZXtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjZGZkZmRmIDAsI2JlYmViZSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsI2RmZGZkZiAwLCNiZWJlYmUgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCNkZmRmZGYgMCwjYmViZWJlIDEwMCUpO2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj0nI2ZmZGZkZmRmJyxlbmRDb2xvcnN0cj0nI2ZmYmViZWJlJyxHcmFkaWVudFR5cGU9MCl9LnNsaWRlci5zbGlkZXItZGlzYWJsZWQgLnNsaWRlci10cmFja3tiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjZTVlNWU1IDAsI2U5ZTllOSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsI2U1ZTVlNSAwLCNlOWU5ZTkgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCNlNWU1ZTUgMCwjZTllOWU5IDEwMCUpO2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj0nI2ZmZTVlNWU1JyxlbmRDb2xvcnN0cj0nI2ZmZTllOWU5JyxHcmFkaWVudFR5cGU9MCk7Y3Vyc29yOm5vdC1hbGxvd2VkfS5zbGlkZXIgaW5wdXR7ZGlzcGxheTpub25lfS5zbGlkZXIgLnRvb2x0aXAudG9we21hcmdpbi10b3A6LTM2cHh9LnNsaWRlciAudG9vbHRpcC1pbm5lcnt3aGl0ZS1zcGFjZTpub3dyYXB9LnNsaWRlciAuaGlkZXtkaXNwbGF5Om5vbmV9LnNsaWRlci10cmFja3twb3NpdGlvbjphYnNvbHV0ZTtjdXJzb3I6cG9pbnRlcjtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjZjVmNWY1IDAsI2Y5ZjlmOSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsI2Y1ZjVmNSAwLCNmOWY5ZjkgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCNmNWY1ZjUgMCwjZjlmOWY5IDEwMCUpO2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj0nI2ZmZjVmNWY1JyxlbmRDb2xvcnN0cj0nI2ZmZjlmOWY5JyxHcmFkaWVudFR5cGU9MCk7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMSk7Ym94LXNoYWRvdzppbnNldCAwIDFweCAycHggcmdiYSgwLDAsMCwwLjEpO2JvcmRlci1yYWRpdXM6NHB4fS5zbGlkZXItc2VsZWN0aW9ue3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCNmOWY5ZjkgMCwjZjVmNWY1IDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6LW8tbGluZWFyLWdyYWRpZW50KHRvcCwjZjlmOWY5IDAsI2Y1ZjVmNSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byBib3R0b20sI2Y5ZjlmOSAwLCNmNWY1ZjUgMTAwJSk7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPScjZmZmOWY5ZjknLGVuZENvbG9yc3RyPScjZmZmNWY1ZjUnLEdyYWRpZW50VHlwZT0wKTstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAtMXB4IDAgcmdiYSgwLDAsMCwwLjE1KTtib3gtc2hhZG93Omluc2V0IDAgLTFweCAwIHJnYmEoMCwwLDAsMC4xNSk7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O2JvcmRlci1yYWRpdXM6NHB4fS5zbGlkZXItc2VsZWN0aW9uLnRpY2stc2xpZGVyLXNlbGVjdGlvbntiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjODljZGVmIDAsIzgxYmZkZSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsIzg5Y2RlZiAwLCM4MWJmZGUgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCM4OWNkZWYgMCwjODFiZmRlIDEwMCUpO2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj0nI2ZmODljZGVmJyxlbmRDb2xvcnN0cj0nI2ZmODFiZmRlJyxHcmFkaWVudFR5cGU9MCl9LnNsaWRlci10cmFjay1sb3csLnNsaWRlci10cmFjay1oaWdoe3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O2JvcmRlci1yYWRpdXM6NHB4fS5zbGlkZXItaGFuZGxle3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7YmFja2dyb3VuZC1jb2xvcjojMzM3YWI3O2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCMxNDliZGYgMCwjMDQ4MGJlIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6LW8tbGluZWFyLWdyYWRpZW50KHRvcCwjMTQ5YmRmIDAsIzA0ODBiZSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byBib3R0b20sIzE0OWJkZiAwLCMwNDgwYmUgMTAwJSk7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPScjZmYxNDliZGYnLGVuZENvbG9yc3RyPScjZmYwNDgwYmUnLEdyYWRpZW50VHlwZT0wKTtmaWx0ZXI6bm9uZTstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAxcHggMCByZ2JhKDI1NSwyNTUsMjU1LC4yKSwwIDFweCAycHggcmdiYSgwLDAsMCwuMDUpO2JveC1zaGFkb3c6aW5zZXQgMCAxcHggMCByZ2JhKDI1NSwyNTUsMjU1LC4yKSwwIDFweCAycHggcmdiYSgwLDAsMCwuMDUpO2JvcmRlcjowIHNvbGlkIHRyYW5zcGFyZW50fS5zbGlkZXItaGFuZGxlLnJvdW5ke2JvcmRlci1yYWRpdXM6NTAlfS5zbGlkZXItaGFuZGxlLnRyaWFuZ2xle2JhY2tncm91bmQ6dHJhbnNwYXJlbnQgbm9uZX0uc2xpZGVyLWhhbmRsZS5jdXN0b217YmFja2dyb3VuZDp0cmFuc3BhcmVudCBub25lfS5zbGlkZXItaGFuZGxlLmN1c3RvbTo6YmVmb3Jle2xpbmUtaGVpZ2h0OjIwcHg7Zm9udC1zaXplOjIwcHg7Y29udGVudDonXFxcXDI2MDUnO2NvbG9yOiM3MjYyMDR9LnNsaWRlci10aWNre3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsI2Y5ZjlmOSAwLCNmNWY1ZjUgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTotby1saW5lYXItZ3JhZGllbnQodG9wLCNmOWY5ZjkgMCwjZjVmNWY1IDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZjlmOWY5IDAsI2Y1ZjVmNSAxMDAlKTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9JyNmZmY5ZjlmOScsZW5kQ29sb3JzdHI9JyNmZmY1ZjVmNScsR3JhZGllbnRUeXBlPTApOy13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIC0xcHggMCByZ2JhKDAsMCwwLDAuMTUpO2JveC1zaGFkb3c6aW5zZXQgMCAtMXB4IDAgcmdiYSgwLDAsMCwwLjE1KTstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZmlsdGVyOm5vbmU7b3BhY2l0eTouODtib3JkZXI6MCBzb2xpZCB0cmFuc3BhcmVudH0uc2xpZGVyLXRpY2sucm91bmR7Ym9yZGVyLXJhZGl1czo1MCV9LnNsaWRlci10aWNrLnRyaWFuZ2xle2JhY2tncm91bmQ6dHJhbnNwYXJlbnQgbm9uZX0uc2xpZGVyLXRpY2suY3VzdG9te2JhY2tncm91bmQ6dHJhbnNwYXJlbnQgbm9uZX0uc2xpZGVyLXRpY2suY3VzdG9tOjpiZWZvcmV7bGluZS1oZWlnaHQ6MjBweDtmb250LXNpemU6MjBweDtjb250ZW50OidcXFxcMjYwNSc7Y29sb3I6IzcyNjIwNH0uc2xpZGVyLXRpY2suaW4tc2VsZWN0aW9ue2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCM4OWNkZWYgMCwjODFiZmRlIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6LW8tbGluZWFyLWdyYWRpZW50KHRvcCwjODljZGVmIDAsIzgxYmZkZSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byBib3R0b20sIzg5Y2RlZiAwLCM4MWJmZGUgMTAwJSk7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPScjZmY4OWNkZWYnLGVuZENvbG9yc3RyPScjZmY4MWJmZGUnLEdyYWRpZW50VHlwZT0wKTtvcGFjaXR5OjF9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL2xpYnJhcmllcy9hbmd1bGFyLWJvb3RzdHJhcC1zbGlkZXIvYm9vdHN0cmFwLXNsaWRlci5taW4uY3NzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cclxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXHJcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xyXG5cdFx0XHRpZihpdGVtWzJdKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDA7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcclxuXHRpZih0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcclxuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xyXG5cdH1cclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xyXG5cclxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xyXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xyXG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcclxuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYobmV3TGlzdCkge1xyXG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xyXG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XHJcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xyXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0aWYoZG9tU3R5bGUpIHtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XHJcblx0dmFyIHN0eWxlcyA9IFtdO1xyXG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xyXG5cdFx0dmFyIGlkID0gaXRlbVswXTtcclxuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xyXG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcclxuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xyXG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xyXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pXHJcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcclxuXHR9XHJcblx0cmV0dXJuIHN0eWxlcztcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KCkge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCgpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0bGlua0VsZW1lbnQucmVsID0gXCJzdHlsZXNoZWV0XCI7XHJcblx0aGVhZC5hcHBlbmRDaGlsZChsaW5rRWxlbWVudCk7XHJcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcclxuXHJcblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XHJcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcclxuXHRcdHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKTtcclxuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxyXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudCgpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXHJcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihzb3VyY2VNYXApIHtcclxuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XHJcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XHJcblx0fVxyXG5cclxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcclxuXHJcblx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XHJcblxyXG5cdGxpbmtFbGVtZW50LmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG5cclxuXHRpZihvbGRTcmMpXHJcblx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiEgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAgICAgICAgICAgICAgVkVSU0lPTiAgNS4xLjFcclxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXHJcbi8qISA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogYm9vdHN0cmFwLXNsaWRlci5qc1xyXG4gKlxyXG4gKiBNYWludGFpbmVyczpcclxuICpcdFx0S3lsZSBLZW1wXHJcbiAqXHRcdFx0LSBUd2l0dGVyOiBAc2VpeXJpYVxyXG4gKlx0XHRcdC0gR2l0aHViOiAgc2VpeXJpYVxyXG4gKlx0XHRSb2hpdCBLYWxrdXJcclxuICpcdFx0XHQtIFR3aXR0ZXI6IEBSb3ZvbHV0aW9uYXJ5XHJcbiAqXHRcdFx0LSBHaXRodWI6ICByb3ZvbHV0aW9uXHJcbiAqXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cclxuIWZ1bmN0aW9uKGEsYil7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXCJqcXVlcnlcIl0sYik7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cyl7dmFyIGM7dHJ5e2M9cmVxdWlyZShcImpxdWVyeVwiKX1jYXRjaChkKXtjPW51bGx9bW9kdWxlLmV4cG9ydHM9YihjKX1lbHNlIGEuU2xpZGVyPWIoYS5qUXVlcnkpfSh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiO3JldHVybiBmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKCl7fWZ1bmN0aW9uIGMoYSl7ZnVuY3Rpb24gYyhiKXtiLnByb3RvdHlwZS5vcHRpb258fChiLnByb3RvdHlwZS5vcHRpb249ZnVuY3Rpb24oYil7YS5pc1BsYWluT2JqZWN0KGIpJiYodGhpcy5vcHRpb25zPWEuZXh0ZW5kKCEwLHRoaXMub3B0aW9ucyxiKSl9KX1mdW5jdGlvbiBlKGIsYyl7YS5mbltiXT1mdW5jdGlvbihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7Zm9yKHZhciBnPWQuY2FsbChhcmd1bWVudHMsMSksaD0wLGk9dGhpcy5sZW5ndGg7aT5oO2grKyl7dmFyIGo9dGhpc1toXSxrPWEuZGF0YShqLGIpO2lmKGspaWYoYS5pc0Z1bmN0aW9uKGtbZV0pJiZcIl9cIiE9PWUuY2hhckF0KDApKXt2YXIgbD1rW2VdLmFwcGx5KGssZyk7aWYodm9pZCAwIT09bCYmbCE9PWspcmV0dXJuIGx9ZWxzZSBmKFwibm8gc3VjaCBtZXRob2QgJ1wiK2UrXCInIGZvciBcIitiK1wiIGluc3RhbmNlXCIpO2Vsc2UgZihcImNhbm5vdCBjYWxsIG1ldGhvZHMgb24gXCIrYitcIiBwcmlvciB0byBpbml0aWFsaXphdGlvbjsgYXR0ZW1wdGVkIHRvIGNhbGwgJ1wiK2UrXCInXCIpfXJldHVybiB0aGlzfXZhciBtPXRoaXMubWFwKGZ1bmN0aW9uKCl7dmFyIGQ9YS5kYXRhKHRoaXMsYik7cmV0dXJuIGQ/KGQub3B0aW9uKGUpLGQuX2luaXQoKSk6KGQ9bmV3IGModGhpcyxlKSxhLmRhdGEodGhpcyxiLGQpKSxhKHRoaXMpfSk7cmV0dXJuIW18fG0ubGVuZ3RoPjE/bTptWzBdfX1pZihhKXt2YXIgZj1cInVuZGVmaW5lZFwiPT10eXBlb2YgY29uc29sZT9iOmZ1bmN0aW9uKGEpe2NvbnNvbGUuZXJyb3IoYSl9O3JldHVybiBhLmJyaWRnZXQ9ZnVuY3Rpb24oYSxiKXtjKGIpLGUoYSxiKX0sYS5icmlkZ2V0fX12YXIgZD1BcnJheS5wcm90b3R5cGUuc2xpY2U7YyhhKX0oYSksZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYyhiLGMpe2Z1bmN0aW9uIGQoYSxiKXt2YXIgYz1cImRhdGEtc2xpZGVyLVwiK2IucmVwbGFjZSgvXy9nLFwiLVwiKSxkPWEuZ2V0QXR0cmlidXRlKGMpO3RyeXtyZXR1cm4gSlNPTi5wYXJzZShkKX1jYXRjaChlKXtyZXR1cm4gZH19dGhpcy5fc3RhdGU9e3ZhbHVlOm51bGwsZW5hYmxlZDpudWxsLG9mZnNldDpudWxsLHNpemU6bnVsbCxwZXJjZW50YWdlOm51bGwsaW5EcmFnOiExLG92ZXI6ITF9LFwic3RyaW5nXCI9PXR5cGVvZiBiP3RoaXMuZWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGIpOmIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCYmKHRoaXMuZWxlbWVudD1iKSxjPWM/Yzp7fTtmb3IodmFyIGY9T2JqZWN0LmtleXModGhpcy5kZWZhdWx0T3B0aW9ucyksZz0wO2c8Zi5sZW5ndGg7ZysrKXt2YXIgaD1mW2ddLGk9Y1toXTtpPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBpP2k6ZCh0aGlzLmVsZW1lbnQsaCksaT1udWxsIT09aT9pOnRoaXMuZGVmYXVsdE9wdGlvbnNbaF0sdGhpcy5vcHRpb25zfHwodGhpcy5vcHRpb25zPXt9KSx0aGlzLm9wdGlvbnNbaF09aX1cInZlcnRpY2FsXCIhPT10aGlzLm9wdGlvbnMub3JpZW50YXRpb258fFwidG9wXCIhPT10aGlzLm9wdGlvbnMudG9vbHRpcF9wb3NpdGlvbiYmXCJib3R0b21cIiE9PXRoaXMub3B0aW9ucy50b29sdGlwX3Bvc2l0aW9uP1wiaG9yaXpvbnRhbFwiIT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9ufHxcImxlZnRcIiE9PXRoaXMub3B0aW9ucy50b29sdGlwX3Bvc2l0aW9uJiZcInJpZ2h0XCIhPT10aGlzLm9wdGlvbnMudG9vbHRpcF9wb3NpdGlvbnx8KHRoaXMub3B0aW9ucy50b29sdGlwX3Bvc2l0aW9uPVwidG9wXCIpOnRoaXMub3B0aW9ucy50b29sdGlwX3Bvc2l0aW9uPVwicmlnaHRcIjt2YXIgaixrLGwsbSxuLG89dGhpcy5lbGVtZW50LnN0eWxlLndpZHRoLHA9ITEscT10aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtpZih0aGlzLnNsaWRlckVsZW0pcD0hMDtlbHNle3RoaXMuc2xpZGVyRWxlbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuc2xpZGVyRWxlbS5jbGFzc05hbWU9XCJzbGlkZXJcIjt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2lmKHIuY2xhc3NOYW1lPVwic2xpZGVyLXRyYWNrXCIsaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGsuY2xhc3NOYW1lPVwic2xpZGVyLXRyYWNrLWxvd1wiLGo9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxqLmNsYXNzTmFtZT1cInNsaWRlci1zZWxlY3Rpb25cIixsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksbC5jbGFzc05hbWU9XCJzbGlkZXItdHJhY2staGlnaFwiLG09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxtLmNsYXNzTmFtZT1cInNsaWRlci1oYW5kbGUgbWluLXNsaWRlci1oYW5kbGVcIixuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksbi5jbGFzc05hbWU9XCJzbGlkZXItaGFuZGxlIG1heC1zbGlkZXItaGFuZGxlXCIsci5hcHBlbmRDaGlsZChrKSxyLmFwcGVuZENoaWxkKGopLHIuYXBwZW5kQ2hpbGQobCksdGhpcy50aWNrcz1bXSxBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy50aWNrcykmJnRoaXMub3B0aW9ucy50aWNrcy5sZW5ndGg+MCl7Zm9yKGc9MDtnPHRoaXMub3B0aW9ucy50aWNrcy5sZW5ndGg7ZysrKXt2YXIgcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3MuY2xhc3NOYW1lPVwic2xpZGVyLXRpY2tcIix0aGlzLnRpY2tzLnB1c2gocyksci5hcHBlbmRDaGlsZChzKX1qLmNsYXNzTmFtZSs9XCIgdGljay1zbGlkZXItc2VsZWN0aW9uXCJ9aWYoci5hcHBlbmRDaGlsZChtKSxyLmFwcGVuZENoaWxkKG4pLHRoaXMudGlja0xhYmVscz1bXSxBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy50aWNrc19sYWJlbHMpJiZ0aGlzLm9wdGlvbnMudGlja3NfbGFiZWxzLmxlbmd0aD4wKWZvcih0aGlzLnRpY2tMYWJlbENvbnRhaW5lcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMudGlja0xhYmVsQ29udGFpbmVyLmNsYXNzTmFtZT1cInNsaWRlci10aWNrLWxhYmVsLWNvbnRhaW5lclwiLGc9MDtnPHRoaXMub3B0aW9ucy50aWNrc19sYWJlbHMubGVuZ3RoO2crKyl7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0LmNsYXNzTmFtZT1cInNsaWRlci10aWNrLWxhYmVsXCIsdC5pbm5lckhUTUw9dGhpcy5vcHRpb25zLnRpY2tzX2xhYmVsc1tnXSx0aGlzLnRpY2tMYWJlbHMucHVzaCh0KSx0aGlzLnRpY2tMYWJlbENvbnRhaW5lci5hcHBlbmRDaGlsZCh0KX12YXIgdT1mdW5jdGlvbihhKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2IuY2xhc3NOYW1lPVwidG9vbHRpcC1hcnJvd1wiO3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7Yy5jbGFzc05hbWU9XCJ0b29sdGlwLWlubmVyXCIsYS5hcHBlbmRDaGlsZChiKSxhLmFwcGVuZENoaWxkKGMpfSx2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7di5jbGFzc05hbWU9XCJ0b29sdGlwIHRvb2x0aXAtbWFpblwiLHUodik7dmFyIHc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt3LmNsYXNzTmFtZT1cInRvb2x0aXAgdG9vbHRpcC1taW5cIix1KHcpO3ZhciB4PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7eC5jbGFzc05hbWU9XCJ0b29sdGlwIHRvb2x0aXAtbWF4XCIsdSh4KSx0aGlzLnNsaWRlckVsZW0uYXBwZW5kQ2hpbGQociksdGhpcy5zbGlkZXJFbGVtLmFwcGVuZENoaWxkKHYpLHRoaXMuc2xpZGVyRWxlbS5hcHBlbmRDaGlsZCh3KSx0aGlzLnNsaWRlckVsZW0uYXBwZW5kQ2hpbGQoeCksdGhpcy50aWNrTGFiZWxDb250YWluZXImJnRoaXMuc2xpZGVyRWxlbS5hcHBlbmRDaGlsZCh0aGlzLnRpY2tMYWJlbENvbnRhaW5lcikscS5pbnNlcnRCZWZvcmUodGhpcy5zbGlkZXJFbGVtLHRoaXMuZWxlbWVudCksdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXk9XCJub25lXCJ9aWYoYSYmKHRoaXMuJGVsZW1lbnQ9YSh0aGlzLmVsZW1lbnQpLHRoaXMuJHNsaWRlckVsZW09YSh0aGlzLnNsaWRlckVsZW0pKSx0aGlzLmV2ZW50VG9DYWxsYmFja01hcD17fSx0aGlzLnNsaWRlckVsZW0uaWQ9dGhpcy5vcHRpb25zLmlkLHRoaXMudG91Y2hDYXBhYmxlPVwib250b3VjaHN0YXJ0XCJpbiB3aW5kb3d8fHdpbmRvdy5Eb2N1bWVudFRvdWNoJiZkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoLHRoaXMudG9vbHRpcD10aGlzLnNsaWRlckVsZW0ucXVlcnlTZWxlY3RvcihcIi50b29sdGlwLW1haW5cIiksdGhpcy50b29sdGlwSW5uZXI9dGhpcy50b29sdGlwLnF1ZXJ5U2VsZWN0b3IoXCIudG9vbHRpcC1pbm5lclwiKSx0aGlzLnRvb2x0aXBfbWluPXRoaXMuc2xpZGVyRWxlbS5xdWVyeVNlbGVjdG9yKFwiLnRvb2x0aXAtbWluXCIpLHRoaXMudG9vbHRpcElubmVyX21pbj10aGlzLnRvb2x0aXBfbWluLnF1ZXJ5U2VsZWN0b3IoXCIudG9vbHRpcC1pbm5lclwiKSx0aGlzLnRvb2x0aXBfbWF4PXRoaXMuc2xpZGVyRWxlbS5xdWVyeVNlbGVjdG9yKFwiLnRvb2x0aXAtbWF4XCIpLHRoaXMudG9vbHRpcElubmVyX21heD10aGlzLnRvb2x0aXBfbWF4LnF1ZXJ5U2VsZWN0b3IoXCIudG9vbHRpcC1pbm5lclwiKSxlW3RoaXMub3B0aW9ucy5zY2FsZV0mJih0aGlzLm9wdGlvbnMuc2NhbGU9ZVt0aGlzLm9wdGlvbnMuc2NhbGVdKSxwPT09ITAmJih0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnNsaWRlckVsZW0sXCJzbGlkZXItaG9yaXpvbnRhbFwiKSx0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnNsaWRlckVsZW0sXCJzbGlkZXItdmVydGljYWxcIiksdGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy50b29sdGlwLFwiaGlkZVwiKSx0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnRvb2x0aXBfbWluLFwiaGlkZVwiKSx0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnRvb2x0aXBfbWF4LFwiaGlkZVwiKSxbXCJsZWZ0XCIsXCJ0b3BcIixcIndpZHRoXCIsXCJoZWlnaHRcIl0uZm9yRWFjaChmdW5jdGlvbihhKXt0aGlzLl9yZW1vdmVQcm9wZXJ0eSh0aGlzLnRyYWNrTG93LGEpLHRoaXMuX3JlbW92ZVByb3BlcnR5KHRoaXMudHJhY2tTZWxlY3Rpb24sYSksdGhpcy5fcmVtb3ZlUHJvcGVydHkodGhpcy50cmFja0hpZ2gsYSl9LHRoaXMpLFt0aGlzLmhhbmRsZTEsdGhpcy5oYW5kbGUyXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3RoaXMuX3JlbW92ZVByb3BlcnR5KGEsXCJsZWZ0XCIpLHRoaXMuX3JlbW92ZVByb3BlcnR5KGEsXCJ0b3BcIil9LHRoaXMpLFt0aGlzLnRvb2x0aXAsdGhpcy50b29sdGlwX21pbix0aGlzLnRvb2x0aXBfbWF4XS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3RoaXMuX3JlbW92ZVByb3BlcnR5KGEsXCJsZWZ0XCIpLHRoaXMuX3JlbW92ZVByb3BlcnR5KGEsXCJ0b3BcIiksdGhpcy5fcmVtb3ZlUHJvcGVydHkoYSxcIm1hcmdpbi1sZWZ0XCIpLHRoaXMuX3JlbW92ZVByb3BlcnR5KGEsXCJtYXJnaW4tdG9wXCIpLHRoaXMuX3JlbW92ZUNsYXNzKGEsXCJyaWdodFwiKSx0aGlzLl9yZW1vdmVDbGFzcyhhLFwidG9wXCIpfSx0aGlzKSksXCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uPyh0aGlzLl9hZGRDbGFzcyh0aGlzLnNsaWRlckVsZW0sXCJzbGlkZXItdmVydGljYWxcIiksdGhpcy5zdHlsZVBvcz1cInRvcFwiLHRoaXMubW91c2VQb3M9XCJwYWdlWVwiLHRoaXMuc2l6ZVBvcz1cIm9mZnNldEhlaWdodFwiKToodGhpcy5fYWRkQ2xhc3ModGhpcy5zbGlkZXJFbGVtLFwic2xpZGVyLWhvcml6b250YWxcIiksdGhpcy5zbGlkZXJFbGVtLnN0eWxlLndpZHRoPW8sdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uPVwiaG9yaXpvbnRhbFwiLHRoaXMuc3R5bGVQb3M9XCJsZWZ0XCIsdGhpcy5tb3VzZVBvcz1cInBhZ2VYXCIsdGhpcy5zaXplUG9zPVwib2Zmc2V0V2lkdGhcIiksdGhpcy5fc2V0VG9vbHRpcFBvc2l0aW9uKCksQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMudGlja3MpJiZ0aGlzLm9wdGlvbnMudGlja3MubGVuZ3RoPjAmJih0aGlzLm9wdGlvbnMubWF4PU1hdGgubWF4LmFwcGx5KE1hdGgsdGhpcy5vcHRpb25zLnRpY2tzKSx0aGlzLm9wdGlvbnMubWluPU1hdGgubWluLmFwcGx5KE1hdGgsdGhpcy5vcHRpb25zLnRpY2tzKSksQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMudmFsdWUpPyh0aGlzLm9wdGlvbnMucmFuZ2U9ITAsdGhpcy5fc3RhdGUudmFsdWU9dGhpcy5vcHRpb25zLnZhbHVlKTp0aGlzLl9zdGF0ZS52YWx1ZT10aGlzLm9wdGlvbnMucmFuZ2U/W3RoaXMub3B0aW9ucy52YWx1ZSx0aGlzLm9wdGlvbnMubWF4XTp0aGlzLm9wdGlvbnMudmFsdWUsdGhpcy50cmFja0xvdz1rfHx0aGlzLnRyYWNrTG93LHRoaXMudHJhY2tTZWxlY3Rpb249anx8dGhpcy50cmFja1NlbGVjdGlvbix0aGlzLnRyYWNrSGlnaD1sfHx0aGlzLnRyYWNrSGlnaCxcIm5vbmVcIj09PXRoaXMub3B0aW9ucy5zZWxlY3Rpb24mJih0aGlzLl9hZGRDbGFzcyh0aGlzLnRyYWNrTG93LFwiaGlkZVwiKSx0aGlzLl9hZGRDbGFzcyh0aGlzLnRyYWNrU2VsZWN0aW9uLFwiaGlkZVwiKSx0aGlzLl9hZGRDbGFzcyh0aGlzLnRyYWNrSGlnaCxcImhpZGVcIikpLHRoaXMuaGFuZGxlMT1tfHx0aGlzLmhhbmRsZTEsdGhpcy5oYW5kbGUyPW58fHRoaXMuaGFuZGxlMixwPT09ITApZm9yKHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMuaGFuZGxlMSxcInJvdW5kIHRyaWFuZ2xlXCIpLHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMuaGFuZGxlMixcInJvdW5kIHRyaWFuZ2xlIGhpZGVcIiksZz0wO2c8dGhpcy50aWNrcy5sZW5ndGg7ZysrKXRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudGlja3NbZ10sXCJyb3VuZCB0cmlhbmdsZSBoaWRlXCIpO3ZhciB5PVtcInJvdW5kXCIsXCJ0cmlhbmdsZVwiLFwiY3VzdG9tXCJdLHo9LTEhPT15LmluZGV4T2YodGhpcy5vcHRpb25zLmhhbmRsZSk7aWYoeilmb3IodGhpcy5fYWRkQ2xhc3ModGhpcy5oYW5kbGUxLHRoaXMub3B0aW9ucy5oYW5kbGUpLHRoaXMuX2FkZENsYXNzKHRoaXMuaGFuZGxlMix0aGlzLm9wdGlvbnMuaGFuZGxlKSxnPTA7Zzx0aGlzLnRpY2tzLmxlbmd0aDtnKyspdGhpcy5fYWRkQ2xhc3ModGhpcy50aWNrc1tnXSx0aGlzLm9wdGlvbnMuaGFuZGxlKTt0aGlzLl9zdGF0ZS5vZmZzZXQ9dGhpcy5fb2Zmc2V0KHRoaXMuc2xpZGVyRWxlbSksdGhpcy5fc3RhdGUuc2l6ZT10aGlzLnNsaWRlckVsZW1bdGhpcy5zaXplUG9zXSx0aGlzLnNldFZhbHVlKHRoaXMuX3N0YXRlLnZhbHVlKSx0aGlzLmhhbmRsZTFLZXlkb3duPXRoaXMuX2tleWRvd24uYmluZCh0aGlzLDApLHRoaXMuaGFuZGxlMS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMuaGFuZGxlMUtleWRvd24sITEpLHRoaXMuaGFuZGxlMktleWRvd249dGhpcy5fa2V5ZG93bi5iaW5kKHRoaXMsMSksdGhpcy5oYW5kbGUyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5oYW5kbGUyS2V5ZG93biwhMSksdGhpcy5tb3VzZWRvd249dGhpcy5fbW91c2Vkb3duLmJpbmQodGhpcyksdGhpcy50b3VjaENhcGFibGUmJnRoaXMuc2xpZGVyRWxlbS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLHRoaXMubW91c2Vkb3duLCExKSx0aGlzLnNsaWRlckVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLHRoaXMubW91c2Vkb3duLCExKSxcImhpZGVcIj09PXRoaXMub3B0aW9ucy50b29sdGlwPyh0aGlzLl9hZGRDbGFzcyh0aGlzLnRvb2x0aXAsXCJoaWRlXCIpLHRoaXMuX2FkZENsYXNzKHRoaXMudG9vbHRpcF9taW4sXCJoaWRlXCIpLHRoaXMuX2FkZENsYXNzKHRoaXMudG9vbHRpcF9tYXgsXCJoaWRlXCIpKTpcImFsd2F5c1wiPT09dGhpcy5vcHRpb25zLnRvb2x0aXA/KHRoaXMuX3Nob3dUb29sdGlwKCksdGhpcy5fYWx3YXlzU2hvd1Rvb2x0aXA9ITApOih0aGlzLnNob3dUb29sdGlwPXRoaXMuX3Nob3dUb29sdGlwLmJpbmQodGhpcyksdGhpcy5oaWRlVG9vbHRpcD10aGlzLl9oaWRlVG9vbHRpcC5iaW5kKHRoaXMpLHRoaXMuc2xpZGVyRWxlbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLHRoaXMuc2hvd1Rvb2x0aXAsITEpLHRoaXMuc2xpZGVyRWxlbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLHRoaXMuaGlkZVRvb2x0aXAsITEpLHRoaXMuaGFuZGxlMS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLnNob3dUb29sdGlwLCExKSx0aGlzLmhhbmRsZTEuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIix0aGlzLmhpZGVUb29sdGlwLCExKSx0aGlzLmhhbmRsZTIuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpcy5zaG93VG9vbHRpcCwhMSksdGhpcy5oYW5kbGUyLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdGhpcy5oaWRlVG9vbHRpcCwhMSkpLHRoaXMub3B0aW9ucy5lbmFibGVkP3RoaXMuZW5hYmxlKCk6dGhpcy5kaXNhYmxlKCl9dmFyIGQ9e2Zvcm1hdEludmFsaWRJbnB1dEVycm9yTXNnOmZ1bmN0aW9uKGEpe3JldHVyblwiSW52YWxpZCBpbnB1dCB2YWx1ZSAnXCIrYStcIicgcGFzc2VkIGluXCJ9LGNhbGxpbmdDb250ZXh0Tm90U2xpZGVySW5zdGFuY2U6XCJDYWxsaW5nIGNvbnRleHQgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGluc3RhbmNlIG9mIFNsaWRlciBib3VuZCB0byBpdC4gQ2hlY2sgeW91ciBjb2RlIHRvIG1ha2Ugc3VyZSB0aGUgSlF1ZXJ5IG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSBjYWxsIHRvIHRoZSBzbGlkZXIoKSBpbml0aWFsaXplciBpcyBjYWxsaW5nIHRoZSBtZXRob2RcIn0sZT17bGluZWFyOnt0b1ZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPWEvMTAwKih0aGlzLm9wdGlvbnMubWF4LXRoaXMub3B0aW9ucy5taW4pO2lmKHRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnMubGVuZ3RoPjApe2Zvcih2YXIgYyxkLGUsZj0wLGc9MDtnPHRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnMubGVuZ3RoO2crKylpZihhPD10aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zW2ddKXtjPWc+MD90aGlzLm9wdGlvbnMudGlja3NbZy0xXTowLGU9Zz4wP3RoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnNbZy0xXTowLGQ9dGhpcy5vcHRpb25zLnRpY2tzW2ddLGY9dGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9uc1tnXTticmVha31pZihnPjApe3ZhciBoPShhLWUpLyhmLWUpO2I9YytoKihkLWMpfX12YXIgaT10aGlzLm9wdGlvbnMubWluK01hdGgucm91bmQoYi90aGlzLm9wdGlvbnMuc3RlcCkqdGhpcy5vcHRpb25zLnN0ZXA7cmV0dXJuIGk8dGhpcy5vcHRpb25zLm1pbj90aGlzLm9wdGlvbnMubWluOmk+dGhpcy5vcHRpb25zLm1heD90aGlzLm9wdGlvbnMubWF4Oml9LHRvUGVyY2VudGFnZTpmdW5jdGlvbihhKXtpZih0aGlzLm9wdGlvbnMubWF4PT09dGhpcy5vcHRpb25zLm1pbilyZXR1cm4gMDtpZih0aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zLmxlbmd0aD4wKXtmb3IodmFyIGIsYyxkLGU9MCxmPTA7Zjx0aGlzLm9wdGlvbnMudGlja3MubGVuZ3RoO2YrKylpZihhPD10aGlzLm9wdGlvbnMudGlja3NbZl0pe2I9Zj4wP3RoaXMub3B0aW9ucy50aWNrc1tmLTFdOjAsZD1mPjA/dGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9uc1tmLTFdOjAsYz10aGlzLm9wdGlvbnMudGlja3NbZl0sZT10aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zW2ZdO2JyZWFrfWlmKGY+MCl7dmFyIGc9KGEtYikvKGMtYik7cmV0dXJuIGQrZyooZS1kKX19cmV0dXJuIDEwMCooYS10aGlzLm9wdGlvbnMubWluKS8odGhpcy5vcHRpb25zLm1heC10aGlzLm9wdGlvbnMubWluKX19LGxvZ2FyaXRobWljOnt0b1ZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPTA9PT10aGlzLm9wdGlvbnMubWluPzA6TWF0aC5sb2codGhpcy5vcHRpb25zLm1pbiksYz1NYXRoLmxvZyh0aGlzLm9wdGlvbnMubWF4KSxkPU1hdGguZXhwKGIrKGMtYikqYS8xMDApO3JldHVybiBkPXRoaXMub3B0aW9ucy5taW4rTWF0aC5yb3VuZCgoZC10aGlzLm9wdGlvbnMubWluKS90aGlzLm9wdGlvbnMuc3RlcCkqdGhpcy5vcHRpb25zLnN0ZXAsZDx0aGlzLm9wdGlvbnMubWluP3RoaXMub3B0aW9ucy5taW46ZD50aGlzLm9wdGlvbnMubWF4P3RoaXMub3B0aW9ucy5tYXg6ZH0sdG9QZXJjZW50YWdlOmZ1bmN0aW9uKGEpe2lmKHRoaXMub3B0aW9ucy5tYXg9PT10aGlzLm9wdGlvbnMubWluKXJldHVybiAwO3ZhciBiPU1hdGgubG9nKHRoaXMub3B0aW9ucy5tYXgpLGM9MD09PXRoaXMub3B0aW9ucy5taW4/MDpNYXRoLmxvZyh0aGlzLm9wdGlvbnMubWluKSxkPTA9PT1hPzA6TWF0aC5sb2coYSk7cmV0dXJuIDEwMCooZC1jKS8oYi1jKX19fTtpZihiPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGMuY2FsbCh0aGlzLGEsYiksdGhpc30sYi5wcm90b3R5cGU9e19pbml0OmZ1bmN0aW9uKCl7fSxjb25zdHJ1Y3RvcjpiLGRlZmF1bHRPcHRpb25zOntpZDpcIlwiLG1pbjowLG1heDoxMCxzdGVwOjEscHJlY2lzaW9uOjAsb3JpZW50YXRpb246XCJob3Jpem9udGFsXCIsdmFsdWU6NSxyYW5nZTohMSxzZWxlY3Rpb246XCJiZWZvcmVcIix0b29sdGlwOlwic2hvd1wiLHRvb2x0aXBfc3BsaXQ6ITEsaGFuZGxlOlwicm91bmRcIixyZXZlcnNlZDohMSxlbmFibGVkOiEwLGZvcm1hdHRlcjpmdW5jdGlvbihhKXtyZXR1cm4gQXJyYXkuaXNBcnJheShhKT9hWzBdK1wiIDogXCIrYVsxXTphfSxuYXR1cmFsX2Fycm93X2tleXM6ITEsdGlja3M6W10sdGlja3NfcG9zaXRpb25zOltdLHRpY2tzX2xhYmVsczpbXSx0aWNrc19zbmFwX2JvdW5kczowLHNjYWxlOlwibGluZWFyXCIsZm9jdXM6ITEsdG9vbHRpcF9wb3NpdGlvbjpudWxsfSxnZXRFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2xpZGVyRWxlbX0sZ2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zLnJhbmdlP3RoaXMuX3N0YXRlLnZhbHVlOnRoaXMuX3N0YXRlLnZhbHVlWzBdfSxzZXRWYWx1ZTpmdW5jdGlvbihhLGIsYyl7YXx8KGE9MCk7dmFyIGQ9dGhpcy5nZXRWYWx1ZSgpO3RoaXMuX3N0YXRlLnZhbHVlPXRoaXMuX3ZhbGlkYXRlSW5wdXRWYWx1ZShhKTt2YXIgZT10aGlzLl9hcHBseVByZWNpc2lvbi5iaW5kKHRoaXMpO3RoaXMub3B0aW9ucy5yYW5nZT8odGhpcy5fc3RhdGUudmFsdWVbMF09ZSh0aGlzLl9zdGF0ZS52YWx1ZVswXSksdGhpcy5fc3RhdGUudmFsdWVbMV09ZSh0aGlzLl9zdGF0ZS52YWx1ZVsxXSksdGhpcy5fc3RhdGUudmFsdWVbMF09TWF0aC5tYXgodGhpcy5vcHRpb25zLm1pbixNYXRoLm1pbih0aGlzLm9wdGlvbnMubWF4LHRoaXMuX3N0YXRlLnZhbHVlWzBdKSksdGhpcy5fc3RhdGUudmFsdWVbMV09TWF0aC5tYXgodGhpcy5vcHRpb25zLm1pbixNYXRoLm1pbih0aGlzLm9wdGlvbnMubWF4LHRoaXMuX3N0YXRlLnZhbHVlWzFdKSkpOih0aGlzLl9zdGF0ZS52YWx1ZT1lKHRoaXMuX3N0YXRlLnZhbHVlKSx0aGlzLl9zdGF0ZS52YWx1ZT1bTWF0aC5tYXgodGhpcy5vcHRpb25zLm1pbixNYXRoLm1pbih0aGlzLm9wdGlvbnMubWF4LHRoaXMuX3N0YXRlLnZhbHVlKSldLHRoaXMuX2FkZENsYXNzKHRoaXMuaGFuZGxlMixcImhpZGVcIiksdGhpcy5fc3RhdGUudmFsdWVbMV09XCJhZnRlclwiPT09dGhpcy5vcHRpb25zLnNlbGVjdGlvbj90aGlzLm9wdGlvbnMubWF4OnRoaXMub3B0aW9ucy5taW4pLHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2U9dGhpcy5vcHRpb25zLm1heD50aGlzLm9wdGlvbnMubWluP1t0aGlzLl90b1BlcmNlbnRhZ2UodGhpcy5fc3RhdGUudmFsdWVbMF0pLHRoaXMuX3RvUGVyY2VudGFnZSh0aGlzLl9zdGF0ZS52YWx1ZVsxXSksMTAwKnRoaXMub3B0aW9ucy5zdGVwLyh0aGlzLm9wdGlvbnMubWF4LXRoaXMub3B0aW9ucy5taW4pXTpbMCwwLDEwMF0sdGhpcy5fbGF5b3V0KCk7dmFyIGY9dGhpcy5vcHRpb25zLnJhbmdlP3RoaXMuX3N0YXRlLnZhbHVlOnRoaXMuX3N0YXRlLnZhbHVlWzBdO3JldHVybiBiPT09ITAmJnRoaXMuX3RyaWdnZXIoXCJzbGlkZVwiLGYpLGQhPT1mJiZjPT09ITAmJnRoaXMuX3RyaWdnZXIoXCJjaGFuZ2VcIix7b2xkVmFsdWU6ZCxuZXdWYWx1ZTpmfSksdGhpcy5fc2V0RGF0YVZhbChmKSx0aGlzfSxkZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5fcmVtb3ZlU2xpZGVyRXZlbnRIYW5kbGVycygpLHRoaXMuc2xpZGVyRWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2xpZGVyRWxlbSksdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXk9XCJcIix0aGlzLl9jbGVhblVwRXZlbnRDYWxsYmFja3NNYXAoKSx0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YVwiKSxhJiYodGhpcy5fdW5iaW5kSlF1ZXJ5RXZlbnRIYW5kbGVycygpLHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YShcInNsaWRlclwiKSl9LGRpc2FibGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3RhdGUuZW5hYmxlZD0hMSx0aGlzLmhhbmRsZTEucmVtb3ZlQXR0cmlidXRlKFwidGFiaW5kZXhcIiksdGhpcy5oYW5kbGUyLnJlbW92ZUF0dHJpYnV0ZShcInRhYmluZGV4XCIpLHRoaXMuX2FkZENsYXNzKHRoaXMuc2xpZGVyRWxlbSxcInNsaWRlci1kaXNhYmxlZFwiKSx0aGlzLl90cmlnZ2VyKFwic2xpZGVEaXNhYmxlZFwiKSx0aGlzfSxlbmFibGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3RhdGUuZW5hYmxlZD0hMCx0aGlzLmhhbmRsZTEuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwwKSx0aGlzLmhhbmRsZTIuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwwKSx0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnNsaWRlckVsZW0sXCJzbGlkZXItZGlzYWJsZWRcIiksdGhpcy5fdHJpZ2dlcihcInNsaWRlRW5hYmxlZFwiKSx0aGlzfSx0b2dnbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3RhdGUuZW5hYmxlZD90aGlzLmRpc2FibGUoKTp0aGlzLmVuYWJsZSgpLHRoaXN9LGlzRW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdGF0ZS5lbmFibGVkfSxvbjpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl9iaW5kTm9uUXVlcnlFdmVudEhhbmRsZXIoYSxiKSx0aGlzfSxvZmY6ZnVuY3Rpb24oYixjKXthPyh0aGlzLiRlbGVtZW50Lm9mZihiLGMpLHRoaXMuJHNsaWRlckVsZW0ub2ZmKGIsYykpOnRoaXMuX3VuYmluZE5vblF1ZXJ5RXZlbnRIYW5kbGVyKGIsYyl9LGdldEF0dHJpYnV0ZTpmdW5jdGlvbihhKXtyZXR1cm4gYT90aGlzLm9wdGlvbnNbYV06dGhpcy5vcHRpb25zfSxzZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5vcHRpb25zW2FdPWIsdGhpc30scmVmcmVzaDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZW1vdmVTbGlkZXJFdmVudEhhbmRsZXJzKCksYy5jYWxsKHRoaXMsdGhpcy5lbGVtZW50LHRoaXMub3B0aW9ucyksYSYmYS5kYXRhKHRoaXMuZWxlbWVudCxcInNsaWRlclwiLHRoaXMpLHRoaXN9LHJlbGF5b3V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xheW91dCgpLHRoaXN9LF9yZW1vdmVTbGlkZXJFdmVudEhhbmRsZXJzOmZ1bmN0aW9uKCl7dGhpcy5oYW5kbGUxLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5oYW5kbGUxS2V5ZG93biwhMSksdGhpcy5oYW5kbGUxLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLHRoaXMuc2hvd1Rvb2x0aXAsITEpLHRoaXMuaGFuZGxlMS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLHRoaXMuaGlkZVRvb2x0aXAsITEpLHRoaXMuaGFuZGxlMi5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMuaGFuZGxlMktleWRvd24sITEpLHRoaXMuaGFuZGxlMi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLmhhbmRsZTJLZXlkb3duLCExKSx0aGlzLmhhbmRsZTIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIix0aGlzLmhhbmRsZTJLZXlkb3duLCExKSx0aGlzLnNsaWRlckVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIix0aGlzLnNob3dUb29sdGlwLCExKSx0aGlzLnNsaWRlckVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIix0aGlzLmhpZGVUb29sdGlwLCExKSx0aGlzLnNsaWRlckVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIix0aGlzLm1vdXNlZG93biwhMSksdGhpcy5zbGlkZXJFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIix0aGlzLm1vdXNlZG93biwhMSl9LF9iaW5kTm9uUXVlcnlFdmVudEhhbmRsZXI6ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT10aGlzLmV2ZW50VG9DYWxsYmFja01hcFthXSYmKHRoaXMuZXZlbnRUb0NhbGxiYWNrTWFwW2FdPVtdKSx0aGlzLmV2ZW50VG9DYWxsYmFja01hcFthXS5wdXNoKGIpfSxfdW5iaW5kTm9uUXVlcnlFdmVudEhhbmRsZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmV2ZW50VG9DYWxsYmFja01hcFthXTtpZih2b2lkIDAhPT1jKWZvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKWlmKGNbZF09PT1iKXtjLnNwbGljZShkLDEpO2JyZWFrfX0sX2NsZWFuVXBFdmVudENhbGxiYWNrc01hcDpmdW5jdGlvbigpe2Zvcih2YXIgYT1PYmplY3Qua2V5cyh0aGlzLmV2ZW50VG9DYWxsYmFja01hcCksYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz1hW2JdO3RoaXMuZXZlbnRUb0NhbGxiYWNrTWFwW2NdPW51bGx9fSxfc2hvd1Rvb2x0aXA6ZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMudG9vbHRpcF9zcGxpdD09PSExPyh0aGlzLl9hZGRDbGFzcyh0aGlzLnRvb2x0aXAsXCJpblwiKSx0aGlzLnRvb2x0aXBfbWluLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy50b29sdGlwX21heC5zdHlsZS5kaXNwbGF5PVwibm9uZVwiKToodGhpcy5fYWRkQ2xhc3ModGhpcy50b29sdGlwX21pbixcImluXCIpLHRoaXMuX2FkZENsYXNzKHRoaXMudG9vbHRpcF9tYXgsXCJpblwiKSx0aGlzLnRvb2x0aXAuc3R5bGUuZGlzcGxheT1cIm5vbmVcIiksdGhpcy5fc3RhdGUub3Zlcj0hMH0sX2hpZGVUb29sdGlwOmZ1bmN0aW9uKCl7dGhpcy5fc3RhdGUuaW5EcmFnPT09ITEmJnRoaXMuYWx3YXlzU2hvd1Rvb2x0aXAhPT0hMCYmKHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudG9vbHRpcCxcImluXCIpLHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudG9vbHRpcF9taW4sXCJpblwiKSx0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnRvb2x0aXBfbWF4LFwiaW5cIikpLHRoaXMuX3N0YXRlLm92ZXI9ITF9LF9sYXlvdXQ6ZnVuY3Rpb24oKXt2YXIgYTtpZihhPXRoaXMub3B0aW9ucy5yZXZlcnNlZD9bMTAwLXRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMF0sdGhpcy5vcHRpb25zLnJhbmdlPzEwMC10aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdOnRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMV1dOlt0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzBdLHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMV1dLHRoaXMuaGFuZGxlMS5zdHlsZVt0aGlzLnN0eWxlUG9zXT1hWzBdK1wiJVwiLHRoaXMuaGFuZGxlMi5zdHlsZVt0aGlzLnN0eWxlUG9zXT1hWzFdK1wiJVwiLEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLnRpY2tzKSYmdGhpcy5vcHRpb25zLnRpY2tzLmxlbmd0aD4wKXt2YXIgYj1NYXRoLm1heC5hcHBseShNYXRoLHRoaXMub3B0aW9ucy50aWNrcyksYz1NYXRoLm1pbi5hcHBseShNYXRoLHRoaXMub3B0aW9ucy50aWNrcyksZD1cInZlcnRpY2FsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb24/XCJoZWlnaHRcIjpcIndpZHRoXCIsZT1cInZlcnRpY2FsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb24/XCJtYXJnaW5Ub3BcIjpcIm1hcmdpbkxlZnRcIixmPXRoaXMuX3N0YXRlLnNpemUvKHRoaXMub3B0aW9ucy50aWNrcy5sZW5ndGgtMSk7aWYodGhpcy50aWNrTGFiZWxDb250YWluZXIpe3ZhciBnPTA7aWYoMD09PXRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnMubGVuZ3RoKXRoaXMudGlja0xhYmVsQ29udGFpbmVyLnN0eWxlW2VdPS1mLzIrXCJweFwiLGc9dGhpcy50aWNrTGFiZWxDb250YWluZXIub2Zmc2V0SGVpZ2h0O2Vsc2UgZm9yKGg9MDtoPHRoaXMudGlja0xhYmVsQ29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoO2grKyl0aGlzLnRpY2tMYWJlbENvbnRhaW5lci5jaGlsZE5vZGVzW2hdLm9mZnNldEhlaWdodD5nJiYoZz10aGlzLnRpY2tMYWJlbENvbnRhaW5lci5jaGlsZE5vZGVzW2hdLm9mZnNldEhlaWdodCk7XCJob3Jpem9udGFsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb24mJih0aGlzLnNsaWRlckVsZW0uc3R5bGUubWFyZ2luQm90dG9tPWcrXCJweFwiKX1mb3IodmFyIGg9MDtoPHRoaXMub3B0aW9ucy50aWNrcy5sZW5ndGg7aCsrKXt2YXIgaT10aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zW2hdfHwxMDAqKHRoaXMub3B0aW9ucy50aWNrc1toXS1jKS8oYi1jKTt0aGlzLnRpY2tzW2hdLnN0eWxlW3RoaXMuc3R5bGVQb3NdPWkrXCIlXCIsdGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy50aWNrc1toXSxcImluLXNlbGVjdGlvblwiKSx0aGlzLm9wdGlvbnMucmFuZ2U/aT49YVswXSYmaTw9YVsxXSYmdGhpcy5fYWRkQ2xhc3ModGhpcy50aWNrc1toXSxcImluLXNlbGVjdGlvblwiKTpcImFmdGVyXCI9PT10aGlzLm9wdGlvbnMuc2VsZWN0aW9uJiZpPj1hWzBdP3RoaXMuX2FkZENsYXNzKHRoaXMudGlja3NbaF0sXCJpbi1zZWxlY3Rpb25cIik6XCJiZWZvcmVcIj09PXRoaXMub3B0aW9ucy5zZWxlY3Rpb24mJmk8PWFbMF0mJnRoaXMuX2FkZENsYXNzKHRoaXMudGlja3NbaF0sXCJpbi1zZWxlY3Rpb25cIiksdGhpcy50aWNrTGFiZWxzW2hdJiYodGhpcy50aWNrTGFiZWxzW2hdLnN0eWxlW2RdPWYrXCJweFwiLHZvaWQgMCE9PXRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnNbaF0mJih0aGlzLnRpY2tMYWJlbHNbaF0uc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLHRoaXMudGlja0xhYmVsc1toXS5zdHlsZVt0aGlzLnN0eWxlUG9zXT10aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zW2hdK1wiJVwiLHRoaXMudGlja0xhYmVsc1toXS5zdHlsZVtlXT0tZi8yK1wicHhcIikpfX12YXIgajtpZih0aGlzLm9wdGlvbnMucmFuZ2Upe2o9dGhpcy5vcHRpb25zLmZvcm1hdHRlcih0aGlzLl9zdGF0ZS52YWx1ZSksdGhpcy5fc2V0VGV4dCh0aGlzLnRvb2x0aXBJbm5lcixqKSx0aGlzLnRvb2x0aXAuc3R5bGVbdGhpcy5zdHlsZVBvc109KGFbMV0rYVswXSkvMitcIiVcIixcInZlcnRpY2FsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb24/dGhpcy5fY3NzKHRoaXMudG9vbHRpcCxcIm1hcmdpbi10b3BcIiwtdGhpcy50b29sdGlwLm9mZnNldEhlaWdodC8yK1wicHhcIik6dGhpcy5fY3NzKHRoaXMudG9vbHRpcCxcIm1hcmdpbi1sZWZ0XCIsLXRoaXMudG9vbHRpcC5vZmZzZXRXaWR0aC8yK1wicHhcIiksXCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uP3RoaXMuX2Nzcyh0aGlzLnRvb2x0aXAsXCJtYXJnaW4tdG9wXCIsLXRoaXMudG9vbHRpcC5vZmZzZXRIZWlnaHQvMitcInB4XCIpOnRoaXMuX2Nzcyh0aGlzLnRvb2x0aXAsXCJtYXJnaW4tbGVmdFwiLC10aGlzLnRvb2x0aXAub2Zmc2V0V2lkdGgvMitcInB4XCIpO3ZhciBrPXRoaXMub3B0aW9ucy5mb3JtYXR0ZXIodGhpcy5fc3RhdGUudmFsdWVbMF0pO3RoaXMuX3NldFRleHQodGhpcy50b29sdGlwSW5uZXJfbWluLGspO3ZhciBsPXRoaXMub3B0aW9ucy5mb3JtYXR0ZXIodGhpcy5fc3RhdGUudmFsdWVbMV0pO3RoaXMuX3NldFRleHQodGhpcy50b29sdGlwSW5uZXJfbWF4LGwpLHRoaXMudG9vbHRpcF9taW4uc3R5bGVbdGhpcy5zdHlsZVBvc109YVswXStcIiVcIixcInZlcnRpY2FsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb24/dGhpcy5fY3NzKHRoaXMudG9vbHRpcF9taW4sXCJtYXJnaW4tdG9wXCIsLXRoaXMudG9vbHRpcF9taW4ub2Zmc2V0SGVpZ2h0LzIrXCJweFwiKTp0aGlzLl9jc3ModGhpcy50b29sdGlwX21pbixcIm1hcmdpbi1sZWZ0XCIsLXRoaXMudG9vbHRpcF9taW4ub2Zmc2V0V2lkdGgvMitcInB4XCIpLHRoaXMudG9vbHRpcF9tYXguc3R5bGVbdGhpcy5zdHlsZVBvc109YVsxXStcIiVcIixcInZlcnRpY2FsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb24/dGhpcy5fY3NzKHRoaXMudG9vbHRpcF9tYXgsXCJtYXJnaW4tdG9wXCIsLXRoaXMudG9vbHRpcF9tYXgub2Zmc2V0SGVpZ2h0LzIrXCJweFwiKTp0aGlzLl9jc3ModGhpcy50b29sdGlwX21heCxcIm1hcmdpbi1sZWZ0XCIsLXRoaXMudG9vbHRpcF9tYXgub2Zmc2V0V2lkdGgvMitcInB4XCIpfWVsc2Ugaj10aGlzLm9wdGlvbnMuZm9ybWF0dGVyKHRoaXMuX3N0YXRlLnZhbHVlWzBdKSx0aGlzLl9zZXRUZXh0KHRoaXMudG9vbHRpcElubmVyLGopLHRoaXMudG9vbHRpcC5zdHlsZVt0aGlzLnN0eWxlUG9zXT1hWzBdK1wiJVwiLFwidmVydGljYWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbj90aGlzLl9jc3ModGhpcy50b29sdGlwLFwibWFyZ2luLXRvcFwiLC10aGlzLnRvb2x0aXAub2Zmc2V0SGVpZ2h0LzIrXCJweFwiKTp0aGlzLl9jc3ModGhpcy50b29sdGlwLFwibWFyZ2luLWxlZnRcIiwtdGhpcy50b29sdGlwLm9mZnNldFdpZHRoLzIrXCJweFwiKTtpZihcInZlcnRpY2FsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb24pdGhpcy50cmFja0xvdy5zdHlsZS50b3A9XCIwXCIsdGhpcy50cmFja0xvdy5zdHlsZS5oZWlnaHQ9TWF0aC5taW4oYVswXSxhWzFdKStcIiVcIix0aGlzLnRyYWNrU2VsZWN0aW9uLnN0eWxlLnRvcD1NYXRoLm1pbihhWzBdLGFbMV0pK1wiJVwiLHRoaXMudHJhY2tTZWxlY3Rpb24uc3R5bGUuaGVpZ2h0PU1hdGguYWJzKGFbMF0tYVsxXSkrXCIlXCIsdGhpcy50cmFja0hpZ2guc3R5bGUuYm90dG9tPVwiMFwiLHRoaXMudHJhY2tIaWdoLnN0eWxlLmhlaWdodD0xMDAtTWF0aC5taW4oYVswXSxhWzFdKS1NYXRoLmFicyhhWzBdLWFbMV0pK1wiJVwiO2Vsc2V7dGhpcy50cmFja0xvdy5zdHlsZS5sZWZ0PVwiMFwiLHRoaXMudHJhY2tMb3cuc3R5bGUud2lkdGg9TWF0aC5taW4oYVswXSxhWzFdKStcIiVcIix0aGlzLnRyYWNrU2VsZWN0aW9uLnN0eWxlLmxlZnQ9TWF0aC5taW4oYVswXSxhWzFdKStcIiVcIix0aGlzLnRyYWNrU2VsZWN0aW9uLnN0eWxlLndpZHRoPU1hdGguYWJzKGFbMF0tYVsxXSkrXCIlXCIsdGhpcy50cmFja0hpZ2guc3R5bGUucmlnaHQ9XCIwXCIsdGhpcy50cmFja0hpZ2guc3R5bGUud2lkdGg9MTAwLU1hdGgubWluKGFbMF0sYVsxXSktTWF0aC5hYnMoYVswXS1hWzFdKStcIiVcIjt2YXIgbT10aGlzLnRvb2x0aXBfbWluLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG49dGhpcy50b29sdGlwX21heC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTttLnJpZ2h0Pm4ubGVmdD8odGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy50b29sdGlwX21heCxcInRvcFwiKSx0aGlzLl9hZGRDbGFzcyh0aGlzLnRvb2x0aXBfbWF4LFwiYm90dG9tXCIpLHRoaXMudG9vbHRpcF9tYXguc3R5bGUudG9wPVwiMThweFwiKToodGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy50b29sdGlwX21heCxcImJvdHRvbVwiKSx0aGlzLl9hZGRDbGFzcyh0aGlzLnRvb2x0aXBfbWF4LFwidG9wXCIpLHRoaXMudG9vbHRpcF9tYXguc3R5bGUudG9wPXRoaXMudG9vbHRpcF9taW4uc3R5bGUudG9wKX19LF9yZW1vdmVQcm9wZXJ0eTpmdW5jdGlvbihhLGIpe2Euc3R5bGUucmVtb3ZlUHJvcGVydHk/YS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShiKTphLnN0eWxlLnJlbW92ZUF0dHJpYnV0ZShiKX0sX21vdXNlZG93bjpmdW5jdGlvbihhKXtpZighdGhpcy5fc3RhdGUuZW5hYmxlZClyZXR1cm4hMTt0aGlzLl9zdGF0ZS5vZmZzZXQ9dGhpcy5fb2Zmc2V0KHRoaXMuc2xpZGVyRWxlbSksdGhpcy5fc3RhdGUuc2l6ZT10aGlzLnNsaWRlckVsZW1bdGhpcy5zaXplUG9zXTt2YXIgYj10aGlzLl9nZXRQZXJjZW50YWdlKGEpO2lmKHRoaXMub3B0aW9ucy5yYW5nZSl7dmFyIGM9TWF0aC5hYnModGhpcy5fc3RhdGUucGVyY2VudGFnZVswXS1iKSxkPU1hdGguYWJzKHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMV0tYik7dGhpcy5fc3RhdGUuZHJhZ2dlZD1kPmM/MDoxfWVsc2UgdGhpcy5fc3RhdGUuZHJhZ2dlZD0wO3RoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbdGhpcy5fc3RhdGUuZHJhZ2dlZF09Yix0aGlzLl9sYXlvdXQoKSx0aGlzLnRvdWNoQ2FwYWJsZSYmKGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLm1vdXNlbW92ZSwhMSksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdGhpcy5tb3VzZXVwLCExKSksdGhpcy5tb3VzZW1vdmUmJmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzLm1vdXNlbW92ZSwhMSksdGhpcy5tb3VzZXVwJiZkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXMubW91c2V1cCwhMSksdGhpcy5tb3VzZW1vdmU9dGhpcy5fbW91c2Vtb3ZlLmJpbmQodGhpcyksdGhpcy5tb3VzZXVwPXRoaXMuX21vdXNldXAuYmluZCh0aGlzKSx0aGlzLnRvdWNoQ2FwYWJsZSYmKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLm1vdXNlbW92ZSwhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdGhpcy5tb3VzZXVwLCExKSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMubW91c2Vtb3ZlLCExKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXMubW91c2V1cCwhMSksdGhpcy5fc3RhdGUuaW5EcmFnPSEwO3ZhciBlPXRoaXMuX2NhbGN1bGF0ZVZhbHVlKCk7cmV0dXJuIHRoaXMuX3RyaWdnZXIoXCJzbGlkZVN0YXJ0XCIsZSksdGhpcy5fc2V0RGF0YVZhbChlKSx0aGlzLnNldFZhbHVlKGUsITEsITApLHRoaXMuX3BhdXNlRXZlbnQoYSksdGhpcy5vcHRpb25zLmZvY3VzJiZ0aGlzLl90cmlnZ2VyRm9jdXNPbkhhbmRsZSh0aGlzLl9zdGF0ZS5kcmFnZ2VkKSwhMH0sX3RyaWdnZXJGb2N1c09uSGFuZGxlOmZ1bmN0aW9uKGEpezA9PT1hJiZ0aGlzLmhhbmRsZTEuZm9jdXMoKSwxPT09YSYmdGhpcy5oYW5kbGUyLmZvY3VzKCl9LF9rZXlkb3duOmZ1bmN0aW9uKGEsYil7aWYoIXRoaXMuX3N0YXRlLmVuYWJsZWQpcmV0dXJuITE7dmFyIGM7c3dpdGNoKGIua2V5Q29kZSl7Y2FzZSAzNzpjYXNlIDQwOmM9LTE7YnJlYWs7Y2FzZSAzOTpjYXNlIDM4OmM9MX1pZihjKXtpZih0aGlzLm9wdGlvbnMubmF0dXJhbF9hcnJvd19rZXlzKXt2YXIgZD1cInZlcnRpY2FsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb24mJiF0aGlzLm9wdGlvbnMucmV2ZXJzZWQsZT1cImhvcml6b250YWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiYmdGhpcy5vcHRpb25zLnJldmVyc2VkOyhkfHxlKSYmKGM9LWMpfXZhciBmPXRoaXMuX3N0YXRlLnZhbHVlW2FdK2MqdGhpcy5vcHRpb25zLnN0ZXA7cmV0dXJuIHRoaXMub3B0aW9ucy5yYW5nZSYmKGY9W2E/dGhpcy5fc3RhdGUudmFsdWVbMF06ZixhP2Y6dGhpcy5fc3RhdGUudmFsdWVbMV1dKSx0aGlzLl90cmlnZ2VyKFwic2xpZGVTdGFydFwiLGYpLHRoaXMuX3NldERhdGFWYWwoZiksdGhpcy5zZXRWYWx1ZShmLCEwLCEwKSx0aGlzLl9zZXREYXRhVmFsKGYpLHRoaXMuX3RyaWdnZXIoXCJzbGlkZVN0b3BcIixmKSx0aGlzLl9sYXlvdXQoKSx0aGlzLl9wYXVzZUV2ZW50KGIpLCExfX0sX3BhdXNlRXZlbnQ6ZnVuY3Rpb24oYSl7YS5zdG9wUHJvcGFnYXRpb24mJmEuc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCYmYS5wcmV2ZW50RGVmYXVsdCgpLGEuY2FuY2VsQnViYmxlPSEwLGEucmV0dXJuVmFsdWU9ITF9LF9tb3VzZW1vdmU6ZnVuY3Rpb24oYSl7aWYoIXRoaXMuX3N0YXRlLmVuYWJsZWQpcmV0dXJuITE7dmFyIGI9dGhpcy5fZ2V0UGVyY2VudGFnZShhKTt0aGlzLl9hZGp1c3RQZXJjZW50YWdlRm9yUmFuZ2VTbGlkZXJzKGIpLHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbdGhpcy5fc3RhdGUuZHJhZ2dlZF09Yix0aGlzLl9sYXlvdXQoKTt2YXIgYz10aGlzLl9jYWxjdWxhdGVWYWx1ZSghMCk7cmV0dXJuIHRoaXMuc2V0VmFsdWUoYywhMCwhMCksITF9LF9hZGp1c3RQZXJjZW50YWdlRm9yUmFuZ2VTbGlkZXJzOmZ1bmN0aW9uKGEpe2lmKHRoaXMub3B0aW9ucy5yYW5nZSl7dmFyIGI9dGhpcy5fZ2V0TnVtRGlnaXRzQWZ0ZXJEZWNpbWFsUGxhY2UoYSk7Yj1iP2ItMTowO3ZhciBjPXRoaXMuX2FwcGx5VG9GaXhlZEFuZFBhcnNlRmxvYXQoYSxiKTswPT09dGhpcy5fc3RhdGUuZHJhZ2dlZCYmdGhpcy5fYXBwbHlUb0ZpeGVkQW5kUGFyc2VGbG9hdCh0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdLGIpPGM/KHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMF09dGhpcy5fc3RhdGUucGVyY2VudGFnZVsxXSx0aGlzLl9zdGF0ZS5kcmFnZ2VkPTEpOjE9PT10aGlzLl9zdGF0ZS5kcmFnZ2VkJiZ0aGlzLl9hcHBseVRvRml4ZWRBbmRQYXJzZUZsb2F0KHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMF0sYik+YyYmKHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMV09dGhpcy5fc3RhdGUucGVyY2VudGFnZVswXSx0aGlzLl9zdGF0ZS5kcmFnZ2VkPTApfX0sX21vdXNldXA6ZnVuY3Rpb24oKXtpZighdGhpcy5fc3RhdGUuZW5hYmxlZClyZXR1cm4hMTt0aGlzLnRvdWNoQ2FwYWJsZSYmKGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLm1vdXNlbW92ZSwhMSksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdGhpcy5tb3VzZXVwLCExKSksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMubW91c2Vtb3ZlLCExKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXMubW91c2V1cCwhMSksdGhpcy5fc3RhdGUuaW5EcmFnPSExLHRoaXMuX3N0YXRlLm92ZXI9PT0hMSYmdGhpcy5faGlkZVRvb2x0aXAoKTt2YXIgYT10aGlzLl9jYWxjdWxhdGVWYWx1ZSghMCk7cmV0dXJuIHRoaXMuX2xheW91dCgpLHRoaXMuX3NldERhdGFWYWwoYSksdGhpcy5fdHJpZ2dlcihcInNsaWRlU3RvcFwiLGEpLCExfSxfY2FsY3VsYXRlVmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI7aWYodGhpcy5vcHRpb25zLnJhbmdlPyhiPVt0aGlzLm9wdGlvbnMubWluLHRoaXMub3B0aW9ucy5tYXhdLDAhPT10aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzBdJiYoYlswXT10aGlzLl90b1ZhbHVlKHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMF0pLGJbMF09dGhpcy5fYXBwbHlQcmVjaXNpb24oYlswXSkpLDEwMCE9PXRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMV0mJihiWzFdPXRoaXMuX3RvVmFsdWUodGhpcy5fc3RhdGUucGVyY2VudGFnZVsxXSksYlsxXT10aGlzLl9hcHBseVByZWNpc2lvbihiWzFdKSkpOihiPXRoaXMuX3RvVmFsdWUodGhpcy5fc3RhdGUucGVyY2VudGFnZVswXSksYj1wYXJzZUZsb2F0KGIpLGI9dGhpcy5fYXBwbHlQcmVjaXNpb24oYikpLGEpe2Zvcih2YXIgYz1bYiwxLzBdLGQ9MDtkPHRoaXMub3B0aW9ucy50aWNrcy5sZW5ndGg7ZCsrKXt2YXIgZT1NYXRoLmFicyh0aGlzLm9wdGlvbnMudGlja3NbZF0tYik7ZTw9Y1sxXSYmKGM9W3RoaXMub3B0aW9ucy50aWNrc1tkXSxlXSl9aWYoY1sxXTw9dGhpcy5vcHRpb25zLnRpY2tzX3NuYXBfYm91bmRzKXJldHVybiBjWzBdfXJldHVybiBifSxfYXBwbHlQcmVjaXNpb246ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5vcHRpb25zLnByZWNpc2lvbnx8dGhpcy5fZ2V0TnVtRGlnaXRzQWZ0ZXJEZWNpbWFsUGxhY2UodGhpcy5vcHRpb25zLnN0ZXApO3JldHVybiB0aGlzLl9hcHBseVRvRml4ZWRBbmRQYXJzZUZsb2F0KGEsYil9LF9nZXROdW1EaWdpdHNBZnRlckRlY2ltYWxQbGFjZTpmdW5jdGlvbihhKXt2YXIgYj0oXCJcIithKS5tYXRjaCgvKD86XFwuKFxcZCspKT8oPzpbZUVdKFsrLV0/XFxkKykpPyQvKTtyZXR1cm4gYj9NYXRoLm1heCgwLChiWzFdP2JbMV0ubGVuZ3RoOjApLShiWzJdPytiWzJdOjApKTowfSxfYXBwbHlUb0ZpeGVkQW5kUGFyc2VGbG9hdDpmdW5jdGlvbihhLGIpe3ZhciBjPWEudG9GaXhlZChiKTtyZXR1cm4gcGFyc2VGbG9hdChjKX0sX2dldFBlcmNlbnRhZ2U6ZnVuY3Rpb24oYSl7IXRoaXMudG91Y2hDYXBhYmxlfHxcInRvdWNoc3RhcnRcIiE9PWEudHlwZSYmXCJ0b3VjaG1vdmVcIiE9PWEudHlwZXx8KGE9YS50b3VjaGVzWzBdKTt2YXIgYj1hW3RoaXMubW91c2VQb3NdLGM9dGhpcy5fc3RhdGUub2Zmc2V0W3RoaXMuc3R5bGVQb3NdLGQ9Yi1jLGU9ZC90aGlzLl9zdGF0ZS5zaXplKjEwMDtyZXR1cm4gZT1NYXRoLnJvdW5kKGUvdGhpcy5fc3RhdGUucGVyY2VudGFnZVsyXSkqdGhpcy5fc3RhdGUucGVyY2VudGFnZVsyXSx0aGlzLm9wdGlvbnMucmV2ZXJzZWQmJihlPTEwMC1lKSxNYXRoLm1heCgwLE1hdGgubWluKDEwMCxlKSl9LF92YWxpZGF0ZUlucHV0VmFsdWU6ZnVuY3Rpb24oYSl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGEpcmV0dXJuIGE7aWYoQXJyYXkuaXNBcnJheShhKSlyZXR1cm4gdGhpcy5fdmFsaWRhdGVBcnJheShhKSxhO3Rocm93IG5ldyBFcnJvcihkLmZvcm1hdEludmFsaWRJbnB1dEVycm9yTXNnKGEpKX0sX3ZhbGlkYXRlQXJyYXk6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspe3ZhciBjPWFbYl07aWYoXCJudW1iZXJcIiE9dHlwZW9mIGMpdGhyb3cgbmV3IEVycm9yKGQuZm9ybWF0SW52YWxpZElucHV0RXJyb3JNc2coYykpfX0sX3NldERhdGFWYWw6ZnVuY3Rpb24oYSl7dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIixhKSx0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwidmFsdWVcIixhKSx0aGlzLmVsZW1lbnQudmFsdWU9YX0sX3RyaWdnZXI6ZnVuY3Rpb24oYixjKXtjPWN8fDA9PT1jP2M6dm9pZCAwO3ZhciBkPXRoaXMuZXZlbnRUb0NhbGxiYWNrTWFwW2JdO2lmKGQmJmQubGVuZ3RoKWZvcih2YXIgZT0wO2U8ZC5sZW5ndGg7ZSsrKXt2YXIgZj1kW2VdO2YoYyl9YSYmdGhpcy5fdHJpZ2dlckpRdWVyeUV2ZW50KGIsYyl9LF90cmlnZ2VySlF1ZXJ5RXZlbnQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz17dHlwZTphLHZhbHVlOmJ9O3RoaXMuJGVsZW1lbnQudHJpZ2dlcihjKSx0aGlzLiRzbGlkZXJFbGVtLnRyaWdnZXIoYyl9LF91bmJpbmRKUXVlcnlFdmVudEhhbmRsZXJzOmZ1bmN0aW9uKCl7dGhpcy4kZWxlbWVudC5vZmYoKSx0aGlzLiRzbGlkZXJFbGVtLm9mZigpfSxfc2V0VGV4dDpmdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBhLmlubmVyVGV4dD9hLmlubmVyVGV4dD1iOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnRleHRDb250ZW50JiYoYS50ZXh0Q29udGVudD1iKX0sX3JlbW92ZUNsYXNzOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWIuc3BsaXQoXCIgXCIpLGQ9YS5jbGFzc05hbWUsZT0wO2U8Yy5sZW5ndGg7ZSsrKXt2YXIgZj1jW2VdLGc9bmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIrZitcIig/OlxcXFxzfCQpXCIpO2Q9ZC5yZXBsYWNlKGcsXCIgXCIpfWEuY2xhc3NOYW1lPWQudHJpbSgpfSxfYWRkQ2xhc3M6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9Yi5zcGxpdChcIiBcIiksZD1hLmNsYXNzTmFtZSxlPTA7ZTxjLmxlbmd0aDtlKyspe3ZhciBmPWNbZV0sZz1uZXcgUmVnRXhwKFwiKD86XFxcXHN8XilcIitmK1wiKD86XFxcXHN8JClcIiksaD1nLnRlc3QoZCk7aHx8KGQrPVwiIFwiK2YpfWEuY2xhc3NOYW1lPWQudHJpbSgpfSxfb2Zmc2V0TGVmdDpmdW5jdGlvbihhKXtyZXR1cm4gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0fSxfb2Zmc2V0VG9wOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1hLm9mZnNldFRvcDsoYT1hLm9mZnNldFBhcmVudCkmJiFpc05hTihhLm9mZnNldFRvcCk7KWIrPWEub2Zmc2V0VG9wO3JldHVybiBifSxfb2Zmc2V0OmZ1bmN0aW9uKGEpe3JldHVybntsZWZ0OnRoaXMuX29mZnNldExlZnQoYSksdG9wOnRoaXMuX29mZnNldFRvcChhKX19LF9jc3M6ZnVuY3Rpb24oYixjLGQpe2lmKGEpYS5zdHlsZShiLGMsZCk7ZWxzZXt2YXIgZT1jLnJlcGxhY2UoL14tbXMtLyxcIm1zLVwiKS5yZXBsYWNlKC8tKFtcXGRhLXpdKS9naSxmdW5jdGlvbihhLGIpe3JldHVybiBiLnRvVXBwZXJDYXNlKCl9KTtiLnN0eWxlW2VdPWR9fSxfdG9WYWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5vcHRpb25zLnNjYWxlLnRvVmFsdWUuYXBwbHkodGhpcyxbYV0pfSxfdG9QZXJjZW50YWdlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm9wdGlvbnMuc2NhbGUudG9QZXJjZW50YWdlLmFwcGx5KHRoaXMsW2FdKX0sX3NldFRvb2x0aXBQb3NpdGlvbjpmdW5jdGlvbigpe3ZhciBhPVt0aGlzLnRvb2x0aXAsdGhpcy50b29sdGlwX21pbix0aGlzLnRvb2x0aXBfbWF4XTtpZihcInZlcnRpY2FsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb24pe3ZhciBiPXRoaXMub3B0aW9ucy50b29sdGlwX3Bvc2l0aW9ufHxcInJpZ2h0XCIsYz1cImxlZnRcIj09PWI/XCJyaWdodFwiOlwibGVmdFwiO2EuZm9yRWFjaChmdW5jdGlvbihhKXt0aGlzLl9hZGRDbGFzcyhhLGIpLGEuc3R5bGVbY109XCIxMDAlXCJ9LmJpbmQodGhpcykpfWVsc2UgYS5mb3JFYWNoKFwiYm90dG9tXCI9PT10aGlzLm9wdGlvbnMudG9vbHRpcF9wb3NpdGlvbj9mdW5jdGlvbihhKXt0aGlzLl9hZGRDbGFzcyhhLFwiYm90dG9tXCIpLGEuc3R5bGUudG9wPVwiMjJweFwifS5iaW5kKHRoaXMpOmZ1bmN0aW9uKGEpe3RoaXMuX2FkZENsYXNzKGEsXCJ0b3BcIiksYS5zdHlsZS50b3A9LXRoaXMudG9vbHRpcC5vdXRlckhlaWdodC0xNCtcInB4XCJ9LmJpbmQodGhpcykpfX0sYSl7dmFyIGY9YS5mbi5zbGlkZXI/XCJib290c3RyYXBTbGlkZXJcIjpcInNsaWRlclwiO2EuYnJpZGdldChmLGIpfX0oYSksYn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWJyYXJpZXMvYW5ndWxhci1ib290c3RyYXAtc2xpZGVyL2Jvb3RzdHJhcC1zbGlkZXIubWluLmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB0aGlzW1wiJFwiXTsgfSgpKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwiJFwiXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHVubGVzcyBhbWRNb2R1bGVJZCBpcyBzZXRcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAocm9vdFsnU2lnbmF0dXJlUGFkJ10gPSBmYWN0b3J5KCkpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgIC8vIGxpa2UgTm9kZS5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICByb290WydTaWduYXR1cmVQYWQnXSA9IGZhY3RvcnkoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbi8qIVxuICogU2lnbmF0dXJlIFBhZCB2MS40LjBcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvc2lnbmF0dXJlX3BhZFxuICpcbiAqIENvcHlyaWdodCAyMDE1IFN6eW1vbiBOb3dha1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKlxuICogVGhlIG1haW4gaWRlYSBhbmQgc29tZSBwYXJ0cyBvZiB0aGUgY29kZSAoZS5nLiBkcmF3aW5nIHZhcmlhYmxlIHdpZHRoIELDqXppZXIgY3VydmUpIGFyZSB0YWtlbiBmcm9tOlxuICogaHR0cDovL2Nvcm5lci5zcXVhcmV1cC5jb20vMjAxMi8wNy9zbW9vdGhlci1zaWduYXR1cmVzLmh0bWxcbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBpbnRlcnBvbGF0aW9uIHVzaW5nIGN1YmljIELDqXppZXIgY3VydmVzIGlzIHRha2VuIGZyb206XG4gKiBodHRwOi8vYmVua25vd3Njb2RlLndvcmRwcmVzcy5jb20vMjAxMi8wOS8xNC9wYXRoLWludGVycG9sYXRpb24tdXNpbmctY3ViaWMtYmV6aWVyLWFuZC1jb250cm9sLXBvaW50LWVzdGltYXRpb24taW4tamF2YXNjcmlwdFxuICpcbiAqIEFsZ29yaXRobSBmb3IgYXBwcm94aW1hdGVkIGxlbmd0aCBvZiBhIELDqXppZXIgY3VydmUgaXMgdGFrZW4gZnJvbTpcbiAqIGh0dHA6Ly93d3cubGVtb2RhLm5ldC9tYXRocy9iZXppZXItbGVuZ3RoL2luZGV4Lmh0bWxcbiAqXG4gKi9cbnZhciBTaWduYXR1cmVQYWQgPSAoZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgU2lnbmF0dXJlUGFkID0gZnVuY3Rpb24gKGNhbnZhcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBvcHRzID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLnZlbG9jaXR5RmlsdGVyV2VpZ2h0ID0gb3B0cy52ZWxvY2l0eUZpbHRlcldlaWdodCB8fCAwLjc7XG4gICAgICAgIHRoaXMubWluV2lkdGggPSBvcHRzLm1pbldpZHRoIHx8IDAuNTtcbiAgICAgICAgdGhpcy5tYXhXaWR0aCA9IG9wdHMubWF4V2lkdGggfHwgMi41O1xuICAgICAgICB0aGlzLmRvdFNpemUgPSBvcHRzLmRvdFNpemUgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm1pbldpZHRoICsgdGhpcy5tYXhXaWR0aCkgLyAyO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBlbkNvbG9yID0gb3B0cy5wZW5Db2xvciB8fCBcImJsYWNrXCI7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3IgfHwgXCJyZ2JhKDAsMCwwLDApXCI7XG4gICAgICAgIHRoaXMub25FbmQgPSBvcHRzLm9uRW5kO1xuICAgICAgICB0aGlzLm9uQmVnaW4gPSBvcHRzLm9uQmVnaW47XG5cbiAgICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLl9jdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgLy8gd2UgbmVlZCBhZGQgdGhlc2UgaW5saW5lIHNvIHRoZXkgYXJlIGF2YWlsYWJsZSB0byB1bmJpbmQgd2hpbGUgc3RpbGwgaGF2aW5nXG4gICAgICAgIC8vICBhY2Nlc3MgdG8gJ3NlbGYnIHdlIGNvdWxkIHVzZSBfLmJpbmQgYnV0IGl0J3Mgbm90IHdvcnRoIGFkZGluZyBhIGRlcGVuZGVuY3lcbiAgICAgICAgdGhpcy5faGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9tb3VzZUJ1dHRvbkRvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGYuX3N0cm9rZUJlZ2luKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9tb3VzZUJ1dHRvbkRvd24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9zdHJva2VVcGRhdGUoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC53aGljaCA9PT0gMSAmJiBzZWxmLl9tb3VzZUJ1dHRvbkRvd24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9tb3VzZUJ1dHRvbkRvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZWxmLl9zdHJva2VFbmQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgc2VsZi5fc3Ryb2tlQmVnaW4odG91Y2gpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmcuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgICAgIHNlbGYuX3N0cm9rZVVwZGF0ZSh0b3VjaCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faGFuZGxlVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB3YXNDYW52YXNUb3VjaGVkID0gZXZlbnQudGFyZ2V0ID09PSBzZWxmLl9jYW52YXM7XG4gICAgICAgICAgICBpZiAod2FzQ2FudmFzVG91Y2hlZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX3N0cm9rZUVuZChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faGFuZGxlTW91c2VFdmVudHMoKTtcbiAgICAgICAgdGhpcy5faGFuZGxlVG91Y2hFdmVudHMoKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eCxcbiAgICAgICAgICAgIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUudG9EYXRhVVJMID0gZnVuY3Rpb24gKGltYWdlVHlwZSwgcXVhbGl0eSkge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuICAgICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTC5hcHBseShjYW52YXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuZnJvbURhdGFVUkwgPSBmdW5jdGlvbiAoZGF0YVVybCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBpbWFnZSA9IG5ldyBJbWFnZSgpLFxuICAgICAgICAgICAgcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICAgICAgd2lkdGggPSB0aGlzLl9jYW52YXMud2lkdGggLyByYXRpbyxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQgLyByYXRpbztcblxuICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICBpbWFnZS5zcmMgPSBkYXRhVXJsO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLl9jdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faXNFbXB0eSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9zdHJva2VVcGRhdGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5fY3JlYXRlUG9pbnQoZXZlbnQpO1xuICAgICAgICB0aGlzLl9hZGRQb2ludChwb2ludCk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3N0cm9rZUJlZ2luID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgIHRoaXMuX3N0cm9rZVVwZGF0ZShldmVudCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbkJlZ2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uQmVnaW4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3N0cm9rZURyYXcgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eCxcbiAgICAgICAgICAgIGRvdFNpemUgPSB0eXBlb2YodGhpcy5kb3RTaXplKSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuZG90U2l6ZSgpIDogdGhpcy5kb3RTaXplO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fZHJhd1BvaW50KHBvaW50LngsIHBvaW50LnksIGRvdFNpemUpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3N0cm9rZUVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgY2FuRHJhd0N1cnZlID0gdGhpcy5wb2ludHMubGVuZ3RoID4gMixcbiAgICAgICAgICAgIHBvaW50ID0gdGhpcy5wb2ludHNbMF07XG5cbiAgICAgICAgaWYgKCFjYW5EcmF3Q3VydmUgJiYgcG9pbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZURyYXcocG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbkVuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5vbkVuZChldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5faGFuZGxlTW91c2VFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5fbW91c2VCdXR0b25Eb3duID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5faGFuZGxlTW91c2VEb3duKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5faGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5faGFuZGxlTW91c2VVcCk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2hhbmRsZVRvdWNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gUGFzcyB0b3VjaCBldmVudHMgdG8gY2FudmFzIGVsZW1lbnQgb24gbW9iaWxlIElFLlxuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUubXNUb3VjaEFjdGlvbiA9ICdub25lJztcblxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5faGFuZGxlVG91Y2hTdGFydCk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX2hhbmRsZVRvdWNoTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl9oYW5kbGVUb3VjaEVuZCk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9oYW5kbGVNb3VzZURvd24pO1xuICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9oYW5kbGVNb3VzZVVwKTtcblxuICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5faGFuZGxlVG91Y2hTdGFydCk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX2hhbmRsZVRvdWNoTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl9oYW5kbGVUb3VjaEVuZCk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRW1wdHk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9sYXN0VmVsb2NpdHkgPSAwO1xuICAgICAgICB0aGlzLl9sYXN0V2lkdGggPSAodGhpcy5taW5XaWR0aCArIHRoaXMubWF4V2lkdGgpIC8gMjtcbiAgICAgICAgdGhpcy5faXNFbXB0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSB0aGlzLnBlbkNvbG9yO1xuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9jcmVhdGVQb2ludCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgICAgICBldmVudC5jbGllbnRZIC0gcmVjdC50b3BcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fYWRkUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgYzIsIGMzLFxuICAgICAgICAgICAgY3VydmUsIHRtcDtcblxuICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG5cbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAvLyBUbyByZWR1Y2UgdGhlIGluaXRpYWwgbGFnIG1ha2UgaXQgd29yayB3aXRoIDMgcG9pbnRzXG4gICAgICAgICAgICAvLyBieSBjb3B5aW5nIHRoZSBmaXJzdCBwb2ludCB0byB0aGUgYmVnaW5uaW5nLlxuICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDMpIHBvaW50cy51bnNoaWZ0KHBvaW50c1swXSk7XG5cbiAgICAgICAgICAgIHRtcCA9IHRoaXMuX2NhbGN1bGF0ZUN1cnZlQ29udHJvbFBvaW50cyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdKTtcbiAgICAgICAgICAgIGMyID0gdG1wLmMyO1xuICAgICAgICAgICAgdG1wID0gdGhpcy5fY2FsY3VsYXRlQ3VydmVDb250cm9sUG9pbnRzKHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgYzMgPSB0bXAuYzE7XG4gICAgICAgICAgICBjdXJ2ZSA9IG5ldyBCZXppZXIocG9pbnRzWzFdLCBjMiwgYzMsIHBvaW50c1syXSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRDdXJ2ZShjdXJ2ZSk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgZWxlbWVudCBmcm9tIHRoZSBsaXN0LFxuICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSBhbHdheXMgaGF2ZSBubyBtb3JlIHRoYW4gNCBwb2ludHMgaW4gcG9pbnRzIGFycmF5LlxuICAgICAgICAgICAgcG9pbnRzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fY2FsY3VsYXRlQ3VydmVDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKHMxLCBzMiwgczMpIHtcbiAgICAgICAgdmFyIGR4MSA9IHMxLnggLSBzMi54LCBkeTEgPSBzMS55IC0gczIueSxcbiAgICAgICAgICAgIGR4MiA9IHMyLnggLSBzMy54LCBkeTIgPSBzMi55IC0gczMueSxcblxuICAgICAgICAgICAgbTEgPSB7eDogKHMxLnggKyBzMi54KSAvIDIuMCwgeTogKHMxLnkgKyBzMi55KSAvIDIuMH0sXG4gICAgICAgICAgICBtMiA9IHt4OiAoczIueCArIHMzLngpIC8gMi4wLCB5OiAoczIueSArIHMzLnkpIC8gMi4wfSxcblxuICAgICAgICAgICAgbDEgPSBNYXRoLnNxcnQoZHgxKmR4MSArIGR5MSpkeTEpLFxuICAgICAgICAgICAgbDIgPSBNYXRoLnNxcnQoZHgyKmR4MiArIGR5MipkeTIpLFxuXG4gICAgICAgICAgICBkeG0gPSAobTEueCAtIG0yLngpLFxuICAgICAgICAgICAgZHltID0gKG0xLnkgLSBtMi55KSxcblxuICAgICAgICAgICAgayA9IGwyIC8gKGwxICsgbDIpLFxuICAgICAgICAgICAgY20gPSB7eDogbTIueCArIGR4bSprLCB5OiBtMi55ICsgZHltKmt9LFxuXG4gICAgICAgICAgICB0eCA9IHMyLnggLSBjbS54LFxuICAgICAgICAgICAgdHkgPSBzMi55IC0gY20ueTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzE6IG5ldyBQb2ludChtMS54ICsgdHgsIG0xLnkgKyB0eSksXG4gICAgICAgICAgICBjMjogbmV3IFBvaW50KG0yLnggKyB0eCwgbTIueSArIHR5KVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9hZGRDdXJ2ZSA9IGZ1bmN0aW9uIChjdXJ2ZSkge1xuICAgICAgICB2YXIgc3RhcnRQb2ludCA9IGN1cnZlLnN0YXJ0UG9pbnQsXG4gICAgICAgICAgICBlbmRQb2ludCA9IGN1cnZlLmVuZFBvaW50LFxuICAgICAgICAgICAgdmVsb2NpdHksIG5ld1dpZHRoO1xuXG4gICAgICAgIHZlbG9jaXR5ID0gZW5kUG9pbnQudmVsb2NpdHlGcm9tKHN0YXJ0UG9pbnQpO1xuICAgICAgICB2ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHlGaWx0ZXJXZWlnaHQgKiB2ZWxvY2l0eVxuICAgICAgICAgICAgKyAoMSAtIHRoaXMudmVsb2NpdHlGaWx0ZXJXZWlnaHQpICogdGhpcy5fbGFzdFZlbG9jaXR5O1xuXG4gICAgICAgIG5ld1dpZHRoID0gdGhpcy5fc3Ryb2tlV2lkdGgodmVsb2NpdHkpO1xuICAgICAgICB0aGlzLl9kcmF3Q3VydmUoY3VydmUsIHRoaXMuX2xhc3RXaWR0aCwgbmV3V2lkdGgpO1xuXG4gICAgICAgIHRoaXMuX2xhc3RWZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgICAgICB0aGlzLl9sYXN0V2lkdGggPSBuZXdXaWR0aDtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fZHJhd1BvaW50ID0gZnVuY3Rpb24gKHgsIHksIHNpemUpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICBjdHguYXJjKHgsIHksIHNpemUsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2lzRW1wdHkgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fZHJhd0N1cnZlID0gZnVuY3Rpb24gKGN1cnZlLCBzdGFydFdpZHRoLCBlbmRXaWR0aCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LFxuICAgICAgICAgICAgd2lkdGhEZWx0YSA9IGVuZFdpZHRoIC0gc3RhcnRXaWR0aCxcbiAgICAgICAgICAgIGRyYXdTdGVwcywgd2lkdGgsIGksIHQsIHR0LCB0dHQsIHUsIHV1LCB1dXUsIHgsIHk7XG5cbiAgICAgICAgZHJhd1N0ZXBzID0gTWF0aC5mbG9vcihjdXJ2ZS5sZW5ndGgoKSk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRyYXdTdGVwczsgaSsrKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIEJlemllciAoeCwgeSkgY29vcmRpbmF0ZSBmb3IgdGhpcyBzdGVwLlxuICAgICAgICAgICAgdCA9IGkgLyBkcmF3U3RlcHM7XG4gICAgICAgICAgICB0dCA9IHQgKiB0O1xuICAgICAgICAgICAgdHR0ID0gdHQgKiB0O1xuICAgICAgICAgICAgdSA9IDEgLSB0O1xuICAgICAgICAgICAgdXUgPSB1ICogdTtcbiAgICAgICAgICAgIHV1dSA9IHV1ICogdTtcblxuICAgICAgICAgICAgeCA9IHV1dSAqIGN1cnZlLnN0YXJ0UG9pbnQueDtcbiAgICAgICAgICAgIHggKz0gMyAqIHV1ICogdCAqIGN1cnZlLmNvbnRyb2wxLng7XG4gICAgICAgICAgICB4ICs9IDMgKiB1ICogdHQgKiBjdXJ2ZS5jb250cm9sMi54O1xuICAgICAgICAgICAgeCArPSB0dHQgKiBjdXJ2ZS5lbmRQb2ludC54O1xuXG4gICAgICAgICAgICB5ID0gdXV1ICogY3VydmUuc3RhcnRQb2ludC55O1xuICAgICAgICAgICAgeSArPSAzICogdXUgKiB0ICogY3VydmUuY29udHJvbDEueTtcbiAgICAgICAgICAgIHkgKz0gMyAqIHUgKiB0dCAqIGN1cnZlLmNvbnRyb2wyLnk7XG4gICAgICAgICAgICB5ICs9IHR0dCAqIGN1cnZlLmVuZFBvaW50Lnk7XG5cbiAgICAgICAgICAgIHdpZHRoID0gc3RhcnRXaWR0aCArIHR0dCAqIHdpZHRoRGVsdGE7XG4gICAgICAgICAgICB0aGlzLl9kcmF3UG9pbnQoeCwgeSwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlV2lkdGggPSBmdW5jdGlvbiAodmVsb2NpdHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubWF4V2lkdGggLyAodmVsb2NpdHkgKyAxKSwgdGhpcy5taW5XaWR0aCk7XG4gICAgfTtcblxuXG4gICAgdmFyIFBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHRpbWUpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy50aW1lID0gdGltZSB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xuXG4gICAgUG9pbnQucHJvdG90eXBlLnZlbG9jaXR5RnJvbSA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudGltZSAhPT0gc3RhcnQudGltZSkgPyB0aGlzLmRpc3RhbmNlVG8oc3RhcnQpIC8gKHRoaXMudGltZSAtIHN0YXJ0LnRpbWUpIDogMTtcbiAgICB9O1xuXG4gICAgUG9pbnQucHJvdG90eXBlLmRpc3RhbmNlVG8gPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSBzdGFydC54LCAyKSArIE1hdGgucG93KHRoaXMueSAtIHN0YXJ0LnksIDIpKTtcbiAgICB9O1xuXG4gICAgdmFyIEJlemllciA9IGZ1bmN0aW9uIChzdGFydFBvaW50LCBjb250cm9sMSwgY29udHJvbDIsIGVuZFBvaW50KSB7XG4gICAgICAgIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQ7XG4gICAgICAgIHRoaXMuY29udHJvbDEgPSBjb250cm9sMTtcbiAgICAgICAgdGhpcy5jb250cm9sMiA9IGNvbnRyb2wyO1xuICAgICAgICB0aGlzLmVuZFBvaW50ID0gZW5kUG9pbnQ7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgYXBwcm94aW1hdGVkIGxlbmd0aC5cbiAgICBCZXppZXIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXBzID0gMTAsXG4gICAgICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICAgICAgaSwgdCwgY3gsIGN5LCBweCwgcHksIHhkaWZmLCB5ZGlmZjtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IHN0ZXBzOyBpKyspIHtcbiAgICAgICAgICAgIHQgPSBpIC8gc3RlcHM7XG4gICAgICAgICAgICBjeCA9IHRoaXMuX3BvaW50KHQsIHRoaXMuc3RhcnRQb2ludC54LCB0aGlzLmNvbnRyb2wxLngsIHRoaXMuY29udHJvbDIueCwgdGhpcy5lbmRQb2ludC54KTtcbiAgICAgICAgICAgIGN5ID0gdGhpcy5fcG9pbnQodCwgdGhpcy5zdGFydFBvaW50LnksIHRoaXMuY29udHJvbDEueSwgdGhpcy5jb250cm9sMi55LCB0aGlzLmVuZFBvaW50LnkpO1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgeGRpZmYgPSBjeCAtIHB4O1xuICAgICAgICAgICAgICAgIHlkaWZmID0gY3kgLSBweTtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gTWF0aC5zcXJ0KHhkaWZmICogeGRpZmYgKyB5ZGlmZiAqIHlkaWZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHB4ID0gY3g7XG4gICAgICAgICAgICBweSA9IGN5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfTtcblxuICAgIEJlemllci5wcm90b3R5cGUuX3BvaW50ID0gZnVuY3Rpb24gKHQsIHN0YXJ0LCBjMSwgYzIsIGVuZCkge1xuICAgICAgICByZXR1cm4gICAgICAgICAgc3RhcnQgKiAoMS4wIC0gdCkgKiAoMS4wIC0gdCkgICogKDEuMCAtIHQpXG4gICAgICAgICAgICAgICArIDMuMCAqICBjMSAgICAqICgxLjAgLSB0KSAqICgxLjAgLSB0KSAgKiB0XG4gICAgICAgICAgICAgICArIDMuMCAqICBjMiAgICAqICgxLjAgLSB0KSAqIHQgICAgICAgICAgKiB0XG4gICAgICAgICAgICAgICArICAgICAgICBlbmQgICAqIHQgICAgICAgICAqIHQgICAgICAgICAgKiB0O1xuICAgIH07XG5cbiAgICByZXR1cm4gU2lnbmF0dXJlUGFkO1xufSkoZG9jdW1lbnQpO1xuXG5yZXR1cm4gU2lnbmF0dXJlUGFkO1xuXG59KSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaWduYXR1cmVfcGFkL3NpZ25hdHVyZV9wYWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBhdXRvc2F2ZSA9IHJlcXVpcmUoJy4vYXV0b3NhdmUvYXV0b3NhdmUnKTtcclxuZXhwb3J0cy5hdXRvc2F2ZSA9IGF1dG9zYXZlO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuYmVoYXZpb3JzJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXHJcbiAgICBhdXRvc2F2ZS5tb2R1bGVOYW1lLFxyXG5dKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVoYXZpb3JzLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2JlaGF2aW9ycy9iZWhhdmlvcnMubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX2F1dG9zYXZlID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmF1dG9zYXZlO1xyXG52YXIgX19wYXJlbnRDaGlsZCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wYXJlbnRDaGlsZEJlaGF2aW9yO1xyXG52YXIgX19vYmplY3RVdGlsaXR5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIF9fYXV0b3NhdmVBY3Rpb24gPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuYXV0b3NhdmVBY3Rpb247XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5iZWhhdmlvcnMuYXV0b3NhdmUnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxBdXRvc2F2ZSc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnQXV0b3NhdmVDb250cm9sbGVyJztcclxudmFyIEF1dG9zYXZlQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBdXRvc2F2ZUNvbnRyb2xsZXIoJHNjb3BlLCAkYXR0cnMsICRwYXJzZSwgJGVsZW1lbnQsICR0aW1lb3V0LCBhdXRvc2F2ZUZhY3RvcnksIHBhcmVudENoaWxkQmVoYXZpb3IsIG9iamVjdFV0aWxpdHkpIHtcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy4kdGltZW91dCA9ICR0aW1lb3V0O1xyXG4gICAgICAgIHZhciBjb250ZW50Rm9ybSA9ICRlbGVtZW50LmNvbnRyb2xsZXIoJ2Zvcm0nKTtcclxuICAgICAgICB2YXIgaGFzVmFsaWRhdG9yID0gb2JqZWN0VXRpbGl0eS5pc051bGxPcldoaXRlc3BhY2UoJGF0dHJzLnZhbGlkYXRlKSA9PT0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHZhbGlkYXRlRXhwcmVzc2lvbiA9ICRwYXJzZSgkYXR0cnMudmFsaWRhdGUpO1xyXG4gICAgICAgIHZhciB2YWxpZGF0ZTtcclxuICAgICAgICBpZiAoaGFzVmFsaWRhdG9yKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXhwcmVzc2lvbigkc2NvcGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2F2ZUV4cHJlc3Npb24gPSAkcGFyc2UoJGF0dHJzLnNhdmUpO1xyXG4gICAgICAgIHZhciBzYXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2F2ZUV4cHJlc3Npb24oJHNjb3BlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBkZWJvdW5jZSA9ICRwYXJzZSgkYXR0cnMuZGVib3VuY2VEdXJhdGlvbikoJHNjb3BlKTtcclxuICAgICAgICB0aGlzLmF1dG9zYXZlID0gYXV0b3NhdmVGYWN0b3J5LmdldEluc3RhbmNlKHtcclxuICAgICAgICAgICAgc2F2ZTogc2F2ZSxcclxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlLFxyXG4gICAgICAgICAgICBjb250ZW50Rm9ybTogY29udGVudEZvcm0sXHJcbiAgICAgICAgICAgIGRlYm91bmNlRHVyYXRpb246IGRlYm91bmNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBiZWhhdmlvciA9IHtcclxuICAgICAgICAgICAgYXV0b3NhdmU6IHRoaXMuYXV0b3NhdmUuYXV0b3NhdmUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyByZWdpc3RlciBhdXRvc2F2ZSBiZWhhdmlvciBhbmQgYXNzaWduIHRoZSB2YWx1ZSBiYWNrIHRvIHRoZSBwYXJlbnRcclxuICAgICAgICB2YXIgY2hpbGRMaW5rID0gJHBhcnNlKCRhdHRycy5ybEF1dG9zYXZlKSgkc2NvcGUpO1xyXG4gICAgICAgIHBhcmVudENoaWxkQmVoYXZpb3IucmVnaXN0ZXJDaGlsZEJlaGF2aW9yKGNoaWxkTGluaywgYmVoYXZpb3IpO1xyXG4gICAgfVxyXG4gICAgQXV0b3NhdmVDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsXHJcbiAgICAgICAgJyRhdHRycycsXHJcbiAgICAgICAgJyRwYXJzZScsXHJcbiAgICAgICAgJyRlbGVtZW50JyxcclxuICAgICAgICAnJHRpbWVvdXQnLFxyXG4gICAgICAgIF9fYXV0b3NhdmUuZmFjdG9yeU5hbWUsXHJcbiAgICAgICAgX19wYXJlbnRDaGlsZC5zZXJ2aWNlTmFtZSxcclxuICAgICAgICBfX29iamVjdFV0aWxpdHkuc2VydmljZU5hbWUsXHJcbiAgICAgICAgX19hdXRvc2F2ZUFjdGlvbi5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gQXV0b3NhdmVDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkF1dG9zYXZlQ29udHJvbGxlciA9IEF1dG9zYXZlQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gYXV0b3NhdmUoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICAgICAgcmVxdWlyZTogWydybEF1dG9zYXZlJywgJz9uZ0Zvcm0nXSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNvbnRyb2xsZXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBhdXRvc2F2ZUNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1swXTtcclxuICAgICAgICAgICAgYXV0b3NhdmVDb250cm9sbGVyLmF1dG9zYXZlLnNldENoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9uKCdrZXl1cCcsIHNjb3BlLiRhcHBseShjYWxsYmFjaykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZigna2V5dXAnKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5hdXRvc2F2ZSA9IGF1dG9zYXZlO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIF9fYXV0b3NhdmUubW9kdWxlTmFtZSxcclxuICAgIF9fYXV0b3NhdmVBY3Rpb24ubW9kdWxlTmFtZSxcclxuICAgIF9fb2JqZWN0VXRpbGl0eS5tb2R1bGVOYW1lLFxyXG4gICAgX19wYXJlbnRDaGlsZC5tb2R1bGVOYW1lLFxyXG5dKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGF1dG9zYXZlKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgQXV0b3NhdmVDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0b3NhdmUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9iZWhhdmlvcnMvYXV0b3NhdmUvYXV0b3NhdmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHRoaXNbXCJybF91dGlsaXRpZXNcIl07IH0oKSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcInJsX3V0aWxpdGllc1wiXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBhdXRvc2F2ZURpYWxvZ0Zvb3RlciA9IHJlcXVpcmUoJy4vYXV0b3NhdmVEaWFsb2dGb290ZXIvYXV0b3NhdmVEaWFsb2dGb290ZXInKTtcclxuZXhwb3J0cy5hdXRvc2F2ZURpYWxvZ0Zvb3RlciA9IGF1dG9zYXZlRGlhbG9nRm9vdGVyO1xyXG52YXIgYnVzeSA9IHJlcXVpcmUoJy4vYnVzeS9idXN5Jyk7XHJcbmV4cG9ydHMuYnVzeSA9IGJ1c3k7XHJcbnZhciBidXR0b25Bc3luYyA9IHJlcXVpcmUoJy4vYnV0dG9uQXN5bmMvYnV0dG9uQXN5bmMnKTtcclxuZXhwb3J0cy5idXR0b25Bc3luYyA9IGJ1dHRvbkFzeW5jO1xyXG52YXIgYnV0dG9uVG9nZ2xlID0gcmVxdWlyZSgnLi9idXR0b25Ub2dnbGUvYnV0dG9uVG9nZ2xlJyk7XHJcbmV4cG9ydHMuYnV0dG9uVG9nZ2xlID0gYnV0dG9uVG9nZ2xlO1xyXG52YXIgY2FyZENvbnRhaW5lciA9IHJlcXVpcmUoJy4vY2FyZENvbnRhaW5lci9jYXJkQ29udGFpbmVyLm1vZHVsZScpO1xyXG5leHBvcnRzLmNhcmRDb250YWluZXIgPSBjYXJkQ29udGFpbmVyO1xyXG52YXIgY29tbWFMaXN0ID0gcmVxdWlyZSgnLi9jb21tYUxpc3QvY29tbWFMaXN0Jyk7XHJcbmV4cG9ydHMuY29tbWFMaXN0ID0gY29tbWFMaXN0O1xyXG52YXIgZGF0ZVRpbWUgPSByZXF1aXJlKCcuL2RhdGVUaW1lL2RhdGVUaW1lJyk7XHJcbmV4cG9ydHMuZGF0ZVRpbWUgPSBkYXRlVGltZTtcclxudmFyIGdlbmVyaWNDb250YWluZXIgPSByZXF1aXJlKCcuL2dlbmVyaWNDb250YWluZXIvZ2VuZXJpY0NvbnRhaW5lcicpO1xyXG5leHBvcnRzLmdlbmVyaWNDb250YWluZXIgPSBnZW5lcmljQ29udGFpbmVyO1xyXG52YXIgbGF6eUxvYWQgPSByZXF1aXJlKCcuL2xhenlMb2FkL2xhenlMb2FkJyk7XHJcbmV4cG9ydHMubGF6eUxvYWQgPSBsYXp5TG9hZDtcclxudmFyIGxvbmdDbGlja0J1dHRvbiA9IHJlcXVpcmUoJy4vbG9uZ0NsaWNrQnV0dG9uL2xvbmdDbGlja0J1dHRvbicpO1xyXG5leHBvcnRzLmxvbmdDbGlja0J1dHRvbiA9IGxvbmdDbGlja0J1dHRvbjtcclxudmFyIG1lc3NhZ2VMb2cgPSByZXF1aXJlKCcuL21lc3NhZ2VMb2cvbWVzc2FnZUxvZy5tb2R1bGUnKTtcclxuZXhwb3J0cy5tZXNzYWdlTG9nID0gbWVzc2FnZUxvZztcclxudmFyIG11bHRpU3RlcEluZGljYXRvciA9IHJlcXVpcmUoJy4vbXVsdGlTdGVwSW5kaWNhdG9yL211bHRpU3RlcEluZGljYXRvcicpO1xyXG5leHBvcnRzLm11bHRpU3RlcEluZGljYXRvciA9IG11bHRpU3RlcEluZGljYXRvcjtcclxudmFyIHJhZGlvID0gcmVxdWlyZSgnLi9yYWRpby9yYWRpby5tb2R1bGUnKTtcclxuZXhwb3J0cy5yYWRpbyA9IHJhZGlvO1xyXG52YXIgcmF0aW5nQmFyID0gcmVxdWlyZSgnLi9yYXRpbmdCYXIvcmF0aW5nQmFyJyk7XHJcbmV4cG9ydHMucmF0aW5nQmFyID0gcmF0aW5nQmFyO1xyXG52YXIgcmVzcG9uc2l2ZUNhcmRHcmlkID0gcmVxdWlyZSgnLi9yZXNwb25zaXZlQ2FyZEdyaWQvcmVzcG9uc2l2ZUNhcmRHcmlkLm1vZHVsZScpO1xyXG5leHBvcnRzLnJlc3BvbnNpdmVDYXJkR3JpZCA9IHJlc3BvbnNpdmVDYXJkR3JpZDtcclxudmFyIHJpY2hUZXh0RWRpdG9yID0gcmVxdWlyZSgnLi9yaWNoVGV4dEVkaXRvci9yaWNoVGV4dEVkaXRvcicpO1xyXG5leHBvcnRzLnJpY2hUZXh0RWRpdG9yID0gcmljaFRleHRFZGl0b3I7XHJcbnZhciBzaWduYXR1cmVQYWQgPSByZXF1aXJlKCcuL3NpZ25hdHVyZVBhZC9zaWduYXR1cmVQYWQnKTtcclxuZXhwb3J0cy5zaWduYXR1cmVQYWQgPSBzaWduYXR1cmVQYWQ7XHJcbnZhciBzaW1wbGVDYXJkTGlzdCA9IHJlcXVpcmUoJy4vc2ltcGxlQ2FyZExpc3Qvc2ltcGxlQ2FyZExpc3QubW9kdWxlJyk7XHJcbmV4cG9ydHMuc2ltcGxlQ2FyZExpc3QgPSBzaW1wbGVDYXJkTGlzdDtcclxudmFyIHNwaW5uZXIgPSByZXF1aXJlKCcuL3NwaW5uZXIvc3Bpbm5lcicpO1xyXG5leHBvcnRzLnNwaW5uZXIgPSBzcGlubmVyO1xyXG52YXIgc3RyaW5nV2l0aFdhdGVybWFyayA9IHJlcXVpcmUoJy4vc3RyaW5nV2l0aFdhdGVybWFyay9zdHJpbmdXaXRoV2F0ZXJtYXJrJyk7XHJcbmV4cG9ydHMuc3RyaW5nV2l0aFdhdGVybWFyayA9IHN0cmluZ1dpdGhXYXRlcm1hcms7XHJcbnZhciB0eXBlYWhlYWQgPSByZXF1aXJlKCcuL3R5cGVhaGVhZC90eXBlYWhlYWQnKTtcclxuZXhwb3J0cy50eXBlYWhlYWQgPSB0eXBlYWhlYWQ7XHJcbnZhciB1c2VyUmF0aW5nID0gcmVxdWlyZSgnLi91c2VyUmF0aW5nL3VzZXJSYXRpbmcnKTtcclxuZXhwb3J0cy51c2VyUmF0aW5nID0gdXNlclJhdGluZztcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMnO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIGF1dG9zYXZlRGlhbG9nRm9vdGVyLm1vZHVsZU5hbWUsXHJcbiAgICBidXN5Lm1vZHVsZU5hbWUsXHJcbiAgICBidXR0b25Bc3luYy5tb2R1bGVOYW1lLFxyXG4gICAgYnV0dG9uVG9nZ2xlLm1vZHVsZU5hbWUsXHJcbiAgICBjYXJkQ29udGFpbmVyLm1vZHVsZU5hbWUsXHJcbiAgICBjb21tYUxpc3QubW9kdWxlTmFtZSxcclxuICAgIGRhdGVUaW1lLm1vZHVsZU5hbWUsXHJcbiAgICBnZW5lcmljQ29udGFpbmVyLm1vZHVsZU5hbWUsXHJcbiAgICBsYXp5TG9hZC5tb2R1bGVOYW1lLFxyXG4gICAgbG9uZ0NsaWNrQnV0dG9uLm1vZHVsZU5hbWUsXHJcbiAgICBtZXNzYWdlTG9nLm1vZHVsZU5hbWUsXHJcbiAgICBtdWx0aVN0ZXBJbmRpY2F0b3IubW9kdWxlTmFtZSxcclxuICAgIHJhZGlvLm1vZHVsZU5hbWUsXHJcbiAgICByYXRpbmdCYXIubW9kdWxlTmFtZSxcclxuICAgIHJlc3BvbnNpdmVDYXJkR3JpZC5tb2R1bGVOYW1lLFxyXG4gICAgcmljaFRleHRFZGl0b3IubW9kdWxlTmFtZSxcclxuICAgIHNpZ25hdHVyZVBhZC5tb2R1bGVOYW1lLFxyXG4gICAgc2ltcGxlQ2FyZExpc3QubW9kdWxlTmFtZSxcclxuICAgIHNwaW5uZXIubW9kdWxlTmFtZSxcclxuICAgIHN0cmluZ1dpdGhXYXRlcm1hcmsubW9kdWxlTmFtZSxcclxuICAgIHR5cGVhaGVhZC5tb2R1bGVOYW1lLFxyXG4gICAgdXNlclJhdGluZy5tb2R1bGVOYW1lLFxyXG5dKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcG9uZW50cy5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NvbXBvbmVudHMubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmF1dG9zYXZlRGlhbG9nRm9vdGVyJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsQXV0b3NhdmVEaWFsb2dGb290ZXInO1xyXG5mdW5jdGlvbiBhdXRvc2F2ZURpYWxvZ0Zvb3RlcigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9hdXRvc2F2ZURpYWxvZ0Zvb3Rlci5odG1sJyksXHJcbiAgICB9O1xyXG59XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgYXV0b3NhdmVEaWFsb2dGb290ZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvc2F2ZURpYWxvZ0Zvb3Rlci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvYXV0b3NhdmVEaWFsb2dGb290ZXIvYXV0b3NhdmVEaWFsb2dGb290ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlclxcXCI+XFxyXFxuXFx0PGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIG5nLWNsaWNrPVxcXCIkY2xvc2UoKVxcXCI+Q2FuY2VsPC9idXR0b24+XFxyXFxuXFx0PGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIG5nLWNsaWNrPVxcXCIkZGlzbWlzcygpXFxcIj5TYXZlPC9idXR0b24+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvYXV0b3NhdmVEaWFsb2dGb290ZXIvYXV0b3NhdmVEaWFsb2dGb290ZXIuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5idXN5JztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsQnVzeSc7XHJcbmZ1bmN0aW9uIGJ1c3koKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6ICc8aSBjbGFzcz1cImZhIGZhLXNwaW4gZmEtc3Bpbm5lciBmYS17e3NpemV9fVwiIG5nLXNob3c9XCJsb2FkaW5nXCI+PC9pPicsXHJcbiAgICAgICAgc2NvcGU6IHtcclxuICAgICAgICAgICAgbG9hZGluZzogJz0nLFxyXG4gICAgICAgICAgICAvLyBWYWxpZCB2YWx1ZXMgYXJlOlxyXG4gICAgICAgICAgICAvLyBgbGdgLCBgMnhgLCBgM3hgLCBgNHhgLCBhbmQgYDV4YFxyXG4gICAgICAgICAgICBzaXplOiAnQCcsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBidXN5KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVzeS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvYnVzeS9idXN5LmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3Byb21pc2VVdGlsaXR5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnByb21pc2U7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmJ1dHRvbic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybEJ1dHRvbkFzeW5jJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdCdXR0b25Bc3luY0NvbnRyb2xsZXInO1xyXG52YXIgQnV0dG9uQXN5bmNDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJ1dHRvbkFzeW5jQ29udHJvbGxlcihwcm9taXNlVXRpbGl0eSkge1xyXG4gICAgICAgIHRoaXMucHJvbWlzZVV0aWxpdHkgPSBwcm9taXNlVXRpbGl0eTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0aGlzLnR5cGUgIT0gbnVsbCA/IHRoaXMudHlwZSA6ICdkZWZhdWx0JztcclxuICAgICAgICB0aGlzLnNpemVDbGFzcyA9IHRoaXMuc2l6ZSAhPSBudWxsID8gJ2J0bi0nICsgdGhpcy5zaXplIDogbnVsbDtcclxuICAgIH1cclxuICAgIEJ1dHRvbkFzeW5jQ29udHJvbGxlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghdGhpcy5idXN5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVzeSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmFjdGlvbigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9taXNlVXRpbGl0eS5pc1Byb21pc2UocmVzdWx0KSAmJiBfLmlzRnVuY3Rpb24ocmVzdWx0LmZpbmFsbHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZmluYWxseShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYnVzeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQnV0dG9uQXN5bmNDb250cm9sbGVyLiRpbmplY3QgPSBbX19wcm9taXNlVXRpbGl0eS5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gQnV0dG9uQXN5bmNDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkJ1dHRvbkFzeW5jQ29udHJvbGxlciA9IEJ1dHRvbkFzeW5jQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gYnV0dG9uQXN5bmMoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9idXR0b25Bc3luYy5odG1sJyksXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgYnVzeTogJz0nLFxyXG4gICAgICAgICAgICBhY3Rpb246ICcmJyxcclxuICAgICAgICAgICAgdHlwZTogJ0AnLFxyXG4gICAgICAgICAgICBuZ0Rpc2FibGVkOiAnPScsXHJcbiAgICAgICAgICAgIHJpZ2h0QWxpZ25lZDogJz0nLFxyXG4gICAgICAgICAgICBzaXplOiAnQCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2J1dHRvbicsXHJcbiAgICB9O1xyXG59XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fcHJvbWlzZVV0aWxpdHkubW9kdWxlTmFtZV0pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgYnV0dG9uQXN5bmMpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBCdXR0b25Bc3luY0NvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b25Bc3luYy5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uQXN5bmMvYnV0dG9uQXN5bmMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHRoaXNbXCJfXCJdOyB9KCkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJfXCJcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi17e2J1dHRvbi50eXBlfX0ge3tidXR0b24uc2l6ZUNsYXNzfX1cXFwiIG5nLWNsaWNrPVxcXCJidXR0b24udHJpZ2dlcigpXFxcIiBuZy1kaXNhYmxlZD1cXFwiYnV0dG9uLmJ1c3kgfHwgYnV0dG9uLm5nRGlzYWJsZWRcXFwiPlxcclxcblxcdDxybC1idXN5IG5nLXNob3c9XFxcImJ1dHRvbi5yaWdodEFsaWduZWRcXFwiIGxvYWRpbmc9XFxcImJ1dHRvbi5idXN5XFxcIj48L3JsLWJ1c3k+XFxyXFxuXFx0PHNwYW4gbmctdHJhbnNjbHVkZT48L3NwYW4+XFxyXFxuXFx0PHJsLWJ1c3kgbmctaGlkZT1cXFwiYnV0dG9uLnJpZ2h0QWxpZ25lZFxcXCIgbG9hZGluZz1cXFwiYnV0dG9uLmJ1c3lcXFwiPjwvcmwtYnVzeT5cXHJcXG48L2J1dHRvbj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b25Bc3luYy9idXR0b25Bc3luYy5odG1sXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX2Jvb2xlYW4gPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuYm9vbGVhbjtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuYnV0dG9uVG9nZ2xlJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsQnV0dG9uVG9nZ2xlJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdCdXR0b25Ub2dnbGVDb250cm9sbGVyJztcclxudmFyIEJ1dHRvblRvZ2dsZUNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnV0dG9uVG9nZ2xlQ29udHJvbGxlcigkc2NvcGUsIGJvb2wpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uQ2xhc3MgPSAkc2NvcGUudHlwZSAhPSBudWxsID8gJHNjb3BlLnR5cGUgOiAnZGVmYXVsdCc7XHJcbiAgICAgICAgdGhpcy5idXR0b25TaXplID0gJHNjb3BlLnNpemUgIT0gbnVsbCA/ICdidG4tJyArICRzY29wZS5zaXplIDogbnVsbDtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKCduZ01vZGVsLiRtb2RlbFZhbHVlJywgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmlzQWN0aXZlID0gYm9vbC50b0Jvb2wodmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBfLmlzRnVuY3Rpb24oJHNjb3BlLm9uVG9nZ2xlKSkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLm9uVG9nZ2xlKHsgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBCdXR0b25Ub2dnbGVDb250cm9sbGVyLnByb3RvdHlwZS5jbGlja2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuJHNjb3BlLm5nTW9kZWwuJHNldFZpZXdWYWx1ZSghdGhpcy4kc2NvcGUubmdNb2RlbC4kdmlld1ZhbHVlKTtcclxuICAgIH07XHJcbiAgICBCdXR0b25Ub2dnbGVDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsIF9fYm9vbGVhbi5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gQnV0dG9uVG9nZ2xlQ29udHJvbGxlcjtcclxufSkoKTtcclxuZnVuY3Rpb24gYnV0dG9uVG9nZ2xlKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHJlcXVpcmU6ICdebmdNb2RlbCcsXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9idXR0b25Ub2dnbGUuaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnYnV0dG9uVG9nZ2xlJyxcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICB0eXBlOiAnQCcsXHJcbiAgICAgICAgICAgIHNpemU6ICdAJyxcclxuICAgICAgICAgICAgb25Ub2dnbGU6ICcmJyxcclxuICAgICAgICAgICAgZGlzYWJsZWQ6ICc9bmdEaXNhYmxlZCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLm5nTW9kZWwgPSBuZ01vZGVsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19ib29sZWFuLm1vZHVsZU5hbWVdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGJ1dHRvblRvZ2dsZSlcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIEJ1dHRvblRvZ2dsZUNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b25Ub2dnbGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2J1dHRvblRvZ2dsZS9idXR0b25Ub2dnbGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi17e2J1dHRvblRvZ2dsZS5idXR0b25DbGFzc319IHt7YnV0dG9uVG9nZ2xlLmJ1dHRvblNpemV9fVxcXCIgXFxyXFxuXFx0XFx0bmctY2xhc3M9XFxcInsgYWN0aXZlIDogYnV0dG9uVG9nZ2xlLmlzQWN0aXZlIH1cXFwiIG5nLWNsaWNrPVxcXCJidXR0b25Ub2dnbGUuY2xpY2tlZCgpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZGlzYWJsZWRcXFwiPlxcclxcblxcdDxpIG5nLXNob3c9XFxcImJ1dHRvblRvZ2dsZS5pc0FjdGl2ZVxcXCIgY2xhc3M9XFxcImZhIGZhLWNoZWNrIGNvbXBsZXRlZFxcXCI+PC9pPiA8c3BhbiBuZy10cmFuc2NsdWRlPjwvc3Bhbj5cXHJcXG48L2J1dHRvbj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b25Ub2dnbGUvYnV0dG9uVG9nZ2xlLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBfX2FycmF5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmFycmF5O1xyXG52YXIgX19wYXJlbnRDaGlsZCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wYXJlbnRDaGlsZEJlaGF2aW9yO1xyXG52YXIgY2FyZCA9IHJlcXVpcmUoJy4vY2FyZC9jYXJkJyk7XHJcbmV4cG9ydHMuY2FyZCA9IGNhcmQ7XHJcbnZhciBjYXJkU2VhcmNoID0gcmVxdWlyZSgnLi9jYXJkU2VhcmNoL2NhcmRTZWFyY2gnKTtcclxuZXhwb3J0cy5jYXJkU2VhcmNoID0gY2FyZFNlYXJjaDtcclxudmFyIGNvbHVtbkhlYWRlciA9IHJlcXVpcmUoJy4vY29sdW1uSGVhZGVyL2NvbHVtbkhlYWRlcicpO1xyXG5leHBvcnRzLmNvbHVtbkhlYWRlciA9IGNvbHVtbkhlYWRlcjtcclxudmFyIGRhdGFTb3VyY2VzID0gcmVxdWlyZSgnLi9kYXRhU291cmNlcy9kYXRhU291cmNlcy5tb2R1bGUnKTtcclxuZXhwb3J0cy5kYXRhU291cmNlcyA9IGRhdGFTb3VyY2VzO1xyXG52YXIgZmlsdGVycyA9IHJlcXVpcmUoJy4vZmlsdGVycy9maWx0ZXJzLm1vZHVsZScpO1xyXG5leHBvcnRzLmZpbHRlcnMgPSBmaWx0ZXJzO1xyXG52YXIgaXRlbUNvdW50ID0gcmVxdWlyZSgnLi9pdGVtQ291bnQvaXRlbUNvdW50Jyk7XHJcbmV4cG9ydHMuaXRlbUNvdW50ID0gaXRlbUNvdW50O1xyXG52YXIgcGFnZXIgPSByZXF1aXJlKCcuL3BhZ2VyL3BhZ2VyJyk7XHJcbmV4cG9ydHMucGFnZXIgPSBwYWdlcjtcclxudmFyIHBhZ2VTaXplID0gcmVxdWlyZSgnLi9wYWdlU2l6ZS9wYWdlU2l6ZScpO1xyXG5leHBvcnRzLnBhZ2VTaXplID0gcGFnZVNpemU7XHJcbnZhciBzZWxlY3Rpb25Db250cm9sID0gcmVxdWlyZSgnLi9zZWxlY3Rpb25Db250cm9sL3NlbGVjdGlvbkNvbnRyb2wnKTtcclxuZXhwb3J0cy5zZWxlY3Rpb25Db250cm9sID0gc2VsZWN0aW9uQ29udHJvbDtcclxudmFyIHNvcnRzID0gcmVxdWlyZSgnLi9zb3J0cy9zb3J0cy5tb2R1bGUnKTtcclxuZXhwb3J0cy5zb3J0cyA9IHNvcnRzO1xyXG52YXIgY2FyZENvbnRhaW5lcl8xID0gcmVxdWlyZSgnLi9jYXJkQ29udGFpbmVyJyk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vY2FyZENvbnRhaW5lcicpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9jYXJkQ29udGFpbmVyLnNlcnZpY2UnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vY29sdW1uJykpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXHJcbiAgICAvLyBkZXBlbmRlbmNpZXNcclxuICAgIGRhdGFTb3VyY2VzLmRhdGFQYWdlci5tb2R1bGVOYW1lLFxyXG4gICAgX19vYmplY3QubW9kdWxlTmFtZSxcclxuICAgIF9fYXJyYXkubW9kdWxlTmFtZSxcclxuICAgIF9fcGFyZW50Q2hpbGQubW9kdWxlTmFtZSxcclxuICAgIC8vIGNvbXBvbmVudHNcclxuICAgIGNhcmQubW9kdWxlTmFtZSxcclxuICAgIGNhcmRTZWFyY2gubW9kdWxlTmFtZSxcclxuICAgIGNvbHVtbkhlYWRlci5tb2R1bGVOYW1lLFxyXG4gICAgaXRlbUNvdW50Lm1vZHVsZU5hbWUsXHJcbiAgICBwYWdlci5tb2R1bGVOYW1lLFxyXG4gICAgcGFnZVNpemUubW9kdWxlTmFtZSxcclxuICAgIHNlbGVjdGlvbkNvbnRyb2wubW9kdWxlTmFtZSxcclxuICAgIC8vIHN1Ym1vZHVsZXNcclxuICAgIGRhdGFTb3VyY2VzLm1vZHVsZU5hbWUsXHJcbiAgICBmaWx0ZXJzLm1vZHVsZU5hbWUsXHJcbiAgICBzb3J0cy5tb2R1bGVOYW1lLFxyXG5dKVxyXG4gICAgLmRpcmVjdGl2ZShjYXJkQ29udGFpbmVyXzEuZGlyZWN0aXZlTmFtZSwgY2FyZENvbnRhaW5lcl8xLmNhcmRDb250YWluZXIpXHJcbiAgICAuY29udHJvbGxlcihjYXJkQ29udGFpbmVyXzEuY29udHJvbGxlck5hbWUsIGNhcmRDb250YWluZXJfMS5DYXJkQ29udGFpbmVyQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhcmRDb250YWluZXIubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRDb250YWluZXIubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19wYXJlbnRDaGlsZCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wYXJlbnRDaGlsZEJlaGF2aW9yO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgaGVhZGVyQ29sdW1uX21vZHVsZV8xID0gcmVxdWlyZSgnLi9oZWFkZXJDb2x1bW4vaGVhZGVyQ29sdW1uLm1vZHVsZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmNhcmQnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxDYXJkJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdDYXJkQ29udHJvbGxlcic7XHJcbnZhciBDYXJkQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDYXJkQ29udHJvbGxlcigkc2NvcGUsICRjb250cm9sbGVyLCAkcSwgcGFyZW50Q2hpbGQsIG9iamVjdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy4kcSA9ICRxO1xyXG4gICAgICAgIHRoaXMucGFyZW50Q2hpbGQgPSBwYXJlbnRDaGlsZDtcclxuICAgICAgICB0aGlzLnNob3dDb250ZW50ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYXV0b3NhdmVMaW5rID0ge307XHJcbiAgICAgICAgdGhpcy5hdXRvc2F2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLnNob3dDb250ZW50ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBhcmVudENoaWxkLnRyaWdnZXJDaGlsZEJlaGF2aW9yKF90aGlzLmF1dG9zYXZlTGluaywgZnVuY3Rpb24gKGJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmVoYXZpb3IuYXV0b3NhdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNob3dDb250ZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuY2FyZEFzKSB7XHJcbiAgICAgICAgICAgICRzY29wZVt0aGlzLmNhcmRBc10gPSB0aGlzLml0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgICRzY29wZS5jb2xsYXBzZSA9IHRoaXMuYXV0b3NhdmU7XHJcbiAgICAgICAgJHNjb3BlLnNldFNlbGVjdGVkID0gdGhpcy5zZXRTZWxlY3RlZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgICRzY29wZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5zb3VyY2UucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnY2FyZC5yZWZyZXNoJyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAkc2NvcGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5zb3VyY2UucmVtb3ZlKF90aGlzLml0ZW0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgJHNjb3BlLmNvbnRhaW5lckRhdGEgPSB0aGlzLmNvbnRhaW5lckRhdGE7XHJcbiAgICAgICAgaWYgKG9iamVjdC5pc051bGxPcldoaXRlc3BhY2UodGhpcy5jYXJkQ29udHJvbGxlcikgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sbGVyID0gJGNvbnRyb2xsZXIodGhpcy5jYXJkQ29udHJvbGxlciwgeyAkc2NvcGU6ICRzY29wZSB9KTtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5pc051bGxPcldoaXRlc3BhY2UodGhpcy5jYXJkQ29udHJvbGxlckFzKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICRzY29wZVt0aGlzLmNhcmRDb250cm9sbGVyQXNdID0gY29udHJvbGxlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJlbnRDaGlsZC5yZWdpc3RlckNoaWxkQmVoYXZpb3IodGhpcy5pdGVtLCB7XHJcbiAgICAgICAgICAgIGNsb3NlOiB0aGlzLmF1dG9zYXZlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRzY29wZS5fX2luaXRDb250ZW50cyA9IGZ1bmN0aW9uIChoYXNCb2R5LCBoYXNGb290ZXIpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGFzQm9keSA9IGhhc0JvZHk7XHJcbiAgICAgICAgICAgIF90aGlzLmhhc0Zvb3RlciA9IGhhc0Zvb3RlcjtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgQ2FyZENvbnRyb2xsZXIucHJvdG90eXBlLnRvZ2dsZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3dDb250ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hdXRvc2F2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYXJkQ29udHJvbGxlci5wcm90b3R5cGUudmFsaWRhdGVDYXJkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMucGFyZW50Q2hpbGQuZ2V0Q2hpbGRCZWhhdmlvcih0aGlzLml0ZW0pO1xyXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oYmVoYXZpb3IudmFsaWRhdGVDYXJkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmVoYXZpb3IudmFsaWRhdGVDYXJkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRyb2xsZXIucHJvdG90eXBlLnNhdmVDYXJkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMucGFyZW50Q2hpbGQuZ2V0Q2hpbGRCZWhhdmlvcih0aGlzLml0ZW0pO1xyXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oYmVoYXZpb3Iuc2F2ZUNhcmQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiZWhhdmlvci5zYXZlQ2FyZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEud2hlbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYXJkQ29udHJvbGxlci5wcm90b3R5cGUuY2xpY2tDYXJkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50Q2hpbGQudHJpZ2dlckNoaWxkQmVoYXZpb3IodGhpcy5pdGVtLCBmdW5jdGlvbiAoYmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihiZWhhdmlvci5jbGlja0NhcmQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVoYXZpb3IuY2xpY2tDYXJkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udHJvbGxlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnBhcmVudENoaWxkLnRyaWdnZXJDaGlsZEJlaGF2aW9yKHRoaXMuaXRlbSwgZnVuY3Rpb24gKGJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oYmVoYXZpb3IuaW5pdENhcmQpKSB7XHJcbiAgICAgICAgICAgICAgICBiZWhhdmlvci5pbml0Q2FyZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuJHNjb3BlLl9fcmxDYXJkQ29udGFpbmVyLm9wZW5DYXJkKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93Q29udGVudCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhcmRDb250cm9sbGVyLnByb3RvdHlwZS5zZXRTZWxlY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHRoaXMuaXRlbS52aWV3RGF0YSkpIHtcclxuICAgICAgICAgICAgdGhpcy5pdGVtLnZpZXdEYXRhID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXRlbS52aWV3RGF0YS5zZWxlY3RlZCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckY29udHJvbGxlcicsICckcScsIF9fcGFyZW50Q2hpbGQuc2VydmljZU5hbWUsIF9fb2JqZWN0LnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBDYXJkQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5DYXJkQ29udHJvbGxlciA9IENhcmRDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBjYXJkKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2NhcmQuaHRtbCcpLFxyXG4gICAgICAgIHJlcXVpcmU6ICdeXnJsQ2FyZENvbnRhaW5lcicsXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdfX2NhcmQnLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIGNvbHVtbnM6ICc9JyxcclxuICAgICAgICAgICAgaXRlbTogJz0nLFxyXG4gICAgICAgICAgICBjbGlja2FibGU6ICc9JyxcclxuICAgICAgICAgICAgc291cmNlOiAnPScsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lckRhdGE6ICc9JyxcclxuICAgICAgICAgICAgY2FyZENvbnRyb2xsZXI6ICc9JyxcclxuICAgICAgICAgICAgY2FyZENvbnRyb2xsZXJBczogJz0nLFxyXG4gICAgICAgICAgICBjYXJkQXM6ICc9JyxcclxuICAgICAgICAgICAgcGVybWFuZW50Rm9vdGVyOiAnPScsXHJcbiAgICAgICAgICAgIHNlbGVjdGFibGU6ICc9JyxcclxuICAgICAgICAgICAgc2VsZWN0aW9uQ2hhbmdlZDogJyYnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29udGVudDtcclxuICAgICAgICAgICAgdmFyIGZvb3RlcjtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHByZTogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgcmxDYXJkQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuX19ybENhcmRDb250YWluZXIgPSBybENhcmRDb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmxDYXJkQ29udGFpbmVyLm1ha2VDYXJkKHNjb3BlLCBmdW5jdGlvbiAoY2xvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNsb25lLmZpbHRlcigncmwtY2FyZC1jb250ZW50Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvb3RlciA9IGNsb25lLmZpbHRlcigncmwtY2FyZC1mb290ZXInKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwb3N0OiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudEFyZWEgPSBlbGVtZW50LmZpbmQoJy5jb250ZW50LXRlbXBsYXRlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEFyZWEuYXBwZW5kKGNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNCb2R5ID0gY29udGVudC5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNGb290ZXIgPSAoZm9vdGVyLmxlbmd0aCA+IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNGb290ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvb3RlckFyZWEgPSBlbGVtZW50LmZpbmQoJy5mb290ZXItdGVtcGxhdGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyQXJlYS5hcHBlbmQoZm9vdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuX19pbml0Q29udGVudHMoaGFzQm9keSwgaGFzRm9vdGVyKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jYXJkID0gY2FyZDtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXHJcbiAgICBfX3BhcmVudENoaWxkLm1vZHVsZU5hbWUsXHJcbiAgICBfX29iamVjdC5tb2R1bGVOYW1lLFxyXG4gICAgaGVhZGVyQ29sdW1uX21vZHVsZV8xLm1vZHVsZU5hbWUsXHJcbl0pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgY2FyZClcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIENhcmRDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FyZC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2NhcmQuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIGhlYWRlckNvbHVtbl8xID0gcmVxdWlyZSgnLi9oZWFkZXJDb2x1bW4nKTtcclxudmFyIHNpemVGb3JCcmVha3BvaW50c18xID0gcmVxdWlyZSgnLi9zaXplRm9yQnJlYWtwb2ludHMnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5jYXJkLmhlYWRlckNvbHVtbic7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW1xyXG4gICAgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnN0cmluZy5tb2R1bGVOYW1lLFxyXG5dKVxyXG4gICAgLmRpcmVjdGl2ZShzaXplRm9yQnJlYWtwb2ludHNfMS5zaXplRm9yQnJlYWtwb2ludHNOYW1lLCBzaXplRm9yQnJlYWtwb2ludHNfMS5zaXplRm9yQnJlYWtwb2ludHMpXHJcbiAgICAuZGlyZWN0aXZlKGhlYWRlckNvbHVtbl8xLmRpcmVjdGl2ZU5hbWUsIGhlYWRlckNvbHVtbl8xLmhlYWRlckNvbHVtbilcclxuICAgIC5jb250cm9sbGVyKGhlYWRlckNvbHVtbl8xLmNvbnRyb2xsZXJOYW1lLCBoZWFkZXJDb2x1bW5fMS5IZWFkZXJDb2x1bW5Db250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVyQ29sdW1uLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2hlYWRlckNvbHVtbi9oZWFkZXJDb2x1bW4ubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybENhcmRIZWFkZXJDb2x1bW4nO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0NhcmRIZWFkZXJDb2x1bW5Db250cm9sbGVyJztcclxudmFyIEhlYWRlckNvbHVtbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSGVhZGVyQ29sdW1uQ29udHJvbGxlcigkc2NvcGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy52YWx1ZSA9IF90aGlzLmNvbHVtbi5nZXRWYWx1ZShfdGhpcy5pdGVtKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgJHNjb3BlLiRvbignY2FyZC5yZWZyZXNoJywgdGhpcy51cGRhdGUpOyAvLypldmVudD9cclxuICAgIH1cclxuICAgIEhlYWRlckNvbHVtbkNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJ107XHJcbiAgICByZXR1cm4gSGVhZGVyQ29sdW1uQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5IZWFkZXJDb2x1bW5Db250cm9sbGVyID0gSGVhZGVyQ29sdW1uQ29udHJvbGxlcjtcclxuaGVhZGVyQ29sdW1uLiRpbmplY3QgPSBbJyRjb21waWxlJ107XHJcbmZ1bmN0aW9uIGhlYWRlckNvbHVtbigkY29tcGlsZSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcblxcdFxcdFxcdDxkaXYgcmwtc2l6ZS1mb3ItYnJlYWtwb2ludHM9XFxcImhlYWRlci5jb2x1bW4uc2l6ZVxcXCIgdGl0bGU9XFxcInt7OjpoZWFkZXIuY29sdW1uLmRlc2NyaXB0aW9ufX1cXFwiPlxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInRlbXBsYXRlLWNvbnRhaW5lclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IGlubGluZS1ibG9ja1xcXCI+PC9kaXY+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XCIsXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdoZWFkZXInLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIGNvbHVtbjogJz0nLFxyXG4gICAgICAgICAgICBpdGVtOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21waWxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBwcmU6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIGhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBoZWFkZXIuY29sdW1uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4udGVtcGxhdGVVcmwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIucmVuZGVyZWRUZW1wbGF0ZSA9ICRjb21waWxlKCc8ZGl2IG5nLWluY2x1ZGU9XCJcXCcnICsgY29sdW1uLnRlbXBsYXRlVXJsICsgJ1xcJ1wiPjwvZGl2PicpKHNjb3BlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29sdW1uLnRlbXBsYXRlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLnJlbmRlcmVkVGVtcGxhdGUgPSAkY29tcGlsZShjb2x1bW4udGVtcGxhdGUpKHNjb3BlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci5yZW5kZXJlZFRlbXBsYXRlID0gJGNvbXBpbGUoJzxzcGFuPnt7aGVhZGVyLnZhbHVlfX08L3NwYW4+Jykoc2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwb3N0OiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBoZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZWxlbWVudC5maW5kKCcudGVtcGxhdGUtY29udGFpbmVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZChoZWFkZXIucmVuZGVyZWRUZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuaGVhZGVyQ29sdW1uID0gaGVhZGVyQ29sdW1uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkZXJDb2x1bW4uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY2FyZC9oZWFkZXJDb2x1bW4vaGVhZGVyQ29sdW1uLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fc3RyaW5nID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnN0cmluZztcclxudmFyIGJyZWFrcG9pbnRfMSA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL3NlcnZpY2VzL2JyZWFrcG9pbnRzL2JyZWFrcG9pbnQnKTtcclxuZXhwb3J0cy5zaXplRm9yQnJlYWtwb2ludHNOYW1lID0gJ3JsU2l6ZUZvckJyZWFrcG9pbnRzJztcclxuc2l6ZUZvckJyZWFrcG9pbnRzLiRpbmplY3QgPSBbJyRwYXJzZScsIF9fc3RyaW5nLnNlcnZpY2VOYW1lXTtcclxuZnVuY3Rpb24gc2l6ZUZvckJyZWFrcG9pbnRzKCRwYXJzZSwgc3RyaW5nVXRpbGl0eSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgICAgIGxpbms6IGxpbmtEaXJlY3RpdmUsXHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gbGlua0RpcmVjdGl2ZShzY29wZSwgZWxlbWVudCwgYXR0cmlidXRlcykge1xyXG4gICAgICAgIHZhciBzaXplcyA9ICRwYXJzZShhdHRyaWJ1dGVzLnJsU2l6ZUZvckJyZWFrcG9pbnRzKShzY29wZSk7XHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcclxuICAgICAgICBjbGFzc2VzLnB1c2goZ2V0Q29sdW1uQ2xhc3Moc2l6ZXMsIGJyZWFrcG9pbnRfMS54cykpO1xyXG4gICAgICAgIGNsYXNzZXMucHVzaChnZXRDb2x1bW5DbGFzcyhzaXplcywgYnJlYWtwb2ludF8xLnNtKSk7XHJcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGdldENvbHVtbkNsYXNzKHNpemVzLCBicmVha3BvaW50XzEubWQpKTtcclxuICAgICAgICBjbGFzc2VzLnB1c2goZ2V0Q29sdW1uQ2xhc3Moc2l6ZXMsIGJyZWFrcG9pbnRfMS5sZykpO1xyXG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoY2xhc3Nlcy5qb2luKCcgJykpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0Q29sdW1uQ2xhc3MoY29sdW1uU2l6ZXMsIGJyZWFrcG9pbnQpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBjb2x1bW5TaXplc1ticmVha3BvaW50XTtcclxuICAgICAgICBpZiAodmFsdWUgPiAwICYmIHZhbHVlICE9PSAnaGlkZGVuJykge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nVXRpbGl0eS5zdWJzdGl0dXRlKCdjb2wtezB9LXsxfScsIGJyZWFrcG9pbnQsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnaGlkZGVuLScgKyBicmVha3BvaW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLnNpemVGb3JCcmVha3BvaW50cyA9IHNpemVGb3JCcmVha3BvaW50cztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2l6ZUZvckJyZWFrcG9pbnRzLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmQvaGVhZGVyQ29sdW1uL3NpemVGb3JCcmVha3BvaW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmV4cG9ydHMubGcgPSAnbGcnO1xyXG5leHBvcnRzLm1kID0gJ21kJztcclxuZXhwb3J0cy5zbSA9ICdzbSc7XHJcbmV4cG9ydHMueHMgPSAneHMnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmVha3BvaW50LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvYnJlYWtwb2ludHMvYnJlYWtwb2ludC5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHJsLWdlbmVyaWMtY29udGFpbmVyIHNlbGVjdG9yPVxcXCJfX2NhcmQuc2VsZWN0YWJsZVxcXCI+XFxyXFxuXFx0PHRlbXBsYXRlIHdoZW4tc2VsZWN0b3I9XFxcImZhbHNlXFxcIiBkZWZhdWx0PlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNhcmRcXFwiIG5nLWNsYXNzPVxcXCJ7ICdzZWxlY3RlZCc6IF9fY2FyZC5pdGVtLnZpZXdEYXRhLnNlbGVjdGVkIH1cXFwiPlxcclxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImhlYWRlclxcXCIgbmctY2xpY2s9XFxcIl9fY2FyZC50b2dnbGVDb250ZW50KClcXFwiIG5nLWNsYXNzPVxcXCJ7ICdhY3RpdmUnOiBfX2NhcmQuaGFzQm9keSB8fCAhX19jYXJkLnBlcm1hbmVudEZvb3RlciB9XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdDxkaXYgbmctcmVwZWF0PVxcXCJjb2x1bW4gaW4gX19jYXJkLmNvbHVtbnNcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDxybC1jYXJkLWhlYWRlci1jb2x1bW4gY29sdW1uPVxcXCJjb2x1bW5cXFwiIGl0ZW09XFxcIl9fY2FyZC5pdGVtXFxcIj48L3JsLWNhcmQtaGVhZGVyLWNvbHVtbj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHJcXG5cXHRcXHRcXHQ8ZGl2IG5nLXNob3c9XFxcIl9fY2FyZC5zaG93Q29udGVudFxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PG5nLWZvcm0gcmwtYXV0b3NhdmU9XFxcIl9fY2FyZC5hdXRvc2F2ZUxpbmtcXFwiIHNhdmU9XFxcIl9fY2FyZC5zYXZlQ2FyZCgpXFxcIiB2YWxpZGF0ZT1cXFwiX19jYXJkLnZhbGlkYXRlQ2FyZCgpXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJib2R5XFxcIiBuZy1jbGFzcz1cXFwieyAnYWN0aXZlJzogX19jYXJkLmNsaWNrYWJsZSB9XFxcIiBuZy1jbGljaz1cXFwiX19jYXJkLmNsaWNrQ2FyZCgpXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb250ZW50LXRlbXBsYXRlXFxcIj48L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0PC9uZy1mb3JtPlxcclxcblxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdDxkaXYgbmctc2hvdz1cXFwiX19jYXJkLmhhc0Zvb3RlciAmJiAoX19jYXJkLnNob3dDb250ZW50IHx8IF9fY2FyZC5wZXJtYW5lbnRGb290ZXIpXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb290ZXJcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImZvb3Rlci10ZW1wbGF0ZVxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdDwvdGVtcGxhdGU+XFxyXFxuXFx0PHRlbXBsYXRlIHdoZW4tc2VsZWN0b3I9XFxcInRydWVcXFwiPlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcInNlbGVjdC1ncm91cFxcXCI+XFxyXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwic2VsZWN0LWNvbHVtblxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBjbGFzcz1cXFwic3RhbmQtYWxvbmUtY2hlY2tib3hcXFwiIG5nLW1vZGVsPVxcXCJfX2NhcmQuaXRlbS52aWV3RGF0YS5zZWxlY3RlZFxcXCIgbmctY2hhbmdlPVxcXCJfX2NhcmQuc2VsZWN0aW9uQ2hhbmdlZCgpXFxcIlxcclxcblxcdFxcdFxcdFxcdFxcdCAgIG5nLWRpc2FibGVkPVxcXCJfX2NhcmQuaXRlbS52aWV3RGF0YS5kaXNhYmxlZFNlbGVjdGlvblxcXCIgdGl0bGU9XFxcInt7X19jYXJkLml0ZW0udmlld0RhdGEuc2VsZWN0aW9uVGl0bGV9fVxcXCIgLz5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJzZWxlY3QtY29udGVudFxcXCI+XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2FyZCBzZWxlY3RhYmxlXFxcIiBuZy1jbGFzcz1cXFwieyAnc2VsZWN0ZWQnOiBfX2NhcmQuaXRlbS52aWV3RGF0YS5zZWxlY3RlZCB9XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJoZWFkZXIgYWN0aXZlXFxcIiBuZy1jbGljaz1cXFwiX19jYXJkLnRvZ2dsZUNvbnRlbnQoKVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IG5nLXJlcGVhdD1cXFwiY29sdW1uIGluIF9fY2FyZC5jb2x1bW5zXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8cmwtY2FyZC1oZWFkZXItY29sdW1uIGNvbHVtbj1cXFwiY29sdW1uXFxcIiBpdGVtPVxcXCJfX2NhcmQuaXRlbVxcXCI+PC9ybC1jYXJkLWhlYWRlci1jb2x1bW4+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBuZy1zaG93PVxcXCJfX2NhcmQuc2hvd0NvbnRlbnRcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDxuZy1mb3JtIHJsLWF1dG9zYXZlPVxcXCJfX2NhcmQuYXV0b3NhdmVMaW5rXFxcIiBzYXZlPVxcXCJfX2NhcmQuc2F2ZUNhcmQoKVxcXCIgdmFsaWRhdGU9XFxcIl9fY2FyZC52YWxpZGF0ZUNhcmQoKVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiYm9keVxcXCIgbmctY2xhc3M9XFxcInsgJ2FjdGl2ZSc6IF9fY2FyZC5jbGlja2FibGUgfVxcXCIgbmctY2xpY2s9XFxcIl9fY2FyZC5jbGlja0NhcmQoKVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29udGVudC10ZW1wbGF0ZVxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDwvbmctZm9ybT5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IG5nLXNob3c9XFxcIl9fY2FyZC5oYXNGb290ZXIgJiYgKF9fY2FyZC5zaG93Q29udGVudCB8fCBfX2NhcmQucGVybWFuZW50Rm9vdGVyKVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiZm9vdGVyXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb290ZXItdGVtcGxhdGVcXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNsZWFyZml4XFxcIj48L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L3RlbXBsYXRlPlxcclxcbjwvcmwtZ2VuZXJpYy1jb250YWluZXI+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2NhcmQuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19nZW5lcmljU2VhcmNoRmlsdGVyID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmdlbmVyaWNTZWFyY2hGaWx0ZXI7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuY2FyZFNlYXJjaCc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybENhcmRTZWFyY2gnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0NhcmRTZWFyY2hDb250cm9sbGVyJztcclxuZXhwb3J0cy5kZWZhdWx0U2VhcmNoUGxhY2Vob2xkZXIgPSAnU2VhcmNoJztcclxuZXhwb3J0cy5kZWZhdWx0U2VhcmNoRGVsYXkgPSAxMDAwO1xyXG52YXIgQ2FyZFNlYXJjaENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FyZFNlYXJjaENvbnRyb2xsZXIoJHNjb3BlLCAkdGltZW91dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zZWFyY2hMZW5ndGhFcnJvciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaGFzU2VhcmNoRmlsdGVyID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5jb250YWluZXJTZXJ2aWNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zZWFyY2hGaWx0ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5jb250YWluZXJTZXJ2aWNlLmxvb2t1cEZpbHRlcihfX2dlbmVyaWNTZWFyY2hGaWx0ZXIuZmlsdGVyTmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoRmlsdGVyID0gZmlsdGVyO1xyXG4gICAgICAgICAgICBpZiAoZmlsdGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFzU2VhcmNoRmlsdGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzU2VhcmNoRmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoUGxhY2Vob2xkZXIgPSBleHBvcnRzLmRlZmF1bHRTZWFyY2hQbGFjZWhvbGRlcjtcclxuICAgICAgICAgICAgdmFyIGRhdGFTb3VyY2UgPSB0aGlzLmNvbnRhaW5lclNlcnZpY2UuZGF0YVNvdXJjZTtcclxuICAgICAgICAgICAgdmFyIGRlbGF5ID0gdGhpcy5kZWxheSAhPSBudWxsXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuZGVsYXlcclxuICAgICAgICAgICAgICAgIDogZXhwb3J0cy5kZWZhdWx0U2VhcmNoRGVsYXk7XHJcbiAgICAgICAgICAgIHZhciB0aW1lcjtcclxuICAgICAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZWFyY2hUZXh0OyB9LCBmdW5jdGlvbiAoc2VhcmNoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWFyY2hGaWx0ZXIuc2VhcmNoVGV4dCA9IHNlYXJjaDtcclxuICAgICAgICAgICAgICAgIF90aGlzLm1pblNlYXJjaExlbmd0aCA9IF90aGlzLnNlYXJjaEZpbHRlci5taW5TZWFyY2hMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52YWxpZGF0ZVNlYXJjaExlbmd0aChzZWFyY2gsIF90aGlzLm1pblNlYXJjaExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0aW1lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aW1lciA9ICR0aW1lb3V0KGRhdGFTb3VyY2UucmVmcmVzaC5iaW5kKGRhdGFTb3VyY2UpLCBkZWxheSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIENhcmRTZWFyY2hDb250cm9sbGVyLnByb3RvdHlwZS52YWxpZGF0ZVNlYXJjaExlbmd0aCA9IGZ1bmN0aW9uIChzZWFyY2gsIG1pbkxlbmd0aCkge1xyXG4gICAgICAgIC8vIHNob3cgZXJyb3IgaWYgc2VhcmNoIHN0cmluZyBleGlzdHMgYnV0IGlzIGJlbG93IG1pbmltdW0gc2l6ZVxyXG4gICAgICAgIHRoaXMuc2VhcmNoTGVuZ3RoRXJyb3IgPSBzZWFyY2ggIT0gbnVsbFxyXG4gICAgICAgICAgICAmJiBzZWFyY2gubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICAmJiBzZWFyY2gubGVuZ3RoIDwgbWluTGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIENhcmRTZWFyY2hDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckdGltZW91dCddO1xyXG4gICAgcmV0dXJuIENhcmRTZWFyY2hDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkNhcmRTZWFyY2hDb250cm9sbGVyID0gQ2FyZFNlYXJjaENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIGNhcmRTZWFyY2goKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vY2FyZFNlYXJjaC5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdjYXJkU2VhcmNoJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBkZWxheTogJz1zZWFyY2hEZWxheScsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclNlcnZpY2U6ICc9JyxcclxuICAgICAgICAgICAgc2VhcmNoRmlsdGVyOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jYXJkU2VhcmNoID0gY2FyZFNlYXJjaDtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBjYXJkU2VhcmNoKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgQ2FyZFNlYXJjaENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXJkU2VhcmNoLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRTZWFyY2gvY2FyZFNlYXJjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXBcXFwiIG5nLXNob3c9XFxcImNhcmRTZWFyY2guaGFzU2VhcmNoRmlsdGVyXFxcIiBuZy1jbGFzcz1cXFwieyAnaGFzLWVycm9yJzogY2FyZFNlYXJjaC5zZWFyY2hMZW5ndGhFcnJvciB9XFxcIj5cXHJcXG5cXHQ8aW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcInt7Y2FyZFNlYXJjaC5zZWFyY2hQbGFjZWhvbGRlcn19XFxcIiBuZy1tb2RlbD1cXFwiY2FyZFNlYXJjaC5zZWFyY2hUZXh0XFxcIlxcclxcblxcdFxcdFxcdHBvcG92ZXI9XFxcIllvdSBtdXN0IGVudGVyIGF0IGxlYXN0IHt7Y2FyZFNlYXJjaC5taW5TZWFyY2hMZW5ndGh9fSBjaGFyYWN0ZXJzIHRvIHBlcmZvcm0gYSBzZWFyY2hcXFwiIHBvcG92ZXItdHJpZ2dlcj1cXFwibW91c2VlbnRlclxcXCIgcG9wb3Zlci1lbmFibGU9XFxcImNhcmRTZWFyY2guc2VhcmNoTGVuZ3RoRXJyb3JcXFwiIC8+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYnRuXFxcIj5cXHJcXG5cXHRcXHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgbmctZGlzYWJsZWQ9XFxcImNhcmRTZWFyY2guc2VhcmNoVGV4dCB8IGlzRW1wdHlcXFwiIG5nLWNsaWNrPVxcXCJjYXJkU2VhcmNoLnNlYXJjaFRleHQgPSBudWxsXFxcIj5cXHJcXG5cXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtdGltZXNcXFwiPjwvaT5cXHJcXG5cXHRcXHQ8L2J1dHRvbj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRTZWFyY2gvY2FyZFNlYXJjaC5odG1sXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgc29ydERpcmVjdGlvbl8xID0gcmVxdWlyZSgnLi4vc29ydHMvc29ydERpcmVjdGlvbicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmNvbHVtbkhlYWRlcic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybENvbHVtbkhlYWRlcic7XHJcbmNhcmRDb2x1bW5IZWFkZXIuJGluamVjdCA9IFsnJGNvbXBpbGUnXTtcclxuZnVuY3Rpb24gY2FyZENvbHVtbkhlYWRlcigkY29tcGlsZSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHJlcXVpcmU6ICdeXnJsQ2FyZENvbnRhaW5lcicsXHJcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuXFx0XFx0XFx0PGRpdiBybC1zaXplLWZvci1icmVha3BvaW50cz1cXFwiY29sdW1uLnNpemVcXFwiIG5nLWNsaWNrPVxcXCJzb3J0KClcXFwiIHRpdGxlPVxcXCJ7ezo6Y29sdW1uLmRlc2NyaXB0aW9ufX1cXFwiXFxuXFx0XFx0XFx0XFx0XFx0Y2xhc3M9XFxcImNvbHVtbi1oZWFkZXJcXFwiPlxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInRlbXBsYXRlLWNvbnRhaW5lclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IGlubGluZS1ibG9ja1xcXCI+PC9kaXY+XFxuXFx0XFx0XFx0XFx0PGkgbmctc2hvdz1cXFwic29ydGluZyA9PT0gc29ydERpcmVjdGlvbi5hc2NlbmRpbmdcXFwiIGNsYXNzPVxcXCJmYSBmYS1zb3J0LWFzY1xcXCI+PC9pPlxcblxcdFxcdFxcdFxcdDxpIG5nLXNob3c9XFxcInNvcnRpbmcgPT09IHNvcnREaXJlY3Rpb24uZGVzY2VuZGluZ1xcXCIgY2xhc3M9XFxcImZhIGZhLXNvcnQtZGVzY1xcXCI+PC9pPlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFwiLFxyXG4gICAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgICAgIGNvbHVtbjogJz0nLFxyXG4gICAgICAgICAgICBzb3J0aW5nOiAnPScsXHJcbiAgICAgICAgICAgIHNvcnQ6ICcmJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHByZTogZnVuY3Rpb24gKHNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHNjb3BlLmNvbHVtbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmhlYWRlclRlbXBsYXRlVXJsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucmVuZGVyZWRUZW1wbGF0ZSA9ICRjb21waWxlKCc8ZGl2IG5nLWluY2x1ZGU9XCJcXCcnICsgY29sdW1uLmhlYWRlclRlbXBsYXRlVXJsICsgJ1xcJ1wiPjwvZGl2PicpKHNjb3BlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29sdW1uLmhlYWRlclRlbXBsYXRlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucmVuZGVyZWRUZW1wbGF0ZSA9ICRjb21waWxlKGNvbHVtbi5oZWFkZXJUZW1wbGF0ZSkoc2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucmVuZGVyZWRUZW1wbGF0ZSA9ICgnPGg1PicgKyBjb2x1bW4ubGFiZWwgKyAnPC9oNScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwb3N0OiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZWxlbWVudC5maW5kKCcudGVtcGxhdGUtY29udGFpbmVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZChzY29wZS5yZW5kZXJlZFRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZS5zb3J0RGlyZWN0aW9uID0gc29ydERpcmVjdGlvbl8xLlNvcnREaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jYXJkQ29sdW1uSGVhZGVyID0gY2FyZENvbHVtbkhlYWRlcjtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBjYXJkQ29sdW1uSGVhZGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sdW1uSGVhZGVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NvbHVtbkhlYWRlci9jb2x1bW5IZWFkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgU29ydERpcmVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTb3J0RGlyZWN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgU29ydERpcmVjdGlvbi50b2dnbGUgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gU29ydERpcmVjdGlvbi5hc2NlbmRpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNvcnREaXJlY3Rpb24uZGVzY2VuZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBTb3J0RGlyZWN0aW9uLmRlc2NlbmRpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNvcnREaXJlY3Rpb24ubm9uZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTb3J0RGlyZWN0aW9uLmFzY2VuZGluZztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU29ydERpcmVjdGlvbi5nZXRGdWxsTmFtZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAndXNlIHN0cmljdCc7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gU29ydERpcmVjdGlvbi5hc2NlbmRpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdhc2NlbmRpbmcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFNvcnREaXJlY3Rpb24uZGVzY2VuZGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2Rlc2NlbmRpbmcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdub25lJztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU29ydERpcmVjdGlvbi5ub25lID0gbmV3IFNvcnREaXJlY3Rpb24oMCk7XHJcbiAgICBTb3J0RGlyZWN0aW9uLmFzY2VuZGluZyA9IG5ldyBTb3J0RGlyZWN0aW9uKDEpO1xyXG4gICAgU29ydERpcmVjdGlvbi5kZXNjZW5kaW5nID0gbmV3IFNvcnREaXJlY3Rpb24oMik7XHJcbiAgICByZXR1cm4gU29ydERpcmVjdGlvbjtcclxufSkoKTtcclxuZXhwb3J0cy5Tb3J0RGlyZWN0aW9uID0gU29ydERpcmVjdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydERpcmVjdGlvbi5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9zb3J0RGlyZWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgc29ydHNfbW9kdWxlXzEgPSByZXF1aXJlKCcuLi9zb3J0cy9zb3J0cy5tb2R1bGUnKTtcclxudmFyIGRhdGFQYWdlciA9IHJlcXVpcmUoJy4vZGF0YVBhZ2VyL2RhdGFQYWdlci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuZGF0YVBhZ2VyID0gZGF0YVBhZ2VyO1xyXG52YXIgZGF0YVNlcnZpY2VEYXRhU291cmNlID0gcmVxdWlyZSgnLi9kYXRhU2VydmljZURhdGFTb3VyY2UvZGF0YVNlcnZpY2VEYXRhU291cmNlLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5kYXRhU2VydmljZURhdGFTb3VyY2UgPSBkYXRhU2VydmljZURhdGFTb3VyY2U7XHJcbnZhciBzaW1wbGVEYXRhU291cmNlID0gcmVxdWlyZSgnLi9zaW1wbGVEYXRhU291cmNlL3NpbXBsZURhdGFTb3VyY2Uuc2VydmljZScpO1xyXG5leHBvcnRzLnNpbXBsZURhdGFTb3VyY2UgPSBzaW1wbGVEYXRhU291cmNlO1xyXG52YXIgc2VydmVyU2VhcmNoRGF0YVNvdXJjZSA9IHJlcXVpcmUoJy4vc2VydmVyU2VhcmNoRGF0YVNvdXJjZS9zZXJ2ZXJTZWFyY2hEYXRhU291cmNlLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5zZXJ2ZXJTZWFyY2hEYXRhU291cmNlID0gc2VydmVyU2VhcmNoRGF0YVNvdXJjZTtcclxudmFyIGRhdGFTb3VyY2VQcm9jZXNzb3IgPSByZXF1aXJlKCcuL2RhdGFTb3VyY2VQcm9jZXNzb3Iuc2VydmljZScpO1xyXG5leHBvcnRzLmRhdGFTb3VyY2VQcm9jZXNzb3IgPSBkYXRhU291cmNlUHJvY2Vzc29yO1xyXG52YXIgZGF0YVNvdXJjZUJhc2UgPSByZXF1aXJlKCcuL2RhdGFTb3VyY2VCYXNlLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5kYXRhU291cmNlQmFzZSA9IGRhdGFTb3VyY2VCYXNlO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2RhdGFTb3VyY2UnKSk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZGF0YVNvdXJjZXMnO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3QubW9kdWxlTmFtZSxcclxuICAgIHNvcnRzX21vZHVsZV8xLm1vZHVsZU5hbWUsXHJcbiAgICBkYXRhUGFnZXIubW9kdWxlTmFtZSxcclxuICAgIGRhdGFTZXJ2aWNlRGF0YVNvdXJjZS5tb2R1bGVOYW1lLFxyXG4gICAgc2ltcGxlRGF0YVNvdXJjZS5tb2R1bGVOYW1lLFxyXG4gICAgc2VydmVyU2VhcmNoRGF0YVNvdXJjZS5tb2R1bGVOYW1lLFxyXG5dKVxyXG4gICAgLnNlcnZpY2UoZGF0YVNvdXJjZVByb2Nlc3Nvci5wcm9jZXNzb3JTZXJ2aWNlTmFtZSwgZGF0YVNvdXJjZVByb2Nlc3Nvci5EYXRhU291cmNlUHJvY2Vzc29yKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YVNvdXJjZXMubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFTb3VyY2VzLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIG1lcmdlU29ydCA9IHJlcXVpcmUoJy4vbWVyZ2VTb3J0L21lcmdlU29ydC5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubWVyZ2VTb3J0ID0gbWVyZ2VTb3J0O1xyXG52YXIgc29ydGVyID0gcmVxdWlyZSgnLi9zb3J0ZXIvc29ydGVyLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5zb3J0ZXIgPSBzb3J0ZXI7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc29ydCcpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9zb3J0RGlyZWN0aW9uJykpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLnNvcnRzJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXHJcbiAgICBtZXJnZVNvcnQubW9kdWxlTmFtZSxcclxuICAgIHNvcnRlci5tb2R1bGVOYW1lLFxyXG5dKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydHMubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3NvcnRzL3NvcnRzLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLnNvcnRzLm1lcmdlU29ydCc7XHJcbmV4cG9ydHMuc2VydmljZU5hbWUgPSAnbWVyZ2VTb3J0JztcclxudmFyIE1lcmdlU29ydCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNZXJnZVNvcnQoKSB7XHJcbiAgICB9XHJcbiAgICBNZXJnZVNvcnQucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoZGF0YSwgY29tcGFyZSkge1xyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wYXJlID09IG51bGwpIHtcclxuICAgICAgICAgICAgY29tcGFyZSA9IHRoaXMuZGVmYXVsdENvbXBhcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaWQ7XHJcbiAgICAgICAgdmFyIGxlZnQ7XHJcbiAgICAgICAgdmFyIHJpZ2h0O1xyXG4gICAgICAgIG1pZCA9IGRhdGEubGVuZ3RoIC8gMjtcclxuICAgICAgICBsZWZ0ID0gdGhpcy5zb3J0KGRhdGEuc2xpY2UoMCwgbWlkKSwgY29tcGFyZSk7XHJcbiAgICAgICAgcmlnaHQgPSB0aGlzLnNvcnQoZGF0YS5zbGljZShtaWQsIGRhdGEubGVuZ3RoKSwgY29tcGFyZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2UobGVmdCwgcmlnaHQsIGNvbXBhcmUpO1xyXG4gICAgfTtcclxuICAgIE1lcmdlU29ydC5wcm90b3R5cGUuZGVmYXVsdENvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhIDwgYlxyXG4gICAgICAgICAgICA/IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS50eXBlcy5Db21wYXJlUmVzdWx0Lmxlc3NcclxuICAgICAgICAgICAgOiAoYSA+IGIgPyB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEudHlwZXMuQ29tcGFyZVJlc3VsdC5ncmVhdGVyIDogdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnR5cGVzLkNvbXBhcmVSZXN1bHQuZXF1YWwpO1xyXG4gICAgfTtcclxuICAgIE1lcmdlU29ydC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgd2hpbGUgKGxlZnQubGVuZ3RoICYmIHJpZ2h0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoY29tcGFyZShsZWZ0WzBdLCByaWdodFswXSkgPT09IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS50eXBlcy5Db21wYXJlUmVzdWx0LmdyZWF0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJpZ2h0LnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgZXF1YWwgaXQgc2hvdWxkIHByZXNlcnZlIHNhbWUgb3JkZXIgKHN0YWJsZSlcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxlZnQuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlZnQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbGVmdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyaWdodC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCByaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1lcmdlU29ydDtcclxufSkoKTtcclxuZXhwb3J0cy5NZXJnZVNvcnQgPSBNZXJnZVNvcnQ7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuc2VydmljZShleHBvcnRzLnNlcnZpY2VOYW1lLCBNZXJnZVNvcnQpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZVNvcnQuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9tZXJnZVNvcnQvbWVyZ2VTb3J0LnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIHNvcnREaXJlY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3NvcnREaXJlY3Rpb24nKTtcclxudmFyIG1lcmdlU29ydF9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9tZXJnZVNvcnQvbWVyZ2VTb3J0LnNlcnZpY2UnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5zb3J0cy5zb3J0ZXInO1xyXG5leHBvcnRzLnNlcnZpY2VOYW1lID0gJ3NvcnRlcic7XHJcbnZhciBTb3J0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU29ydGVyKG1lcmdlU29ydCkge1xyXG4gICAgICAgIHRoaXMubWVyZ2VTb3J0ID0gbWVyZ2VTb3J0O1xyXG4gICAgfVxyXG4gICAgU29ydGVyLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGRhdGEsIHNvcnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChzb3J0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoXy5pc0FycmF5KHNvcnQpKSB7XHJcbiAgICAgICAgICAgIHZhciByZXZlcnNlU29ydHMgPSBfLmNsb25lKHNvcnQpO1xyXG4gICAgICAgICAgICByZXZlcnNlU29ydHMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5yZWR1Y2UocmV2ZXJzZVNvcnRzLCBmdW5jdGlvbiAoc29ydGVkRGF0YSwgbmV4dFNvcnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zaW5nbGVTb3J0KHNvcnRlZERhdGEsIG5leHRTb3J0KTtcclxuICAgICAgICAgICAgfSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNpbmdsZVNvcnQoZGF0YSwgc29ydCk7XHJcbiAgICB9O1xyXG4gICAgU29ydGVyLnByb3RvdHlwZS5zaW5nbGVTb3J0ID0gZnVuY3Rpb24gKGRhdGEsIHNvcnQpIHtcclxuICAgICAgICB2YXIgY29tcGFyZUZ1bmN0aW9uID0gdGhpcy5idWlsZFNvcnRGdW5jdGlvbihzb3J0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXJnZVNvcnQuc29ydChkYXRhLCBjb21wYXJlRnVuY3Rpb24pO1xyXG4gICAgfTtcclxuICAgIFNvcnRlci5wcm90b3R5cGUuYnVpbGRTb3J0RnVuY3Rpb24gPSBmdW5jdGlvbiAoc29ydCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBpZiAoc29ydC5kaXJlY3Rpb24gPT09IHNvcnREaXJlY3Rpb25fMS5Tb3J0RGlyZWN0aW9uLm5vbmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEudHlwZXMuQ29tcGFyZVJlc3VsdC5lcXVhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsdWVPZkEgPSBzb3J0LmNvbHVtbi5nZXRWYWx1ZShhKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlT2ZCID0gc29ydC5jb2x1bW4uZ2V0VmFsdWUoYik7XHJcbiAgICAgICAgICAgIHZhciBncmVhdGVyUmVzdWx0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnR5cGVzLkNvbXBhcmVSZXN1bHQuZ3JlYXRlcjtcclxuICAgICAgICAgICAgdmFyIGxlc3NSZXN1bHQgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEudHlwZXMuQ29tcGFyZVJlc3VsdC5sZXNzO1xyXG4gICAgICAgICAgICB2YXIgZGVzY2VuZGluZ1NvcnQgPSAoc29ydC5kaXJlY3Rpb24gPT09IHNvcnREaXJlY3Rpb25fMS5Tb3J0RGlyZWN0aW9uLmRlc2NlbmRpbmcpO1xyXG4gICAgICAgICAgICB2YXIgZmxpcCA9IHNvcnQuY29sdW1uLmZsaXBTb3J0O1xyXG4gICAgICAgICAgICAvLyBFeGNsdXNpdmUgT1IuLi4gaWYgZmxpcHBpbmcgYSBkZXNjZW5kaW5nIHNvcnQsIHlvdSBnZXQgYW4gYXNjZW5kaW5nIHNvcnRcclxuICAgICAgICAgICAgaWYgKChkZXNjZW5kaW5nU29ydCB8fCBmbGlwKSAmJiAhKGRlc2NlbmRpbmdTb3J0ICYmIGZsaXApKSB7XHJcbiAgICAgICAgICAgICAgICBncmVhdGVyUmVzdWx0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnR5cGVzLkNvbXBhcmVSZXN1bHQubGVzcztcclxuICAgICAgICAgICAgICAgIGxlc3NSZXN1bHQgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEudHlwZXMuQ29tcGFyZVJlc3VsdC5ncmVhdGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZU9mQSA+IHZhbHVlT2ZCXHJcbiAgICAgICAgICAgICAgICA/IGdyZWF0ZXJSZXN1bHRcclxuICAgICAgICAgICAgICAgIDogKHZhbHVlT2ZBIDwgdmFsdWVPZkIgPyBsZXNzUmVzdWx0IDogdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnR5cGVzLkNvbXBhcmVSZXN1bHQuZXF1YWwpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgU29ydGVyLiRpbmplY3QgPSBbbWVyZ2VTb3J0X3NlcnZpY2VfMS5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gU29ydGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlNvcnRlciA9IFNvcnRlcjtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5zZXJ2aWNlKGV4cG9ydHMuc2VydmljZU5hbWUsIFNvcnRlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnRlci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3NvcnRzL3NvcnRlci9zb3J0ZXIuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvc29ydHMvc29ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi8uLi8uLi90eXBpbmdzL2xvZGFzaFR5cGVFeHRlbnNpb25zLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZGF0YVNvdXJjZXMuZGF0YVBhZ2VyJztcclxuZXhwb3J0cy5mYWN0b3J5TmFtZSA9ICdkYXRhUGFnZXInO1xyXG5leHBvcnRzLmRlZmF1bHRQYWdlU2l6ZSA9IDEwO1xyXG52YXIgRGF0YVBhZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERhdGFQYWdlcigpIHtcclxuICAgICAgICB0aGlzLnBhZ2VOdW1iZXIgPSAxO1xyXG4gICAgICAgIHRoaXMucGFnZVNpemUgPSBleHBvcnRzLmRlZmF1bHRQYWdlU2l6ZTtcclxuICAgIH1cclxuICAgIERhdGFQYWdlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGRhdGFTZXQpIHtcclxuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMucGFnZVNpemU7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gKHRoaXMucGFnZU51bWJlciAtIDEpICogc2l6ZTtcclxuICAgICAgICByZXR1cm4gXyhkYXRhU2V0KVxyXG4gICAgICAgICAgICAuZHJvcChzdGFydClcclxuICAgICAgICAgICAgLnRha2Uoc2l6ZSlcclxuICAgICAgICAgICAgLnZhbHVlKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGFQYWdlcjtcclxufSkoKTtcclxuZXhwb3J0cy5EYXRhUGFnZXIgPSBEYXRhUGFnZXI7XHJcbmZ1bmN0aW9uIGRhdGFQYWdlckZhY3RvcnkoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YVBhZ2VyKCk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5kYXRhUGFnZXJGYWN0b3J5ID0gZGF0YVBhZ2VyRmFjdG9yeTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5mYWN0b3J5KGV4cG9ydHMuZmFjdG9yeU5hbWUsIGRhdGFQYWdlckZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhUGFnZXIuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9kYXRhUGFnZXIvZGF0YVBhZ2VyLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JzZXJ2YWJsZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYnNlcnZhYmxlO1xyXG52YXIgX19hcnJheSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5hcnJheTtcclxudmFyIGRhdGFTb3VyY2VCYXNlX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL2RhdGFTb3VyY2VCYXNlLnNlcnZpY2UnKTtcclxudmFyIGRhdGFTb3VyY2VQcm9jZXNzb3Jfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vZGF0YVNvdXJjZVByb2Nlc3Nvci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZGF0YVNvdXJjZXMuZGF0YVNlcnZpY2VEYXRhU291cmNlJztcclxuZXhwb3J0cy5mYWN0b3J5TmFtZSA9ICdkYXRhU2VydmljZURhdGFTb3VyY2UnO1xyXG52YXIgRGF0YVNlcnZpY2VEYXRhU291cmNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEYXRhU2VydmljZURhdGFTb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXRhU2VydmljZURhdGFTb3VyY2UoZ2V0RGF0YVNldCwgJHEsIG9ic2VydmFibGVGYWN0b3J5LCBkYXRhU291cmNlUHJvY2Vzc29yLCBhcnJheSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG9ic2VydmFibGVGYWN0b3J5LCBkYXRhU291cmNlUHJvY2Vzc29yLCBhcnJheSk7XHJcbiAgICAgICAgdGhpcy5nZXREYXRhU2V0ID0gZ2V0RGF0YVNldDtcclxuICAgICAgICB0aGlzLiRxID0gJHE7XHJcbiAgICAgICAgdGhpcy5jb3VudEZpbHRlckdyb3VwcyA9IHRydWU7XHJcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLmdldERhdGFTZXQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgRGF0YVNlcnZpY2VEYXRhU291cmNlLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmRhdGFTZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmF3RGF0YVNldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nRGF0YVNldCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy4kcS53aGVuKHRoaXMuZ2V0RGF0YVNldCgpKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmxvYWRpbmdEYXRhU2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLnJhd0RhdGFTZXQgPSBkYXRhO1xyXG4gICAgICAgICAgICBfdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIF90aGlzLm9ic2VydmFibGUuZmlyZSgncmVsb2FkZWQnKTtcclxuICAgICAgICAgICAgX3RoaXMub2JzZXJ2YWJsZS5maXJlKCdjaGFuZ2VkJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGFTZXJ2aWNlRGF0YVNvdXJjZTtcclxufSkoZGF0YVNvdXJjZUJhc2Vfc2VydmljZV8xLkRhdGFTb3VyY2VCYXNlKTtcclxuZXhwb3J0cy5EYXRhU2VydmljZURhdGFTb3VyY2UgPSBEYXRhU2VydmljZURhdGFTb3VyY2U7XHJcbmRhdGFTZXJ2aWNlRGF0YVNvdXJjZUZhY3RvcnkuJGluamVjdCA9IFtfX29ic2VydmFibGUuZmFjdG9yeU5hbWUsIGRhdGFTb3VyY2VQcm9jZXNzb3Jfc2VydmljZV8xLnByb2Nlc3NvclNlcnZpY2VOYW1lLCBfX2FycmF5LnNlcnZpY2VOYW1lLCAnJHEnXTtcclxuZnVuY3Rpb24gZGF0YVNlcnZpY2VEYXRhU291cmNlRmFjdG9yeShvYnNlcnZhYmxlRmFjdG9yeSwgZGF0YVNvdXJjZVByb2Nlc3NvciwgYXJyYXksICRxKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoZ2V0RGF0YVNldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFTZXJ2aWNlRGF0YVNvdXJjZShnZXREYXRhU2V0LCAkcSwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmRhdGFTZXJ2aWNlRGF0YVNvdXJjZUZhY3RvcnkgPSBkYXRhU2VydmljZURhdGFTb3VyY2VGYWN0b3J5O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29ic2VydmFibGUubW9kdWxlTmFtZSwgX19hcnJheS5tb2R1bGVOYW1lXSlcclxuICAgIC5mYWN0b3J5KGV4cG9ydHMuZmFjdG9yeU5hbWUsIGRhdGFTZXJ2aWNlRGF0YVNvdXJjZUZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhU2VydmljZURhdGFTb3VyY2Uuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9kYXRhU2VydmljZURhdGFTb3VyY2UvZGF0YVNlcnZpY2VEYXRhU291cmNlLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgRGF0YVNvdXJjZUJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0YVNvdXJjZUJhc2Uob2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KSB7XHJcbiAgICAgICAgdGhpcy5kYXRhU291cmNlUHJvY2Vzc29yID0gZGF0YVNvdXJjZVByb2Nlc3NvcjtcclxuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XHJcbiAgICAgICAgdGhpcy5zb3J0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuY291bnRGaWx0ZXJHcm91cHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvYWRpbmdEYXRhU2V0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZUZhY3RvcnkuZ2V0SW5zdGFuY2UoKTtcclxuICAgIH1cclxuICAgIERhdGFTb3VyY2VCYXNlLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIChhY3Rpb24sIGV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2YWJsZS5yZWdpc3RlcihhY3Rpb24sIGV2ZW50KTtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlQmFzZS5wcm90b3R5cGUucHJvY2Vzc0RhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHByb2Nlc3NlZERhdGE7XHJcbiAgICAgICAgaWYgKHRoaXMuY291bnRGaWx0ZXJHcm91cHMpIHtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuZGF0YVNvdXJjZVByb2Nlc3Nvci5wcm9jZXNzQW5kQ291bnQodGhpcy5zb3J0cywgdGhpcy5maWx0ZXJzLCB0aGlzLnBhZ2VyLCB0aGlzLnJhd0RhdGFTZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuZGF0YVNvdXJjZVByb2Nlc3Nvci5wcm9jZXNzKHRoaXMuc29ydHMsIHRoaXMuZmlsdGVycywgdGhpcy5wYWdlciwgdGhpcy5yYXdEYXRhU2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IHByb2Nlc3NlZERhdGEuY291bnQ7XHJcbiAgICAgICAgdGhpcy5kYXRhU2V0ID0gcHJvY2Vzc2VkRGF0YS5kYXRhU2V0O1xyXG4gICAgICAgIHRoaXMuZmlsdGVyZWREYXRhU2V0ID0gcHJvY2Vzc2VkRGF0YS5maWx0ZXJlZERhdGFTZXQ7XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRpbmdEYXRhU2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0RhdGEoKTtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlLmZpcmUoJ3JlZHJhd2luZycpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlQmFzZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYXJyYXkucmVtb3ZlKHRoaXMucmF3RGF0YVNldCwgZGF0YSk7XHJcbiAgICAgICAgaWYgKGl0ZW0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZSgncmVtb3ZlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZSgnY2hhbmdlZCcpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYWdlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMucmF3RGF0YVNldC5wdXNoKGRhdGEpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZS5maXJlKCdhZGRlZCcpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZS5maXJlKCdjaGFuZ2VkJyk7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAob2xkRGF0YSwgbmV3RGF0YSkge1xyXG4gICAgICAgIHZhciBsb2NhdGlvbk9mT2xkRGF0YSA9IHRoaXMucmF3RGF0YVNldC5pbmRleE9mKG9sZERhdGEpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbk9mT2xkRGF0YSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJyYXkucmVwbGFjZSh0aGlzLnJhd0RhdGFTZXQsIG9sZERhdGEsIG5ld0RhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZSgncmVwbGFjZWQnKTtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlLmZpcmUoJ2NoYW5nZWQnKTtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXRhU291cmNlQmFzZTtcclxufSkoKTtcclxuZXhwb3J0cy5EYXRhU291cmNlQmFzZSA9IERhdGFTb3VyY2VCYXNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhU291cmNlQmFzZS5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFTb3VyY2VCYXNlLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgc29ydGVyX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL3NvcnRzL3NvcnRlci9zb3J0ZXIuc2VydmljZScpO1xyXG5leHBvcnRzLnByb2Nlc3NvclNlcnZpY2VOYW1lID0gJ2RhdGFTb3VyY2VQcm9jZXNzb3InO1xyXG52YXIgRGF0YVNvdXJjZVByb2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhU291cmNlUHJvY2Vzc29yKG9iamVjdCwgc29ydGVyKSB7XHJcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcbiAgICAgICAgdGhpcy5zb3J0ZXIgPSBzb3J0ZXI7XHJcbiAgICB9XHJcbiAgICBEYXRhU291cmNlUHJvY2Vzc29yLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHNvcnRzLCBmaWx0ZXJzLCBwYWdlciwgZGF0YSkge1xyXG4gICAgICAgIHZhciBwcm9jZXNzZWREYXRhID0gZGF0YTtcclxuICAgICAgICBpZiAodGhpcy5vYmplY3QuaXNOdWxsT3JFbXB0eShzb3J0cykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGEgPSB0aGlzLnNvcnRlci5zb3J0KHByb2Nlc3NlZERhdGEsIHNvcnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0LmlzTnVsbE9yRW1wdHkoZmlsdGVycykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGEgPSBfLnJlZHVjZShmaWx0ZXJzLCBmdW5jdGlvbiAoZmlsdGVyZWREYXRhLCBmaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEZpbHRlciB0aGUgZGF0YSBzZXQgdXNpbmcgdGhlIGZpbHRlciBmdW5jdGlvbiBvbiB0aGUgZmlsdGVyXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5maWx0ZXIoZmlsdGVyZWREYXRhLCBmaWx0ZXIuZmlsdGVyLCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICB9LCBwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgY291bnQ6IChwcm9jZXNzZWREYXRhICE9IG51bGwgPyBwcm9jZXNzZWREYXRhLmxlbmd0aCA6IDApLFxyXG4gICAgICAgICAgICBmaWx0ZXJlZERhdGFTZXQ6IHByb2Nlc3NlZERhdGEsXHJcbiAgICAgICAgICAgIGRhdGFTZXQ6IHByb2Nlc3NlZERhdGEsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAocGFnZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQuZGF0YVNldCA9IHBhZ2VyLmZpbHRlcihwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlUHJvY2Vzc29yLnByb3RvdHlwZS5wcm9jZXNzQW5kQ291bnQgPSBmdW5jdGlvbiAoc29ydHMsIGZpbHRlcnMsIHBhZ2VyLCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZmlsdGVycyB0aGF0IG5lZWQgdG8gdXBkYXRlZCBvcHRpb24gY291bnRzLCB1c2UgdGhlIG5vcm1hbCBwcm9jZXNzb3JcclxuICAgICAgICBpZiAodGhpcy5vYmplY3QuaXNOdWxsT3JFbXB0eShmaWx0ZXJzKVxyXG4gICAgICAgICAgICB8fCBfLmFueShmaWx0ZXJzLCBmdW5jdGlvbiAoZmlsdGVyKSB7IHJldHVybiBfLmlzRnVuY3Rpb24oZmlsdGVyLnVwZGF0ZU9wdGlvbkNvdW50cyk7IH0pID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzKHNvcnRzLCBmaWx0ZXJzLCBwYWdlciwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9jZXNzZWREYXRhID0gZGF0YTtcclxuICAgICAgICBpZiAodGhpcy5vYmplY3QuaXNOdWxsT3JFbXB0eShzb3J0cykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGEgPSB0aGlzLnNvcnRlci5zb3J0KHByb2Nlc3NlZERhdGEsIHNvcnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdyYXBwZWREYXRhID0gdGhpcy53cmFwRGF0YShwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICAvLyBSdW4gZmlsdHJhdGlvbiBsb2dpYyBhbmQgY29tcHV0ZSB2aXNpYmxlIGl0ZW1zXHJcbiAgICAgICAgXy5lYWNoKGZpbHRlcnMsIGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgXy5lYWNoKHdyYXBwZWREYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5maWx0ZXJEYXRhW2ZpbHRlci50eXBlXSA9IGZpbHRlci5maWx0ZXIoaXRlbS5kYXRhKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gR2l2ZSBlYWNoIGZpbHRlciBhIGNoYW5jZSB0byB1cGRhdGUgb3B0aW9uIGNvdW50c1xyXG4gICAgICAgIF8uZWFjaChmaWx0ZXJzLCBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oZmlsdGVyLnVwZGF0ZU9wdGlvbkNvdW50cykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdGhlckZpbHRlcnNBcHBsaWVkID0gXy5maWx0ZXIod3JhcHBlZERhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT21pdCB0aGUgdHJ1ZSBvciBmYWxzZSBvZiB0aGUgY3VycmVudCBmaWx0ZXIgYW5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgb25seSBmaWx0ZXIgb3V0IGl0ZW1zIHJlbW92ZWQgYnkgb3RoZXIgZmlsdGVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJEYXRhID0gXy5vbWl0KGl0ZW0uZmlsdGVyRGF0YSwgZmlsdGVyLnR5cGUpOyAvLypmaWx0ZXJEYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uYWxsKF8udmFsdWVzKGZpbHRlckRhdGEpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyLnVwZGF0ZU9wdGlvbkNvdW50cyhfdGhpcy51bndyYXBEYXRhKG90aGVyRmlsdGVyc0FwcGxpZWQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEZpbHRlciBkb3duIHRvIGZpbmFsIGRhdGEgc2V0IGJ5IHJlbW92aW5nIGl0ZW1zIHRoYXQgZG9uJ3QgbWF0Y2ggYWxsIGZpbHRlcnNcclxuICAgICAgICB3cmFwcGVkRGF0YSA9IF8uZmlsdGVyKHdyYXBwZWREYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXy5hbGwoXy52YWx1ZXMoaXRlbS5maWx0ZXJEYXRhKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcHJvY2Vzc2VkRGF0YSA9IHRoaXMudW53cmFwRGF0YSh3cmFwcGVkRGF0YSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgY291bnQ6IHByb2Nlc3NlZERhdGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBmaWx0ZXJlZERhdGFTZXQ6IHByb2Nlc3NlZERhdGEsXHJcbiAgICAgICAgICAgIGRhdGFTZXQ6IHByb2Nlc3NlZERhdGEsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAocGFnZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQuZGF0YVNldCA9IHBhZ2VyLmZpbHRlcihwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlUHJvY2Vzc29yLnByb3RvdHlwZS53cmFwRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIF8ubWFwKGRhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBpdGVtLFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyRGF0YToge30sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZVByb2Nlc3Nvci5wcm90b3R5cGUudW53cmFwRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIF8ubWFwKGRhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmRhdGE7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZVByb2Nlc3Nvci4kaW5qZWN0ID0gW19fb2JqZWN0LnNlcnZpY2VOYW1lLCBzb3J0ZXJfc2VydmljZV8xLnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBEYXRhU291cmNlUHJvY2Vzc29yO1xyXG59KSgpO1xyXG5leHBvcnRzLkRhdGFTb3VyY2VQcm9jZXNzb3IgPSBEYXRhU291cmNlUHJvY2Vzc29yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhU291cmNlUHJvY2Vzc29yLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvZGF0YVNvdXJjZVByb2Nlc3Nvci5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29ic2VydmFibGUgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JzZXJ2YWJsZTtcclxudmFyIF9fYXJyYXkgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuYXJyYXk7XHJcbnZhciBkYXRhU291cmNlQmFzZV9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9kYXRhU291cmNlQmFzZS5zZXJ2aWNlJyk7XHJcbnZhciBkYXRhU291cmNlUHJvY2Vzc29yX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL2RhdGFTb3VyY2VQcm9jZXNzb3Iuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmRhdGFTb3VyY2VzLnNpbXBsZURhdGFTb3VyY2UnO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ3NpbXBsZURhdGFTb3VyY2UnO1xyXG52YXIgU2ltcGxlRGF0YVNvdXJjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2ltcGxlRGF0YVNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNpbXBsZURhdGFTb3VyY2UoZGF0YSwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KTtcclxuICAgICAgICB0aGlzLmNvdW50RmlsdGVyR3JvdXBzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yYXdEYXRhU2V0ID0gZGF0YTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NEYXRhKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU2ltcGxlRGF0YVNvdXJjZTtcclxufSkoZGF0YVNvdXJjZUJhc2Vfc2VydmljZV8xLkRhdGFTb3VyY2VCYXNlKTtcclxuZXhwb3J0cy5TaW1wbGVEYXRhU291cmNlID0gU2ltcGxlRGF0YVNvdXJjZTtcclxuc2ltcGxlRGF0YVNvdXJjZUZhY3RvcnkuJGluamVjdCA9IFtfX29ic2VydmFibGUuZmFjdG9yeU5hbWUsIGRhdGFTb3VyY2VQcm9jZXNzb3Jfc2VydmljZV8xLnByb2Nlc3NvclNlcnZpY2VOYW1lLCBfX2FycmF5LnNlcnZpY2VOYW1lXTtcclxuZnVuY3Rpb24gc2ltcGxlRGF0YVNvdXJjZUZhY3Rvcnkob2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpbXBsZURhdGFTb3VyY2UoZGF0YSwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnNpbXBsZURhdGFTb3VyY2VGYWN0b3J5ID0gc2ltcGxlRGF0YVNvdXJjZUZhY3Rvcnk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JzZXJ2YWJsZS5tb2R1bGVOYW1lLCBfX2FycmF5Lm1vZHVsZU5hbWVdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgc2ltcGxlRGF0YVNvdXJjZUZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGVEYXRhU291cmNlLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvc2ltcGxlRGF0YVNvdXJjZS9zaW1wbGVEYXRhU291cmNlLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JzZXJ2YWJsZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYnNlcnZhYmxlO1xyXG52YXIgX19hcnJheSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5hcnJheTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIF9fc3luY2hyb25pemVkUmVxdWVzdHMgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuc3luY2hyb25pemVkUmVxdWVzdHM7XHJcbnZhciBkYXRhU291cmNlQmFzZV9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9kYXRhU291cmNlQmFzZS5zZXJ2aWNlJyk7XHJcbnZhciBkYXRhU291cmNlUHJvY2Vzc29yX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL2RhdGFTb3VyY2VQcm9jZXNzb3Iuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmRhdGFTb3VyY2VzLnNlcnZlclNlYXJjaERhdGFTb3VyY2UnO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ3NlcnZlclNlYXJjaERhdGFTb3VyY2UnO1xyXG52YXIgU2VydmVyU2VhcmNoRGF0YVNvdXJjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2VydmVyU2VhcmNoRGF0YVNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNlcnZlclNlYXJjaERhdGFTb3VyY2UoZ2V0RGF0YVNldCwgc2VhcmNoRmlsdGVyLCBnZXRGaWx0ZXJNb2RlbCwgdmFsaWRhdGVNb2RlbCwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5LCBvYmplY3QsIHN5bmNocm9uaXplZFJlcXVlc3RzRmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KTtcclxuICAgICAgICB0aGlzLnNlYXJjaEZpbHRlciA9IHNlYXJjaEZpbHRlcjtcclxuICAgICAgICB0aGlzLmdldEZpbHRlck1vZGVsID0gZ2V0RmlsdGVyTW9kZWw7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1vZGVsID0gdmFsaWRhdGVNb2RlbDtcclxuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuICAgICAgICB0aGlzLm1pblNlYXJjaExlbmd0aCA9IDQ7XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlUmVsb2FkID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgX3RoaXMubG9hZGluZ0RhdGFTZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMucmF3RGF0YVNldCA9IGRhdGE7XHJcbiAgICAgICAgICAgIF90aGlzLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgX3RoaXMub2JzZXJ2YWJsZS5maXJlKCdyZWxvYWRlZCcpO1xyXG4gICAgICAgICAgICBfdGhpcy5vYnNlcnZhYmxlLmZpcmUoJ2NoYW5nZWQnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZ2V0RmlsdGVyTW9kZWwgPSB0aGlzLmdldEZpbHRlck1vZGVsIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1vZGVsID0gdGhpcy52YWxpZGF0ZU1vZGVsIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XHJcbiAgICAgICAgdGhpcy5jb3VudEZpbHRlckdyb3VwcyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzZWFyY2hGaWx0ZXIuc2VhcmNoVGV4dDtcclxuICAgICAgICB0aGlzLmZpbHRlck1vZGVsID0gXy5jbG9uZSh0aGlzLmdldEZpbHRlck1vZGVsKCkpO1xyXG4gICAgICAgIHNlYXJjaEZpbHRlci5taW5TZWFyY2hMZW5ndGggPSB0aGlzLm1pblNlYXJjaExlbmd0aDtcclxuICAgICAgICB0aGlzLnN5bmNocm9uaXplZFJlcXVlc3RzID0gc3luY2hyb25pemVkUmVxdWVzdHNGYWN0b3J5LmdldEluc3RhbmNlKGdldERhdGFTZXQsIHRoaXMucmVzb2x2ZVJlbG9hZC5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2ZXJTZWFyY2hEYXRhU291cmNlLnByb3RvdHlwZSwgXCJnZXREYXRhU2V0XCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnN5bmNocm9uaXplZFJlcXVlc3RzLmRhdGFQcm92aWRlciA9IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU2VydmVyU2VhcmNoRGF0YVNvdXJjZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWFyY2hGaWx0ZXIuc2VhcmNoVGV4dCAhPT0gdGhpcy5zZWFyY2hcclxuICAgICAgICAgICAgfHwgdGhpcy5maWx0ZXJNb2RlbENoYW5nZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZWZyZXNoLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlcnZlclNlYXJjaERhdGFTb3VyY2UucHJvdG90eXBlLnJlbG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNlYXJjaCA9IHRoaXMuc2VhcmNoRmlsdGVyLnNlYXJjaFRleHQ7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJNb2RlbCA9IF8uY2xvbmUodGhpcy5nZXRGaWx0ZXJNb2RlbCgpKTtcclxuICAgICAgICB2YXIgaGFzVmFsaWRTZWFyY2ggPSAhdGhpcy5vYmplY3QuaXNOdWxsT3JFbXB0eSh0aGlzLnNlYXJjaCkgJiYgdGhpcy5zZWFyY2gubGVuZ3RoID49IHRoaXMubWluU2VhcmNoTGVuZ3RoO1xyXG4gICAgICAgIHZhciBoYXNWYWxpZEZpbHRlck1vZGVsID0gdGhpcy5maWx0ZXJNb2RlbCAhPSBudWxsICYmIHRoaXMudmFsaWRhdGVNb2RlbCh0aGlzLmZpbHRlck1vZGVsKTtcclxuICAgICAgICBpZiAoIWhhc1ZhbGlkU2VhcmNoICYmICFoYXNWYWxpZEZpbHRlck1vZGVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZVJlbG9hZChudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRhdGFTZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmF3RGF0YVNldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nRGF0YVNldCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZWRSZXF1ZXN0cy5nZXREYXRhKHRoaXMuYnVpbGRTZWFyY2hQYXJhbXMoKSk7XHJcbiAgICB9O1xyXG4gICAgU2VydmVyU2VhcmNoRGF0YVNvdXJjZS5wcm90b3R5cGUuZmlsdGVyTW9kZWxDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5vYmplY3QuYXJlRXF1YWwodGhpcy5nZXRGaWx0ZXJNb2RlbCgpLCB0aGlzLmZpbHRlck1vZGVsKTtcclxuICAgIH07XHJcbiAgICBTZXJ2ZXJTZWFyY2hEYXRhU291cmNlLnByb3RvdHlwZS5idWlsZFNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VhcmNoTW9kZWwgPSB0aGlzLmdldEZpbHRlck1vZGVsKCk7XHJcbiAgICAgICAgaWYgKHNlYXJjaE1vZGVsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2VhcmNoTW9kZWwuc2VhcmNoID0gdGhpcy5zZWFyY2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZWFyY2hNb2RlbCA9IHRoaXMuc2VhcmNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VhcmNoTW9kZWw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNlcnZlclNlYXJjaERhdGFTb3VyY2U7XHJcbn0pKGRhdGFTb3VyY2VCYXNlX3NlcnZpY2VfMS5EYXRhU291cmNlQmFzZSk7XHJcbmV4cG9ydHMuU2VydmVyU2VhcmNoRGF0YVNvdXJjZSA9IFNlcnZlclNlYXJjaERhdGFTb3VyY2U7XHJcbnNlcnZlclNlYXJjaERhdGFTb3VyY2VGYWN0b3J5LiRpbmplY3QgPSBbX19vYnNlcnZhYmxlLmZhY3RvcnlOYW1lLCBkYXRhU291cmNlUHJvY2Vzc29yX3NlcnZpY2VfMS5wcm9jZXNzb3JTZXJ2aWNlTmFtZSwgX19hcnJheS5zZXJ2aWNlTmFtZSwgX19vYmplY3Quc2VydmljZU5hbWUsIF9fc3luY2hyb25pemVkUmVxdWVzdHMuZmFjdG9yeU5hbWVdO1xyXG5mdW5jdGlvbiBzZXJ2ZXJTZWFyY2hEYXRhU291cmNlRmFjdG9yeShvYnNlcnZhYmxlRmFjdG9yeSwgZGF0YVNvdXJjZVByb2Nlc3NvciwgYXJyYXksIG9iamVjdCwgc3luY2hyb25pemVkUmVxdWVzdHNGYWN0b3J5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoZ2V0RGF0YVNldCwgc2VhcmNoRmlsdGVyLCBnZXRGaWx0ZXJNb2RlbCwgdmFsaWRhdGVNb2RlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlcnZlclNlYXJjaERhdGFTb3VyY2UoZ2V0RGF0YVNldCwgc2VhcmNoRmlsdGVyLCBnZXRGaWx0ZXJNb2RlbCwgdmFsaWRhdGVNb2RlbCwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5LCBvYmplY3QsIHN5bmNocm9uaXplZFJlcXVlc3RzRmFjdG9yeSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5zZXJ2ZXJTZWFyY2hEYXRhU291cmNlRmFjdG9yeSA9IHNlcnZlclNlYXJjaERhdGFTb3VyY2VGYWN0b3J5O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29ic2VydmFibGUubW9kdWxlTmFtZSwgX19hcnJheS5tb2R1bGVOYW1lLCBfX29iamVjdC5tb2R1bGVOYW1lLCBfX3N5bmNocm9uaXplZFJlcXVlc3RzLm1vZHVsZU5hbWVdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgc2VydmVyU2VhcmNoRGF0YVNvdXJjZUZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXJTZWFyY2hEYXRhU291cmNlLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvc2VydmVyU2VhcmNoRGF0YVNvdXJjZS9zZXJ2ZXJTZWFyY2hEYXRhU291cmNlLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhU291cmNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFTb3VyY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIGNvbHVtblNlYXJjaEZpbHRlciA9IHJlcXVpcmUoJy4vY29sdW1uU2VhcmNoRmlsdGVyL2NvbHVtblNlYXJjaEZpbHRlci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuY29sdW1uU2VhcmNoRmlsdGVyID0gY29sdW1uU2VhcmNoRmlsdGVyO1xyXG52YXIgZmlsdGVyR3JvdXAgPSByZXF1aXJlKCcuL2ZpbHRlckdyb3VwL2ZpbHRlckdyb3VwLm1vZHVsZScpO1xyXG5leHBvcnRzLmZpbHRlckdyb3VwID0gZmlsdGVyR3JvdXA7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZmlsdGVycyc7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW1xyXG4gICAgY29sdW1uU2VhcmNoRmlsdGVyLm1vZHVsZU5hbWUsXHJcbiAgICBmaWx0ZXJHcm91cC5tb2R1bGVOYW1lLFxyXG5dKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVycy5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJzLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgX19zdHJpbmcgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuc3RyaW5nO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmZpbHRlcnMuY29sdW1uU2VhcmNoRmlsdGVyJztcclxuZXhwb3J0cy5mYWN0b3J5TmFtZSA9ICdjb2x1bW5TZWFyY2hGaWx0ZXInO1xyXG5leHBvcnRzLmZpbHRlck5hbWUgPSAnY29sdW1uLXNlYXJjaCc7XHJcbnZhciBDb2x1bW5TZWFyY2hGaWx0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29sdW1uU2VhcmNoRmlsdGVyKG9iamVjdCwgc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XHJcbiAgICAgICAgdGhpcy50eXBlID0gZXhwb3J0cy5maWx0ZXJOYW1lO1xyXG4gICAgfVxyXG4gICAgQ29sdW1uU2VhcmNoRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm9iamVjdC50b1N0cmluZyh0aGlzLmNvbHVtbi5nZXRWYWx1ZShpdGVtKSk7XHJcbiAgICAgICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoVGV4dDtcclxuICAgICAgICBpZiAoIXRoaXMuY2FzZVNlbnNpdGl2ZSkge1xyXG4gICAgICAgICAgICBzZWFyY2ggPSBzZWFyY2gudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuY29udGFpbnModmFsdWUsIHNlYXJjaCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbHVtblNlYXJjaEZpbHRlcjtcclxufSkoKTtcclxuZXhwb3J0cy5Db2x1bW5TZWFyY2hGaWx0ZXIgPSBDb2x1bW5TZWFyY2hGaWx0ZXI7XHJcbmNvbHVtblNlYXJjaEZpbHRlckZhY3RvcnkuJGluamVjdCA9IFtfX29iamVjdC5zZXJ2aWNlTmFtZSwgX19zdHJpbmcuc2VydmljZU5hbWVdO1xyXG5mdW5jdGlvbiBjb2x1bW5TZWFyY2hGaWx0ZXJGYWN0b3J5KG9iamVjdCwgc3RyaW5nKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sdW1uU2VhcmNoRmlsdGVyKG9iamVjdCwgc3RyaW5nKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmNvbHVtblNlYXJjaEZpbHRlckZhY3RvcnkgPSBjb2x1bW5TZWFyY2hGaWx0ZXJGYWN0b3J5O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29iamVjdC5tb2R1bGVOYW1lLCBfX3N0cmluZy5tb2R1bGVOYW1lXSlcclxuICAgIC5mYWN0b3J5KGV4cG9ydHMuZmFjdG9yeU5hbWUsIGNvbHVtblNlYXJjaEZpbHRlckZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2x1bW5TZWFyY2hGaWx0ZXIuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2NvbHVtblNlYXJjaEZpbHRlci9jb2x1bW5TZWFyY2hGaWx0ZXIuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIGZpbHRlck9wdGlvbiA9IHJlcXVpcmUoJy4vZmlsdGVyT3B0aW9uL2ZpbHRlck9wdGlvbicpO1xyXG5leHBvcnRzLmZpbHRlck9wdGlvbiA9IGZpbHRlck9wdGlvbjtcclxudmFyIG1vZGVGaWx0ZXJHcm91cCA9IHJlcXVpcmUoJy4vbW9kZUZpbHRlckdyb3VwL21vZGVGaWx0ZXJHcm91cC5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubW9kZUZpbHRlckdyb3VwID0gbW9kZUZpbHRlckdyb3VwO1xyXG52YXIgcmFuZ2VGaWx0ZXJHcm91cCA9IHJlcXVpcmUoJy4vcmFuZ2VGaWx0ZXJHcm91cC9yYW5nZUZpbHRlckdyb3VwLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5yYW5nZUZpbHRlckdyb3VwID0gcmFuZ2VGaWx0ZXJHcm91cDtcclxudmFyIGZpbHRlckdyb3VwX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vZmlsdGVyR3JvdXAuc2VydmljZScpO1xyXG52YXIgZmlsdGVyR3JvdXBfZGlyZWN0aXZlXzEgPSByZXF1aXJlKCcuL2ZpbHRlckdyb3VwLmRpcmVjdGl2ZScpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2ZpbHRlckdyb3VwLmRpcmVjdGl2ZScpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9maWx0ZXJHcm91cC5zZXJ2aWNlJykpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmZpbHRlcnMuZmlsdGVyR3JvdXAnO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3QubW9kdWxlTmFtZSxcclxuICAgIGZpbHRlck9wdGlvbi5tb2R1bGVOYW1lLFxyXG4gICAgbW9kZUZpbHRlckdyb3VwLm1vZHVsZU5hbWUsXHJcbiAgICByYW5nZUZpbHRlckdyb3VwLm1vZHVsZU5hbWUsXHJcbl0pXHJcbiAgICAuZmFjdG9yeShmaWx0ZXJHcm91cF9zZXJ2aWNlXzEuZmFjdG9yeU5hbWUsIGZpbHRlckdyb3VwX3NlcnZpY2VfMS5maWx0ZXJHcm91cEZhY3RvcnkpXHJcbiAgICAuZGlyZWN0aXZlKGZpbHRlckdyb3VwX2RpcmVjdGl2ZV8xLmRpcmVjdGl2ZU5hbWUsIGZpbHRlckdyb3VwX2RpcmVjdGl2ZV8xLmZpbHRlckdyb3VwKVxyXG4gICAgLmNvbnRyb2xsZXIoZmlsdGVyR3JvdXBfZGlyZWN0aXZlXzEuY29udHJvbGxlck5hbWUsIGZpbHRlckdyb3VwX2RpcmVjdGl2ZV8xLkZpbHRlckdyb3VwQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlckdyb3VwLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlckdyb3VwLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi8uLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZmlsdGVycy5maWx0ZXJHcm91cC5maWx0ZXJPcHRpb24nO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxGaWx0ZXJPcHRpb24nO1xyXG5mdW5jdGlvbiBmaWx0ZXJPcHRpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vZmlsdGVyT3B0aW9uLmh0bWwnKSxcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICBhY3RpdmF0ZTogJyYnLFxyXG4gICAgICAgICAgICBpc0FjdGl2ZTogJz1hY3RpdmUnLFxyXG4gICAgICAgICAgICBvcHRpb246ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmZpbHRlck9wdGlvbiA9IGZpbHRlck9wdGlvbjtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBmaWx0ZXJPcHRpb24pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXJPcHRpb24uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9maWx0ZXJPcHRpb24vZmlsdGVyT3B0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3cgZmlsdGVyLW9wdGlvblxcXCIgbmctY2xhc3M9XFxcInsgJ2FjdGl2ZSc6IGlzQWN0aXZlIH1cXFwiIG5nLWNsaWNrPVxcXCJhY3RpdmF0ZSgpXFxcIj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tMVxcXCI+XFxyXFxuXFx0XFx0PGkgY2xhc3M9J2ZhIGZhLWFycm93LXJpZ2h0JyBuZy1zaG93PVxcXCJpc0FjdGl2ZSA9PSB0cnVlXFxcIj48L2k+XFxyXFxuXFx0PC9kaXY+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiY29sLXNtLTFcXFwiIG5nLWlmPVxcXCJoYXNJY29uXFxcIiBuZy1iaW5kLWh0bWw9XFxcIm9wdGlvbi5pY29uXFxcIj48L2Rpdj5cXHJcXG5cXHQ8ZGl2IG5nLWNsYXNzPVxcXCJ7ICdjb2wtc20tNic6IGhhc0ljb24sICdjb2wtc20tNyc6ICFoYXNJY29uIH1cXFwiPlxcclxcblxcdFxcdHt7b3B0aW9uLmxhYmVsfX1cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tMyB0ZXh0LXJpZ2h0XFxcIiBuZy1zaG93PVxcXCJvcHRpb24uY291bnQgIT0gbnVsbFxcXCI+XFxyXFxuXFx0XFx0KHt7b3B0aW9uLmNvdW50fX0pXFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlck9wdGlvbi9maWx0ZXJPcHRpb24uaHRtbFxuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgZmlsdGVyR3JvdXBfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vZmlsdGVyR3JvdXAuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmZpbHRlcnMuZmlsdGVyR3JvdXAubW9kZUZpbHRlckdyb3VwJztcclxuZXhwb3J0cy5mYWN0b3J5TmFtZSA9ICdtb2RlRmlsdGVyR3JvdXAnO1xyXG52YXIgTW9kZUZpbHRlckdyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNb2RlRmlsdGVyR3JvdXAsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNb2RlRmlsdGVyR3JvdXAoc2V0dGluZ3MsIG9iamVjdCkge1xyXG4gICAgICAgIHRoaXMuZ2V0VmFsdWUgPSBzZXR0aW5ncy5nZXRWYWx1ZTtcclxuICAgICAgICBzZXR0aW5ncy5vcHRpb25zID0gXy5tYXAoc2V0dGluZ3Mub3B0aW9ucywgdGhpcy5idWlsZE1vZGVPcHRpb24sIHRoaXMpO1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNldHRpbmdzLCBvYmplY3QpO1xyXG4gICAgfVxyXG4gICAgTW9kZUZpbHRlckdyb3VwLnByb3RvdHlwZS5idWlsZE1vZGVPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgbW9kZU9wdGlvbiA9IG9wdGlvbjtcclxuICAgICAgICBtb2RlT3B0aW9uLmZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGlmIChtb2RlT3B0aW9uLmRpc3BsYXlBbGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRWYWx1ZShpdGVtKSA9PT0gbW9kZU9wdGlvbi52YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBtb2RlT3B0aW9uO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNb2RlRmlsdGVyR3JvdXA7XHJcbn0pKGZpbHRlckdyb3VwX3NlcnZpY2VfMS5GaWx0ZXJHcm91cCk7XHJcbmV4cG9ydHMuTW9kZUZpbHRlckdyb3VwID0gTW9kZUZpbHRlckdyb3VwO1xyXG5tb2RlRmlsdGVyR3JvdXBGYWN0b3J5LiRpbmplY3QgPSBbX19vYmplY3Quc2VydmljZU5hbWVdO1xyXG5mdW5jdGlvbiBtb2RlRmlsdGVyR3JvdXBGYWN0b3J5KG9iamVjdCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kZUZpbHRlckdyb3VwKHNldHRpbmdzLCBvYmplY3QpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMubW9kZUZpbHRlckdyb3VwRmFjdG9yeSA9IG1vZGVGaWx0ZXJHcm91cEZhY3Rvcnk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JqZWN0Lm1vZHVsZU5hbWVdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgbW9kZUZpbHRlckdyb3VwRmFjdG9yeSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVGaWx0ZXJHcm91cC5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvbW9kZUZpbHRlckdyb3VwL21vZGVGaWx0ZXJHcm91cC5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxuZXhwb3J0cy5mYWN0b3J5TmFtZSA9ICdmaWx0ZXJHcm91cCc7XHJcbnZhciBGaWx0ZXJHcm91cCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGaWx0ZXJHcm91cChzZXR0aW5ncywgb2JqZWN0KSB7XHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IHNldHRpbmdzLmxhYmVsO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHNldHRpbmdzLnR5cGUgIT0gbnVsbCA/IHNldHRpbmdzLnR5cGUgOiBzZXR0aW5ncy5sYWJlbDtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBzZXR0aW5ncy5vcHRpb25zO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT3B0aW9uID0gdGhpcy5vcHRpb25zWzBdO1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLm9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9uLnR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb24udHlwZSA9IG9wdGlvbi5sYWJlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcHRpb24udHlwZSA9IG9iamVjdC50b1N0cmluZyhvcHRpb24udHlwZSkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIEZpbHRlckdyb3VwLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZU9wdGlvbi5maWx0ZXIoaXRlbSk7XHJcbiAgICB9O1xyXG4gICAgRmlsdGVyR3JvdXAucHJvdG90eXBlLnNldEFjdGl2ZU9wdGlvbiA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5vcHRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU9wdGlvbiA9IHRoaXMub3B0aW9uc1tpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEZpbHRlckdyb3VwLnByb3RvdHlwZS5zZXRPcHRpb25Db3VudHMgPSBmdW5jdGlvbiAoY291bnRzKSB7XHJcbiAgICAgICAgXy5lYWNoKHRoaXMub3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoXy5oYXMoY291bnRzLCBvcHRpb24udHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi5jb3VudCA9IGNvdW50c1tvcHRpb24udHlwZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBGaWx0ZXJHcm91cC5wcm90b3R5cGUudXBkYXRlT3B0aW9uQ291bnRzID0gZnVuY3Rpb24gKGZpbHRlcmVkRGF0YVNldCkge1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLm9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgICAgb3B0aW9uLmNvdW50ID0gXy5maWx0ZXIoZmlsdGVyZWREYXRhU2V0LCBvcHRpb24uZmlsdGVyLCBvcHRpb24pLmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmlsdGVyR3JvdXA7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRmlsdGVyR3JvdXAgPSBGaWx0ZXJHcm91cDtcclxuZmlsdGVyR3JvdXBGYWN0b3J5LiRpbmplY3QgPSBbX19vYmplY3Quc2VydmljZU5hbWVdO1xyXG5mdW5jdGlvbiBmaWx0ZXJHcm91cEZhY3Rvcnkob2JqZWN0KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJHcm91cChzZXR0aW5ncywgb2JqZWN0KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmZpbHRlckdyb3VwRmFjdG9yeSA9IGZpbHRlckdyb3VwRmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyR3JvdXAuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlckdyb3VwLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIGZpbHRlckdyb3VwX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL2ZpbHRlckdyb3VwLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5maWx0ZXJzLmZpbHRlckdyb3VwLnJhbmdlRmlsdGVyR3JvdXAnO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ3JhbmdlRmlsdGVyR3JvdXAnO1xyXG52YXIgUmFuZ2VGaWx0ZXJHcm91cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUmFuZ2VGaWx0ZXJHcm91cCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJhbmdlRmlsdGVyR3JvdXAoc2V0dGluZ3MsIG9iamVjdCkge1xyXG4gICAgICAgIHRoaXMuZ2V0VmFsdWUgPSBzZXR0aW5ncy5nZXRWYWx1ZTtcclxuICAgICAgICBzZXR0aW5ncy5vcHRpb25zID0gXy5tYXAoc2V0dGluZ3Mub3B0aW9ucywgdGhpcy5idWlsZFJhbmdlT3B0aW9uLCB0aGlzKTtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncywgb2JqZWN0KTtcclxuICAgIH1cclxuICAgIFJhbmdlRmlsdGVyR3JvdXAucHJvdG90eXBlLmJ1aWxkUmFuZ2VPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgbW9kZU9wdGlvbiA9IG9wdGlvbjtcclxuICAgICAgICBtb2RlT3B0aW9uLmZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF90aGlzLmdldFZhbHVlKGl0ZW0pO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9uLmhpZ2hFeGNsdXNpdmUpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUgPCBvcHRpb24uaGlnaEV4Y2x1c2l2ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfLmlzVW5kZWZpbmVkKG9wdGlvbi5oaWdoSW5jbHVzaXZlKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlIDw9IG9wdGlvbi5oaWdoSW5jbHVzaXZlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKG9wdGlvbi5sb3dFeGNsdXNpdmUpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIHZhbHVlID4gb3B0aW9uLmxvd0V4Y2x1c2l2ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfLmlzVW5kZWZpbmVkKG9wdGlvbi5sb3dJbmNsdXNpdmUpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIHZhbHVlID49IG9wdGlvbi5sb3dJbmNsdXNpdmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBtb2RlT3B0aW9uO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSYW5nZUZpbHRlckdyb3VwO1xyXG59KShmaWx0ZXJHcm91cF9zZXJ2aWNlXzEuRmlsdGVyR3JvdXApO1xyXG5yYW5nZUZpbHRlckdyb3VwRmFjdG9yeS4kaW5qZWN0ID0gW19fb2JqZWN0LnNlcnZpY2VOYW1lXTtcclxuZnVuY3Rpb24gcmFuZ2VGaWx0ZXJHcm91cEZhY3Rvcnkob2JqZWN0KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZUZpbHRlckdyb3VwKHNldHRpbmdzLCBvYmplY3QpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucmFuZ2VGaWx0ZXJHcm91cEZhY3RvcnkgPSByYW5nZUZpbHRlckdyb3VwRmFjdG9yeTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19vYmplY3QubW9kdWxlTmFtZV0pXHJcbiAgICAuZmFjdG9yeShleHBvcnRzLmZhY3RvcnlOYW1lLCByYW5nZUZpbHRlckdyb3VwRmFjdG9yeSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbmdlRmlsdGVyR3JvdXAuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL3JhbmdlRmlsdGVyR3JvdXAvcmFuZ2VGaWx0ZXJHcm91cC5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxGaWx0ZXJHcm91cCc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnRmlsdGVyR3JvdXBDb250cm9sbGVyJztcclxudmFyIEZpbHRlckdyb3VwQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGaWx0ZXJHcm91cENvbnRyb2xsZXIoJHNjb3BlKSB7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy5oYXNJY29uID0gdGhpcy5pY29uICE9IG51bGwgJiYgdGhpcy5pY29uICE9PSAnJztcclxuICAgICAgICB0aGlzLnNob3dDaGlsZHJlbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBGaWx0ZXJHcm91cENvbnRyb2xsZXIucHJvdG90eXBlLnRvZ2dsZUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2hvd0NoaWxkcmVuID0gIXRoaXMuc2hvd0NoaWxkcmVuO1xyXG4gICAgfTtcclxuICAgIEZpbHRlckdyb3VwQ29udHJvbGxlci5wcm90b3R5cGUuc2VsZWN0T3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgIHRoaXMuZmlsdGVyR3JvdXAuYWN0aXZlT3B0aW9uID0gb3B0aW9uO1xyXG4gICAgICAgIHRoaXMuc2hvd0NoaWxkcmVuID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2UucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy4kc2NvcGUuJGVtaXQoJ2RhdGFTb3VyY2UucmVxdWVzdFJlZnJlc2gnKTsgLy8qZXZlbnQ/XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEZpbHRlckdyb3VwQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnXTtcclxuICAgIHJldHVybiBGaWx0ZXJHcm91cENvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRmlsdGVyR3JvdXBDb250cm9sbGVyID0gRmlsdGVyR3JvdXBDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBmaWx0ZXJHcm91cCgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9maWx0ZXJHcm91cC5kaXJlY3RpdmUuaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnY29udHJvbGxlcicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgaWNvbjogJz0nLFxyXG4gICAgICAgICAgICBmaWx0ZXJHcm91cDogJz0nLFxyXG4gICAgICAgICAgICBzb3VyY2U6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmZpbHRlckdyb3VwID0gZmlsdGVyR3JvdXA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlckdyb3VwLmRpcmVjdGl2ZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlckdyb3VwLmRpcmVjdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiZmlsdGVyLWdyb3VwXFxcIj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJyb3cgZmlsdGVyLWhlYWRlclxcXCIgbmctY2xpY2s9XFxcImNvbnRyb2xsZXIudG9nZ2xlQ2hpbGRyZW4oKVxcXCI+XFxyXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLXNtLTEyXFxcIj5cXHJcXG5cXHRcXHRcXHQ8aSBjbGFzcz1cXFwiY29sbGFwc2UtaWNvbiBmYSBmYS1jYXJldC1kb3duIGZhLTJ4XFxcIiBuZy1zaG93PVxcXCJjb250cm9sbGVyLnNob3dDaGlsZHJlblxcXCIgdGl0bGU9XFxcIkhpZGUgZmlsdGVyIGxpc3RcXFwiPjwvaT5cXHJcXG5cXHRcXHRcXHQ8aSBjbGFzcz1cXFwiY29sbGFwc2UtaWNvbiBmYSBmYS1jYXJldC1yaWdodCBmYS0yeFxcXCIgbmctaGlkZT1cXFwiY29udHJvbGxlci5zaG93Q2hpbGRyZW5cXFwiIHRpdGxlPVxcXCJTaG93IGZpbHRlciBsaXN0XFxcIj48L2k+XFxyXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiZmlsdGVyLW9wdGlvblxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PGRpdiBzdHlsZT1cXFwiZGlzcGxheTppbmxpbmUtYmxvY2tcXFwiIG5nLXNob3c9XFxcImNvbnRyb2xsZXIuaGFzSWNvblxcXCIgbmctYmluZC1odG1sPVxcXCJjb250cm9sbGVyLmljb25cXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdFxcdDxoNCBzdHlsZT1cXFwiZGlzcGxheTogaW5saW5lLWJsb2NrXFxcIj57e2NvbnRyb2xsZXIuZmlsdGVyR3JvdXAubGFiZWx9fToge3tjb250cm9sbGVyLmZpbHRlckdyb3VwLmFjdGl2ZU9wdGlvbi5sYWJlbH19PC9oND5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHQ8ZGl2IG5nLXNob3c9XFxcImNvbnRyb2xsZXIuc2hvd0NoaWxkcmVuXFxcIiBuZy1yZXBlYXQ9XFxcImZpbHRlck9wdGlvbiBpbiBjb250cm9sbGVyLmZpbHRlckdyb3VwLm9wdGlvbnNcXFwiPlxcclxcblxcdFxcdDxybC1maWx0ZXItb3B0aW9uIG9wdGlvbj1cXFwiZmlsdGVyT3B0aW9uXFxcIiBhY3RpdmU9XFxcImZpbHRlckdyb3VwLmFjdGl2ZU9wdGlvbiA9PT0gZmlsdGVyT3B0aW9uXFxcIiBhY3RpdmF0ZT1cXFwiY29udHJvbGxlci5zZWxlY3RPcHRpb24oZmlsdGVyT3B0aW9uKVxcXCI+PC9ybC1maWx0ZXItb3B0aW9uPlxcclxcblxcdDwvZGl2PlxcclxcbjwvZGl2PlxcclxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9maWx0ZXJHcm91cC5kaXJlY3RpdmUuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLml0ZW1Db3VudCc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybEl0ZW1Db3VudCc7XHJcbmZ1bmN0aW9uIGl0ZW1Db3VudCgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICByZXF1aXJlOiAnXl5ybENhcmRDb250YWluZXInLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2l0ZW1Db3VudC5odG1sJyksXHJcbiAgICAgICAgc2NvcGU6IHtcclxuICAgICAgICAgICAgY29udGFpbmVyU2VydmljZTogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuaXRlbUNvdW50ID0gaXRlbUNvdW50O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGl0ZW1Db3VudCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW1Db3VudC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9pdGVtQ291bnQvaXRlbUNvdW50LmpzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8cCBuZy1zaG93PVxcXCIhY29udGFpbmVyU2VydmljZS5kYXRhU291cmNlLmxvYWRpbmdEYXRhU2V0XFxcIj5cXHJcXG5cXHRTaG93aW5nIDxzdHJvbmc+e3tjb250YWluZXJTZXJ2aWNlLmRhdGFTb3VyY2UuZGF0YVNldC5sZW5ndGh9fSBvZiB7e2NvbnRhaW5lclNlcnZpY2UuZGF0YVNvdXJjZS5jb3VudH19PC9zdHJvbmc+IHRvdGFsIGl0ZW1zXFxyXFxuPC9wPlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvaXRlbUNvdW50L2l0ZW1Db3VudC5odG1sXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5wYWdlcic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFBhZ2VyJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdQYWdlckNvbnRyb2xsZXInO1xyXG5leHBvcnRzLmRlZmF1bHRWaXNpYmxlUGFnZUNvdW50ID0gNTtcclxudmFyIFBhZ2VyQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQYWdlckNvbnRyb2xsZXIoJHNjb3BlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNhbkdvQmFjayA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FuR29Gb3J3YXJkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5oYXNQYWdlRmlsdGVyID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVBhZ2VDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRvdGFsSXRlbXMgPSBfdGhpcy5kYXRhU291cmNlLmNvdW50O1xyXG4gICAgICAgICAgICB2YXIgbmV3TGFzdFBhZ2UgPSBNYXRoLmNlaWwodG90YWxJdGVtcyAvIF90aGlzLnBhZ2VyLnBhZ2VTaXplKTtcclxuICAgICAgICAgICAgaWYgKG5ld0xhc3RQYWdlICE9PSBfdGhpcy5sYXN0UGFnZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubGFzdFBhZ2UgPSBuZXdMYXN0UGFnZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnRQYWdlID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy51cGRhdGVQYWdpbmcoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lclNlcnZpY2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFnZXIgPSB0aGlzLmNvbnRhaW5lclNlcnZpY2UucGFnZXI7XHJcbiAgICAgICAgaWYgKHRoaXMucGFnZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmhhc1BhZ2VGaWx0ZXIgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZVBhZ2VDb3VudCA9IHRoaXMucGFnZUNvdW50ICE9IG51bGwgPyB0aGlzLnBhZ2VDb3VudCA6IGV4cG9ydHMuZGVmYXVsdFZpc2libGVQYWdlQ291bnQ7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFBhZ2UgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSB0aGlzLmNvbnRhaW5lclNlcnZpY2UuZGF0YVNvdXJjZTtcclxuICAgICAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kYXRhU291cmNlLmNvdW50OyB9LCB0aGlzLnVwZGF0ZVBhZ2VDb3VudCk7XHJcbiAgICAgICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucGFnZXIucGFnZVNpemU7IH0sIHRoaXMudXBkYXRlUGFnZUNvdW50KTtcclxuICAgICAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jdXJyZW50UGFnZTsgfSwgZnVuY3Rpb24gKHBhZ2UpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVBhZ2luZygpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucGFnZXIucGFnZU51bWJlciA9IHBhZ2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXRhU291cmNlLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgUGFnZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVQYWdpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlO1xyXG4gICAgICAgIHRoaXMuY2FuR29CYWNrID0gcGFnZSA+IDE7XHJcbiAgICAgICAgdGhpcy5jYW5Hb0ZvcndhcmQgPSBwYWdlIDwgdGhpcy5sYXN0UGFnZTtcclxuICAgICAgICB2YXIgbm9uQ3VycmVudFZpc2libGVQYWdlcyA9IHRoaXMudmlzaWJsZVBhZ2VDb3VudCAtIDE7XHJcbiAgICAgICAgdmFyIGJlZm9yZSA9IE1hdGguZmxvb3Iobm9uQ3VycmVudFZpc2libGVQYWdlcyAvIDIpO1xyXG4gICAgICAgIHZhciBhZnRlciA9IE1hdGguY2VpbChub25DdXJyZW50VmlzaWJsZVBhZ2VzIC8gMik7XHJcbiAgICAgICAgdmFyIHN0YXJ0UGFnZSA9IHBhZ2UgLSBiZWZvcmU7XHJcbiAgICAgICAgdmFyIGVuZFBhZ2UgPSBwYWdlICsgYWZ0ZXI7XHJcbiAgICAgICAgaWYgKHN0YXJ0UGFnZSA8IDEpIHtcclxuICAgICAgICAgICAgc3RhcnRQYWdlID0gMTtcclxuICAgICAgICAgICAgZW5kUGFnZSA9IE1hdGgubWluKHRoaXMudmlzaWJsZVBhZ2VDb3VudCwgdGhpcy5sYXN0UGFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGVuZFBhZ2UgPiB0aGlzLmxhc3RQYWdlKSB7XHJcbiAgICAgICAgICAgIGVuZFBhZ2UgPSB0aGlzLmxhc3RQYWdlO1xyXG4gICAgICAgICAgICBzdGFydFBhZ2UgPSBNYXRoLm1heCh0aGlzLmxhc3RQYWdlIC0gbm9uQ3VycmVudFZpc2libGVQYWdlcywgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFnZXMgPSBfLnJhbmdlKHN0YXJ0UGFnZSwgZW5kUGFnZSArIDEpO1xyXG4gICAgfTtcclxuICAgIFBhZ2VyQ29udHJvbGxlci5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IDE7XHJcbiAgICB9O1xyXG4gICAgUGFnZXJDb250cm9sbGVyLnByb3RvdHlwZS5wcmV2aW91cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGFnZSA+IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFnZS0tO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQYWdlckNvbnRyb2xsZXIucHJvdG90eXBlLmdvdG8gPSBmdW5jdGlvbiAocGFnZSkge1xyXG4gICAgICAgIGlmIChwYWdlID49IDEgJiYgcGFnZSA8PSB0aGlzLmxhc3RQYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSBwYWdlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQYWdlckNvbnRyb2xsZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhZ2UgPCB0aGlzLmxhc3RQYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhZ2UrKztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUGFnZXJDb250cm9sbGVyLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSB0aGlzLmxhc3RQYWdlO1xyXG4gICAgfTtcclxuICAgIFBhZ2VyQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnXTtcclxuICAgIHJldHVybiBQYWdlckNvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUGFnZXJDb250cm9sbGVyID0gUGFnZXJDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBwYWdlcigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9wYWdlci5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdwYWdlcicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgcGFnZUNvdW50OiAnPXZpc2libGVQYWdlcycsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclNlcnZpY2U6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnBhZ2VyID0gcGFnZXI7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgcGFnZXIpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBQYWdlckNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlci9wYWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPG5hdiBuZy1pZj1cXFwicGFnZXIuaGFzUGFnZUZpbHRlclxcXCI+XFxyXFxuXFx0PHVsIGNsYXNzPVxcXCJwYWdpbmF0aW9uXFxcIj5cXHJcXG5cXHRcXHQ8bGkgdGl0bGU9XFxcIkdvIHRvIGZpcnN0IHBhZ2VcXFwiIG5nLWNsaWNrPVxcXCJwYWdlci5maXJzdCgpXFxcIlxcclxcblxcdFxcdFxcdG5nLWNsYXNzPVxcXCJ7ICdkaXNhYmxlZCc6ICFwYWdlci5jYW5Hb0JhY2sgfVxcXCI+XFxyXFxuXFx0XFx0XFx0PGE+PGkgY2xhc3M9XFxcImZhIGZhLWFuZ2xlLWRvdWJsZS1sZWZ0XFxcIj48L2k+PC9hPlxcclxcblxcdFxcdDwvbGk+XFxyXFxuXFx0XFx0PGxpIHRpdGxlPVxcXCJHbyB0byBwcmV2aW91cyBwYWdlXFxcIiBuZy1jbGljaz1cXFwicGFnZXIucHJldmlvdXMoKVxcXCJcXHJcXG5cXHRcXHRcXHRuZy1jbGFzcz1cXFwieyAnZGlzYWJsZWQnOiAhcGFnZXIuY2FuR29CYWNrIH1cXFwiPlxcclxcblxcdFxcdFxcdDxhPjxpIGNsYXNzPVxcXCJmYSBmYS1hbmdsZS1sZWZ0XFxcIj48L2k+PC9hPlxcclxcblxcdFxcdDwvbGk+XFxyXFxuXFx0XFx0PGxpIHRpdGxlPVxcXCJHbyB0byBwYWdlIHt7cGFnZXIucGFnZX19XFxcIiBuZy1jbGljaz1cXFwicGFnZXIuZ290byhwYWdlKVxcXCJcXHJcXG5cXHRcXHRcXHRuZy1yZXBlYXQ9XFxcInBhZ2UgaW4gcGFnZXIucGFnZXNcXFwiXFxyXFxuXFx0XFx0XFx0bmctY2xhc3M9XFxcInsgJ2FjdGl2ZSc6IHBhZ2VyLmN1cnJlbnRQYWdlID09IHBhZ2UgfVxcXCI+XFxyXFxuXFx0XFx0XFx0PGE+e3twYWdlfX08L2E+XFxyXFxuXFx0XFx0PC9saT5cXHJcXG5cXHRcXHQ8bGkgdGl0bGU9XFxcIkdvIHRvIG5leHQgcGFnZVxcXCIgbmctY2xpY2s9XFxcInBhZ2VyLm5leHQoKVxcXCJcXHJcXG5cXHRcXHRcXHRuZy1jbGFzcz1cXFwieyAnZGlzYWJsZWQnOiAhcGFnZXIuY2FuR29Gb3J3YXJkIH1cXFwiPlxcclxcblxcdFxcdFxcdDxhPjxpIGNsYXNzPVxcXCJmYSBmYS1hbmdsZS1yaWdodFxcXCI+PC9pPjwvYT5cXHJcXG5cXHRcXHQ8L2xpPlxcclxcblxcdFxcdDxsaSB0aXRsZT1cXFwiR28gdG8gbGFzdCBwYWdlXFxcIiBuZy1jbGljaz1cXFwicGFnZXIubGFzdCgpXFxcIlxcclxcblxcdFxcdFxcdG5nLWNsYXNzPVxcXCJ7ICdkaXNhYmxlZCc6ICFwYWdlci5jYW5Hb0ZvcndhcmQgfVxcXCI+XFxyXFxuXFx0XFx0XFx0PGE+PGkgY2xhc3M9XFxcImZhIGZhLWFuZ2xlLWRvdWJsZS1yaWdodFxcXCI+PC9pPjwvYT5cXHJcXG5cXHRcXHQ8L2xpPlxcclxcblxcdDwvdWw+XFxyXFxuPC9uYXY+XFxyXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlci9wYWdlci5odG1sXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5wYWdlU2l6ZSc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFBhZ2VTaXplJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdQYWdlU2l6ZUNvbnRyb2xsZXInO1xyXG5leHBvcnRzLmF2YWlsYWJsZVBhZ2VTaXplcyA9IFsxMCwgMjUsIDUwLCAxMDBdO1xyXG5leHBvcnRzLmRlZmF1bHRQYWdlU2l6ZSA9IDEwO1xyXG52YXIgUGFnZVNpemVDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBhZ2VTaXplQ29udHJvbGxlcigkc2NvcGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lclNlcnZpY2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRQYWdlU2l6ZSA9IGV4cG9ydHMuZGVmYXVsdFBhZ2VTaXplO1xyXG4gICAgICAgIHRoaXMucGFnZVNpemVzID0gZXhwb3J0cy5hdmFpbGFibGVQYWdlU2l6ZXM7XHJcbiAgICAgICAgdGhpcy5oYXNQYWdlRmlsdGVyID0gdHJ1ZTtcclxuICAgICAgICB2YXIgcGFnZXIgPSB0aGlzLmNvbnRhaW5lclNlcnZpY2UucGFnZXI7XHJcbiAgICAgICAgaWYgKHBhZ2VyID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5oYXNQYWdlRmlsdGVyID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNlbGVjdGVkUGFnZVNpemU7IH0sIGZ1bmN0aW9uIChuZXdQYWdlU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhZ2VyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlci5wYWdlU2l6ZSA9IG5ld1BhZ2VTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRhaW5lclNlcnZpY2UuZGF0YVNvdXJjZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFBhZ2VTaXplQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnXTtcclxuICAgIHJldHVybiBQYWdlU2l6ZUNvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUGFnZVNpemVDb250cm9sbGVyID0gUGFnZVNpemVDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBwYWdlU2l6ZSgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9wYWdlU2l6ZS5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdjb250cm9sbGVyJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBjb250YWluZXJTZXJ2aWNlOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5wYWdlU2l6ZSA9IHBhZ2VTaXplO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIHBhZ2VTaXplKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgUGFnZVNpemVDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZVNpemUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvcGFnZVNpemUvcGFnZVNpemUuanNcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgbmctc2hvdz1cXFwiY29udHJvbGxlci5oYXNQYWdlRmlsdGVyXFxcIj5cXHJcXG5cXHQ8c2VsZWN0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHRpdGxlPVxcXCJDYXJkcyBwZXIgcGFnZVxcXCIgbmctbW9kZWw9XFxcImNvbnRyb2xsZXIuc2VsZWN0ZWRQYWdlU2l6ZVxcXCJcXHJcXG5cXHRcXHRcXHRuZy1vcHRpb25zPVxcXCJwYWdlU2l6ZSBmb3IgcGFnZVNpemUgaW4gY29udHJvbGxlci5wYWdlU2l6ZXNcXFwiPjwvc2VsZWN0PlxcclxcbjwvZGl2PlxcclxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvcGFnZVNpemUvcGFnZVNpemUuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX2Jvb2xlYW4gPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuYm9vbGVhbjtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5zZWxlY3Rpb25Db250cm9sJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsU2VsZWN0aW9uQ29udHJvbCc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXInO1xyXG52YXIgU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXIoJHNjb3BlLCBib29sKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICBpZiAodGhpcy5jb250YWluZXJTZXJ2aWNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXMgPSB0aGlzLmNvbnRhaW5lclNlcnZpY2UubnVtYmVyU2VsZWN0ZWQ7XHJcbiAgICAgICAgdGhpcy5wYWdpbmdFbmFibGVkID0gYm9vbC50b0Jvb2wodGhpcy5jb250YWluZXJTZXJ2aWNlLnBhZ2VyKTtcclxuICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSB0aGlzLmNvbnRhaW5lclNlcnZpY2UuZGF0YVNvdXJjZTtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbnRhaW5lclNlcnZpY2UubnVtYmVyU2VsZWN0ZWQ7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5zZWxlY3RlZEl0ZW1zID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlci5wcm90b3R5cGUuc2VsZWN0UGFnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfLmVhY2godGhpcy5kYXRhU291cmNlLmRhdGFTZXQsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGl0ZW0udmlld0RhdGEuc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlLiRlbWl0KCdzZWxlY3Rpb25DaGFuZ2VkJyk7IC8vKmV2ZW50cz9cclxuICAgIH07XHJcbiAgICBTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlci5wcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLmRhdGFTb3VyY2UuZmlsdGVyZWREYXRhU2V0LCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBpdGVtLnZpZXdEYXRhLnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiRzY29wZS4kZW1pdCgnc2VsZWN0aW9uQ2hhbmdlZCcpOyAvLypldmVudHM/XHJcbiAgICB9O1xyXG4gICAgU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXIucHJvdG90eXBlLmNsZWFyUGFnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfLmVhY2godGhpcy5kYXRhU291cmNlLmRhdGFTZXQsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGl0ZW0udmlld0RhdGEuc2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiRzY29wZS4kZW1pdCgnc2VsZWN0aW9uQ2hhbmdlZCcpOyAvLypldmVudHM/XHJcbiAgICB9O1xyXG4gICAgU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXIucHJvdG90eXBlLmNsZWFyQWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLmRhdGFTb3VyY2UuZmlsdGVyZWREYXRhU2V0LCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBpdGVtLnZpZXdEYXRhLnNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUuJGVtaXQoJ3NlbGVjdGlvbkNoYW5nZWQnKTsgLy8qZXZlbnRzP1xyXG4gICAgfTtcclxuICAgIFNlbGVjdGlvbkNvbnRyb2xDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsIF9fYm9vbGVhbi5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXIgPSBTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gc2VsZWN0aW9uQ29udHJvbCgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9zZWxlY3Rpb25Db250cm9sLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ3NlbGVjdGlvbicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgY29udGFpbmVyU2VydmljZTogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuc2VsZWN0aW9uQ29udHJvbCA9IHNlbGVjdGlvbkNvbnRyb2w7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fYm9vbGVhbi5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBzZWxlY3Rpb25Db250cm9sKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3Rpb25Db250cm9sLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3NlbGVjdGlvbkNvbnRyb2wvc2VsZWN0aW9uQ29udHJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdj5cXHJcXG5cXHQ8ZGl2IHN0eWxlPVxcXCJtYXJnaW4tYm90dG9tOiA1cHhcXFwiPlxcclxcblxcdFxcdDxzcGFuPjxzdHJvbmc+e3tzZWxlY3Rpb24uc2VsZWN0ZWRJdGVtc319PC9zdHJvbmc+IGl0ZW1zIHNlbGVjdGVkPC9zcGFuPlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxkaXYgc3R5bGU9XFxcIm1hcmdpbi1ib3R0b206IDVweFxcXCIgbmctaWY9XFxcInNlbGVjdGlvbi5wYWdpbmdFbmFibGVkXFxcIj5cXHJcXG5cXHRcXHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgbmctY2xpY2s9XFxcInNlbGVjdGlvbi5zZWxlY3RQYWdlKClcXFwiPlNlbGVjdCBwYWdlPC9idXR0b24+XFxyXFxuXFx0XFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3Rpb24uY2xlYXJQYWdlKClcXFwiPkNsZWFyIHBhZ2U8L2J1dHRvbj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHQ8ZGl2PlxcclxcblxcdFxcdDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiBuZy1jbGljaz1cXFwic2VsZWN0aW9uLnNlbGVjdEFsbCgpXFxcIj5TZWxlY3QgYWxsPC9idXR0b24+XFxyXFxuXFx0XFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3Rpb24uY2xlYXJBbGwoKVxcXCI+Q2xlYXIgYWxsPC9idXR0b24+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zZWxlY3Rpb25Db250cm9sL3NlbGVjdGlvbkNvbnRyb2wuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBfX2FycmF5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmFycmF5O1xyXG52YXIgX19wYXJlbnRDaGlsZCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wYXJlbnRDaGlsZEJlaGF2aW9yO1xyXG52YXIgZGF0YVNvdXJjZXNfbW9kdWxlXzEgPSByZXF1aXJlKCcuL2RhdGFTb3VyY2VzL2RhdGFTb3VyY2VzLm1vZHVsZScpO1xyXG52YXIgc29ydHNfbW9kdWxlXzEgPSByZXF1aXJlKCcuL3NvcnRzL3NvcnRzLm1vZHVsZScpO1xyXG52YXIgYnJlYWtwb2ludF8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvYnJlYWtwb2ludHMvYnJlYWtwb2ludCcpO1xyXG52YXIgY2FyZENvbnRhaW5lcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuL2NhcmRDb250YWluZXIuc2VydmljZScpO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxDYXJkQ29udGFpbmVyJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdDYXJkQ29udGFpbmVyQ29udHJvbGxlcic7XHJcbmV4cG9ydHMuZGVmYXVsdE1heENvbHVtblNvcnRzID0gMjtcclxuZXhwb3J0cy5kZWZhdWx0U2VsZWN0aW9uVGl0bGUgPSAnU2VsZWN0IGNhcmQnO1xyXG52YXIgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIoJHNjb3BlLCAkYXR0cnMsIG9iamVjdCwgYXJyYXksIGRhdGFQYWdlckZhY3RvcnksIHBhcmVudENoaWxkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XHJcbiAgICAgICAgdGhpcy5kYXRhUGFnZXJGYWN0b3J5ID0gZGF0YVBhZ2VyRmFjdG9yeTtcclxuICAgICAgICB0aGlzLnBhcmVudENoaWxkID0gcGFyZW50Q2hpbGQ7XHJcbiAgICAgICAgdGhpcy5udW1iZXJTZWxlY3RlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5hZGRWaWV3RGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgXy5lYWNoKF90aGlzLmRhdGFTb3VyY2UucmF3RGF0YVNldCwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGl0ZW0udmlld0RhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS52aWV3RGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBfdGhpcy51cGRhdGVEaXNhYmxlZFNlbGVjdGlvbnMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuY2xlYXJGaWx0ZXJlZFNlbGVjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBub25WaXNpYmxlSXRlbXMgPSBfLmRpZmZlcmVuY2UoX3RoaXMuZGF0YVNvdXJjZS5yYXdEYXRhU2V0LCBfdGhpcy5kYXRhU291cmNlLmZpbHRlcmVkRGF0YVNldCk7XHJcbiAgICAgICAgICAgIF8uZWFjaChub25WaXNpYmxlSXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChpdGVtLnZpZXdEYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udmlld0RhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaXRlbS52aWV3RGF0YS5zZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaXRlbS52aWV3RGF0YS5zZWxlY3Rpb25UaXRsZSA9IGV4cG9ydHMuZGVmYXVsdFNlbGVjdGlvblRpdGxlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlU2VsZWN0ZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm51bWJlclNlbGVjdGVkID0gXy5maWx0ZXIoX3RoaXMuZGF0YVNvdXJjZS5maWx0ZXJlZERhdGFTZXQsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS52aWV3RGF0YSAhPSBudWxsICYmIGl0ZW0udmlld0RhdGEuc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgIH0pLmxlbmd0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudXBkYXRlRGlzYWJsZWRTZWxlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuZGlzYWJsaW5nU2VsZWN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKF90aGlzLmRhdGFTb3VyY2UucmF3RGF0YVNldCwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzYWJsZWRSZWFzb24gPSBfdGhpcy5kaXNhYmxlU2VsZWN0aW9uKHsgaXRlbTogaXRlbSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnZpZXdEYXRhLmRpc2FibGVkU2VsZWN0aW9uID0gKGRpc2FibGVkUmVhc29uICE9IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udmlld0RhdGEuc2VsZWN0aW9uVGl0bGUgPSAoaXRlbS52aWV3RGF0YS5kaXNhYmxlZFNlbGVjdGlvbiA/IGRpc2FibGVkUmVhc29uIDogZXhwb3J0cy5kZWZhdWx0U2VsZWN0aW9uVGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IHRoaXMuc291cmNlO1xyXG4gICAgICAgIHRoaXMucGVybWFuZW50Rm9vdGVycyA9IF8uaXNVbmRlZmluZWQodGhpcy5wZXJtYW5lbnRGb290ZXJzKSA/IGZhbHNlIDogdGhpcy5wZXJtYW5lbnRGb290ZXJzO1xyXG4gICAgICAgIHRoaXMubWF4Q29sU29ydHMgPSB0aGlzLm1heENvbHVtblNvcnRzICE9IG51bGwgPyB0aGlzLm1heENvbHVtblNvcnRzIDogZXhwb3J0cy5kZWZhdWx0TWF4Q29sdW1uU29ydHM7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxpbmdTZWxlY3Rpb25zID0gb2JqZWN0LmlzTnVsbE9yV2hpdGVzcGFjZSgkYXR0cnMuZGlzYWJsZVNlbGVjdGlvbikgPT09IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc29ydERpcmVjdGlvbiA9IHNvcnRzX21vZHVsZV8xLlNvcnREaXJlY3Rpb247XHJcbiAgICAgICAgdGhpcy5zeW5jRmlsdGVycygpO1xyXG4gICAgICAgIHRoaXMuc2V0dXBQYWdpbmcoKTtcclxuICAgICAgICB0aGlzLmJ1aWxkQ29sdW1uU2l6ZXMoKTtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RhYmxlQ2FyZHMpIHtcclxuICAgICAgICAgICAgLy8qdXNlIGNhcmQgY29udGFpbmVyIGV2ZW50IHNlcnZpY2U/XHJcbiAgICAgICAgICAgICRzY29wZS4kb24oJ3NlbGVjdGlvbkNoYW5nZWQnLCB0aGlzLnVwZGF0ZVNlbGVjdGVkKTtcclxuICAgICAgICAgICAgJHNjb3BlLiRvbigndXBkYXRlRGlzYWJsZWRTZWxlY3Rpb25zJywgdGhpcy51cGRhdGVEaXNhYmxlZFNlbGVjdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2Uud2F0Y2godGhpcy5hZGRWaWV3RGF0YSwgJ2NoYW5nZWQnKTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLndhdGNoKHRoaXMuY2xlYXJGaWx0ZXJlZFNlbGVjdGlvbnMsICdyZWRyYXdpbmcnKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRWaWV3RGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbHVtbiA9IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnZpZXdEYXRhLnNlbGVjdGVkO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZsaXBTb3J0OiB0cnVlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlLnNvcnRzID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnNvcnRzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgICRzY29wZS5jb250YWluZXJTZXJ2aWNlID0gbmV3IGNhcmRDb250YWluZXJfc2VydmljZV8xLkNhcmRDb250YWluZXJTZXJ2aWNlKHRoaXMpO1xyXG4gICAgICAgICRzY29wZS5jb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhO1xyXG4gICAgfVxyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLnNvcnRTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNvcnQodGhpcy5zZWxlY3Rpb25Db2x1bW4pO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS5vcGVuQ2FyZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYmVoYXZpb3JzID0gdGhpcy5wYXJlbnRDaGlsZC5nZXRBbGxDaGlsZEJlaGF2aW9ycyh0aGlzLmRhdGFTb3VyY2UuZGF0YVNldCk7XHJcbiAgICAgICAgcmV0dXJuIF8uYWxsKF8ubWFwKGJlaGF2aW9ycywgZnVuY3Rpb24gKGJlaGF2aW9yKSB7IHJldHVybiBiZWhhdmlvci5jbG9zZSgpOyB9KSk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoY29sdW1uKSB7XHJcbiAgICAgICAgdmFyIHNvcnRMaXN0ID0gdGhpcy5kYXRhU291cmNlLnNvcnRzO1xyXG4gICAgICAgIHZhciBmaXJzdFNvcnQgPSBzb3J0TGlzdFswXTtcclxuICAgICAgICAvLyBJZiBjb2x1bW4gaXMgYWxyZWFkeSB0aGUgcHJpbWFyeSBzb3J0LCBjaGFuZ2UgdGhlIGRpcmVjdGlvblxyXG4gICAgICAgIGlmIChmaXJzdFNvcnQgIT0gbnVsbFxyXG4gICAgICAgICAgICAmJiBmaXJzdFNvcnQuY29sdW1uID09PSBjb2x1bW4pIHtcclxuICAgICAgICAgICAgZmlyc3RTb3J0LmRpcmVjdGlvbiA9IHNvcnRzX21vZHVsZV8xLlNvcnREaXJlY3Rpb24udG9nZ2xlKGZpcnN0U29ydC5kaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAvLyBDbGVhciBzb3J0XHJcbiAgICAgICAgICAgIGlmIChmaXJzdFNvcnQuZGlyZWN0aW9uID09PSBzb3J0c19tb2R1bGVfMS5Tb3J0RGlyZWN0aW9uLm5vbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJWaXN1YWxTb3J0SW5kaWNhdG9yKGZpcnN0U29ydCk7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFNvcnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvbHVtbiBoYXMgc2Vjb25kYXJ5IHNvcnRzIGRvbid0IGZhbGwgYmFjayB0byBhXHJcbiAgICAgICAgICAgICAgICAvLyAgc2Vjb25kYXJ5IHNvcnQsIGluc3RlYWQganVzdCBjbGVhciBhbGwgc29ydHNcclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uc2Vjb25kYXJ5U29ydHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvcnRMaXN0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3J0TGlzdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBFbHNlIG1ha2UgY29sdW1uIHByaW1hcnkgYXNjZW5kaW5nIHNvcnRcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBub24tcHJpbWFyeSBzb3J0cyBvbiBjb2x1bW5cclxuICAgICAgICAgICAgdGhpcy5hcnJheS5yZW1vdmUoc29ydExpc3QsIGZ1bmN0aW9uIChzb3J0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uID09PSBzb3J0LmNvbHVtbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIGFzY2VuZGluZyBzb3J0IGZvciBjb2x1bW5cclxuICAgICAgICAgICAgdmFyIG5ld1NvcnQgPSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogc29ydHNfbW9kdWxlXzEuU29ydERpcmVjdGlvbi5hc2NlbmRpbmcsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNvcnRMaXN0LnVuc2hpZnQobmV3U29ydCk7XHJcbiAgICAgICAgICAgIGZpcnN0U29ydCA9IG5ld1NvcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlVmlzdWFsQ29sdW1uU29ydGluZygpO1xyXG4gICAgICAgIC8vIElmIGNvbHVtbiBoYXMgc2Vjb25kYXJ5IHNvcnRzLCB3aXBlIHRoZSBzb3J0IG9yZGVyIGFuZCBqdXN0IGFwcGx5IHRoZSBzZWNvbmRhcnkgc29ydHNcclxuICAgICAgICBpZiAoZmlyc3RTb3J0ICE9IG51bGwgJiYgY29sdW1uLnNlY29uZGFyeVNvcnRzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc29ydExpc3QubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdmFyIHNlY29uZGFyeVNvcnRzID0gdGhpcy5idWlsZFNlY29uZGFyeVNvcnRzKGZpcnN0U29ydC5kaXJlY3Rpb24sIGNvbHVtbi5zZWNvbmRhcnlTb3J0cyk7XHJcbiAgICAgICAgICAgIHNvcnRMaXN0LnB1c2goZmlyc3RTb3J0KTtcclxuICAgICAgICAgICAgc29ydExpc3QucHVzaC5hcHBseShzb3J0TGlzdCwgc2Vjb25kYXJ5U29ydHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgbm90IHVzaW5nIGNvbHVtbiBzZWNvbmRhcnkgc29ydHMsIGxpbWl0IHRoZSBtYXhpbXVtIG51bWJlclxyXG4gICAgICAgICAgICAvLyAgb2Ygc29ydHMgYXBwbGllZCB0byB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc29ydHNcclxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnNvcnRzID0gXy50YWtlKHNvcnRMaXN0LCB0aGlzLm1heENvbFNvcnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnJlZnJlc2goKTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUuc2VsZWN0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkKCk7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUuJGVtaXQoJ3NlbGVjdGlvbkNoYW5nZWQnKTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUuc3luY0ZpbHRlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVycyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZmlsdGVyIGFycmF5IHRvIGRpY3Rpb25hcnkgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkodGhpcy5maWx0ZXJzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gdGhpcy5hcnJheS50b0RpY3Rpb25hcnkodGhpcy5maWx0ZXJzLCBmdW5jdGlvbiAoZmlsdGVyKSB7IHJldHVybiBmaWx0ZXIudHlwZTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLmZpbHRlcnMgPSB0aGlzLmZpbHRlcnM7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGF0YVNvdXJjZS5maWx0ZXJzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gdGhpcy5kYXRhU291cmNlLmZpbHRlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS5zZXR1cFBhZ2luZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBJZiBwYWdpbmcgZmxhZyBpcyBzcGVjaWZpZWQsIGNhcmQgY29udGFpbmVyIGNvbnRyb2xzIHBhZ2VyIGluc3RhbmNlXHJcbiAgICAgICAgaWYgKHRoaXMucGFnaW5nICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFnaW5nID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnBhZ2VyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFnZXIgPSB0aGlzLmRhdGFQYWdlckZhY3RvcnkuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5wYWdlciA9IHRoaXMucGFnZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kYXRhU291cmNlLnBhZ2VyKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYWdpbmcgZmxhZyBpcyBub3Qgc2V0IGFuZCB0aGUgZGF0YVNvdXJjZSBoYXMgYSBwYWdlciwgc2F2ZSBhIHJlZmVyZW5jZSBoZXJlXHJcbiAgICAgICAgICAgIHRoaXMucGFnZXIgPSB0aGlzLmRhdGFTb3VyY2UucGFnZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS5idWlsZENvbHVtblNpemVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgXy5lYWNoKHRoaXMuY29sdW1ucywgZnVuY3Rpb24gKGNvbHVtbikge1xyXG4gICAgICAgICAgICB2YXIgc2l6ZXMgPSBjb2x1bW4uc2l6ZTtcclxuICAgICAgICAgICAgaWYgKF8uaXNPYmplY3Qoc2l6ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplc1ticmVha3BvaW50XzEueHNdID0gX3RoaXMub2JqZWN0LnZhbHVlT3JEZWZhdWx0KHNpemVzW2JyZWFrcG9pbnRfMS54c10sIDApO1xyXG4gICAgICAgICAgICAgICAgc2l6ZXNbYnJlYWtwb2ludF8xLnNtXSA9IF90aGlzLm9iamVjdC52YWx1ZU9yRGVmYXVsdChzaXplc1ticmVha3BvaW50XzEuc21dLCBzaXplc1ticmVha3BvaW50XzEueHNdKTtcclxuICAgICAgICAgICAgICAgIHNpemVzW2JyZWFrcG9pbnRfMS5tZF0gPSBfdGhpcy5vYmplY3QudmFsdWVPckRlZmF1bHQoc2l6ZXNbYnJlYWtwb2ludF8xLm1kXSwgc2l6ZXNbYnJlYWtwb2ludF8xLnNtXSk7XHJcbiAgICAgICAgICAgICAgICBzaXplc1ticmVha3BvaW50XzEubGddID0gX3RoaXMub2JqZWN0LnZhbHVlT3JEZWZhdWx0KHNpemVzW2JyZWFrcG9pbnRfMS5sZ10sIHNpemVzW2JyZWFrcG9pbnRfMS5tZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29sdW1uLnNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeHM6IHNpemVzLFxyXG4gICAgICAgICAgICAgICAgICAgIHNtOiBzaXplcyxcclxuICAgICAgICAgICAgICAgICAgICBtZDogc2l6ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgbGc6IHNpemVzLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS5sb29rdXBDb2x1bW4gPSBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICByZXR1cm4gXy5maW5kKHRoaXMuY29sdW1ucywgZnVuY3Rpb24gKGNvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gY29sdW1uLmxhYmVsID09PSBsYWJlbDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUuYnVpbGRTZWNvbmRhcnlTb3J0cyA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIHNlY29uZGFyeVNvcnRzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgc29ydExpc3QgPSBzZWNvbmRhcnlTb3J0c1tzb3J0c19tb2R1bGVfMS5Tb3J0RGlyZWN0aW9uLmdldEZ1bGxOYW1lKGRpcmVjdGlvbildO1xyXG4gICAgICAgIHJldHVybiBfLm1hcChzb3J0TGlzdCwgZnVuY3Rpb24gKHNvcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogc29ydC5kaXJlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBjb2x1bW46IF90aGlzLmxvb2t1cENvbHVtbihzb3J0LmNvbHVtbiksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZVZpc3VhbENvbHVtblNvcnRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfLmVhY2godGhpcy5kYXRhU291cmNlLnNvcnRzLCBmdW5jdGlvbiAoc29ydCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgLy8gT25seSBmaXJzdCBzb3J0IHNob3VsZCBoYXZlIHZpc2libGUgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlVmlzdWFsU29ydEluZGljYXRvcihzb3J0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyVmlzdWFsU29ydEluZGljYXRvcihzb3J0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVWaXN1YWxTb3J0SW5kaWNhdG9yID0gZnVuY3Rpb24gKHNvcnQpIHtcclxuICAgICAgICBzb3J0LmNvbHVtbi5zb3J0RGlyZWN0aW9uID0gc29ydC5kaXJlY3Rpb247XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLmNsZWFyVmlzdWFsU29ydEluZGljYXRvciA9IGZ1bmN0aW9uIChzb3J0KSB7XHJcbiAgICAgICAgc29ydC5jb2x1bW4uc29ydERpcmVjdGlvbiA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRhdHRycycsIF9fb2JqZWN0LnNlcnZpY2VOYW1lLCBfX2FycmF5LnNlcnZpY2VOYW1lLCBkYXRhU291cmNlc19tb2R1bGVfMS5kYXRhUGFnZXIuZmFjdG9yeU5hbWUsIF9fcGFyZW50Q2hpbGQuc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIENhcmRDb250YWluZXJDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkNhcmRDb250YWluZXJDb250cm9sbGVyID0gQ2FyZENvbnRhaW5lckNvbnRyb2xsZXI7XHJcbmNhcmRDb250YWluZXIuJGluamVjdCA9IFsnJGNvbXBpbGUnXTtcclxuZnVuY3Rpb24gY2FyZENvbnRhaW5lcigkY29tcGlsZSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vY2FyZENvbnRhaW5lci5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdjYXJkQ29udGFpbmVyJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICAvLyBzdW1tYXJ5OiBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSBjYXJkIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAvLyByZW1hcmtzOiBDYW4gYmUgYW4gYXJyYXkgb2Ygb2JqZWN0cywgb3IgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGRhdGEgc291cmNlIGNvbnRyYWN0OiB7XHJcbiAgICAgICAgICAgIC8vICAgICBzb3J0czogQSBsaXN0IG9mIHNvcnRzIHRvIGFwcGx5IHRvIHRoZSBkYXRhLiBTb3J0cyBzaG91bGQgYmUgaW4gdGhpcyBmb3JtYXQ6IHtcclxuICAgICAgICAgICAgLy8gICAgICAgICBjb2x1bW46IFRoZSBuYW1lIG9mIHRoZSBjb2x1bW4gdG8gc29ydCBvbixcclxuICAgICAgICAgICAgLy8gICAgICAgICBkaXJlY3Rpb246IFNvcnQgYXNjZW5kaW5nIG9yIGRlc2NlbmRpbmcgKHNvcnREaXJlY3Rpb24uanMpXHJcbiAgICAgICAgICAgIC8vICAgICB9LFxyXG4gICAgICAgICAgICAvLyAgICAgZmlsdGVyczogQSBsaXN0IG9mIGZpbHRlcnMgdG8gYXBwbHkgdG8gdGhlIGRhdGEgc291cmNlLFxyXG4gICAgICAgICAgICAvLyAgICAgcGFnZXI6IEEgcGFnZXIgdGhhdCBjYW4gYmUgb3B0aW9uYWxseSB1c2VkIHRvIHBhZ2UgdGhlIGRhdGE6IHtcclxuICAgICAgICAgICAgLy8gICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKGRhdGFTZXQpIHtcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgVGFrZXMgdGhlIGRhdGEgc2V0IGFuZCBmaWx0ZXJzIGl0IGRvd24gdG8gcGFnZXNcclxuICAgICAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vICAgICB9LFxyXG4gICAgICAgICAgICAvLyAgICAgcmVmcmVzaDogW2Z1bmN0aW9uXSBDYWxsIHRvIHRyaWdnZXIgdGhlIGRhdGEgc291cmNlIHRvIHJlZnJlc2gsXHJcbiAgICAgICAgICAgIC8vICAgICBkYXRhU2V0OiBXaWxsIGNvbnRhaW4gdGhlIHJlc3VsdGluZyBkYXRhIHByb3ZpZGVkIGJ5IHRoZSBzb3VyY2UsIGFmdGVyIHNvcnRzIGFuZCBmaWx0ZXJzIGFyZSBhcHBsaWVkLFxyXG4gICAgICAgICAgICAvLyAgICAgY291bnQ6IFRoZSBudW1iZXIgb2YgaXRlbXMgYXZhaWxhYmxlIGluIHRoZSBkYXRhIHNldCAodXNlZCBmb3IgcGFnaW5nKS5cclxuICAgICAgICAgICAgLy8gICAgIGxvYWRpbmdEYXRhU2V0OiBBIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgZGF0YVNldCBpcyBiZWluZyByZWZyZXNoZWQgLyBsb2FkZWQsXHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgc291cmNlOiAnPScsXHJcbiAgICAgICAgICAgIC8vIHN1bW1hcnk6IEEgbGlzdCBvZiBmaWx0ZXJzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGRhdGEgc291cmNlXHJcbiAgICAgICAgICAgIC8vIHJlbWFya3M6IEVhY2ggZmlsdGVyIHNob3VsZCBpbXBsZW1lbnQgdGhlIGRhdGEgZmlsdGVyIGNvbnRyYWN0OiB7XHJcbiAgICAgICAgICAgIC8vICAgICB0eXBlOiBBIG5hbWUgdGhhdCBjYW4gYmUgdXNlZCB0byBsb29rIHVwIHRoZSBmaWx0ZXIsXHJcbiAgICAgICAgICAgIC8vICAgICBmaWx0ZXI6IGZ1bmN0aW9uKGl0ZW0pIHsgdGFrZXMgYW4gaXRlbSBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIHRoZSBkYXRhIHNldCB9LFxyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIGZpbHRlcnM6ICc9JyxcclxuICAgICAgICAgICAgLy8gc3VtbWFyeTogVHVybiBwYWdpbmcgb24gb3Igb2ZmICh0cnVlIC8gZmFsc2UpXHJcbiAgICAgICAgICAgIHBhZ2luZzogJz0nLFxyXG4gICAgICAgICAgICAvLyBzdW1tYXJ5OiBBIGxpc3Qgb2YgdGhlIGNvbHVtbnMgZm9yIGJ1aWxkaW5nIHRoZSBjb2x1bW4gaGVhZGVyIGFuZCBjYXJkIGhlYWRlcnMuXHJcbiAgICAgICAgICAgIC8vIHJlbWFya3M6IEVhY2ggY29sdW1uIG9iamVjdCBzaG91bGQgYmUgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6IHtcclxuICAgICAgICAgICAgLy8gICAgIGxhYmVsOiBUaGUgbGFiZWwgZm9yIHRoZSBjb2x1bW4gaGVhZGVyLFxyXG4gICAgICAgICAgICAvLyAgICAgZGVzY3JpcHRpb246IEEgZGVzY3JpcHRpb24gZm9yIHRoZSBjb2x1bW47IHNob3duIGluIHRvb2x0aXBzLFxyXG4gICAgICAgICAgICAvLyAgICAgc2l6ZTogQSBkZXNjcmlwdGlvbiBvZiB0aGUgY29sdW1uIHNpemUgYXQgYnJlYWtwb2ludHM7IGVpdGhlciBhIGNvbnN0YW50IGludCAoZm9yIGNvbnN0YW50IHNpemUpIG9yIGJyZWFrcG9pbnQgZGV0YWlsIG9iamVjdDoge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIFt4c106IG9wdGlvbmFsIHNpemUgZm9yIHhzIGJyZWFrcG9pbnQgKGRlZmF1bHRzIHRvIDApLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFtzbV06IG9wdGlvbmFsIHNpemUgZm9yIHNtIGJyZWFrcG9pbnQgKGRlZmF1bHRzIHRvIHhzKSxcclxuICAgICAgICAgICAgLy8gICAgICAgICBbbWRdOiBvcHRpb25hbCBzaXplIGZvciBtZCBicmVha3BvaW50IChkZWZhdWx0cyB0byBzbSksXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgW2xnXTogb3B0aW9uYWwgc2l6ZSBmb3IgbGcgYnJlYWtwb2ludCAoZGVmYXVsdHMgdG8gbWQpLFxyXG4gICAgICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAgICAgLy8gICAgIGdldFZhbHVlOiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBkYXRhIHJlY29yZCBhbmQgcmV0cmlldmVzIHRoZSB2YWx1ZSBmb3IgdGhlIGNvbHVtbixcclxuICAgICAgICAgICAgLy8gICAgIGhlYWRlclRlbXBsYXRlVXJsOiBUaGUgcGF0aCB0byBhbiBIVE1MIHRlbXBsYXRlIGZvciB0aGUgY29sdW1uIGhlYWRlcixcclxuICAgICAgICAgICAgLy8gICAgIGhlYWRlclRlbXBsYXRlOiBBbiBIVE1MIHRlbXBsYXRlIHN0cmluZyBmb3IgdGhlIGNvbHVtbiBoZWFkZXIgKG92ZXJyaWRlbiBieSBoZWFkZXJUZW1wbGF0ZVVybCBpZiBwcmVzZW50KSxcclxuICAgICAgICAgICAgLy8gICAgIHRlbXBsYXRlVXJsOiBUaGUgcGF0aCB0byBhbiBIVE1MIHRlbXBsYXRlIGZvciB0aGUgY2FyZCBoZWFkZXIsXHJcbiAgICAgICAgICAgIC8vICAgICB0ZW1wbGF0ZTogQW4gSFRNTCB0ZW1wbGF0ZSBzdHJpbmcgZm9yIHRoZSBjYXJkIGhlYWRlciAob3ZlcnJpZGVuIGJ5IHRlbXBsYXRlVXJsIGlmIHByZXNlbnQpLFxyXG4gICAgICAgICAgICAvLyAgICAgc2Vjb25kYXJ5U29ydHM6IEEgc2V0IG9mIHNlY29uZGFyeSBzb3J0cyB0byBhcHBseSBvbiBvdGhlciBjb2x1bW5zIHdoZW4gdGhpcyBjb2x1bW4gaXMgc29ydGVkIChhc2NlbmRpbmcgYW5kIC8gb3IgZGVzY2VuZGluZyk6IHtcclxuICAgICAgICAgICAgLy8gICAgICAgIHNvcnREaXJlY3Rpb24uYXNjZW5kaW5nICgnYXNjJyk6ICBbXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgIGNvbHVtbjogVGhlIGxhYmVsIG9mIGFub3RoZXIgY29sdW1uIHRvIHNvcnQgb24sXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFRoZSBkaXJlY3Rpb24gdG8gc29ydCB0aGUgY29sdW1uLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAuLi5cclxuICAgICAgICAgICAgLy8gICAgICAgIF0sXHJcbiAgICAgICAgICAgIC8vICAgICAgICBzb3J0RGlyZWN0aW9uLmRlc2NlbmRpbmcgKCdkZXNjJyk6IFtcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgY29sdW1uOiBUaGUgbGFiZWwgb2YgYW5vdGhlciBjb2x1bW4gdG8gc29ydCBvbixcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogVGhlIGRpcmVjdGlvbiB0byBzb3J0IHRoZSBjb2x1bW4sXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIC4uLlxyXG4gICAgICAgICAgICAvLyAgICAgICAgXSxcclxuICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICBjb2x1bW5zOiAnPScsXHJcbiAgICAgICAgICAgIC8vIHN1bW1hcnk6IGNvbnRhaW5lci13aWRlIGRhdGEgYXZhaWxhYmxlIGluIGNhcmRzXHJcbiAgICAgICAgICAgIGNvbnRhaW5lckRhdGE6ICc9JyxcclxuICAgICAgICAgICAgLy8gc3VtbWFyeTogY29udHJvbGxlciBzaGFyZWQgYnkgYWxsIGNvbXBvbmVudHMgb24gYSBjYXJkXHJcbiAgICAgICAgICAgIC8vIHJlbWFya3M6IHRoaXMgY29udHJvbGxlciBjYW5ub3Qgb3ZlcnJpZGUgYW55IG9mIHRoZSBmb2xsb3dpbmcgdmFyaWFibGUgbmFtZXM6XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgIGNvbHVtbnNcclxuICAgICAgICAgICAgLy8gICAgICAgICAgaXRlbVxyXG4gICAgICAgICAgICAvLyAgICAgICAgICBjb250ZW50VGVtcGxhdGVcclxuICAgICAgICAgICAgLy8gICAgICAgICAgZm9vdGVyVGVtcGxhdGVcclxuICAgICAgICAgICAgLy8gICAgICAgICAgY2xpY2thYmxlXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgIGNhcmRDb250cm9sbGVyXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgIGNhcmRDb250cm9sbGVyQXNcclxuICAgICAgICAgICAgLy8gICAgICAgICAgY2FyZEFzXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgIHNob3dDb250ZW50XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgIHRvZ2dsZUNvbnRlbnRcclxuICAgICAgICAgICAgLy8gICAgICAgICAgY29sbGFwc2VcclxuICAgICAgICAgICAgLy8gICAgICAgICAgc2VsZWN0ZWRcclxuICAgICAgICAgICAgLy8gICAgICAgICAgc2V0U2VsZWN0ZWRcclxuICAgICAgICAgICAgY2FyZENvbnRyb2xsZXI6ICdAJyxcclxuICAgICAgICAgICAgLy8gc3VtbWFyeTogY29udHJvbGxlciBhbGlhcyBzcGVjaWZpZWQgdXNpbmcgY29udHJvbGxlckFzIHN5bnRheFxyXG4gICAgICAgICAgICBjYXJkQ29udHJvbGxlckFzOiAnQCcsXHJcbiAgICAgICAgICAgIC8vIHN1bW1hcnk6IG5hbWUgdXNlZCB0byBhY2Nlc3MgdGhlIGNhcmQgZGF0YVxyXG4gICAgICAgICAgICBjYXJkQXM6ICdAJyxcclxuICAgICAgICAgICAgLy8gc3VtbWFyeTogSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBzaG93IGFjdGl2ZSBzdGF0ZSBvbiBtb3VzZSBvdmVyXHJcbiAgICAgICAgICAgIGNsaWNrYWJsZUNhcmRzOiAnPScsXHJcbiAgICAgICAgICAgIC8vIHN1bW1hcnk6IFRoZSBudW1iZXIgb2Ygc29ydHMgdGhhdCBjYW4gYmUgYXBwbGllZCBhdCBhIHRpbWUuXHJcbiAgICAgICAgICAgIG1heENvbHVtblNvcnRzOiAnPScsXHJcbiAgICAgICAgICAgIHBlcm1hbmVudEZvb3RlcnM6ICc9JyxcclxuICAgICAgICAgICAgLy8gc3VtbWFyeTogSWYgdHJ1ZSwgdHVybnMgb24gc2VsZWN0aW9uIGZvciBjYXJkcyB2aWEgdGhlIGNhcmREYXRhLnZpZXdEYXRhLnNlbGVjdGVkIHByb3BlcnR5XHJcbiAgICAgICAgICAgIHNlbGVjdGFibGVDYXJkczogJz0nLFxyXG4gICAgICAgICAgICAvLyBzdW1tYXJ5OiBGdW5jdGlvbiBjYWxsZWQgd2l0aCBlYWNoIGl0ZW0uIElmIHRydWUgaXMgcmV0dXJuZWQgc2VsZWN0aW9uIGlzIGRpc2FibGVkIGZvciB0aGlzIGl0ZW0uXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgIElmIGZ1bmN0aW9uIGlzIG5vdCBkZWZpbmVkLCBzZWxlY3Rpb24gaXMgZW5hYmxlZCBmb3IgYWxsIGJ5IGRlZmF1bHQuXHJcbiAgICAgICAgICAgIGRpc2FibGVTZWxlY3Rpb246ICcmJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNvbnRyb2xsZXIsIHRyYW5zY2x1ZGUpIHtcclxuICAgICAgICAgICAgdmFyIGhlYWRlckFyZWEgPSBlbGVtZW50LmZpbmQoJy5jb250YWluZXItaGVhZGVyLXRlbXBsYXRlJyk7XHJcbiAgICAgICAgICAgIHZhciBmb290ZXJBcmVhID0gZWxlbWVudC5maW5kKCcuY29udGFpbmVyLWZvb3Rlci10ZW1wbGF0ZScpO1xyXG4gICAgICAgICAgICBjb250cm9sbGVyLm1ha2VDYXJkID0gdHJhbnNjbHVkZTtcclxuICAgICAgICAgICAgdHJhbnNjbHVkZShzY29wZSwgZnVuY3Rpb24gKGNsb25lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gY2xvbmUuZmlsdGVyKCdybC1jb250YWluZXItaGVhZGVyJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0SGVhZGVyID0gcmVxdWlyZSgnLi9kZWZhdWx0Q2FyZENvbnRhaW5lckhlYWRlci5odG1sJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gJGNvbXBpbGUoZGVmYXVsdEhlYWRlcikoc2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaGVhZGVyQXJlYS5hcHBlbmQoaGVhZGVyKTtcclxuICAgICAgICAgICAgICAgIHZhciBmb290ZXIgPSBjbG9uZS5maWx0ZXIoJ3JsLWNvbnRhaW5lci1mb290ZXInKTtcclxuICAgICAgICAgICAgICAgIGlmIChmb290ZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRGb290ZXIgPSByZXF1aXJlKCcuL2RlZmF1bHRDYXJkQ29udGFpbmVyRm9vdGVyLmh0bWwnKTtcclxuICAgICAgICAgICAgICAgICAgICBmb290ZXIgPSAkY29tcGlsZShkZWZhdWx0Rm9vdGVyKShzY29wZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb290ZXJBcmVhLmFwcGVuZChmb290ZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuY2FyZENvbnRhaW5lciA9IGNhcmRDb250YWluZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhcmRDb250YWluZXIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY2FyZENvbnRhaW5lci5qc1xuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgQ2FyZENvbnRhaW5lclNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FyZENvbnRhaW5lclNlcnZpY2UoY2FyZENvbnRhaW5lcikge1xyXG4gICAgICAgIHRoaXMuY2FyZENvbnRhaW5lciA9IGNhcmRDb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5wYWdlciA9IGNhcmRDb250YWluZXIucGFnZXI7XHJcbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gY2FyZENvbnRhaW5lci5kYXRhU291cmNlO1xyXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IGNhcmRDb250YWluZXIuZmlsdGVycztcclxuICAgIH1cclxuICAgIENhcmRDb250YWluZXJTZXJ2aWNlLnByb3RvdHlwZS5sb29rdXBGaWx0ZXIgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnNbdHlwZV07XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhcmRDb250YWluZXJTZXJ2aWNlLnByb3RvdHlwZSwgXCJudW1iZXJTZWxlY3RlZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhcmRDb250YWluZXIubnVtYmVyU2VsZWN0ZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQ2FyZENvbnRhaW5lclNlcnZpY2U7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ2FyZENvbnRhaW5lclNlcnZpY2UgPSBDYXJkQ29udGFpbmVyU2VydmljZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FyZENvbnRhaW5lci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRDb250YWluZXIuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiY2FyZC1jb250YWluZXJcXFwiPlxcclxcblxcdDxkaXY+XFxyXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiY2FyZC1jb250YWluZXItaGVhZGVyXFxcIj5cXHJcXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb250YWluZXItaGVhZGVyLXRlbXBsYXRlXFxcIj48L2Rpdj5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHJcXG5cXHRcXHQ8cmwtZ2VuZXJpYy1jb250YWluZXIgc2VsZWN0b3I9XFxcImNhcmRDb250YWluZXIuc2VsZWN0YWJsZUNhcmRzXFxcIj5cXHJcXG5cXHRcXHRcXHQ8dGVtcGxhdGUgd2hlbi1zZWxlY3Rvcj1cXFwiZmFsc2VcXFwiIGRlZmF1bHQ+XFxyXFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2FyZC1jb2x1bW5zLWhlYWRlclxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBuZy1yZXBlYXQ9XFxcImNvbHVtbiBpbiBjYXJkQ29udGFpbmVyLmNvbHVtbnNcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDxybC1jb2x1bW4taGVhZGVyIHNvcnQ9XFxcImNhcmRDb250YWluZXIuc29ydChjb2x1bW4pXFxcIiBzb3J0aW5nPVxcXCJjb2x1bW4uc29ydERpcmVjdGlvblxcXCIgY29sdW1uPVxcXCJjb2x1bW5cXFwiPjwvcmwtY29sdW1uLWhlYWRlcj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0PC90ZW1wbGF0ZT5cXHJcXG5cXHRcXHRcXHQ8dGVtcGxhdGUgd2hlbi1zZWxlY3Rvcj1cXFwidHJ1ZVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2FyZC1jb2x1bW5zLWhlYWRlclxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwic2VsZWN0LWdyb3VwXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJzZWxlY3QtY29sdW1uXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtY2hlY2tcXFwiIHN0eWxlPVxcXCJtYXJnaW4tbGVmdDogNnB4OyBjdXJzb3I6IHBvaW50ZXJcXFwiIG5nLWNsaWNrPVxcXCJjYXJkQ29udGFpbmVyLnNvcnRTZWxlY3RlZCgpXFxcIj48L2k+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGkgbmctc2hvdz1cXFwiY2FyZENvbnRhaW5lci5zb3J0Q29sdW1uLnNvcnREaXJlY3Rpb24gPT09IGNhcmRDb250YWluZXIuc29ydERpcmVjdGlvbi5hc2NlbmRpbmdcXFwiIGNsYXNzPVxcXCJmYSBmYS1zb3J0LWFzY1xcXCI+PC9pPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpIG5nLXNob3c9XFxcImNhcmRDb250YWluZXIuc29ydENvbHVtbi5zb3J0RGlyZWN0aW9uID09PSBjYXJkQ29udGFpbmVyLnNvcnREaXJlY3Rpb24uZGVzY2VuZGluZ1xcXCIgY2xhc3M9XFxcImZhIGZhLXNvcnQtZGVzY1xcXCI+PC9pPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInNlbGVjdC1jb250ZW50XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IG5nLXJlcGVhdD1cXFwiY29sdW1uIGluIGNhcmRDb250YWluZXIuY29sdW1uc1xcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PHJsLWNvbHVtbi1oZWFkZXIgc29ydD1cXFwiY2FyZENvbnRhaW5lci5zb3J0KGNvbHVtbilcXFwiIHNvcnRpbmc9XFxcImNvbHVtbi5zb3J0RGlyZWN0aW9uXFxcIiBjb2x1bW49XFxcImNvbHVtblxcXCI+PC9ybC1jb2x1bW4taGVhZGVyPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNsZWFyZml4XFxcIj48L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8L3RlbXBsYXRlPlxcclxcblxcdFxcdDwvcmwtZ2VuZXJpYy1jb250YWluZXI+XFxyXFxuXFxyXFxuXFx0XFx0PGRpdiBuZy1yZXBlYXQ9XFxcImNhcmQgaW4gY2FyZENvbnRhaW5lci5kYXRhU291cmNlLmRhdGFTZXRcXFwiPlxcclxcblxcdFxcdFxcdDxybC1jYXJkIGNvbHVtbnM9XFxcImNhcmRDb250YWluZXIuY29sdW1uc1xcXCIgaXRlbT1cXFwiY2FyZFxcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHQgY2xpY2thYmxlPVxcXCJjYXJkQ29udGFpbmVyLmNsaWNrYWJsZUNhcmRzXFxcIlxcclxcblxcdFxcdFxcdFxcdFxcdCBzZWxlY3RhYmxlPVxcXCJjYXJkQ29udGFpbmVyLnNlbGVjdGFibGVDYXJkc1xcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHQgc2VsZWN0aW9uLWNoYW5nZWQ9XFxcImNhcmRDb250YWluZXIuc2VsZWN0aW9uQ2hhbmdlZCgpXFxcIlxcclxcblxcdFxcdFxcdFxcdFxcdCBjb250YWluZXItZGF0YT1cXFwiY2FyZENvbnRhaW5lci5jb250YWluZXJEYXRhXFxcIlxcclxcblxcdFxcdFxcdFxcdFxcdCBzb3VyY2U9XFxcImNhcmRDb250YWluZXIuZGF0YVNvdXJjZVxcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHQgcGVybWFuZW50LWZvb3Rlcj1cXFwiY2FyZENvbnRhaW5lci5wZXJtYW5lbnRGb290ZXJzXFxcIlxcclxcblxcdFxcdFxcdFxcdFxcdCBjYXJkLWNvbnRyb2xsZXI9XFxcImNhcmRDb250YWluZXIuY2FyZENvbnRyb2xsZXJcXFwiXFxyXFxuXFx0XFx0XFx0XFx0XFx0IGNhcmQtY29udHJvbGxlci1hcz1cXFwiY2FyZENvbnRhaW5lci5jYXJkQ29udHJvbGxlckFzXFxcIlxcclxcblxcdFxcdFxcdFxcdFxcdCBjYXJkLWFzPVxcXCJjYXJkQ29udGFpbmVyLmNhcmRBc1xcXCI+PC9ybC1jYXJkPlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcclxcblxcdFxcdDxkaXY+XFxyXFxuXFx0XFx0XFx0PHJsLWJ1c3kgbG9hZGluZz1cXFwiY2FyZENvbnRhaW5lci5kYXRhU291cmNlLmxvYWRpbmdEYXRhU2V0XFxcIiBzaXplPVxcXCIyeFxcXCI+PC9ybC1idXN5PlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNhcmQtY29udGFpbmVyLWZvb3RlclxcXCI+XFxyXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29udGFpbmVyLWZvb3Rlci10ZW1wbGF0ZVxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0PC9kaXY+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkQ29udGFpbmVyLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiY29sLXNtLTlcXFwiPlxcclxcblxcdFxcdDxybC1jYXJkLXNlYXJjaCBjb250YWluZXItc2VydmljZT1cXFwiY29udGFpbmVyU2VydmljZVxcXCI+PC9ybC1jYXJkLXNlYXJjaD5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tM1xcXCI+XFxyXFxuXFx0XFx0PHJsLXBhZ2Utc2l6ZSBjb250YWluZXItc2VydmljZT1cXFwiY29udGFpbmVyU2VydmljZVxcXCI+PC9ybC1wYWdlLXNpemU+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kZWZhdWx0Q2FyZENvbnRhaW5lckhlYWRlci5odG1sXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcblxcdDxkaXYgbmctaWY9XFxcIiFjYXJkQ29udGFpbmVyLnNlbGVjdGFibGVDYXJkc1xcXCIgY2xhc3M9XFxcImNvbC1zbS02XFxcIj5cXHJcXG5cXHRcXHQ8cmwtaXRlbS1jb3VudCBjb250YWluZXItc2VydmljZT1cXFwiY29udGFpbmVyU2VydmljZVxcXCI+PC9ybC1pdGVtLWNvdW50PlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxzcGFuIG5nLWlmPVxcXCJjYXJkQ29udGFpbmVyLnNlbGVjdGFibGVDYXJkc1xcXCI+XFxyXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLXNtLTNcXFwiPlxcclxcblxcdFxcdFxcdDxybC1zZWxlY3Rpb24tY29udHJvbCBjb250YWluZXItc2VydmljZT1cXFwiY29udGFpbmVyU2VydmljZVxcXCI+PC9ybC1zZWxlY3Rpb24tY29udHJvbD5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tM1xcXCI+XFxyXFxuXFx0XFx0XFx0PHJsLWl0ZW0tY291bnQgY29udGFpbmVyLXNlcnZpY2U9XFxcImNvbnRhaW5lclNlcnZpY2VcXFwiPjwvcmwtaXRlbS1jb3VudD5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L3NwYW4+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiY29sLXNtLTZcXFwiPlxcclxcblxcdFxcdDxybC1wYWdlciBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCIgY29udGFpbmVyLXNlcnZpY2U9XFxcImNvbnRhaW5lclNlcnZpY2VcXFwiPjwvcmwtcGFnZXI+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kZWZhdWx0Q2FyZENvbnRhaW5lckZvb3Rlci5odG1sXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sdW1uLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NvbHVtbi5qc1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jb21tYUxpc3QnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxDb21tYUxpc3QnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0NvbW1hTGlzdENvbnRyb2xsZXInO1xyXG52YXIgQ29tbWFMaXN0Q29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21tYUxpc3RDb250cm9sbGVyKCRhdHRycywgb2JqZWN0KSB7XHJcbiAgICAgICAgdGhpcy5yZW1haW5pbmdJdGVtcyA9IDA7XHJcbiAgICAgICAgdGhpcy5oYXNUcmFuc2Zvcm0gPSBvYmplY3QuaXNOdWxsT3JXaGl0ZXNwYWNlKCRhdHRycy50cmFuc2Zvcm0pID09PSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxpc3QgPSB0aGlzLmdldEZpcnN0SXRlbXModGhpcy5pbkxpc3QpO1xyXG4gICAgfVxyXG4gICAgQ29tbWFMaXN0Q29udHJvbGxlci5wcm90b3R5cGUuZ2V0Rmlyc3RJdGVtcyA9IGZ1bmN0aW9uIChsaXN0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5oYXNUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgbGlzdCA9IF8ubWFwKGxpc3QsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtKHsgaXRlbTogaXRlbSB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICB2YXIgbmV3TGlzdDtcclxuICAgICAgICBpZiAodGhpcy5tYXggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBuZXdMaXN0ID0gXy50YWtlKGxpc3QsIHRoaXMubWF4KTtcclxuICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdJdGVtcyA9IGxpc3QubGVuZ3RoIC0gdGhpcy5tYXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdMaXN0ID0gXy5jbG9uZShsaXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld0xpc3Q7XHJcbiAgICB9O1xyXG4gICAgQ29tbWFMaXN0Q29udHJvbGxlci4kaW5qZWN0ID0gWyckYXR0cnMnLCBfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gQ29tbWFMaXN0Q29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5Db21tYUxpc3RDb250cm9sbGVyID0gQ29tbWFMaXN0Q29udHJvbGxlcjtcclxuZnVuY3Rpb24gY29tbWFMaXN0KCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcblxcdFxcdFxcdDxzcGFuPlxcblxcdFxcdFxcdFxcdDxzcGFuIG5nLXJlcGVhdD1cXFwiaXRlbSBpbiBjb21tYUxpc3QubGlzdCB0cmFjayBieSAkaW5kZXhcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxzcGFuPnt7aXRlbX19PC9zcGFuPjxzcGFuIG5nLWhpZGU9XFxcIiRsYXN0XFxcIj4sIDwvc3Bhbj5cXG5cXHRcXHRcXHRcXHQ8L3NwYW4+XFxuXFx0XFx0XFx0XFx0PHNwYW4gbmctc2hvdz1cXFwiY29tbWFMaXN0LnJlbWFpbmluZ0l0ZW1zID4gMFxcXCI+Li4uIHt7Y29tbWFMaXN0LnJlbWFpbmluZ0l0ZW1zfX0gbW9yZSBpdGVtczwvc3Bhbj5cXG5cXHRcXHRcXHQ8L3NwYW4+XFxuXFx0XFx0XCIsXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdjb21tYUxpc3QnLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIGluTGlzdDogJz1saXN0JyxcclxuICAgICAgICAgICAgbWF4OiAnPScsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJyYnLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JqZWN0Lm1vZHVsZU5hbWVdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGNvbW1hTGlzdClcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIENvbW1hTGlzdENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tYUxpc3QuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NvbW1hTGlzdC9jb21tYUxpc3QuanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG4vLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2Jvb3RzdHJhcERhdGVUaW1lUGlja2VyLmQudHMnIC8+XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5kYXRlVGltZSc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybERhdGVUaW1lJztcclxudmFyIF9fZGF0ZVRpbWVGb3JtYXRTdHJpbmdzID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmRhdGU7XHJcbmRhdGVUaW1lLiRpbmplY3QgPSBbdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm1vbWVudC5zZXJ2aWNlTmFtZSwgX19kYXRlVGltZUZvcm1hdFN0cmluZ3MuZGF0ZVRpbWVGb3JtYXRTZXJ2aWNlTmFtZV07XHJcbmZ1bmN0aW9uIGRhdGVUaW1lKG1vbWVudCwgZGF0ZVRpbWVGb3JtYXRTdHJpbmdzKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXBcXFwiIG5nLWNsYXNzPVxcXCJ7ICdoYXMtd2FybmluZyc6ICF2YWxpZEZvcm1hdH1cXFwiIGlkPVxcXCJ7e2lucHV0SWR9fVxcXCI+XFxuXFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIG5nLW1vZGVsPVxcXCJuZ01vZGVsXFxcIiAvPlxcblxcdFxcdFxcdFxcdDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1idG5cXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBzaG93LWRhdGUtcGlja2VyXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlKClcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jYWxlbmRhclxcXCI+PC9pPjwvYnV0dG9uPlxcblxcdFxcdFxcdFxcdDwvc3Bhbj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcIixcclxuICAgICAgICByZXF1aXJlOiAnP15uZ01vZGVsJyxcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICBtaW51dGVTdGVwcGluZzogJz0nLFxyXG4gICAgICAgICAgICBuZ01vZGVsOiAnPScsXHJcbiAgICAgICAgICAgIHVzZURhdGU6ICc9JyxcclxuICAgICAgICAgICAgdXNlVGltZTogJz0nLFxyXG4gICAgICAgICAgICBtaW46ICc9JyxcclxuICAgICAgICAgICAgbWF4OiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsKSB7XHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHRzIHRvIHRydWVcclxuICAgICAgICAgICAgdmFyIGhhc0RhdGUgPSBfLmlzVW5kZWZpbmVkKHNjb3BlLnVzZURhdGUpID8gdHJ1ZSA6IHNjb3BlLnVzZURhdGU7XHJcbiAgICAgICAgICAgIHZhciBoYXNUaW1lID0gXy5pc1VuZGVmaW5lZChzY29wZS51c2VUaW1lKSA/IHRydWUgOiBzY29wZS51c2VUaW1lO1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBlbGVtZW50LmRhdGV0aW1lcGlja2VyLmRlZmF1bHRzO1xyXG4gICAgICAgICAgICB2YXIgbWluID0gc2NvcGUubWluICE9IG51bGwgPyBzY29wZS5taW4gOiBkZWZhdWx0cy5taW5EYXRlO1xyXG4gICAgICAgICAgICB2YXIgbWF4ID0gc2NvcGUubWF4ICE9IG51bGwgPyBzY29wZS5tYXggOiBkZWZhdWx0cy5tYXhEYXRlO1xyXG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goJ25nTW9kZWwnLCBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZS52YWxpZEZvcm1hdCA9IG1vbWVudChuZXdWYWx1ZSkuaXNWYWxpZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gLS0tIEltcGxlbWVudGF0aW9uIC0tLVxyXG4gICAgICAgICAgICBlbGVtZW50LmRhdGV0aW1lcGlja2VyKHtcclxuICAgICAgICAgICAgICAgIHN0ZXBwaW5nOiBzY29wZS5taW51dGVTdGVwcGluZyB8fCAxLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBzY29wZS5mb3JtYXQgfHwgZGVmYXVsdEZvcm1hdChoYXNEYXRlLCBoYXNUaW1lKSxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JvdHRvbScsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50SGVpZ2h0OiAzMixcclxuICAgICAgICAgICAgICAgIHBpY2tEYXRlOiBoYXNEYXRlLFxyXG4gICAgICAgICAgICAgICAgcGlja1RpbWU6IGhhc1RpbWUsXHJcbiAgICAgICAgICAgICAgICBtaW5EYXRlOiBtaW4sXHJcbiAgICAgICAgICAgICAgICBtYXhEYXRlOiBtYXgsXHJcbiAgICAgICAgICAgIH0pLm9uKCdjaGFuZ2UuZHAnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSAkKHRoaXMpLmZpbmQoJ2lucHV0JykudmFsKCk7XHJcbiAgICAgICAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0Rm9ybWF0KGhhc0RhdGUsIGhhc1RpbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNEYXRlICYmIGhhc1RpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZVRpbWVGb3JtYXRTdHJpbmdzLmRhdGVUaW1lRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRlVGltZUZvcm1hdFN0cmluZ3MuZGF0ZUZvcm1hdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc1RpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZVRpbWVGb3JtYXRTdHJpbmdzLnRpbWVGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXZlcnQgdG8gZGVmYXVsdCBmb3JtYXRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGRhdGVUaW1lKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZVRpbWUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2RhdGVUaW1lL2RhdGVUaW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBqcXVlcnlfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvanF1ZXJ5L2pxdWVyeS5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmdlbmVyaWNDb250YWluZXInO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxHZW5lcmljQ29udGFpbmVyJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdHZW5lcmljQ29udGFpbmVyQ29udHJvbGxlcic7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBHZW5lcmljQ29udGFpbmVyQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBHZW5lcmljQ29udGFpbmVyQ29udHJvbGxlcigkc2NvcGUsIG9iamVjdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZWxlY3RvcjsgfSwgZnVuY3Rpb24gKG5ld1R5cGUsIG9sZFR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLm9iamVjdC5hcmVFcXVhbChuZXdUeXBlLCBvbGRUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IF90aGlzLnJlc29sdmVUZW1wbGF0ZShuZXdUeXBlKTtcclxuICAgICAgICAgICAgX3RoaXMuc3dhcFRlbXBsYXRlcyh0ZW1wbGF0ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBHZW5lcmljQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLnJlc29sdmVUZW1wbGF0ZSh0aGlzLnNlbGVjdG9yKTtcclxuICAgICAgICB0aGlzLnN3YXBUZW1wbGF0ZXModGVtcGxhdGUpO1xyXG4gICAgfTtcclxuICAgIEdlbmVyaWNDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZXNvbHZlVGVtcGxhdGUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZU9iamVjdDtcclxuICAgICAgICBpZiAoXy5oYXModGhpcy50ZW1wbGF0ZXMsIHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRlbXBsYXRlT2JqZWN0ID0gdGhpcy50ZW1wbGF0ZXNbdHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0ZW1wbGF0ZU9iamVjdCA9IHRoaXMuZGVmYXVsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gdGVtcGxhdGVPYmplY3Q7XHJcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRlbXBsYXRlLnRlbXBsYXRlVXJsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJzxuZy1pbmNsdWRlIHNyYz1cIlxcJycgKyB0ZW1wbGF0ZS50ZW1wbGF0ZVVybCArICdcXCdcIj48L25nLWluY2x1ZGU+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQodGVtcGxhdGUudGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZS50ZW1wbGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZU9iamVjdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2VuZXJpY0NvbnRhaW5lckNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgX19vYmplY3Quc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIEdlbmVyaWNDb250YWluZXJDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkdlbmVyaWNDb250YWluZXJDb250cm9sbGVyID0gR2VuZXJpY0NvbnRhaW5lckNvbnRyb2xsZXI7XHJcbmdlbmVyaWNDb250YWluZXIuJGluamVjdCA9IFsnJGNvbXBpbGUnLCAnJGludGVycG9sYXRlJywganF1ZXJ5X3NlcnZpY2VfMS5zZXJ2aWNlTmFtZSwgX19vYmplY3Quc2VydmljZU5hbWVdO1xyXG5mdW5jdGlvbiBnZW5lcmljQ29udGFpbmVyKCRjb21waWxlLCAkaW50ZXJwb2xhdGUsIGpxdWVyeSwgb2JqZWN0KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6ICc8ZGl2IGlkPVwiY29udGFpbmVyXCI+PC9kaXY+JyxcclxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnZ2VuZXJpY0NvbnRhaW5lcicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICc9JyxcclxuICAgICAgICAgICAgY29uZmlndXJlZFRlbXBsYXRlczogJz10ZW1wbGF0ZXMnLFxyXG4gICAgICAgICAgICBkZWZhdWx0VGVtcGxhdGU6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cmlidXRlcywgY29udHJvbGxlciwgdHJhbnNjbHVkZSkge1xyXG4gICAgICAgICAgICBpbml0RGVmYXVsdHMoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBlbGVtZW50LmZpbmQoJyNjb250YWluZXInKTtcclxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlU2NvcGU7XHJcbiAgICAgICAgICAgIC8vIExvYWQgdGVtcGxhdGVzIGZyb20gdGhlIERPTVxyXG4gICAgICAgICAgICB0cmFuc2NsdWRlKGZ1bmN0aW9uIChjbG9uZSwgdHJhbnNjbHVzaW9uU2NvcGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZXMgPSBjbG9uZS5maWx0ZXIoJ3RlbXBsYXRlJyk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuZWFjaChmdW5jdGlvbiAoaW5kZXgsIHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlRWxlbWVudCA9IGFuZ3VsYXIuZWxlbWVudCh0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlSHRtbCA9IHRlbXBsYXRlRWxlbWVudC5odG1sKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWdnZXJBdHRyaWJ1dGUgPSB0ZW1wbGF0ZUVsZW1lbnQuYXR0cignd2hlbi1zZWxlY3RvcicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb2JqZWN0LmlzTnVsbE9yV2hpdGVzcGFjZSh0cmlnZ2VyQXR0cmlidXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJpZ2dlciA9ICRpbnRlcnBvbGF0ZSh0cmlnZ2VyQXR0cmlidXRlKSh0cmFuc2NsdXNpb25TY29wZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIudGVtcGxhdGVzW3RyaWdnZXJdID0gdGVtcGxhdGVIdG1sO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNEZWZhdWx0ID0gdGVtcGxhdGVFbGVtZW50LmF0dHIoJ2RlZmF1bHQnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoaXNEZWZhdWx0KSAmJiBpc0RlZmF1bHQudG9Mb3dlckNhc2UoKSAhPT0gJ2ZhbHNlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmRlZmF1bHQgPSB0ZW1wbGF0ZUh0bWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVNjb3BlID0gdHJhbnNjbHVzaW9uU2NvcGU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRyb2xsZXIuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5kZWZhdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPGRpdj48L2Rpdj4nLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250cm9sbGVyLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gaW5pdERlZmF1bHRzKGNvbnRyb2xsZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZGVmYXVsdCA9IGNvbnRyb2xsZXIuZGVmYXVsdFRlbXBsYXRlO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci50ZW1wbGF0ZXMgPSBjb250cm9sbGVyLmNvbmZpZ3VyZWRUZW1wbGF0ZXMgPyBjb250cm9sbGVyLmNvbmZpZ3VyZWRUZW1wbGF0ZXMgOiB7fTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuc3dhcFRlbXBsYXRlcyA9IHN3YXBUZW1wbGF0ZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3dhcFRlbXBsYXRlcyh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSAkY29tcGlsZSh0ZW1wbGF0ZSkodGVtcGxhdGVTY29wZSk7XHJcbiAgICAgICAgICAgICAgICBqcXVlcnkucmVwbGFjZUNvbnRlbnQoY29udGFpbmVyLCBjb250ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbanF1ZXJ5X3NlcnZpY2VfMS5tb2R1bGVOYW1lLCBfX29iamVjdC5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBnZW5lcmljQ29udGFpbmVyKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgR2VuZXJpY0NvbnRhaW5lckNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmljQ29udGFpbmVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9nZW5lcmljQ29udGFpbmVyL2dlbmVyaWNDb250YWluZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzXCIgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnV0aWxpdGllcy5zZXJ2aWNlcy5qcXVlcnknO1xyXG5leHBvcnRzLnNlcnZpY2VOYW1lID0gJ2pxdWVyeVV0aWxpdHknO1xyXG52YXIgSlF1ZXJ5VXRpbGl0eSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBKUXVlcnlVdGlsaXR5KCkge1xyXG4gICAgfVxyXG4gICAgSlF1ZXJ5VXRpbGl0eS5wcm90b3R5cGUucmVwbGFjZUNvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudEFyZWEsIG5ld0NvbnRlbnQpIHtcclxuICAgICAgICBjb250ZW50QXJlYS5lbXB0eSgpO1xyXG4gICAgICAgIGNvbnRlbnRBcmVhLmFwcGVuZChuZXdDb250ZW50KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSlF1ZXJ5VXRpbGl0eTtcclxufSkoKTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5zZXJ2aWNlKGV4cG9ydHMuc2VydmljZU5hbWUsIEpRdWVyeVV0aWxpdHkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1qcXVlcnkuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2pxdWVyeS9qcXVlcnkuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5sYXp5TG9hZCc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybExhenlMb2FkJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdMYXp5TG9hZENvbnRyb2xsZXInO1xyXG52YXIgTGF6eUxvYWRDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExhenlMb2FkQ29udHJvbGxlcigkc2NvcGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuaW5pdCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB1bmJpbmQgPSAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNob3c7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmluaXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdW5iaW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIExhenlMb2FkQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnXTtcclxuICAgIHJldHVybiBMYXp5TG9hZENvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTGF6eUxvYWRDb250cm9sbGVyID0gTGF6eUxvYWRDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBsYXp5TG9hZCgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcblxcdFxcdFxcdDxkaXYgbmctaWY9XFxcImxhenlMb2FkLmluaXRcXFwiPlxcblxcdFxcdFxcdFxcdDxkaXYgbmctc2hvdz1cXFwibGF6eUxvYWQuc2hvd1xcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFwiLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnbGF6eUxvYWQnLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIHNob3c6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGxhenlMb2FkKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgTGF6eUxvYWRDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF6eUxvYWQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2xhenlMb2FkL2xhenlMb2FkLmpzXG4gKiogbW9kdWxlIGlkID0gNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fcHJvbWlzZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wcm9taXNlO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5sb25nQ2xpY2tCdXR0b24nO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxMb25nQ2xpY2tCdXR0b24nO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0xvbmdDbGlja0J1dHRvbkNvbnRyb2xsZXInO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMb25nQ2xpY2tCdXR0b25Db250cm9sbGVyKCRzY29wZSwgJGludGVydmFsLCAkdGltZW91dCwgb2JqZWN0VXRpbGl0eSwgcHJvbWlzZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kaW50ZXJ2YWwgPSAkaW50ZXJ2YWw7XHJcbiAgICAgICAgdGhpcy4kdGltZW91dCA9ICR0aW1lb3V0O1xyXG4gICAgICAgIHRoaXMub2JqZWN0VXRpbGl0eSA9IG9iamVjdFV0aWxpdHk7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcclxuICAgICAgICB0aGlzLmludGVydmFsID0gMjU7XHJcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDE1MDA7XHJcbiAgICAgICAgdGhpcy5idXR0b25UZXh0ID0gdGhpcy50ZXh0O1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHRoaXMudHlwZSAhPSBudWxsID8gdGhpcy50eXBlIDogJ2RlZmF1bHQnO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuc2l6ZSAhPSBudWxsID8gJ2J0bi0nICsgdGhpcy5zaXplIDogbnVsbDtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmJ1dHRvblRleHQ7IH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMud2lkdGggPSAkKCcjYWN0aW9uQnV0dG9uJykub3V0ZXJXaWR0aCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIExvbmdDbGlja0J1dHRvbkNvbnRyb2xsZXIucHJvdG90eXBlLnN0YXJ0QWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlIHx8IHRoaXMuYnVzeSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aW9uUHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFjdGlvbkludGVydmFsID0gdGhpcy4kaW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5hY3Rpb25Qcm9ncmVzcyArPSBfdGhpcy5pbnRlcnZhbDtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmFjdGlvblByb2dyZXNzID49IF90aGlzLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jbGVhbnVwKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5idXR0b25UZXh0ID0gX3RoaXMudGV4dDtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRoaXMuaW50ZXJ2YWwpO1xyXG4gICAgfTtcclxuICAgIExvbmdDbGlja0J1dHRvbkNvbnRyb2xsZXIucHJvdG90eXBlLnN0b3BBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvblByb2dyZXNzIDwgdGhpcy5kdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53YXJuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvbmdDbGlja0J1dHRvbkNvbnRyb2xsZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy4kaW50ZXJ2YWwuY2FuY2VsKHRoaXMuYWN0aW9uSW50ZXJ2YWwpO1xyXG4gICAgICAgIHRoaXMuYWN0aW9uUHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5vYmplY3RVdGlsaXR5LmlzTnVsbE9yRW1wdHkodGhpcy5vblNob3J0Q2xpY2tUZXh0KSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25UZXh0ID0gdGhpcy5vblNob3J0Q2xpY2tUZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMb25nQ2xpY2tCdXR0b25Db250cm9sbGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF0aGlzLmJ1c3kpIHtcclxuICAgICAgICAgICAgdGhpcy5idXN5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYWN0aW9uKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb21pc2UuaXNQcm9taXNlKHJlc3VsdCkgJiYgXy5pc0Z1bmN0aW9uKHJlc3VsdC5maW5hbGx5KSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmZpbmFsbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmJ1c3kgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvbmdDbGlja0J1dHRvbkNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRpbnRlcnZhbCcsICckdGltZW91dCcsIF9fb2JqZWN0LnNlcnZpY2VOYW1lLCBfX3Byb21pc2Uuc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIExvbmdDbGlja0J1dHRvbkNvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlciA9IExvbmdDbGlja0J1dHRvbkNvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIGxvbmdDbGlja0J1dHRvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9sb25nQ2xpY2tCdXR0b24uaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnYnV0dG9uJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBhY3Rpb246ICcmJyxcclxuICAgICAgICAgICAgdGV4dDogJ0AnLFxyXG4gICAgICAgICAgICBvblNob3J0Q2xpY2tUZXh0OiAnQCcsXHJcbiAgICAgICAgICAgIGljb246ICdAJyxcclxuICAgICAgICAgICAgYnVzeTogJz0nLFxyXG4gICAgICAgICAgICByaWdodEFsaWduZWQ6ICc9JyxcclxuICAgICAgICAgICAgdHlwZTogJ0AnLFxyXG4gICAgICAgICAgICBuZ0Rpc2FibGVkOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19vYmplY3QubW9kdWxlTmFtZV0pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgbG9uZ0NsaWNrQnV0dG9uKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvbmdDbGlja0J1dHRvbi5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbG9uZ0NsaWNrQnV0dG9uL2xvbmdDbGlja0J1dHRvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwibG9uZy1jbGljay1idXR0b25cXFwiPlxcclxcblxcdDxidXR0b24gaWQ9XFxcImFjdGlvbkJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4te3tidXR0b24udHlwZX19IHt7YnV0dG9uLnNpemV9fVxcXCIgbmctbW91c2Vkb3duPVxcXCJidXR0b24uc3RhcnRBY3Rpb24oKVxcXCIgbmctbW91c2VsZWF2ZT1cXFwiYnV0dG9uLnN0b3BBY3Rpb24oKVxcXCIgbmctbW91c2V1cD1cXFwiYnV0dG9uLnN0b3BBY3Rpb24oKVxcXCIgbmctZGlzYWJsZWQ9XFxcImJ1dHRvbi5idXN5IHx8IGJ1dHRvbi5uZ0Rpc2FibGVkXFxcIj5cXHJcXG5cXHRcXHQ8cmwtYnVzeSBsb2FkaW5nPVxcXCJidXR0b24uYnVzeVxcXCIgbmctaWY9XFxcImJ1dHRvbi5yaWdodEFsaWduZWRcXFwiPjwvcmwtYnVzeT5cXHJcXG5cXHRcXHQ8aSBuZy1zaG93PVxcXCJidXR0b24uaWNvbiAhPSBudWxsXFxcIiBjbGFzcz1cXFwiZmEgZmEte3tidXR0b24uaWNvbn19XFxcIj48L2k+IHt7YnV0dG9uLmJ1dHRvblRleHR9fVxcclxcblxcdFxcdDxybC1idXN5IGxvYWRpbmc9XFxcImJ1dHRvbi5idXN5XFxcIiBuZy1pZj1cXFwiIWJ1dHRvbi5yaWdodEFsaWduZWRcXFwiPjwvcmwtYnVzeT5cXHJcXG5cXHQ8L2J1dHRvbj5cXHJcXG5cXHQ8cmwtcmF0aW5nLWJhciBuZy1pZj1cXFwiYnV0dG9uLmFjdGl2ZVxcXCIgd2lkdGg9XFxcImJ1dHRvbi53aWR0aFxcXCIgaGVpZ2h0PVxcXCI1XFxcIiBtaW49XFxcIjBcXFwiIG1heD1cXFwiYnV0dG9uLmR1cmF0aW9uXFxcIlxcclxcblxcdFxcdFxcdFxcdHZhbHVlPVxcXCJidXR0b24uYWN0aW9uUHJvZ3Jlc3NcXFwiIGJhY2tncm91bmQ9XFxcInRyYW5zcGFyZW50XFxcIj48L3JsLXJhdGluZy1iYXI+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbG9uZ0NsaWNrQnV0dG9uL2xvbmdDbGlja0J1dHRvbi5odG1sXG4gKiogbW9kdWxlIGlkID0gNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgbWVzc2FnZUxvZ19zZXJ2aWNlXzEgPSByZXF1aXJlKCcuL21lc3NhZ2VMb2cuc2VydmljZScpO1xyXG52YXIgbWVzc2FnZUxvZ19kaXJlY3RpdmVfMSA9IHJlcXVpcmUoJy4vbWVzc2FnZUxvZy5kaXJlY3RpdmUnKTtcclxudmFyIGVkaXRhYmxlTWVzc2FnZUxvZ18xID0gcmVxdWlyZSgnLi9lZGl0YWJsZU1lc3NhZ2VMb2cnKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9tZXNzYWdlTG9nLnNlcnZpY2UnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vbWVzc2FnZUxvZy5kaXJlY3RpdmUnKSk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLm1lc3NhZ2VMb2cnO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29iamVjdC5tb2R1bGVOYW1lXSlcclxuICAgIC5mYWN0b3J5KG1lc3NhZ2VMb2dfc2VydmljZV8xLmZhY3RvcnlOYW1lLCBtZXNzYWdlTG9nX3NlcnZpY2VfMS5tZXNzYWdlTG9nRmFjdG9yeSlcclxuICAgIC5kaXJlY3RpdmUobWVzc2FnZUxvZ19kaXJlY3RpdmVfMS5kaXJlY3RpdmVOYW1lLCBtZXNzYWdlTG9nX2RpcmVjdGl2ZV8xLm1lc3NhZ2VMb2cpXHJcbiAgICAuY29udHJvbGxlcihtZXNzYWdlTG9nX2RpcmVjdGl2ZV8xLmNvbnRyb2xsZXJOYW1lLCBtZXNzYWdlTG9nX2RpcmVjdGl2ZV8xLk1lc3NhZ2VMb2dDb250cm9sbGVyKVxyXG4gICAgLmRpcmVjdGl2ZShlZGl0YWJsZU1lc3NhZ2VMb2dfMS5kaXJlY3RpdmVOYW1lLCBlZGl0YWJsZU1lc3NhZ2VMb2dfMS5lZGl0YWJsZU1lc3NhZ2VMb2cpXHJcbiAgICAuY29udHJvbGxlcihlZGl0YWJsZU1lc3NhZ2VMb2dfMS5jb250cm9sbGVyTmFtZSwgZWRpdGFibGVNZXNzYWdlTG9nXzEuRWRpdGFibGVNZXNzYWdlTG9nQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VMb2cubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9tZXNzYWdlTG9nL21lc3NhZ2VMb2cubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZXhwb3J0cy5mYWN0b3J5TmFtZSA9ICdtZXNzYWdlTG9nJztcclxuZXhwb3J0cy5kZWZhdWx0UGFnZVNpemUgPSAxMDtcclxudmFyIE1lc3NhZ2VMb2cgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWVzc2FnZUxvZygpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGFydGluZ01lc3NhZ2UgPSAwO1xyXG4gICAgICAgIHRoaXMuX2hhc0ZvcndhcmRNZXNzYWdlcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2hhc0JhY2t3YXJkTWVzc2FnZXMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wYWdlU2l6ZSA9IGV4cG9ydHMuZGVmYXVsdFBhZ2VTaXplO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VMb2cucHJvdG90eXBlLCBcInBhZ2VTaXplXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VTaXplO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGUgKi9cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wYWdlU2l6ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRQYWdlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZUxvZy5wcm90b3R5cGUsIFwiaGFzRm9yd2FyZE1lc3NhZ2VzXCIsIHtcclxuICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNGb3J3YXJkTWVzc2FnZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZUxvZy5wcm90b3R5cGUsIFwiaGFzQmFja3dhcmRNZXNzYWdlc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNCYWNrd2FyZE1lc3NhZ2VzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VMb2cucHJvdG90eXBlLCBcImRhdGFTZXJ2aWNlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFTZXJ2aWNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGUgKi9cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhU2VydmljZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlTWVzc2FnZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50UGFnZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKiB0c2xpbnQ6ZW5hYmxlICovXHJcbiAgICBNZXNzYWdlTG9nLnByb3RvdHlwZS5hZGRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLnNhdmVNZXNzYWdlKG1lc3NhZ2UpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5nZXRUb3BQYWdlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTWVzc2FnZUxvZy5wcm90b3R5cGUuZ2V0TmV4dFBhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvcndhcmRNZXNzYWdlcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXJ0aW5nTWVzc2FnZSArPSB0aGlzLnBhZ2VTaXplO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUN1cnJlbnRQYWdlKCk7XHJcbiAgICB9O1xyXG4gICAgTWVzc2FnZUxvZy5wcm90b3R5cGUuZ2V0UHJldmlvdXNQYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5oYXNCYWNrd2FyZE1lc3NhZ2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhcnRpbmdNZXNzYWdlIC09IHRoaXMucGFnZVNpemU7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXJ0aW5nTWVzc2FnZSA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhcnRpbmdNZXNzYWdlID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ3VycmVudFBhZ2UoKTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nLnByb3RvdHlwZS5nZXRUb3BQYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXJ0aW5nTWVzc2FnZSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ3VycmVudFBhZ2UoKTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUN1cnJlbnRQYWdlKCk7XHJcbiAgICB9O1xyXG4gICAgTWVzc2FnZUxvZy5wcm90b3R5cGUudXBkYXRlQ3VycmVudFBhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5kYXRhU2VydmljZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJ1c3kgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLmdldE1lc3NhZ2VzKHRoaXMuY3VycmVudFN0YXJ0aW5nTWVzc2FnZSwgdGhpcy5wYWdlU2l6ZSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLnZpc2libGVNZXNzYWdlcyA9IHJlc3VsdC5tZXNzYWdlcztcclxuICAgICAgICAgICAgX3RoaXMuX2hhc0ZvcndhcmRNZXNzYWdlcyA9IHJlc3VsdC5oYXNNb3JlTWVzc2FnZXM7XHJcbiAgICAgICAgICAgIF90aGlzLl9oYXNCYWNrd2FyZE1lc3NhZ2VzID0gKF90aGlzLmN1cnJlbnRTdGFydGluZ01lc3NhZ2UgPiAwKTtcclxuICAgICAgICAgICAgX3RoaXMuYnVzeSA9IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNZXNzYWdlTG9nO1xyXG59KSgpO1xyXG5leHBvcnRzLk1lc3NhZ2VMb2cgPSBNZXNzYWdlTG9nO1xyXG5mdW5jdGlvbiBtZXNzYWdlTG9nRmFjdG9yeSgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlTG9nKCk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5tZXNzYWdlTG9nRmFjdG9yeSA9IG1lc3NhZ2VMb2dGYWN0b3J5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlTG9nLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL21lc3NhZ2VMb2cvbWVzc2FnZUxvZy5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgbWVzc2FnZUxvZ19zZXJ2aWNlXzEgPSByZXF1aXJlKCcuL21lc3NhZ2VMb2cuc2VydmljZScpO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxNZXNzYWdlTG9nJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdNZXNzYWdlTG9nQ29udHJvbGxlcic7XHJcbnZhciBNZXNzYWdlTG9nQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNZXNzYWdlTG9nQ29udHJvbGxlcigkc2NvcGUsIG1lc3NhZ2VMb2dGYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm1lc3NhZ2VMb2cgPSB0aGlzLm1lc3NhZ2VMb2dCaW5kaW5nIHx8IG1lc3NhZ2VMb2dGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXNzYWdlTG9nLnZpc2libGVNZXNzYWdlczsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm1lc3NhZ2VzID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXNzYWdlTG9nLmhhc0ZvcndhcmRNZXNzYWdlczsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhhc05leHRQYWdlID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXNzYWdlTG9nLmhhc0JhY2t3YXJkTWVzc2FnZXM7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5oYXNQcmV2aW91c1BhZ2UgPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm1lc3NhZ2VMb2cuYnVzeTsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRpbmdJbml0aWFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2VydmljZTsgfSwgZnVuY3Rpb24gKHNlcnZpY2UpIHtcclxuICAgICAgICAgICAgX3RoaXMubWVzc2FnZUxvZy5kYXRhU2VydmljZSA9IHNlcnZpY2U7XHJcbiAgICAgICAgICAgIF90aGlzLmxvYWRpbmdJbml0aWFsID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VMb2cucGFnZVNpemUgPSB0aGlzLnBhZ2VTaXplICE9IG51bGwgPyB0aGlzLnBhZ2VTaXplIDogODtcclxuICAgIH1cclxuICAgIE1lc3NhZ2VMb2dDb250cm9sbGVyLnByb3RvdHlwZS5nZXRPbGRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlTG9nLmdldE5leHRQYWdlKCk7XHJcbiAgICB9O1xyXG4gICAgTWVzc2FnZUxvZ0NvbnRyb2xsZXIucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlTG9nLmdldFRvcFBhZ2UoKTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCBtZXNzYWdlTG9nX3NlcnZpY2VfMS5mYWN0b3J5TmFtZV07XHJcbiAgICByZXR1cm4gTWVzc2FnZUxvZ0NvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTWVzc2FnZUxvZ0NvbnRyb2xsZXIgPSBNZXNzYWdlTG9nQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gbWVzc2FnZUxvZygpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9tZXNzYWdlTG9nLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2xvZycsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgc2VydmljZTogJz0nLFxyXG4gICAgICAgICAgICBwYWdlU2l6ZTogJz0nLFxyXG4gICAgICAgICAgICBtZXNzYWdlTG9nQmluZGluZzogJz1tZXNzYWdlTG9nJyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLm1lc3NhZ2VMb2cgPSBtZXNzYWdlTG9nO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlTG9nLmRpcmVjdGl2ZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbWVzc2FnZUxvZy9tZXNzYWdlTG9nLmRpcmVjdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdj5cXHJcXG5cXHQ8cmwtYnVzeSBsb2FkaW5nPVxcXCJsb2cubG9hZGluZ0luaXRpYWxcXFwiIHNpemU9XFxcIjJ4XFxcIj48L3JsLWJ1c3k+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiY29udGVudC1ncm91cFxcXCIgbmctcmVwZWF0PVxcXCJlbnRyeSBpbiBsb2cubWVzc2FnZXNcXFwiPlxcclxcblxcdFxcdDxkaXYgbmctYmluZC1odG1sPVxcXCJlbnRyeS5tZXNzYWdlXFxcIj48L2Rpdj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJieWxpbmVcXFwiPnt7ZW50cnkuY3JlYXRlZEJ5fX08L2Rpdj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJieWxpbmVcXFwiPnt7ZW50cnkuY3JlYXRlZERhdGV9fSB7e2VudHJ5LmNyZWF0ZWRUaW1lfX0gVVRDPC9kaXY+XFxyXFxuXFx0PC9kaXY+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiY29udGVudC1ncm91cFxcXCIgbmctaWY9XFxcIihsb2cubWVzc2FnZXMgfCBpc0VtcHR5KSAmJiAhbG9nLmxvYWRpbmdJbml0aWFsXFxcIj5ObyBleGlzdGluZyBtZXNzYWdlczwvZGl2PlxcclxcblxcdDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxyXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLXhzLTEyXFxcIj5cXHJcXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PHJsLWJ1dHRvbi1hc3luYyB0eXBlPVxcXCJkZWZhdWx0XFxcIiBhY3Rpb249XFxcImxvZy5nZXRUb3BQYWdlKClcXFwiIG5nLWRpc2FibGVkPVxcXCJsb2cubG9hZGluZ1xcXCIgcmlnaHQtYWxpZ25lZD1cXFwidHJ1ZVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PHNwYW4gbmctc2hvdz1cXFwibG9nLmhhc1ByZXZpb3VzUGFnZVxcXCI+VG9wPC9zcGFuPlxcclxcblxcdFxcdFxcdFxcdFxcdDxzcGFuIG5nLWhpZGU9XFxcImxvZy5oYXNQcmV2aW91c1BhZ2VcXFwiPlJlZnJlc2g8L3NwYW4+XFxyXFxuXFx0XFx0XFx0XFx0PC9ybC1idXR0b24tYXN5bmM+XFxyXFxuXFx0XFx0XFx0XFx0PHJsLWJ1dHRvbi1hc3luYyB0eXBlPVxcXCJkZWZhdWx0XFxcIiBuZy1kaXNhYmxlZD1cXFwibG9nLmhhc05leHRQYWdlID09IGZhbHNlIHx8IGxvZy5sb2FkaW5nXFxcIiBhY3Rpb249XFxcImxvZy5nZXROZXh0UGFnZSgpXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRPbGRlciA8aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1yaWdodFxcXCI+PC9pPlxcclxcblxcdFxcdFxcdFxcdDwvcmwtYnV0dG9uLWFzeW5jPlxcclxcblxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdDwvZGl2PlxcclxcbjwvZGl2PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL21lc3NhZ2VMb2cvbWVzc2FnZUxvZy5odG1sXG4gKiogbW9kdWxlIGlkID0gODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIG1lc3NhZ2VMb2dfc2VydmljZV8xID0gcmVxdWlyZSgnLi9tZXNzYWdlTG9nLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsRWRpdGFibGVNZXNzYWdlTG9nJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdFZGl0YWJsZU1lc3NhZ2VMb2dDb250cm9sbGVyJztcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxuO1xyXG52YXIgRWRpdGFibGVNZXNzYWdlTG9nQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFZGl0YWJsZU1lc3NhZ2VMb2dDb250cm9sbGVyKCRzY29wZSwgbWVzc2FnZUxvZ0ZhY3RvcnksIG9iamVjdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlTG9nU2VydmljZSA9IG1lc3NhZ2VMb2dGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXNzYWdlTG9nU2VydmljZS5idXN5OyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYnVzeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2F2aW5nTWVzc2FnZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYnVzeSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIEVkaXRhYmxlTWVzc2FnZUxvZ0NvbnRyb2xsZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5vYmplY3QuaXNOdWxsT3JXaGl0ZXNwYWNlKHRoaXMubmV3TWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2F2aW5nTWVzc2FnZSA9IHRydWU7XHJcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLm5ld01lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5uZXdNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUxvZ1NlcnZpY2UuYWRkTWVzc2FnZShtZXNzYWdlKTtcclxuICAgIH07XHJcbiAgICBFZGl0YWJsZU1lc3NhZ2VMb2dDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsIG1lc3NhZ2VMb2dfc2VydmljZV8xLmZhY3RvcnlOYW1lLCBfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gRWRpdGFibGVNZXNzYWdlTG9nQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5FZGl0YWJsZU1lc3NhZ2VMb2dDb250cm9sbGVyID0gRWRpdGFibGVNZXNzYWdlTG9nQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gZWRpdGFibGVNZXNzYWdlTG9nKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcblxcdFxcdFxcdDxmb3JtIG5nLXN1Ym1pdD1cXFwibG9nLmFkZCgpXFxcIj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIG5nLW1vZGVsPVxcXCJsb2cubmV3TWVzc2FnZVxcXCIgcGxhY2Vob2xkZXI9XFxcIkVudGVyIGxvZyBtZXNzYWdlXFxcIiAvPlxcblxcdFxcdFxcdFxcdFxcdDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1idG5cXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgdHlwZT1cXFwic3VibWl0XFxcIiBuZy1kaXNhYmxlZD1cXFwibG9nLmJ1c3lcXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxybC1idXN5IGxvYWRpbmc9XFxcImxvZy5zYXZpbmdNZXNzYWdlXFxcIj48L3JsLWJ1c3k+IEFkZFxcblxcdFxcdFxcdFxcdFxcdFxcdDwvYnV0dG9uPlxcblxcdFxcdFxcdFxcdFxcdDwvc3Bhbj5cXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJzaGFsbG93IHdlbGxcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxybC1tZXNzYWdlLWxvZyBzZXJ2aWNlPVxcXCJsb2cuc2VydmljZVxcXCIgcGFnZS1zaXplPVxcXCJsb2cucGFnZVNpemVcXFwiIG1lc3NhZ2UtbG9nPVxcXCJsb2cubWVzc2FnZUxvZ1NlcnZpY2VcXFwiPjwvcmwtbWVzc2FnZS1sb2c+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0PC9mb3JtPlxcblxcdFxcdFwiLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnbG9nJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBzZXJ2aWNlOiAnPScsXHJcbiAgICAgICAgICAgIHBhZ2VTaXplOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5lZGl0YWJsZU1lc3NhZ2VMb2cgPSBlZGl0YWJsZU1lc3NhZ2VMb2c7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkaXRhYmxlTWVzc2FnZUxvZy5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbWVzc2FnZUxvZy9lZGl0YWJsZU1lc3NhZ2VMb2cuanNcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5tdWx0aVN0ZXBJbmRpY2F0b3InO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxNdWx0aVN0ZXBJbmRpY2F0b3InO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ011bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXInO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyKCRzdGF0ZSwgJHEsIG9iamVjdCkge1xyXG4gICAgICAgIHRoaXMuJHN0YXRlID0gJHN0YXRlO1xyXG4gICAgICAgIHRoaXMuJHEgPSAkcTtcclxuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuICAgICAgICB0aGlzLmNvbmZpZ3VyZVN0ZXBzKCk7XHJcbiAgICB9XHJcbiAgICBNdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyLnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgICBpZiAoIXRoaXMuYW55TG9hZGluZygpKSB7XHJcbiAgICAgICAgICAgIHN0ZXAubG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuJHEud2hlbihzdGVwLm9uQ2xpY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXIucHJvdG90eXBlLmFueUxvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uYW55KHRoaXMuc3RlcHMsIGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGVwLmxvYWRpbmc7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlci5wcm90b3R5cGUuY29uZmlndXJlU3RlcHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfLmVhY2godGhpcy5zdGVwcywgZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgICAgICAgc3RlcC5oYXNDb3VudCA9IF8uaXNGdW5jdGlvbihzdGVwLmNvdW50KTtcclxuICAgICAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24oc3RlcC5vbkNsaWNrKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9iamVjdC5pc051bGxPcldoaXRlc3BhY2Uoc3RlcC5zdGF0ZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcC5pbmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGVwLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZWRpcmVjdFRvU3RhdGUoc3RlcCk7IH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLiRzdGF0ZS5pbmNsdWRlcyhzdGVwLnN0YXRlTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcC5pc0N1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXIucHJvdG90eXBlLnJlZGlyZWN0VG9TdGF0ZSA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy4kc3RhdGUuZ28oc3RlcC5zdGF0ZU5hbWUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jbGVhckN1cnJlbnRTdGF0ZSgpO1xyXG4gICAgICAgICAgICBzdGVwLmlzQ3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYXJDdXJyZW50U3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXy5lYWNoKHRoaXMuc3RlcHMsIGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgICAgICAgIHN0ZXAuaXNDdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc3RhdGUnLCAnJHEnLCBfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5NdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyID0gTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gbXVsdGlTdGVwSW5kaWNhdG9yKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL211bHRpU3RlcEluZGljYXRvci5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdicmVhZGNydW1iJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBzdGVwczogJz0nLFxyXG4gICAgICAgICAgICBudW1iZXJlZDogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JqZWN0Lm1vZHVsZU5hbWVdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIG11bHRpU3RlcEluZGljYXRvcilcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIE11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aVN0ZXBJbmRpY2F0b3IuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL211bHRpU3RlcEluZGljYXRvci9tdWx0aVN0ZXBJbmRpY2F0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcIm11bHRpLXN0ZXBcXFwiIG5nLWNsYXNzPVxcXCJ7ICdudW1iZXJlZCc6IGJyZWFkY3J1bWIubnVtYmVyZWQgfVxcXCI+XFxyXFxuXFx0PG9sPlxcclxcblxcdFxcdDxsaSBuZy1yZXBlYXQ9XFxcInN0ZXAgaW4gYnJlYWRjcnVtYi5zdGVwc1xcXCIgbmctY2xpY2s9XFxcImJyZWFkY3J1bWIub25DbGljayhzdGVwKVxcXCJcXHJcXG5cXHRcXHRcXHRuZy1jbGFzcz1cXFwieyAnY29tcGxldGVkJzogc3RlcC5pc0NvbXBsZXRlZCwgJ2N1cnJlbnQnOiBzdGVwLmlzQ3VycmVudCwgJ2FjdGl2ZSc6ICFzdGVwLmluYWN0aXZlICYmICFicmVhZGNydW1iLmFueUxvYWRpbmcoKSB9XFxcIj5cXHJcXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJ3cmFwXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHQ8cCBjbGFzcz1cXFwiYmFkZ2VcXFwiIG5nLXNob3c9XFxcInN0ZXAuaGFzQ291bnRcXFwiPnt7c3RlcC5jb3VudCgpfX08L3A+XFxyXFxuXFx0XFx0XFx0XFx0PHAgY2xhc3M9XFxcInRpdGxlXFxcIj57e3N0ZXAudGl0bGV9fSA8cmwtYnVzeSBsb2FkaW5nPVxcXCJzdGVwLmxvYWRpbmdcXFwiPjwvcmwtYnVzeT48L3A+XFxyXFxuXFx0XFx0XFx0XFx0PHAgY2xhc3M9XFxcInN1YnRpdGxlXFxcIj57e3N0ZXAuc3VidGl0bGV9fTwvcD5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8L2xpPlxcclxcblxcdDwvb2w+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbXVsdGlTdGVwSW5kaWNhdG9yL211bHRpU3RlcEluZGljYXRvci5odG1sXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciByYWRpb0dyb3VwXzEgPSByZXF1aXJlKCcuL3JhZGlvR3JvdXAnKTtcclxuZXhwb3J0cy5yYWRpb0dyb3VwRGlyZWN0aXZlTmFtZSA9IHJhZGlvR3JvdXBfMS5kaXJlY3RpdmVOYW1lO1xyXG5leHBvcnRzLnJhZGlvR3JvdXAgPSByYWRpb0dyb3VwXzEucmFkaW9Hcm91cDtcclxuZXhwb3J0cy5yYWRpb0dyb3VwQ29udHJvbGxlck5hbWUgPSByYWRpb0dyb3VwXzEuY29udHJvbGxlck5hbWU7XHJcbmV4cG9ydHMuUmFkaW9Hcm91cENvbnRyb2xsZXIgPSByYWRpb0dyb3VwXzEuUmFkaW9Hcm91cENvbnRyb2xsZXI7XHJcbnZhciByYWRpb18xID0gcmVxdWlyZSgnLi9yYWRpbycpO1xyXG5leHBvcnRzLnJhZGlvRGlyZWN0aXZlTmFtZSA9IHJhZGlvXzEuZGlyZWN0aXZlTmFtZTtcclxuZXhwb3J0cy5yYWRpbyA9IHJhZGlvXzEucmFkaW87XHJcbmV4cG9ydHMucmFkaW9Db250cm9sbGVyTmFtZSA9IHJhZGlvXzEuY29udHJvbGxlck5hbWU7XHJcbmV4cG9ydHMuUmFkaW9Db250cm9sbGVyID0gcmFkaW9fMS5SYWRpb0NvbnRyb2xsZXI7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybDIxLmNvbXBvbmVudHMucmFkaW8nO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29iamVjdC5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUocmFkaW9Hcm91cF8xLmRpcmVjdGl2ZU5hbWUsIHJhZGlvR3JvdXBfMS5yYWRpb0dyb3VwKVxyXG4gICAgLmNvbnRyb2xsZXIocmFkaW9Hcm91cF8xLmNvbnRyb2xsZXJOYW1lLCByYWRpb0dyb3VwXzEuUmFkaW9Hcm91cENvbnRyb2xsZXIpXHJcbiAgICAuZGlyZWN0aXZlKHJhZGlvXzEuZGlyZWN0aXZlTmFtZSwgcmFkaW9fMS5yYWRpbylcclxuICAgIC5jb250cm9sbGVyKHJhZGlvXzEuY29udHJvbGxlck5hbWUsIHJhZGlvXzEuUmFkaW9Db250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFkaW8ubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yYWRpby9yYWRpby5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxSYWRpb0dyb3VwJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdSYWRpb0dyb3VwQ29udHJvbGxlcic7XHJcbnZhciBSYWRpb0dyb3VwID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJhZGlvR3JvdXAoJHNjb3BlLCBuZ01vZGVsLCBuYW1lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gbmdNb2RlbC4kdmlld1ZhbHVlOyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgX3RoaXMuc2VsZWN0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZWxlY3Rpb247IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJhZGlvR3JvdXA7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmFkaW9Hcm91cCA9IFJhZGlvR3JvdXA7XHJcbnZhciBSYWRpb0dyb3VwQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSYWRpb0dyb3VwQ29udHJvbGxlcigkc2NvcGUsICRhdHRycywgJGVsZW1lbnQsIG9iamVjdCkge1xyXG4gICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgIGlmICghb2JqZWN0LmlzTnVsbE9yV2hpdGVzcGFjZSgkYXR0cnMucmxSYWRpb0dyb3VwKSkge1xyXG4gICAgICAgICAgICBuYW1lID0gJGF0dHJzLnJsUmFkaW9Hcm91cDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW9iamVjdC5pc051bGxPcldoaXRlc3BhY2UoJGF0dHJzLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSAkYXR0cnMubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSAnUmFkaW9Hcm91cCcgKyB0aGlzLmdldE5leHRJZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmdNb2RlbCA9ICRlbGVtZW50LmNvbnRyb2xsZXIoJ25nTW9kZWwnKTtcclxuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IFJhZGlvR3JvdXAoJHNjb3BlLCBuZ01vZGVsLCBuYW1lKTtcclxuICAgIH1cclxuICAgIFJhZGlvR3JvdXBDb250cm9sbGVyLnByb3RvdHlwZS5yZWdpc3RlckJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ncm91cDtcclxuICAgIH07XHJcbiAgICBSYWRpb0dyb3VwQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0TmV4dElkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBuZXh0SWQgPSBSYWRpb0dyb3VwQ29udHJvbGxlci5uZXh0SWQudG9TdHJpbmcoKTtcclxuICAgICAgICBSYWRpb0dyb3VwQ29udHJvbGxlci5uZXh0SWQrKztcclxuICAgICAgICByZXR1cm4gbmV4dElkO1xyXG4gICAgfTtcclxuICAgIFJhZGlvR3JvdXBDb250cm9sbGVyLm5leHRJZCA9IDE7XHJcbiAgICBSYWRpb0dyb3VwQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCAnJGF0dHJzJywgJyRlbGVtZW50JywgX19vYmplY3Quc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIFJhZGlvR3JvdXBDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlJhZGlvR3JvdXBDb250cm9sbGVyID0gUmFkaW9Hcm91cENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHJhZGlvR3JvdXAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnQUUnLFxyXG4gICAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnJhZGlvR3JvdXAgPSByYWRpb0dyb3VwO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYWRpb0dyb3VwLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yYWRpby9yYWRpb0dyb3VwLmpzXG4gKiogbW9kdWxlIGlkID0gODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIHJhZGlvR3JvdXBfMSA9IHJlcXVpcmUoJy4vcmFkaW9Hcm91cCcpO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxSYWRpbyc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnUmFkaW9Db250cm9sbGVyJztcclxudmFyIFJhZGlvQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSYWRpb0NvbnRyb2xsZXIoJHNjb3BlLCAkZWxlbWVudCkge1xyXG4gICAgICAgIHZhciByYWRpb0dyb3VwQ29udHJvbGxlciA9ICRlbGVtZW50LmNvbnRyb2xsZXIoJ3JsUmFkaW9Hcm91cCcpO1xyXG4gICAgICAgIGlmIChyYWRpb0dyb3VwQ29udHJvbGxlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmFkaW9Hcm91cCA9IHJhZGlvR3JvdXBDb250cm9sbGVyLnJlZ2lzdGVyQnV0dG9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbmdNb2RlbCA9ICRlbGVtZW50LmNvbnRyb2xsZXIoJ25nTW9kZWwnKTtcclxuICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwID0gbmV3IHJhZGlvR3JvdXBfMS5SYWRpb0dyb3VwKCRzY29wZSwgbmdNb2RlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgUmFkaW9Db250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckZWxlbWVudCddO1xyXG4gICAgcmV0dXJuIFJhZGlvQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5SYWRpb0NvbnRyb2xsZXIgPSBSYWRpb0NvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHJhZGlvKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHJlcXVpcmU6IFsnP15ecmxSYWRpb0dyb3VwJywgJz9uZ01vZGVsJ10sXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8bGFiZWw+XFxuXFx0XFx0XFx0XFx0PGlucHV0IGlkPVxcXCJyYWRpb1xcXCIgdHlwZT1cXFwicmFkaW9cXFwiIG5hbWU9XFxcInt7cmFkaW8ucmFkaW9Hcm91cC5uYW1lfX1cXFwiIG5nLW1vZGVsPVxcXCJyYWRpby5yYWRpb0dyb3VwLnNlbGVjdGlvblxcXCIgbmctdmFsdWU9XFxcInJhZGlvLnZhbHVlXFxcIiAvPlxcblxcdFxcdFxcdFxcdDxzcGFuIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXFx0XFx0XFx0PC9sYWJlbD5cXG5cXHRcXHRcIixcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ3JhZGlvJyxcclxuICAgICAgICBzY29wZTogdHJ1ZSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5yYWRpbyA9IHJhZGlvO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYWRpby5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvcmFkaW8vcmFkaW8uanNcbiAqKiBtb2R1bGUgaWQgPSA4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHJhdGluZ0JhckJhY2tncm91bmRzX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vcmF0aW5nQmFyQmFja2dyb3VuZHMuc2VydmljZScpO1xyXG52YXIgcmF0aW5nQmFyQ2xhc3Nfc2VydmljZV8xID0gcmVxdWlyZSgnLi9yYXRpbmdCYXJDbGFzcy5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLnJhdGluZ0Jhcic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFJhdGluZ0Jhcic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnUmF0aW5nQmFyQ29udHJvbGxlcic7XHJcbnZhciBSYXRpbmdCYXJDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJhdGluZ0JhckNvbnRyb2xsZXIoJHNjb3BlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB2YXIgcmF0aW5nQmFyQmFja2dyb3VuZHMgPSBuZXcgcmF0aW5nQmFyQmFja2dyb3VuZHNfc2VydmljZV8xLlJhdGluZ0JhckJhY2tncm91bmRTZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMucmF0aW5nQmFyQ2xhc3MgPSBuZXcgcmF0aW5nQmFyQ2xhc3Nfc2VydmljZV8xLlJhdGluZ0JhckNsYXNzU2VydmljZTtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDbGFzcyA9IHJhdGluZ0JhckJhY2tncm91bmRzLmdldEJhY2tncm91bmQodGhpcy5iYWNrZ3JvdW5kKTtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnZhbHVlOyB9LCBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlVmFsdWUobmV3VmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudG90YWxXaWR0aDsgfSwgZnVuY3Rpb24gKG5ld1dpZHRoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRpbWVuc2lvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3V2lkdGggKyAyLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBfdGhpcy5oZWlnaHQgKyAyLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy51cGRhdGVWYWx1ZShfdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBSYXRpbmdCYXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgIHZhciBjb25maWRlbmNlU2NvcmUgPSAobmV3VmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XHJcbiAgICAgICAgdGhpcy5iYXJDbGFzcyA9IHRoaXMucmF0aW5nQmFyQ2xhc3MuZ2V0Q2xhc3MoY29uZmlkZW5jZVNjb3JlKTtcclxuICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5yb3VuZChjb25maWRlbmNlU2NvcmUgKiB0aGlzLnRvdGFsV2lkdGgpO1xyXG4gICAgfTtcclxuICAgIFJhdGluZ0JhckNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJ107XHJcbiAgICByZXR1cm4gUmF0aW5nQmFyQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5SYXRpbmdCYXJDb250cm9sbGVyID0gUmF0aW5nQmFyQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gcmF0aW5nQmFyKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInJhdGluZy1iYXJcXFwiPlxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInt7cmF0aW5nQmFyLmJhY2tncm91bmRDbGFzc319XFxcIiBuZy1jbGFzcz1cXFwieyBlbXB0eTogcmF0aW5nQmFyLnZhbHVlID09IG1pbiB9XFxcIiBuZy1zdHlsZT1cXFwicmF0aW5nQmFyLmRpbWVuc2lvbnNcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxkaXYgbmctY2xhc3M9XFxcInJhdGluZ0Jhci5iYXJDbGFzc1xcXCIgbmctc3R5bGU9XFxcInsgd2lkdGg6IHJhdGluZ0Jhci53aWR0aCwgaGVpZ2h0OiByYXRpbmdCYXIuaGVpZ2h0IH1cXFwiPjwvZGl2PlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFwiLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAncmF0aW5nQmFyJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICB0b3RhbFdpZHRoOiAnPXdpZHRoJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnPScsXHJcbiAgICAgICAgICAgIHZhbHVlOiAnPScsXHJcbiAgICAgICAgICAgIG1pbjogJz0nLFxyXG4gICAgICAgICAgICBtYXg6ICc9JyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZDogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucmF0aW5nQmFyID0gcmF0aW5nQmFyO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIHJhdGluZ0JhcilcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIFJhdGluZ0JhckNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYXRpbmdCYXIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3JhdGluZ0Jhci9yYXRpbmdCYXIuanNcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgUmF0aW5nQmFyQmFja2dyb3VuZFNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmF0aW5nQmFyQmFja2dyb3VuZFNlcnZpY2UoKSB7XHJcbiAgICAgICAgdGhpcy5zdGFuZGFyZCA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ3N0YW5kYXJkJyxcclxuICAgICAgICAgICAgY2xhc3M6ICdiYWNrZ3JvdW5kJyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZGFyayA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ2RhcmsnLFxyXG4gICAgICAgICAgICBjbGFzczogJ2JhY2tncm91bmQtZGFyaycsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAndHJhbnNwYXJlbnQnLFxyXG4gICAgICAgICAgICBjbGFzczogJ2JhY2tncm91bmQtdHJhbnNwYXJlbnQnLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBSYXRpbmdCYXJCYWNrZ3JvdW5kU2VydmljZS5wcm90b3R5cGUuZ2V0QmFja2dyb3VuZCA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IHRoaXMuZGFyay50eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhcmsuY2xhc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IHRoaXMudHJhbnNwYXJlbnQudHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BhcmVudC5jbGFzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YW5kYXJkLmNsYXNzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gUmF0aW5nQmFyQmFja2dyb3VuZFNlcnZpY2U7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmF0aW5nQmFyQmFja2dyb3VuZFNlcnZpY2UgPSBSYXRpbmdCYXJCYWNrZ3JvdW5kU2VydmljZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmF0aW5nQmFyQmFja2dyb3VuZHMuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvcmF0aW5nQmFyL3JhdGluZ0JhckJhY2tncm91bmRzLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgUmF0aW5nQmFyQ2xhc3NTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJhdGluZ0JhckNsYXNzU2VydmljZSgpIHtcclxuICAgIH1cclxuICAgIFJhdGluZ0JhckNsYXNzU2VydmljZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoY29uZmlkZW5jZSkge1xyXG4gICAgICAgIGlmIChjb25maWRlbmNlID49IDAuOCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3ZlcnktaGlnaCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZGVuY2UgPj0gMC42KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnaGlnaCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZGVuY2UgPj0gMC40KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnbWVkaXVtJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29uZmlkZW5jZSA+PSAwLjIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdsb3cnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICd2ZXJ5LWxvdyc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBSYXRpbmdCYXJDbGFzc1NlcnZpY2U7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmF0aW5nQmFyQ2xhc3NTZXJ2aWNlID0gUmF0aW5nQmFyQ2xhc3NTZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYXRpbmdCYXJDbGFzcy5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yYXRpbmdCYXIvcmF0aW5nQmFyQ2xhc3Muc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19wYXJlbnRDaGlsZEJlaGF2aW9yID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnBhcmVudENoaWxkQmVoYXZpb3I7XHJcbnZhciBfX29ic2VydmFibGUgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JzZXJ2YWJsZTtcclxudmFyIF9fcHJvbWlzZVV0aWxpdHkgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucHJvbWlzZTtcclxudmFyIF9fbnVtYmVyVXRpbGl0eSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5udW1iZXI7XHJcbnZhciBqcXVlcnlfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvanF1ZXJ5L2pxdWVyeS5zZXJ2aWNlJyk7XHJcbnZhciBncmlkID0gcmVxdWlyZSgnLi9yZXNwb25zaXZlQ2FyZEdyaWQnKTtcclxuZXhwb3J0cy5yZXNwb25zaXZlQ2FyZEdyaWQgPSBncmlkO1xyXG52YXIgY2FyZCA9IHJlcXVpcmUoJy4vcmVzcG9uc2l2ZUNhcmQnKTtcclxuZXhwb3J0cy5yZXNwb25zaXZlQ2FyZCA9IGNhcmQ7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLnJlc3BvbnNpdmVDYXJkR3JpZCc7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW1xyXG4gICAganF1ZXJ5X3NlcnZpY2VfMS5tb2R1bGVOYW1lLFxyXG4gICAgX19wYXJlbnRDaGlsZEJlaGF2aW9yLm1vZHVsZU5hbWUsXHJcbiAgICBfX29ic2VydmFibGUubW9kdWxlTmFtZSxcclxuICAgIF9fcHJvbWlzZVV0aWxpdHkubW9kdWxlTmFtZSxcclxuICAgIF9fbnVtYmVyVXRpbGl0eS5tb2R1bGVOYW1lLFxyXG5dKVxyXG4gICAgLmRpcmVjdGl2ZShncmlkLmRpcmVjdGl2ZU5hbWUsIGdyaWQucmVzcG9uc2l2ZUNhcmRHcmlkKVxyXG4gICAgLmNvbnRyb2xsZXIoZ3JpZC5jb250cm9sbGVyTmFtZSwgZ3JpZC5SZXNwb25zaXZlQ2FyZEdyaWRDb250cm9sbGVyKVxyXG4gICAgLmRpcmVjdGl2ZShjYXJkLmRpcmVjdGl2ZU5hbWUsIGNhcmQucmVzcG9uc2l2ZUNhcmQpXHJcbiAgICAuY29udHJvbGxlcihjYXJkLmNvbnRyb2xsZXJOYW1lLCBjYXJkLlJlc3BvbnNpdmVDYXJkQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3BvbnNpdmVDYXJkR3JpZC5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3Jlc3BvbnNpdmVDYXJkR3JpZC9yZXNwb25zaXZlQ2FyZEdyaWQubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIGJyZWFrcG9pbnRzX21vZHVsZV8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvYnJlYWtwb2ludHMvYnJlYWtwb2ludHMubW9kdWxlJyk7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFJlc3BvbnNpdmVDYXJkR3JpZCc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnUmVzcG9uc2l2ZUNhcmRHcmlkQ29udHJvbGxlcic7XHJcbnZhciBfX29ic2VydmFibGUgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JzZXJ2YWJsZTtcclxudmFyIF9fbnVtYmVyVXRpbGl0eSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5udW1iZXI7XHJcbnZhciBSZXNwb25zaXZlQ2FyZEdyaWRDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlc3BvbnNpdmVDYXJkR3JpZENvbnRyb2xsZXIob2JzZXJ2YWJsZUZhY3RvcnksICRxLCBicmVha3BvaW50cywgbnVtYmVyVXRpbGl0eSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kcSA9ICRxO1xyXG4gICAgICAgIHRoaXMuYnJlYWtwb2ludHMgPSBicmVha3BvaW50cztcclxuICAgICAgICB0aGlzLm51bWJlclV0aWxpdHkgPSBudW1iZXJVdGlsaXR5O1xyXG4gICAgICAgIHRoaXMuZW1wdHlDYXJkcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYmVoYXZpb3JzID0gW107XHJcbiAgICAgICAgdGhpcy51cGRhdGVDYXJkRW5kT2ZSb3dTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm9ic2VydmFibGUuZmlyZSgndXBkYXRlRW5kT2ZSb3dTdGF0dXMnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGVGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRpbmdJbmRleCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1wdHlDYXJkcyA9IF8ucmFuZ2UodGhpcy5zdGFydGluZ0luZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWtwb2ludHMucmVnaXN0ZXIodGhpcy51cGRhdGVDYXJkRW5kT2ZSb3dTdGF0dXMpO1xyXG4gICAgfVxyXG4gICAgUmVzcG9uc2l2ZUNhcmRHcmlkQ29udHJvbGxlci5wcm90b3R5cGUucmVnaXN0ZXJDYXJkID0gZnVuY3Rpb24gKGJlaGF2aW9yLCBlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5maW5kUG9zaXRpb24oZWxlbWVudCk7XHJcbiAgICAgICAgaW5kZXggPSB0aGlzLnN0YXJ0aW5nSW5kZXggIT0gbnVsbCA/IGluZGV4ICsgdGhpcy5zdGFydGluZ0luZGV4IDogaW5kZXg7XHJcbiAgICAgICAgdmFyIHVucmVnaXN0ZXJGdW5jdGlvbnMgPSBbXTtcclxuICAgICAgICB1bnJlZ2lzdGVyRnVuY3Rpb25zLnB1c2godGhpcy5vYnNlcnZhYmxlLnJlZ2lzdGVyKGJlaGF2aW9yLmF1dG9zYXZlLCAnYXV0b3NhdmUnKSk7XHJcbiAgICAgICAgdW5yZWdpc3RlckZ1bmN0aW9ucy5wdXNoKHRoaXMub2JzZXJ2YWJsZS5yZWdpc3RlcihiZWhhdmlvci5jbG9zZSwgJ2Nsb3NlJykpO1xyXG4gICAgICAgIHVucmVnaXN0ZXJGdW5jdGlvbnMucHVzaCh0aGlzLm9ic2VydmFibGUucmVnaXN0ZXIoYmVoYXZpb3IuaG92ZXJPdXQsICdob3Zlck91dCcpKTtcclxuICAgICAgICB1bnJlZ2lzdGVyRnVuY3Rpb25zLnB1c2godGhpcy5vYnNlcnZhYmxlLnJlZ2lzdGVyKGJlaGF2aW9yLnVwZGF0ZUVuZE9mUm93U3RhdHVzLCAndXBkYXRlRW5kT2ZSb3dTdGF0dXMnKSk7XHJcbiAgICAgICAgdmFyIGluZGV4ZWRCZWhhdmlvciA9IGJlaGF2aW9yO1xyXG4gICAgICAgIGluZGV4ZWRCZWhhdmlvci5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuYmVoYXZpb3JzLnB1c2goaW5kZXhlZEJlaGF2aW9yKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfLmVhY2godW5yZWdpc3RlckZ1bmN0aW9ucywgZnVuY3Rpb24gKHVucmVnaXN0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHVucmVnaXN0ZXIoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBSZXNwb25zaXZlQ2FyZEdyaWRDb250cm9sbGVyLnByb3RvdHlwZS5vcGVuQ2FyZCA9IGZ1bmN0aW9uIChvcGVuaW5nQ2FyZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmF1dG9zYXZlQ2FyZCgpKSB7XHJcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmdldEN1cnJlbnRSb3cob3BlbmluZ0NhcmQuaW5kZXgpLCBmdW5jdGlvbiAoY2FyZCkge1xyXG4gICAgICAgICAgICAgICAgY2FyZC5vcGVuKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZXNwb25zaXZlQ2FyZEdyaWRDb250cm9sbGVyLnByb3RvdHlwZS5jbG9zZUNhcmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hdXRvc2F2ZUNhcmQoKTtcclxuICAgIH07XHJcbiAgICBSZXNwb25zaXZlQ2FyZEdyaWRDb250cm9sbGVyLnByb3RvdHlwZS5hdXRvc2F2ZUNhcmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLm9ic2VydmFibGUuZmlyZSgnYXV0b3NhdmUnKTtcclxuICAgICAgICBpZiAoXy5hbGwocmVzdWx0cykpIHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlLmZpcmUoJ2Nsb3NlJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgUmVzcG9uc2l2ZUNhcmRHcmlkQ29udHJvbGxlci5wcm90b3R5cGUuaG92ZXJJbiA9IGZ1bmN0aW9uIChjdXJyZW50Q2FyZCkge1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLmdldEN1cnJlbnRSb3coY3VycmVudENhcmQuaW5kZXgpLCBmdW5jdGlvbiAoY2FyZCkge1xyXG4gICAgICAgICAgICBjYXJkLmhvdmVySW4oKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSZXNwb25zaXZlQ2FyZEdyaWRDb250cm9sbGVyLnByb3RvdHlwZS5ob3Zlck91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZSgnaG92ZXJPdXQnKTtcclxuICAgIH07XHJcbiAgICBSZXNwb25zaXZlQ2FyZEdyaWRDb250cm9sbGVyLnByb3RvdHlwZS5jYXJkSXNFbmRPZlJvdyA9IGZ1bmN0aW9uIChjdXJyZW50Q2FyZCkge1xyXG4gICAgICAgIHJldHVybiAoY3VycmVudENhcmQuaW5kZXggKyAxKSAlIHRoaXMuY2FyZHNQZXJSb3cgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgUmVzcG9uc2l2ZUNhcmRHcmlkQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q3VycmVudFJvdyA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gY2FjaGUgdGhlIHZhbHVlIG9mIGNhcmRzUGVyUm93IHRvIGF2b2lkIGNhc2VzIHdoZXJlIHRoZSBicmVha3BvaW50IHVwZGF0ZXMgaW4gdGhlIG1pZGRsZSBvZiB0aGlzIGZ1bmN0aW9uXHJcbiAgICAgICAgdmFyIGNhcmRzUGVyUm93ID0gdGhpcy5jYXJkc1BlclJvdztcclxuICAgICAgICB2YXIgY3VycmVudFJvdyA9IHRoaXMubnVtYmVyVXRpbGl0eS5pbnRlZ2VyRGl2aWRlKGluZGV4LCBjYXJkc1BlclJvdyk7XHJcbiAgICAgICAgcmV0dXJuIF8uZmlsdGVyKHRoaXMuYmVoYXZpb3JzLCBmdW5jdGlvbiAoYmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSb3cgPT09IF90aGlzLm51bWJlclV0aWxpdHkuaW50ZWdlckRpdmlkZShiZWhhdmlvci5pbmRleCwgY2FyZHNQZXJSb3cpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNwb25zaXZlQ2FyZEdyaWRDb250cm9sbGVyLnByb3RvdHlwZSwgXCJjYXJkc1BlclJvd1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50QnJlYWtwb2ludCA9IHRoaXMuYnJlYWtwb2ludHMuY3VycmVudEJyZWFrcG9pbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJyZWFrcG9pbnRSb3dEaWN0aW9uYXJ5W2N1cnJlbnRCcmVha3BvaW50XTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNwb25zaXZlQ2FyZEdyaWRDb250cm9sbGVyLnByb3RvdHlwZSwgXCJicmVha3BvaW50Um93RGljdGlvbmFyeVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ID0gW107XHJcbiAgICAgICAgICAgIGxpc3RbYnJlYWtwb2ludHNfbW9kdWxlXzEueHNdID0gMTtcclxuICAgICAgICAgICAgbGlzdFticmVha3BvaW50c19tb2R1bGVfMS5zbV0gPSAxO1xyXG4gICAgICAgICAgICBsaXN0W2JyZWFrcG9pbnRzX21vZHVsZV8xLm1kXSA9IDI7XHJcbiAgICAgICAgICAgIGxpc3RbYnJlYWtwb2ludHNfbW9kdWxlXzEubGddID0gMztcclxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBSZXNwb25zaXZlQ2FyZEdyaWRDb250cm9sbGVyLiRpbmplY3QgPSBbX19vYnNlcnZhYmxlLmZhY3RvcnlOYW1lLCAnJHEnLCBicmVha3BvaW50c19tb2R1bGVfMS5icmVha3BvaW50U2VydmljZU5hbWUsIF9fbnVtYmVyVXRpbGl0eS5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gUmVzcG9uc2l2ZUNhcmRHcmlkQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5SZXNwb25zaXZlQ2FyZEdyaWRDb250cm9sbGVyID0gUmVzcG9uc2l2ZUNhcmRHcmlkQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gcmVzcG9uc2l2ZUNhcmRHcmlkKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuXFx0XFx0XFx0PGRpdj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtbGctNCBjb2wtbWQtNiBjb2wtc20tMTIgc21hbGxDYXJkc0xpc3RcXFwiIG5nLXJlcGVhdD1cXFwiZW1wdHlDYXJkIGluIGdyaWQuZW1wdHlDYXJkc1xcXCIgbmctaWY9XFxcImdyaWQuZmlsbEVtcHR5U3BhY2VcXFwiPjwvZGl2PlxcblxcdFxcdFxcdFxcdDxkaXYgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcIixcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2dyaWQnLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6ICc9JyxcclxuICAgICAgICAgICAgZmlsbEVtcHR5U3BhY2U6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IHtcclxuICAgICAgICAgICAgcHJlOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBncmlkKSB7XHJcbiAgICAgICAgICAgICAgICBncmlkLmZpbmRQb3NpdGlvbiA9IGZ1bmN0aW9uIChjYXJkRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBieSBpdGVyYXRpbmcgb3ZlciB0aGUgY2FyZHMgYW5kIGZpbmRpbmcgYSBtYXRjaGluZyBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhcmRzID0gZWxlbWVudC5maW5kKCdybC1yZXNwb25zaXZlLWNhcmQnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcmRzLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXJkRWxlbWVudFswXSA9PT0gZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnJlc3BvbnNpdmVDYXJkR3JpZCA9IHJlc3BvbnNpdmVDYXJkR3JpZDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzcG9uc2l2ZUNhcmRHcmlkLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yZXNwb25zaXZlQ2FyZEdyaWQvcmVzcG9uc2l2ZUNhcmRHcmlkLmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgd2luZG93V3JhcHBlcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi93aW5kb3dXcmFwcGVyL3dpbmRvd1dyYXBwZXIuc2VydmljZScpO1xyXG52YXIgdmlzaWJsZUJyZWFrcG9pbnRfc2VydmljZV8xID0gcmVxdWlyZSgnLi92aXNpYmxlQnJlYWtwb2ludC5zZXJ2aWNlJyk7XHJcbnZhciBicmVha3BvaW50c19zZXJ2aWNlXzEgPSByZXF1aXJlKCcuL2JyZWFrcG9pbnRzLnNlcnZpY2UnKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9icmVha3BvaW50JykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3Zpc2libGVCcmVha3BvaW50LnNlcnZpY2UnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vYnJlYWtwb2ludHMuc2VydmljZScpKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLnNlcnZpY2VzLmJyZWFrcG9pbnRzJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXHJcbiAgICB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JzZXJ2YWJsZS5tb2R1bGVOYW1lLFxyXG4gICAgd2luZG93V3JhcHBlcl9zZXJ2aWNlXzEubW9kdWxlTmFtZSxcclxuXSlcclxuICAgIC5jb25zdGFudCgncmVzaXplRGVib3VuY2VNaWxsaXNlY29uZHMnLCA1MDApXHJcbiAgICAuc2VydmljZSh2aXNpYmxlQnJlYWtwb2ludF9zZXJ2aWNlXzEudmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlTmFtZSwgdmlzaWJsZUJyZWFrcG9pbnRfc2VydmljZV8xLlZpc2libGVCcmVha3BvaW50U2VydmljZSlcclxuICAgIC5zZXJ2aWNlKGJyZWFrcG9pbnRzX3NlcnZpY2VfMS5icmVha3BvaW50U2VydmljZU5hbWUsIGJyZWFrcG9pbnRzX3NlcnZpY2VfMS5CcmVha3BvaW50U2VydmljZSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyZWFrcG9pbnRzLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2JyZWFrcG9pbnRzL2JyZWFrcG9pbnRzLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuc2VydmljZXMud2luZG93V3JhcHBlcic7XHJcbmV4cG9ydHMuc2VydmljZU5hbWUgPSAnd2luZG93V3JhcHBlcic7XHJcbnZhciBXaW5kb3dTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFdpbmRvd1NlcnZpY2UoKSB7XHJcbiAgICAgICAgdGhpcy53aW5kb3dDb250cm9sID0gJCh3aW5kb3cpO1xyXG4gICAgfVxyXG4gICAgV2luZG93U2VydmljZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy53aW5kb3dDb250cm9sLnJlc2l6ZShjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFdpbmRvd1NlcnZpY2U7XHJcbn0pKCk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuc2VydmljZShleHBvcnRzLnNlcnZpY2VOYW1lLCBXaW5kb3dTZXJ2aWNlKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93V3JhcHBlci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvd2luZG93V3JhcHBlci93aW5kb3dXcmFwcGVyLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG4vKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBhbHNvIHJlcXVpcmVzIHRoZSBmb2xsb3dpbmcgZWxlbWVudHMgdG8gYmUgaW5zZXJ0ZWQgb24gdGhlIHBhZ2U6XHJcbiAqICAgPGRpdiBjbGFzcz1cImRldmljZS14cyB2aXNpYmxlLXhzXCI+PC9kaXY+XHJcbiAqICAgPGRpdiBjbGFzcz1cImRldmljZS1zbSB2aXNpYmxlLXNtXCI+PC9kaXY+XHJcbiAqICAgPGRpdiBjbGFzcz1cImRldmljZS1tZCB2aXNpYmxlLW1kXCI+PC9kaXY+XHJcbiAqICAgPGRpdiBjbGFzcz1cImRldmljZS1sZyB2aXNpYmxlLWxnXCI+PC9kaXY+XHJcbiAqIFRoZXkgaGF2ZSBiZWVuIGluc2VydGVkIGludG8gaW5kZXguaHRtbCBmb3IgeW91ciBjb252ZW5pZW5jZS5cclxuICovXHJcbmV4cG9ydHMudmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlTmFtZSA9ICd2aXNpYmxlQnJlYWtwb2ludCc7XHJcbnZhciBWaXNpYmxlQnJlYWtwb2ludFNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlKCkge1xyXG4gICAgfVxyXG4gICAgVmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoYnJlYWtwb2ludCkge1xyXG4gICAgICAgIC8vIGpxdWVyeSBnZXRzIHRoZSBicmVha3BvaW50IHRyaWdnZXIgZGlyZWN0aXZlcyBsaXN0ZWQgYWJvdmUgb24gbGluZSAzXHJcbiAgICAgICAgcmV0dXJuICQoJy5kZXZpY2UtJyArIGJyZWFrcG9pbnQpLmlzKCc6dmlzaWJsZScpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBWaXNpYmxlQnJlYWtwb2ludFNlcnZpY2U7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlID0gVmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXNpYmxlQnJlYWtwb2ludC5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvYnJlYWtwb2ludHMvdmlzaWJsZUJyZWFrcG9pbnQuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciB3aW5kb3dXcmFwcGVyX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL3dpbmRvd1dyYXBwZXIvd2luZG93V3JhcHBlci5zZXJ2aWNlJyk7XHJcbnZhciB2aXNpYmxlQnJlYWtwb2ludF9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuL3Zpc2libGVCcmVha3BvaW50LnNlcnZpY2UnKTtcclxudmFyIGJyZWFrcG9pbnRfMSA9IHJlcXVpcmUoJy4vYnJlYWtwb2ludCcpO1xyXG5leHBvcnRzLmJyZWFrcG9pbnRTZXJ2aWNlTmFtZSA9ICdicmVha3BvaW50cyc7XHJcbnZhciBfX29ic2VydmFibGUgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JzZXJ2YWJsZTtcclxudmFyIEJyZWFrcG9pbnRTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJyZWFrcG9pbnRTZXJ2aWNlKCRyb290U2NvcGUsIHZpc2libGVCcmVha3BvaW50cywgcmVzaXplRGVib3VuY2VNaWxsaXNlY29uZHMsIHdpbmRvd1NlcnZpY2UsIG9ic2VydmFibGVGYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRyb290U2NvcGUgPSAkcm9vdFNjb3BlO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZUJyZWFrcG9pbnRzID0gdmlzaWJsZUJyZWFrcG9pbnRzO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQnJlYWtwb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5ld0JyZWFrUG9pbnQgPSBfdGhpcy5nZXRCcmVha3BvaW50KCk7XHJcbiAgICAgICAgICAgIGlmIChuZXdCcmVha1BvaW50ICE9PSBfdGhpcy5jdXJyZW50QnJlYWtwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuJHJvb3RTY29wZS4kYXBwbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnRCcmVha3BvaW50ID0gbmV3QnJlYWtQb2ludDtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vYnNlcnZhYmxlLmZpcmUoJ3dpbmRvdy5icmVha3BvaW50Q2hhbmdlZCcsIF90aGlzLmN1cnJlbnRCcmVha3BvaW50KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRCcmVha3BvaW50ID0gdGhpcy5nZXRCcmVha3BvaW50KCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZUZhY3RvcnkuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB2YXIgZWZmaWNpZW50UmVzaXplID0gXy5kZWJvdW5jZSh0aGlzLnVwZGF0ZUJyZWFrcG9pbnQsIHJlc2l6ZURlYm91bmNlTWlsbGlzZWNvbmRzLCB7XHJcbiAgICAgICAgICAgIGxlYWRpbmc6IHRydWUsXHJcbiAgICAgICAgICAgIHRyYWlsaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICBtYXhXYWl0OiByZXNpemVEZWJvdW5jZU1pbGxpc2Vjb25kcyxcclxuICAgICAgICB9KTtcclxuICAgICAgICB3aW5kb3dTZXJ2aWNlLnJlc2l6ZShlZmZpY2llbnRSZXNpemUpO1xyXG4gICAgfVxyXG4gICAgQnJlYWtwb2ludFNlcnZpY2UucHJvdG90eXBlLmdldEJyZWFrcG9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZUJyZWFrcG9pbnRzLmlzVmlzaWJsZShicmVha3BvaW50XzEubGcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBicmVha3BvaW50XzEubGc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmlzaWJsZUJyZWFrcG9pbnRzLmlzVmlzaWJsZShicmVha3BvaW50XzEubWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBicmVha3BvaW50XzEubWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmlzaWJsZUJyZWFrcG9pbnRzLmlzVmlzaWJsZShicmVha3BvaW50XzEuc20pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBicmVha3BvaW50XzEuc207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYnJlYWtwb2ludF8xLnhzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCcmVha3BvaW50U2VydmljZS5wcm90b3R5cGUuaXNCcmVha3BvaW50ID0gZnVuY3Rpb24gKGJyZWFrcG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50QnJlYWtwb2ludCA9PT0gYnJlYWtwb2ludDtcclxuICAgIH07XHJcbiAgICBCcmVha3BvaW50U2VydmljZS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2YWJsZS5yZWdpc3RlcihhY3Rpb24sICd3aW5kb3cuYnJlYWtwb2ludENoYW5nZWQnKTtcclxuICAgIH07XHJcbiAgICBCcmVha3BvaW50U2VydmljZS4kaW5qZWN0ID0gWyckcm9vdFNjb3BlJywgdmlzaWJsZUJyZWFrcG9pbnRfc2VydmljZV8xLnZpc2libGVCcmVha3BvaW50U2VydmljZU5hbWUsICdyZXNpemVEZWJvdW5jZU1pbGxpc2Vjb25kcycsIHdpbmRvd1dyYXBwZXJfc2VydmljZV8xLnNlcnZpY2VOYW1lLCBfX29ic2VydmFibGUuZmFjdG9yeU5hbWVdO1xyXG4gICAgcmV0dXJuIEJyZWFrcG9pbnRTZXJ2aWNlO1xyXG59KSgpO1xyXG5leHBvcnRzLkJyZWFrcG9pbnRTZXJ2aWNlID0gQnJlYWtwb2ludFNlcnZpY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyZWFrcG9pbnRzLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy9icmVha3BvaW50cy9icmVha3BvaW50cy5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIGpxdWVyeV9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy9qcXVlcnkvanF1ZXJ5LnNlcnZpY2UnKTtcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsUmVzcG9uc2l2ZUNhcmQnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1Jlc3BvbnNpdmVDYXJkQ29udHJvbGxlcic7XHJcbnZhciBfX3BhcmVudENoaWxkQmVoYXZpb3IgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucGFyZW50Q2hpbGRCZWhhdmlvcjtcclxudmFyIF9fcHJvbWlzZVV0aWxpdHkgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucHJvbWlzZTtcclxudmFyIFJlc3BvbnNpdmVDYXJkQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZXNwb25zaXZlQ2FyZENvbnRyb2xsZXIoJHNjb3BlLCAkcSwgJGVsZW1lbnQsIHBhcmVudENoaWxkQmVoYXZpb3IsIHByb21pc2VVdGlsaXR5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB0aGlzLiRxID0gJHE7XHJcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50O1xyXG4gICAgICAgIHRoaXMucGFyZW50Q2hpbGRCZWhhdmlvciA9IHBhcmVudENoaWxkQmVoYXZpb3I7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlVXRpbGl0eSA9IHByb21pc2VVdGlsaXR5O1xyXG4gICAgICAgIHRoaXMuYXV0b3NhdmVMaW5rID0geyB2aWV3RGF0YTogbnVsbCB9O1xyXG4gICAgICAgIC8vIGJlaGF2aW9yIGZ1bmN0aW9uc1xyXG4gICAgICAgIHRoaXMuYXV0b3NhdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5zaG93RGV0YWlscyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBiZWhhdmlvciA9IF90aGlzLnBhcmVudENoaWxkQmVoYXZpb3IuZ2V0Q2hpbGRCZWhhdmlvcihfdGhpcy5hdXRvc2F2ZUxpbmspO1xyXG4gICAgICAgICAgICByZXR1cm4gYmVoYXZpb3IuYXV0b3NhdmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnNob3dEZXRhaWxzID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9wZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnNob3dEZXRhaWxzID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaG92ZXJJbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuaXNIb3ZlcmluZyA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhvdmVyT3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5pc0hvdmVyaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVuZE9mUm93U3RhdHVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5pc0VuZE9mUm93ID0gX3RoaXMuY2FyZEdyaWRDb250cm9sbGVyLmNhcmRJc0VuZE9mUm93KF90aGlzLmJlaGF2aW9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYmVoYXZpb3IgPSB7XHJcbiAgICAgICAgICAgIGF1dG9zYXZlOiB0aGlzLmF1dG9zYXZlLFxyXG4gICAgICAgICAgICBjbG9zZTogdGhpcy5jbG9zZSxcclxuICAgICAgICAgICAgb3BlbjogdGhpcy5vcGVuLFxyXG4gICAgICAgICAgICBob3ZlckluOiB0aGlzLmhvdmVySW4sXHJcbiAgICAgICAgICAgIGhvdmVyT3V0OiB0aGlzLmhvdmVyT3V0LFxyXG4gICAgICAgICAgICB1cGRhdGVFbmRPZlJvd1N0YXR1czogdGhpcy51cGRhdGVFbmRPZlJvd1N0YXR1cyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc3VtbWFyeSA9IHRoaXMuaGVhZGVyLnN1bW1hcnkgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJyc7IH07XHJcbiAgICAgICAgdGhpcy5zdW1tYXJ5TGVuZ3RoID0gXy5pc1VuZGVmaW5lZCh0aGlzLmhlYWRlci5zdW1tYXJ5TGVuZ3RoKSA/IDI1IDogdGhpcy5oZWFkZXIuc3VtbWFyeUxlbmd0aDtcclxuICAgICAgICB0aGlzLnNob3dJY29uID0gdGhpcy5oZWFkZXIuc2hvd0ljb24gfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XHJcbiAgICAgICAgdGhpcy5jYXJkR3JpZENvbnRyb2xsZXIgPSAkZWxlbWVudC5jb250cm9sbGVyKCdybFJlc3BvbnNpdmVDYXJkR3JpZCcpO1xyXG4gICAgICAgIHRoaXMudW5yZWdpc3RlciA9IHRoaXMuY2FyZEdyaWRDb250cm9sbGVyLnJlZ2lzdGVyQ2FyZCh0aGlzLmJlaGF2aW9yLCAkZWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy5pc0VuZE9mUm93ID0gdGhpcy5jYXJkR3JpZENvbnRyb2xsZXIuY2FyZElzRW5kT2ZSb3codGhpcy5iZWhhdmlvcik7XHJcbiAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnVucmVnaXN0ZXIoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFJlc3BvbnNpdmVDYXJkQ29udHJvbGxlci5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNob3dEZXRhaWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FyZEdyaWRDb250cm9sbGVyLmNsb3NlQ2FyZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jYXJkR3JpZENvbnRyb2xsZXIub3BlbkNhcmQodGhpcy5iZWhhdmlvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlc3BvbnNpdmVDYXJkQ29udHJvbGxlci5wcm90b3R5cGUudHJpZ2dlckhvdmVySW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYXJkR3JpZENvbnRyb2xsZXIuaG92ZXJJbih0aGlzLmJlaGF2aW9yKTtcclxuICAgIH07XHJcbiAgICBSZXNwb25zaXZlQ2FyZENvbnRyb2xsZXIucHJvdG90eXBlLnRyaWdnZXJIb3Zlck91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhcmRHcmlkQ29udHJvbGxlci5ob3Zlck91dCgpO1xyXG4gICAgfTtcclxuICAgIFJlc3BvbnNpdmVDYXJkQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCAnJHEnLCAnJGVsZW1lbnQnLCBfX3BhcmVudENoaWxkQmVoYXZpb3Iuc2VydmljZU5hbWUsIF9fcHJvbWlzZVV0aWxpdHkuc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIFJlc3BvbnNpdmVDYXJkQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5SZXNwb25zaXZlQ2FyZENvbnRyb2xsZXIgPSBSZXNwb25zaXZlQ2FyZENvbnRyb2xsZXI7XHJcbnJlc3BvbnNpdmVDYXJkLiRpbmplY3QgPSBbanF1ZXJ5X3NlcnZpY2VfMS5zZXJ2aWNlTmFtZV07XHJcbmZ1bmN0aW9uIHJlc3BvbnNpdmVDYXJkKGpxdWVyeUhlbHBlcikge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgICAgcmVxdWlyZTogJ15ecmxSZXNwb25zaXZlQ2FyZEdyaWQnLFxyXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInNtYWxsQ2FyZHNMaXN0IGNvbC1sZy00IGNvbC1tZC02IGNvbC1zbS0xMlxcXCI+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwic21hbGwtY2FyZFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwic21hbGwtY2FyZC1oZWFkZXJcXFwiIG5nLWNsYXNzPVxcXCJ7ICdzbWFsbENhcmRIZWFkZXJIb3Zlcic6IGNhcmQuaXNIb3ZlcmluZyB9XFxcIlxcblxcdFxcdFxcdFxcdFxcdFxcdG5nLWNsaWNrPVxcXCJjYXJkLnRvZ2dsZSgpXFxcIiBuZy1tb3VzZW92ZXI9XFxcImNhcmQudHJpZ2dlckhvdmVySW4oKVxcXCIgbmctbW91c2VsZWF2ZT1cXFwiY2FyZC50cmlnZ2VySG92ZXJPdXQoKVxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwic21hbGwtY2FyZC1oZWFkZXItY2FyZC1uYW1lXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8c3BhbiBuZy1iaW5kLWh0bWw9XFxcImNhcmQuaGVhZGVyLm5hbWVcXFwiPjwvc3Bhbj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8c3BhbiBuZy1pZj1cXFwiY2FyZC5zdW1tYXJ5KCkgfCBpc0VtcHR5OmZhbHNlXFxcIj4gLSA8L3NwYW4+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwic21hbGwtY2FyZC1oZWFkZXItc3VtbWFyeS10ZXh0XFxcIiBuZy1iaW5kLWh0bWw9XFxcImNhcmQuc3VtbWFyeSgpfHRydW5jYXRlOmNhcmQuc3VtbWFyeUxlbmd0aDp0cnVlXFxcIj48L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8c3BhbiBjbGFzcz1cXFwic21hbGwtY2FyZC1oZWFkZXItaXRlbS1jb3VudFxcXCIgbmctaWY9XFxcImNhcmQuaGVhZGVyLmNvdW50ICE9IG51bGxcXFwiPjxzcGFuIGNsYXNzPVxcXCJiYWRnZVxcXCI+e3tjYXJkLmhlYWRlci5jb3VudCgpfX08L3NwYW4+PC9zcGFuPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxzcGFuIGNsYXNzPVxcXCJzbWFsbC1jYXJkLWhlYWRlci1pdGVtLWNvdW50XFxcIiBuZy1pZj1cXFwiY2FyZC5oZWFkZXIuc3RhdHVzICE9IG51bGxcXFwiPjxzcGFuIGNsYXNzPVxcXCJiYWRnZVxcXCI+e3tjYXJkLmhlYWRlci5zdGF0dXMoKX19PC9zcGFuPjwvc3Bhbj5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8c3BhbiBjbGFzcz1cXFwic21hbGwtY2FyZC1oZWFkZXItaWNvblxcXCIgbmctaWY9XFxcImNhcmQuc2hvd0ljb24oKVxcXCI+IDxpIGNsYXNzPVxcXCJzbWFsbC1jYXJkLWluZGljYXRvciBmYSBmYS0yeCBmYS17e2NhcmQuaGVhZGVyLmljb259fVxcXCIgdGl0bGU9XFxcInt7Y2FyZC5oZWFkZXIuaWNvblRvb2x0aXB9fVxcXCIgLz48L3NwYW4+XFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0PG5nLWZvcm0gcmwtYXV0b3NhdmU9XFxcImNhcmQuYXV0b3NhdmVMaW5rXFxcIiB2YWxpZGF0ZT1cXFwiY2FyZC52YWxpZGF0ZSgpXFxcIiBzYXZlPVxcXCJjYXJkLnNhdmUoKVxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBuZy1pZj1cXFwiY2FyZC5zaG93RGV0YWlsc1xcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwic21hbGwtY2FyZC1jb250ZW50XFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdDwvbmctZm9ybT5cXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCIgbmctaWY9XFxcImNhcmQuaXNFbmRPZlJvd1xcXCI+PC9kaXY+XFxuXFx0XFx0XCIsXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdjYXJkJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBoZWFkZXI6ICc9JyxcclxuICAgICAgICAgICAgdmFsaWRhdGU6ICcmJyxcclxuICAgICAgICAgICAgc2F2ZTogJyYnLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucmVzcG9uc2l2ZUNhcmQgPSByZXNwb25zaXZlQ2FyZDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzcG9uc2l2ZUNhcmQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3Jlc3BvbnNpdmVDYXJkR3JpZC9yZXNwb25zaXZlQ2FyZC5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxucmVxdWlyZSgnbmctd2lnL2Rpc3QvY3NzL25nLXdpZy5jc3MnKTtcclxucmVxdWlyZSgnbmctd2lnL2Rpc3Qvbmctd2lnJyk7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgcmljaFRleHRFZGl0b3JfY29uZmlnXzEgPSByZXF1aXJlKCcuL3JpY2hUZXh0RWRpdG9yLmNvbmZpZycpO1xyXG52YXIgaGVhZGVyQnV0dG9uXzEgPSByZXF1aXJlKCcuL2hlYWRlckJ1dHRvbicpO1xyXG52YXIgcGFyYWdyYXBoQnV0dG9uXzEgPSByZXF1aXJlKCcuL3BhcmFncmFwaEJ1dHRvbicpO1xyXG52YXIgZXh0ZXJuYWxQcm92aWRlck5hbWUgPSByaWNoVGV4dEVkaXRvcl9jb25maWdfMS5wcm92aWRlck5hbWUgKyAnUHJvdmlkZXInO1xyXG5leHBvcnRzLnByb3ZpZGVyTmFtZSA9IGV4dGVybmFsUHJvdmlkZXJOYW1lO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5yaWNoVGV4dEVkaXRvcic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFJpY2hUZXh0RWRpdG9yJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdSaWNoVGV4dEVkaXRvckNvbnRyb2xsZXInO1xyXG52YXIgUmljaFRleHRFZGl0b3JDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJpY2hUZXh0RWRpdG9yQ29udHJvbGxlcihvYmplY3QsIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy50b29sYmFyID0gJ2gxLCBwYXJhZ3JhcGgsIGJvbGQsIGl0YWxpYywgdW5kZXJsaW5lLCBsaXN0MSwgbGlzdDIsIGluZGVudCwgb3V0ZGVudCc7XHJcbiAgICAgICAgaWYgKCFvYmplY3QuaXNOdWxsT3JFbXB0eSh0aGlzLmN1c3RvbUJ1dHRvbnMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9vbGJhciArPSAnLCAnICsgdGhpcy5jdXN0b21CdXR0b25zO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFJpY2hUZXh0RWRpdG9yQ29udHJvbGxlci4kaW5qZWN0ID0gW19fb2JqZWN0LnNlcnZpY2VOYW1lLCByaWNoVGV4dEVkaXRvcl9jb25maWdfMS5wcm92aWRlck5hbWVdO1xyXG4gICAgcmV0dXJuIFJpY2hUZXh0RWRpdG9yQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5SaWNoVGV4dEVkaXRvckNvbnRyb2xsZXIgPSBSaWNoVGV4dEVkaXRvckNvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHJpY2hUZXh0RWRpdG9yKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3JpY2hUZXh0RWRpdG9yLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2VkaXRvcicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgbmdNb2RlbDogJz0nLFxyXG4gICAgICAgICAgICBjdXN0b21CdXR0b25zOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5yaWNoVGV4dEVkaXRvciA9IHJpY2hUZXh0RWRpdG9yO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFsnbmdXaWcnLCBfX29iamVjdC5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCByaWNoVGV4dEVkaXRvcilcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIFJpY2hUZXh0RWRpdG9yQ29udHJvbGxlcilcclxuICAgIC5kaXJlY3RpdmUoaGVhZGVyQnV0dG9uXzEuaGVhZGVyQnV0dG9uRGlyZWN0aXZlTmFtZSwgaGVhZGVyQnV0dG9uXzEuaGVhZGVyQnV0dG9uKVxyXG4gICAgLmRpcmVjdGl2ZShwYXJhZ3JhcGhCdXR0b25fMS5wYXJhZ3JhcGhCdXR0b25EaXJlY3RpdmVOYW1lLCBwYXJhZ3JhcGhCdXR0b25fMS5wYXJhZ3JhcGhCdXR0b24pXHJcbiAgICAucHJvdmlkZXIocmljaFRleHRFZGl0b3JfY29uZmlnXzEucHJvdmlkZXJOYW1lLCByaWNoVGV4dEVkaXRvcl9jb25maWdfMS5yaWNoVGV4dEVkaXRvclByb3ZpZGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmljaFRleHRFZGl0b3IuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3JpY2hUZXh0RWRpdG9yL3JpY2hUZXh0RWRpdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbmctd2lnLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbmctd2lnLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbmctd2lnLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbmctd2lnL2Rpc3QvY3NzL25nLXdpZy5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAaW1wb3J0IHVybChodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2ZvbnQtYXdlc29tZS80LjQuMC9jc3MvZm9udC1hd2Vzb21lLm1pbi5jc3MpO1wiLCBcIlwiXSk7XG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogLS0tLS0tLS0gTkctV0lHIC0tLS0tLS0tICovXFxuLyoqXFxuICpcXG4gKiAgUkVTRVQgQk9YIE1PREVMXFxuICpcXG4gKi9cXG4ubmctd2lnLFxcbltjbGFzc149XFxcIm53LVxcXCJdIHtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIC1vLWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAtbXMtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcblxcbi8qKlxcbiAqICAgbWFpbiB3cmFwcGVyIGZvciB0aGUgZWRpdG9yXFxuICpcXG4gKiAgLm5nLXdpZ1xcbiAqXFxuICovXFxuLm5nLXdpZyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHBhZGRpbmc6IDA7XFxuICBtYXJnaW46IDA7XFxufVxcblxcblxcbi8qKlxcbiAqICBzdHlsaW5nIGZvciB0b29sYmFyIGFuZCBpdHMgaXRlbXNcXG4gKlxcbiAqICAubnctdG9vbGJhclxcbiAqICAgICZfX2l0ZW1cXG4gKlxcbiAqL1xcbi5udy10b29sYmFyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XFxuICBwYWRkaW5nOiAwICFpbXBvcnRhbnQ7XFxuICBsaXN0LXN0eWxlOiBub25lICFpbXBvcnRhbnQ7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBjb2xvcjogIzZCNzI3NztcXG5cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KDkwZGVnLCAjZmZmZmZmIDAlLCAjZjlmOWY5IDEwMCUpO1xcbiAgYmFja2dyb3VuZDogICAgLW1vei1saW5lYXItZ3JhZGllbnQoOTBkZWcsICNmZmZmZmYgMCUsICNmOWY5ZjkgMTAwJSk7XFxuICBiYWNrZ3JvdW5kOiAgICAgICAgIGxpbmVhci1ncmFkaWVudCgxODBkZWcsICNmZmZmZmYgMCUsICNmOWY5ZjkgMTAwJSk7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjQ0NDQ0NDO1xcbiAgYm9yZGVyLXJhZGl1czogM3B4IDNweCAwIDA7XFxufVxcblxcbi5udy10b29sYmFyX19pdGVtIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuXFxuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjREVERURFO1xcbn1cXG5cXG4ubnctdG9vbGJhciBsYWJlbCB7XFxuICBsaW5lLWhlaWdodDogMzBweDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHBhZGRpbmc6IDAgNnB4IDAgM3B4O1xcbn1cXG5cXG4ubnctdG9vbGJhciBpbnB1dFt0eXBlPWNoZWNrYm94XSB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogLTNweDtcXG4gIG1hcmdpbi1yaWdodDogLTFweDtcXG59XFxuXFxuLyoqXFxuICogIHN0eWxpbmcgZm9yIHRoZSBlZGl0b3IgcGFydDogc291cmNlIGNvZGUgKG9yaWdpbmFsIHRleHRhcmVhKSBhbmQgcmVzdWx0aW5nIGRpdlxcbiAqXFxuICogIC5udy1lZGl0b3JcXG4gKiAgICAmX19zcmNcXG4gKiAgICAmX19yZXNcXG4gKlxcbiAqL1xcbi5udy1lZGl0b3Ige1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgcGFkZGluZzogMCA4cHg7XFxuICAvKiBEZWZhdWx0IHdoZW4gaGVpZ2h0IGlzIG5vdCBzZXQgKi9cXG4gIG1pbi1oZWlnaHQ6IDMwMHB4O1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIGN1cnNvcjogdGV4dDtcXG59XFxuXFxuLm53LWludmlzaWJsZSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4ubnctZWRpdG9yLWNvbnRhaW5lciB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjQ0NDQ0NDO1xcbiAgYm9yZGVyLXRvcDogbm9uZTtcXG4gIGJvcmRlci1yYWRpdXM6IDAgMCAzcHggM3B4O1xcbn1cXG5cXG4ubnctZWRpdG9yX19yZXMge1xcbiAgbWluLWhlaWdodDogMTAwJTtcXG4gIG1hcmdpbjogLTFweCAwO1xcbiAgcGFkZGluZzogMXB4IDA7XFxufVxcblxcbi5udy1lZGl0b3JfX3NyYyxcXG4ubnctZWRpdG9yX19yZXMge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGJvcmRlcjogbm9uZTtcXG59XFxuXFxuLm53LWVkaXRvcl9fc3JjIHtcXG4gIHJlc2l6ZTogbm9uZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogMDtcXG4gIHRvcDogMDtcXG4gIHBhZGRpbmc6IDhweDtcXG59XFxuXFxuXFxuLyoqXFxuICogIHN0eWxpbmcgZm9yIHRvb2xiYXIgYnV0dG9uLCBoYXMgdHdvIG1vZGlmaWVyczogYWN0aXZlIGFuZCB0eXBlIG9mIGljb24gZm9yIGJhY2tncm91bmRcXG4gKlxcbiAqICAubnctYnV0dG9uXFxuICogICAgJi0tYWN0aXZlXFxuICogICAgJi0te2J1dHRvbiB0eXBlfVxcbiAqXFxuICovXFxuLm53LWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAtbW96LWFwcGVhcmFuY2U6ICAgIG5vbmU7XFxuICBhcHBlYXJhbmNlOiAgICAgICAgIG5vbmU7XFxuXFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAzMHB4O1xcbiAgaGVpZ2h0OiAzMHB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIG9wYWNpdHk6IDAuNTtcXG5cXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyIGNlbnRlcjtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBib3JkZXI6IG5vbmU7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5udy1idXR0b246Zm9jdXMge1xcbiAgb3V0bGluZTogbm9uZTtcXG59XFxuXFxuLm53LWJ1dHRvbjpob3ZlcixcXG4ubnctYnV0dG9uLm53LWJ1dHRvbi0tYWN0aXZlIHtcXG4gIG9wYWNpdHk6IDFcXG59XFxuXFxuLm53LWJ1dHRvbi0tYWN0aXZlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNFRUVFRUU7XFxufVxcblxcbi8qKlxcbiAqICBzdHlsaW5nICYgZm9ybWF0dGluZyBvZiBjb250ZW50IGluc2lkZSBjb250ZW50ZWRpdGFibGUgZGl2XFxuICpcXG4gKiAgLm53LWNvbnRlbnRcXG4gKlxcbiAqL1xcbi5udy1jb250ZW50IHtcXG4gIHBhZGRpbmc6IDEycHg7XFxuICBtYXJnaW46IDA7XFxuXFxuICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGxpbmUtaGVpZ2h0OiAyNHB4O1xcbn1cXG5cXG4ubnctc2VsZWN0IHtcXG4gIGhlaWdodDogMzBweDtcXG4gIHBhZGRpbmc6IDZweDtcXG4gIGNvbG9yOiAjNTU1O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG4gIGJvcmRlcjogMDtcXG59XFxuXFxuLm53LXNlbGVjdDpmb2N1cyB7IG91dGxpbmU6IG5vbmU7IH1cXG5cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi9uZy13aWcvZGlzdC9jc3Mvbmctd2lnLmNzc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiB2ZXJzaW9uOiAyLjIuMFxuICovXG5hbmd1bGFyLm1vZHVsZSgnbmdXaWcnLCBbJ25nd2lnLWFwcC10ZW1wbGF0ZXMnXSk7XG5cbmFuZ3VsYXIubW9kdWxlKCduZ1dpZycpXG4gIC5kaXJlY3RpdmUoJ25nV2lnJywgW1wiJHdpbmRvd1wiLCBcIiRkb2N1bWVudFwiLCBcIm5nV2lnVG9vbGJhclwiLCBmdW5jdGlvbiAoJHdpbmRvdywgJGRvY3VtZW50LCBuZ1dpZ1Rvb2xiYXIpIHtcblxuICAgIHJldHVybiB7XG4gICAgICBzY29wZToge1xuICAgICAgICBjb250ZW50OiAnPW5nV2lnJyxcbiAgICAgICAgb25QYXN0ZTogJz0nXG4gICAgICB9LFxuICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICB0ZW1wbGF0ZVVybDogJ25nLXdpZy92aWV3cy9uZy13aWcuaHRtbCcsXG4gICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG5cbiAgICAgICAgc2NvcGUuZWRpdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgc2NvcGUuYXV0b2V4cGFuZCA9ICEoJ2F1dG9leHBhbmQnIGluIGF0dHJzKSB8fCBhdHRyc1snYXV0b2V4cGFuZCddICE9PSAnb2ZmJztcbiAgICAgICAgc2NvcGUudG9vbGJhckJ1dHRvbnMgPSBuZ1dpZ1Rvb2xiYXIuZ2V0VG9vbGJhckJ1dHRvbnMoYXR0cnMuYnV0dG9ucyAmJiBzdHJpbmcyYXJyYXkoYXR0cnMuYnV0dG9ucykpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZzJhcnJheShrZXlzU3RyaW5nKXtcbiAgICAgICAgICByZXR1cm4ga2V5c1N0cmluZy5zcGxpdCgnLCcpLm1hcChGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCwgU3RyaW5nLnByb3RvdHlwZS50cmltKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLnRvZ2dsZUVkaXRNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNjb3BlLmVkaXRNb2RlID0gIXNjb3BlLmVkaXRNb2RlO1xuXG4gICAgICAgICAgaWYgKCR3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKSB7XG4gICAgICAgICAgICAkd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzY29wZS5leGVjQ29tbWFuZCA9IGZ1bmN0aW9uIChjb21tYW5kLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYoc2NvcGUuZWRpdE1vZGUgKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoY29tbWFuZCA9PT0gJ2NyZWF0ZWxpbmsnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gcHJvbXB0KCdQbGVhc2UgZW50ZXIgdGhlIFVSTCcsICdodHRwOi8vJyk7XG4gICAgICAgICAgICBpZighb3B0aW9ucykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjb3BlLiRicm9hZGNhc3QoJ2V4ZWNDb21tYW5kJywge2NvbW1hbmQ6IGNvbW1hbmQsIG9wdGlvbnM6IG9wdGlvbnN9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1dXG4pO1xuXG5cbmFuZ3VsYXIubW9kdWxlKCduZ1dpZycpXG4gIC5kaXJlY3RpdmUoJ25nV2lnRWRpdGFibGUnLCBbXCIkZG9jdW1lbnRcIiwgZnVuY3Rpb24gKCRkb2N1bWVudCkge1xuICAgIGZ1bmN0aW9uIGluaXQoc2NvcGUsICRlbGVtZW50LCBhdHRycywgbmdNb2RlbENvbnRyb2xsZXIpIHtcblxuICAgICAgJGVsZW1lbnQuYXR0cignY29udGVudGVkaXRhYmxlJywgdHJ1ZSk7XG5cbiAgICAgIC8vbW9kZWwgLS0+IHZpZXdcbiAgICAgIG5nTW9kZWxDb250cm9sbGVyLiRyZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICRlbGVtZW50Lmh0bWwobmdNb2RlbENvbnRyb2xsZXIuJHZpZXdWYWx1ZSB8fCAnJyk7XG4gICAgICB9O1xuXG4gICAgICAvL3ZpZXcgLS0+IG1vZGVsXG4gICAgICBmdW5jdGlvbiB2aWV3VG9Nb2RlbCgpIHtcbiAgICAgICAgbmdNb2RlbENvbnRyb2xsZXIuJHNldFZpZXdWYWx1ZSgkZWxlbWVudC5odG1sKCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZlbnRzVG9CaW5kID0gW1xuICAgICAgICAnYmx1cicsXG4gICAgICAgICdrZXl1cCcsXG4gICAgICAgICdjaGFuZ2UnLFxuICAgICAgICAnZm9jdXMnLFxuICAgICAgICAnY2xpY2snXG4gICAgICBdO1xuXG4gICAgICBpZiAoYW5ndWxhci5pc0Z1bmN0aW9uKHNjb3BlLm9uUGFzdGUpKSB7XG4gICAgICAgICRlbGVtZW50Lm9uKCdwYXN0ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBzY29wZS5vblBhc3RlKGUsICRlbGVtZW50Lmh0bWwoKSkudGhlbihmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICRlbGVtZW50Lmh0bWwodmFsKTtcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1lbHNle1xuICAgICAgICBldmVudHNUb0JpbmQucHVzaCgncGFzdGUnKTtcbiAgICAgIH1cblxuICAgICAgJGVsZW1lbnQuYmluZChldmVudHNUb0JpbmQuam9pbignICcpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmlld1RvTW9kZWwoKTtcbiAgICAgICAgc2NvcGUuJGFwcGx5QXN5bmMoKTtcbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS5pc0VkaXRvckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICRlbGVtZW50WzBdID09PSAkZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudDtcbiAgICAgIH07XG5cbiAgICAgIHNjb3BlLiRvbignZXhlY0NvbW1hbmQnLCBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICAkZWxlbWVudFswXS5mb2N1cygpO1xuXG4gICAgICAgIHZhciBpZVN0eWxlVGV4dFNlbGVjdGlvbiA9ICRkb2N1bWVudFswXS5zZWxlY3Rpb24sXG4gICAgICAgICAgY29tbWFuZCA9IHBhcmFtcy5jb21tYW5kLFxuICAgICAgICAgIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcblxuICAgICAgICBpZiAoaWVTdHlsZVRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgdGV4dFJhbmdlID0gaWVTdHlsZVRleHRTZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkZG9jdW1lbnRbMF0ucXVlcnlDb21tYW5kU3VwcG9ydGVkICYmICEkZG9jdW1lbnRbMF0ucXVlcnlDb21tYW5kU3VwcG9ydGVkKGNvbW1hbmQpKSB7XG4gICAgICAgICAgdGhyb3cgJ1RoZSBjb21tYW5kIFwiJyArIGNvbW1hbmQgKyAnXCIgaXMgbm90IHN1cHBvcnRlZCc7XG4gICAgICAgIH1cblxuICAgICAgICAkZG9jdW1lbnRbMF0uZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChpZVN0eWxlVGV4dFNlbGVjdGlvbikge1xuICAgICAgICAgIHRleHRSYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgICAgdGV4dFJhbmdlLnNlbGVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmlld1RvTW9kZWwoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgcmVxdWlyZTogJ25nTW9kZWwnLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIGxpbms6IGluaXRcbiAgICB9XG4gIH1dXG4pO1xuXG5hbmd1bGFyLm1vZHVsZSgnbmdXaWcnKVxuICAgIC5kaXJlY3RpdmUoJ25nV2lnUGx1Z2luJywgW1wiJGNvbXBpbGVcIiwgZnVuY3Rpb24gKCRjb21waWxlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSAnPCcgKyBzY29wZS5idXR0b24ucGx1Z2luTmFtZSArICcgLz4nLFxuICAgICAgICAgICAgICAgICAgICBjb21waWxlZCA9ICRjb21waWxlKHRlbXBsYXRlKShzY29wZSk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlcGxhY2VXaXRoKGNvbXBpbGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuYW5ndWxhci5tb2R1bGUoJ25nV2lnJykucHJvdmlkZXIoJ25nV2lnVG9vbGJhcicsIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgYnV0dG9uTGlicmFyeSA9IHtcbiAgICBsaXN0MToge3RpdGxlOiAnVW5vcmRlcmVkIExpc3QnLCBjb21tYW5kOiAnaW5zZXJ0dW5vcmRlcmVkbGlzdCcsIHN0eWxlQ2xhc3M6ICdmYS1saXN0LXVsJ30sXG4gICAgbGlzdDI6IHt0aXRsZTogJ09yZGVyZWQgTGlzdCcsIGNvbW1hbmQ6ICdpbnNlcnRvcmRlcmVkbGlzdCcsIHN0eWxlQ2xhc3M6ICdmYS1saXN0LW9sJ30sXG4gICAgYm9sZDoge3RpdGxlOiAnQm9sZCcsIGNvbW1hbmQ6ICdib2xkJywgc3R5bGVDbGFzczogJ2ZhLWJvbGQnfSxcbiAgICBpdGFsaWM6IHt0aXRsZTogJ0l0YWxpYycsIGNvbW1hbmQ6ICdpdGFsaWMnLCBzdHlsZUNsYXNzOiAnZmEtaXRhbGljJ30sXG4gICAgbGluazoge3RpdGxlOiAnTGluaycsIGNvbW1hbmQ6ICdjcmVhdGVsaW5rJywgc3R5bGVDbGFzczogJ2ZhLWxpbmsnfVxuICB9O1xuXG4gIHZhciBkZWZhdWx0QnV0dG9uc0xpc3QgPSBbJ2xpc3QxJywgJ2xpc3QyJywgJ2JvbGQnLCAnaXRhbGljJywgJ2xpbmsnXTtcblxuICB2YXIgaXNCdXR0b25BY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZCAmJiBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZSh0aGlzLmNvbW1hbmQpO1xuICB9O1xuXG4gIHRoaXMuc2V0QnV0dG9ucyA9IGZ1bmN0aW9uKGJ1dHRvbnMpIHtcbiAgICBpZighYW5ndWxhci5pc0FycmF5KGJ1dHRvbnMpKSB7XG4gICAgICB0aHJvdyAnQXJndW1lbnQgXCJidXR0b25zXCIgc2hvdWxkIGJlIGFuIGFycmF5JztcbiAgICB9XG5cbiAgICBkZWZhdWx0QnV0dG9uc0xpc3QgPSBidXR0b25zO1xuICB9O1xuXG4gIHRoaXMuYWRkU3RhbmRhcmRCdXR0b24gPSBmdW5jdGlvbiAobmFtZSwgdGl0bGUsIGNvbW1hbmQsIHN0eWxlQ2xhc3MpIHtcbiAgICBpZighbmFtZSB8fCAhdGl0bGUgfHwgIWNvbW1hbmQpIHtcbiAgICAgIHRocm93ICdBcmd1bWVudHMgXCJuYW1lXCIsIFwidGl0bGVcIiBhbmQgXCJjb21tYW5kXCIgYXJlIHJlcXVpcmVkJztcbiAgICB9XG5cbiAgICBzdHlsZUNsYXNzID0gc3R5bGVDbGFzcyB8fCAnJztcbiAgICBidXR0b25MaWJyYXJ5W25hbWVdID0ge3RpdGxlOiB0aXRsZSwgY29tbWFuZDogY29tbWFuZCwgc3R5bGVDbGFzczogc3R5bGVDbGFzc31cbiAgICBkZWZhdWx0QnV0dG9uc0xpc3QucHVzaChuYW1lKTtcbiAgfTtcblxuICB0aGlzLmFkZEN1c3RvbUJ1dHRvbiA9IGZ1bmN0aW9uIChuYW1lLCBwbHVnaW5OYW1lKSB7XG4gICAgaWYoIW5hbWUgfHwgIXBsdWdpbk5hbWUpIHtcbiAgICAgIHRocm93ICdBcmd1bWVudHMgXCJuYW1lXCIgYW5kIFwicGx1Z2luTmFtZVwiIGFyZSByZXF1aXJlZCc7XG4gICAgfVxuXG4gICAgYnV0dG9uTGlicmFyeVtuYW1lXSA9IHtwbHVnaW5OYW1lOiBwbHVnaW5OYW1lLCBpc0NvbXBsZXg6IHRydWV9O1xuICAgIGRlZmF1bHRCdXR0b25zTGlzdC5wdXNoKG5hbWUpO1xuICB9O1xuXG4gIHRoaXMuJGdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0VG9vbGJhckJ1dHRvbnM6IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgdmFyIHRvb2xiYXJCdXR0b25zID0gW107XG4gICAgICAgIChsaXN0IHx8IGRlZmF1bHRCdXR0b25zTGlzdCkuZm9yRWFjaChmdW5jdGlvbihidXR0b25LZXkpIHtcbiAgICAgICAgICBpZighYnV0dG9uTGlicmFyeVtidXR0b25LZXldKSB7XG4gICAgICAgICAgICB0aHJvdyAnVGhlcmUgaXMgbm8gXCInICsgYnV0dG9uS2V5ICsgJ1wiIGluIHlvdXIgbGlicmFyeS4gUG9zc2libGUgdmFyaWFudHM6ICcgKyBPYmplY3Qua2V5cyhidXR0b25MaWJyYXJ5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYnV0dG9uID0gYW5ndWxhci5jb3B5KGJ1dHRvbkxpYnJhcnlbYnV0dG9uS2V5XSk7XG5cbiAgICAgICAgICBpZighYW5ndWxhci5pc0Z1bmN0aW9uKGJ1dHRvbi5pc0FjdGl2ZSkpIHtcbiAgICAgICAgICAgIGJ1dHRvbi5pc0FjdGl2ZSA9IGlzQnV0dG9uQWN0aXZlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvb2xiYXJCdXR0b25zLnB1c2goYnV0dG9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0b29sYmFyQnV0dG9ucztcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG5cbn0pO1xuYW5ndWxhci5tb2R1bGUoJ25nV2lnJylcbiAgICAuY29uZmlnKFsnbmdXaWdUb29sYmFyUHJvdmlkZXInLCBmdW5jdGlvbiAobmdXaWdUb29sYmFyUHJvdmlkZXIpIHtcbiAgICAgICBuZ1dpZ1Rvb2xiYXJQcm92aWRlci5hZGRDdXN0b21CdXR0b24oJ2Zvcm1hdHMnLCAnbnctZm9ybWF0cy1idXR0b24nKTtcbiAgICB9XSlcbiAgICAuZGlyZWN0aXZlKCdud0Zvcm1hdHNCdXR0b24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8c2VsZWN0IGNsYXNzPVwibnctc2VsZWN0XCIgbmctbW9kZWw9XCJmb3JtYXRcIiBuZy1jaGFuZ2U9XCJleGVjQ29tbWFuZChcXCdmb3JtYXRibG9ja1xcJywgZm9ybWF0LnZhbHVlKVwiIG5nLW9wdGlvbnM9XCJmb3JtYXQubmFtZSBmb3IgZm9ybWF0IGluIGZvcm1hdHNcIiBuZy1kaXNhYmxlZD1cImVkaXRNb2RlXCI+PC9zZWxlY3Q+JyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICAgICAgICAgIHNjb3BlLmZvcm1hdHMgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnTm9ybWFsIHRleHQnLCB2YWx1ZTogJ3AnfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdIZWFkZXIgMScsIHZhbHVlOiAnaDEnfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdIZWFkZXIgMicsIHZhbHVlOiAnaDInfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdIZWFkZXIgMycsIHZhbHVlOiAnaDMnfVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBzY29wZS5mb3JtYXQgPSBzY29wZS5mb3JtYXRzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG5cbmFuZ3VsYXIubW9kdWxlKCduZ3dpZy1hcHAtdGVtcGxhdGVzJywgWyduZy13aWcvdmlld3Mvbmctd2lnLmh0bWwnXSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwibmctd2lnL3ZpZXdzL25nLXdpZy5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwibmctd2lnL3ZpZXdzL25nLXdpZy5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJuZy13aWdcXFwiPlxcblwiICtcbiAgICBcIiAgPHVsIGNsYXNzPVxcXCJudy10b29sYmFyXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGxpIGNsYXNzPVxcXCJudy10b29sYmFyX19pdGVtXFxcIiBuZy1yZXBlYXQ9XFxcImJ1dHRvbiBpbiB0b29sYmFyQnV0dG9uc1xcXCIgPlxcblwiICtcbiAgICBcIiAgICAgICAgPGRpdiBuZy1pZj1cXFwiIWJ1dHRvbi5pc0NvbXBsZXhcXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIm53LWJ1dHRvblxcXCIgdGl0bGU9XFxcInt7YnV0dG9uLnRpdGxlfX1cXFwiIG5nLWNsaWNrPVxcXCJleGVjQ29tbWFuZChidXR0b24uY29tbWFuZClcXFwiIG5nLWNsYXNzPVxcXCJ7ICdudy1idXR0b24tLWFjdGl2ZSc6IGlzRWRpdG9yQWN0aXZlKCkgJiYgYnV0dG9uLmlzQWN0aXZlKCkgfVxcXCIgbmctZGlzYWJsZWQ9XFxcImVkaXRNb2RlXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEge3tidXR0b24uc3R5bGVDbGFzc319XFxcIj48L2k+XFxuXCIgK1xuICAgIFwiICAgICAgICAgIDwvYnV0dG9uPlxcblwiICtcbiAgICBcIiAgICAgICAgPC9kaXY+XFxuXCIgK1xuICAgIFwiICAgICAgICA8ZGl2IG5nLWlmPVxcXCJidXR0b24uaXNDb21wbGV4XFxcIj5cXG5cIiArXG4gICAgXCIgICAgICAgICAgPG5nLXdpZy1wbHVnaW4gcGx1Z2luPVxcXCJ7e2J1dHRvbn19XFxcIj48L25nLXdpZy1wbHVnaW4+XFxuXCIgK1xuICAgIFwiICAgICAgICA8L2Rpdj5cXG5cIiArXG4gICAgXCIgICAgPC9saT48IS0tXFxuXCIgK1xuICAgIFwiICAgIC0tPjxsaSBjbGFzcz1cXFwibnctdG9vbGJhcl9faXRlbVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJudy1idXR0b24gbnctYnV0dG9uLS1zb3VyY2VcXFwiIG5nLWNsYXNzPVxcXCJ7ICdudy1idXR0b24tLWFjdGl2ZSc6IGVkaXRNb2RlIH1cXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVFZGl0TW9kZSgpXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtcGVuY2lsXFxcIj48L2k+PC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgIDwvbGk+XFxuXCIgK1xuICAgIFwiICA8L3VsPlxcblwiICtcbiAgICBcIlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwibnctZWRpdG9yLWNvbnRhaW5lclxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxkaXYgY2xhc3M9XFxcIm53LWVkaXRvclxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRleHRhcmVhICBjbGFzcz1cXFwibnctZWRpdG9yX19zcmNcXFwiIG5nLXNob3c9XFxcImVkaXRNb2RlXFxcIiBuZy1tb2RlbD1cXFwiY29udGVudFxcXCI+PC90ZXh0YXJlYT5cXG5cIiArXG4gICAgXCIgICAgICA8ZGl2IHRhYmluZGV4PVxcXCItMVxcXCIgbmctY2xhc3M9XFxcInsnbnctaW52aXNpYmxlJzogZWRpdE1vZGUsICdudy1hdXRvZXhwYW5kJzogYXV0b2V4cGFuZH1cXFwiIGNsYXNzPVxcXCJudy1lZGl0b3JfX3Jlc1xcXCIgbmctbW9kZWw9XFxcImNvbnRlbnRcXFwiIG5nLXdpZy1lZGl0YWJsZSBvbi1wYXN0ZT1cXFwib25QYXN0ZVxcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiICAgIDwvZGl2PlxcblwiICtcbiAgICBcIiAgPC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbmctd2lnL2Rpc3Qvbmctd2lnLmpzXG4gKiogbW9kdWxlIGlkID0gMTAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmV4cG9ydHMucHJvdmlkZXJOYW1lID0gJ3JpY2hUZXh0RWRpdG9yJztcclxucmljaFRleHRFZGl0b3JQcm92aWRlci4kaW5qZWN0ID0gWyduZ1dpZ1Rvb2xiYXJQcm92aWRlciddO1xyXG5mdW5jdGlvbiByaWNoVGV4dEVkaXRvclByb3ZpZGVyKG5nV2lnVG9vbGJhclByb3ZpZGVyKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFkZEN1c3RvbUJ1dHRvbjogZnVuY3Rpb24gKG5hbWUsIGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBuZ1dpZ1Rvb2xiYXJQcm92aWRlci5hZGRDdXN0b21CdXR0b24obmFtZSwgY29tcG9uZW50KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZFN0YW5kYXJkQnV0dG9uOiBmdW5jdGlvbiAobmFtZSwgdG9vbHRpcCwgY29tbWFuZCwgaWNvbikge1xyXG4gICAgICAgICAgICBuZ1dpZ1Rvb2xiYXJQcm92aWRlci5hZGRTdGFuZGFyZEJ1dHRvbihuYW1lLCB0b29sYmFyLCBjb21tYW5kLCAnZmEtJyArIGljb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBuZ1dpZ1Rvb2xiYXJQcm92aWRlci5hZGRDdXN0b21CdXR0b24oJ3BhcmFncmFwaCcsICdybC1wYXJhZ3JhcGgtYnV0dG9uJyk7XHJcbiAgICAgICAgICAgIG5nV2lnVG9vbGJhclByb3ZpZGVyLmFkZEN1c3RvbUJ1dHRvbignaDEnLCAncmwtaGVhZGVyLWJ1dHRvbicpO1xyXG4gICAgICAgICAgICBuZ1dpZ1Rvb2xiYXJQcm92aWRlci5hZGRTdGFuZGFyZEJ1dHRvbigndW5kZXJsaW5lJywgJ1VuZGVybGluZScsICd1bmRlcmxpbmUnLCAnZmEtdW5kZXJsaW5lJyk7XHJcbiAgICAgICAgICAgIG5nV2lnVG9vbGJhclByb3ZpZGVyLmFkZFN0YW5kYXJkQnV0dG9uKCdpbmRlbnQnLCAnSW5kZW50JywgJ2luZGVudCcsICdmYS1pbmRlbnQnKTtcclxuICAgICAgICAgICAgbmdXaWdUb29sYmFyUHJvdmlkZXIuYWRkU3RhbmRhcmRCdXR0b24oJ291dGRlbnQnLCAnT3V0ZGVudCcsICdvdXRkZW50JywgJ2ZhLW91dGRlbnQnKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnJpY2hUZXh0RWRpdG9yUHJvdmlkZXIgPSByaWNoVGV4dEVkaXRvclByb3ZpZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yaWNoVGV4dEVkaXRvci5jb25maWcuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3JpY2hUZXh0RWRpdG9yL3JpY2hUZXh0RWRpdG9yLmNvbmZpZy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbmV4cG9ydHMuaGVhZGVyQnV0dG9uRGlyZWN0aXZlTmFtZSA9ICdybEhlYWRlckJ1dHRvbic7XHJcbmZ1bmN0aW9uIGhlYWRlckJ1dHRvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIm53LWJ1dHRvblxcXCIgbmctY2xpY2s9XFxcInRyaWdnZXIoKVxcXCIgbmctZGlzYWJsZWQ9XFxcImVkaXRNb2RlXFxcIiB0aXRsZT1cXFwiSGVhZGVyIDFcXFwiPlxcblxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1oZWFkZXJcXFwiPjwvaT5cXG5cXHRcXHRcXHQ8L2J1dHRvbj5cXG5cXHRcXHRcIixcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUpIHtcclxuICAgICAgICAgICAgc2NvcGUudHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlLmV4ZWNDb21tYW5kKCdmb3JtYXRibG9jaycsICdoMScpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuaGVhZGVyQnV0dG9uID0gaGVhZGVyQnV0dG9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkZXJCdXR0b24uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3JpY2hUZXh0RWRpdG9yL2hlYWRlckJ1dHRvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbmV4cG9ydHMucGFyYWdyYXBoQnV0dG9uRGlyZWN0aXZlTmFtZSA9ICdybFBhcmFncmFwaEJ1dHRvbic7XHJcbmZ1bmN0aW9uIHBhcmFncmFwaEJ1dHRvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIm53LWJ1dHRvblxcXCIgbmctY2xpY2s9XFxcInRyaWdnZXIoKVxcXCIgbmctZGlzYWJsZWQ9XFxcImVkaXRNb2RlXFxcIiB0aXRsZT1cXFwicGFyYWdyYXBoXFxcIj5cXG5cXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtcGFyYWdyYXBoXFxcIj48L2k+XFxuXFx0XFx0XFx0PC9idXR0b24+XFxuXFx0XFx0XCIsXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLnRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5leGVjQ29tbWFuZCgnZm9ybWF0YmxvY2snLCAncCcpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucGFyYWdyYXBoQnV0dG9uID0gcGFyYWdyYXBoQnV0dG9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhZ3JhcGhCdXR0b24uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3JpY2hUZXh0RWRpdG9yL3BhcmFncmFwaEJ1dHRvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZXh0YXJlYSBjbGFzcz1cXFwicmljaC10ZXh0LWVkaXRvclxcXCIgbmctd2lnPVxcXCJlZGl0b3IubmdNb2RlbFxcXCIgYnV0dG9ucz1cXFwie3tlZGl0b3IudG9vbGJhcn19XFxcIj48L3RleHRhcmVhPlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3JpY2hUZXh0RWRpdG9yL3JpY2hUZXh0RWRpdG9yLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBTaWduYXR1cmVQYWQgPSByZXF1aXJlKCdzaWduYXR1cmVfcGFkJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLnNpZ25hdHVyZVBhZCc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFNpZ25hdHVyZVBhZCc7XHJcbmZ1bmN0aW9uIHNpZ25hdHVyZVBhZCgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICByZXF1aXJlOiAnbmdNb2RlbCcsXHJcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuXFx0XFx0XFx0PGNhbnZhcyBjbGFzcz1cXFwic2lnbmF0dXJlLXBhZFxcXCIgbmctaWY9XFxcIiFuZ0Rpc2FibGVkXFxcIj48L2NhbnZhcz5cXG5cXHRcXHRcXHQ8aW1nIG5nLXNyYz1cXFwie3tuZ01vZGVsLiR2aWV3VmFsdWV9fVxcXCIgbmctc3R5bGU9XFxcInN0eWxlXFxcIiBuZy1pZj1cXFwibmdEaXNhYmxlZFxcXCIgLz5cXG5cXHRcXHRcIixcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICBwYWQ6ICc9JyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnPScsXHJcbiAgICAgICAgICAgIHdpZHRoOiAnPScsXHJcbiAgICAgICAgICAgIG5nRGlzYWJsZWQ6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcclxuICAgICAgICAgICAgc2NvcGUuJHdhdGNoKCduZ0Rpc2FibGVkJywgZnVuY3Rpb24gKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5uZ01vZGVsID0gbmdNb2RlbDtcclxuICAgICAgICAgICAgICAgIGlmIChkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnN0eWxlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHNjb3BlLmhlaWdodCAhPSBudWxsID8gc2NvcGUuaGVpZ2h0IDogMTAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2NvcGUud2lkdGggIT0gbnVsbCA/IHNjb3BlLndpZHRoIDogMjAwLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZWxlbWVudC5maW5kKCcuc2lnbmF0dXJlLXBhZCcpLmdldCgwKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiKDI1NSwgMjU1LCAyNTUpJyxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnBhZCA9IG5ldyBTaWduYXR1cmVQYWQoY2FudmFzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gc2NvcGUuaGVpZ2h0ICE9IG51bGwgPyBzY29wZS5oZWlnaHQgOiAxMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gc2NvcGUud2lkdGggIT0gbnVsbCA/IHNjb3BlLndpZHRoIDogMjAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBuZ01vZGVsLiR2aWV3VmFsdWU7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucGFkLmZyb21EYXRhVVJMKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZS5wYWQudG9EYXRhVVJMKCk7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnNpZ25hdHVyZVBhZCA9IHNpZ25hdHVyZVBhZDtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBzaWduYXR1cmVQYWQpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmVQYWQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3NpZ25hdHVyZVBhZC9zaWduYXR1cmVQYWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29ic2VydmFibGUgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JzZXJ2YWJsZTtcclxudmFyIF9fcGFyZW50Q2hpbGQgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucGFyZW50Q2hpbGRCZWhhdmlvcjtcclxudmFyIGNhcmQgPSByZXF1aXJlKCcuL3NpbXBsZUNhcmQnKTtcclxuZXhwb3J0cy5zaW1wbGVDYXJkID0gY2FyZDtcclxudmFyIGxpc3QgPSByZXF1aXJlKCcuL3NpbXBsZUNhcmRMaXN0Jyk7XHJcbmV4cG9ydHMuc2ltcGxlQ2FyZExpc3QgPSBsaXN0O1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5zaW1wbGVDYXJkTGlzdCc7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JzZXJ2YWJsZS5tb2R1bGVOYW1lLCBfX3BhcmVudENoaWxkLm1vZHVsZU5hbWVdKVxyXG4gICAgLmRpcmVjdGl2ZShsaXN0LmRpcmVjdGl2ZU5hbWUsIGxpc3Quc2ltcGxlQ2FyZExpc3QpXHJcbiAgICAuY29udHJvbGxlcihsaXN0LmNvbnRyb2xsZXJOYW1lLCBsaXN0LlNpbXBsZUNhcmRMaXN0Q29udHJvbGxlcilcclxuICAgIC5kaXJlY3RpdmUoY2FyZC5kaXJlY3RpdmVOYW1lLCBjYXJkLnNpbXBsZUNhcmQpXHJcbiAgICAuY29udHJvbGxlcihjYXJkLmNvbnRyb2xsZXJOYW1lLCBjYXJkLlNpbXBsZUNhcmRDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2ltcGxlQ2FyZExpc3QubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9zaW1wbGVDYXJkTGlzdC9zaW1wbGVDYXJkTGlzdC5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3BhcmVudENoaWxkID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnBhcmVudENoaWxkQmVoYXZpb3I7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFNpbXBsZUNhcmQnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1NpbXBsZUNhcmRDb250cm9sbGVyJztcclxudmFyIFNpbXBsZUNhcmRDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNpbXBsZUNhcmRDb250cm9sbGVyKCRzY29wZSwgJGVsZW1lbnQsIHBhcmVudENoaWxkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB0aGlzLnBhcmVudENoaWxkID0gcGFyZW50Q2hpbGQ7XHJcbiAgICAgICAgdGhpcy5zaG93Q29udGVudCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYXV0b3NhdmVMaW5rID0ge307XHJcbiAgICAgICAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLnNob3dDb250ZW50ID09PSBmYWxzZSB8fCBfdGhpcy5hbHdheXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXV0b3NhdmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLmNhbk9wZW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbk9wZW4gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpc3RDb250cm9sbGVyID0gJGVsZW1lbnQuY29udHJvbGxlcigncmxTaW1wbGVDYXJkTGlzdCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3RDb250cm9sbGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0Q29udHJvbGxlciA9IHRoaXMubm9MaXN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiZWhhdmlvciA9IHtcclxuICAgICAgICAgICAgYXV0b3NhdmU6IHRoaXMuYXV0b3NhdmUuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgY2xvc2U6IHRoaXMuY2xvc2UsXHJcbiAgICAgICAgICAgIHNldEFsd2F5c09wZW46IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYWx3YXlzT3BlbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5saXN0Q29udHJvbGxlci5yZWdpc3RlckNhcmQoYmVoYXZpb3IpO1xyXG4gICAgICAgIHBhcmVudENoaWxkLnJlZ2lzdGVyQ2hpbGRCZWhhdmlvcih0aGlzLmNoaWxkTGluaywgYmVoYXZpb3IpO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYWx3YXlzT3BlbjsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2hvd0NvbnRlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgU2ltcGxlQ2FyZENvbnRyb2xsZXIucHJvdG90eXBlLnRvZ2dsZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd0NvbnRlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNpbXBsZUNhcmRDb250cm9sbGVyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhbk9wZW4gJiYgdGhpcy5saXN0Q29udHJvbGxlci5vcGVuQ2FyZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0NvbnRlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLm9uT3BlbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTaW1wbGVDYXJkQ29udHJvbGxlci5wcm90b3R5cGUuYXV0b3NhdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRDaGlsZC50cmlnZ2VyQ2hpbGRCZWhhdmlvcih0aGlzLmF1dG9zYXZlTGluaywgZnVuY3Rpb24gKGJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgIHZhciBjYW5DbG9zZSA9IGJlaGF2aW9yLmF1dG9zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmIChjYW5DbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2hvd0NvbnRlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2FuQ2xvc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU2ltcGxlQ2FyZENvbnRyb2xsZXIucHJvdG90eXBlLm5vTGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvcGVuQ2FyZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyQ2FyZDogZnVuY3Rpb24gKGJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFNpbXBsZUNhcmRDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckZWxlbWVudCcsIF9fcGFyZW50Q2hpbGQuc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIFNpbXBsZUNhcmRDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlNpbXBsZUNhcmRDb250cm9sbGVyID0gU2ltcGxlQ2FyZENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHNpbXBsZUNhcmQoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICByZXF1aXJlOiAnP15ecmxTaW1wbGVDYXJkTGlzdCcsXHJcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2FyZCBjb2wteHMtMTJcXFwiPlxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImhlYWRlciByb3dcXFwiIG5nLWNsYXNzPVxcXCJ7ICdhY3RpdmUnOiBjYXJkLmNhbk9wZW4gJiYgIWNhcmQuYWx3YXlzT3BlbiB9XFxcIiBuZy1jbGljaz1cXFwiY2FyZC50b2dnbGVDb250ZW50KClcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImhlYWRlci10ZW1wbGF0ZVxcXCI+PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcblxcdFxcdFxcdFxcdDxuZy1mb3JtIHJsLWF1dG9zYXZlPVxcXCJjYXJkLmF1dG9zYXZlTGlua1xcXCIgdmFsaWRhdGU9XFxcImNhcmQudmFsaWRhdGUoKVxcXCIgc2F2ZT1cXFwiY2FyZC5zYXZlKClcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxkaXYgbmctc2hvdz1cXFwiY2FyZC5zaG93Q29udGVudCB8fCBjYXJkLmFsd2F5c09wZW5cXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImJvZHkgcm93XFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb250ZW50LXRlbXBsYXRlXFxcIj48L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0PC9uZy1mb3JtPlxcblxcdFxcdFxcdFxcdDxkaXYgbmctc2hvdz1cXFwiaGFzRm9vdGVyICYmIGNhcmQuc2hvd0NvbnRlbnRcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImZvb3RlciByb3dcXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImZvb3Rlci10ZW1wbGF0ZVxcXCI+PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFwiLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnY2FyZCcsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgb25PcGVuOiAnJicsXHJcbiAgICAgICAgICAgIGNhbk9wZW46ICc9JyxcclxuICAgICAgICAgICAgYWx3YXlzT3BlbjogJz0nLFxyXG4gICAgICAgICAgICBjaGlsZExpbms6ICc9JyxcclxuICAgICAgICAgICAgdmFsaWRhdGU6ICcmJyxcclxuICAgICAgICAgICAgc2F2ZTogJyYnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaGVhZGVyO1xyXG4gICAgICAgICAgICB2YXIgY29udGVudDtcclxuICAgICAgICAgICAgdmFyIGZvb3RlcjtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHByZTogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlciwgdHJhbnNjbHVkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY2x1ZGUoZnVuY3Rpb24gKGNsb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IGNsb25lLmZpbHRlcigncmwtY2FyZC1oZWFkZXInKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNsb25lLmZpbHRlcigncmwtY2FyZC1jb250ZW50Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvb3RlciA9IGNsb25lLmZpbHRlcigncmwtY2FyZC1mb290ZXInKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwb3N0OiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyQXJlYSA9IGVsZW1lbnQuZmluZCgnLmhlYWRlci10ZW1wbGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlckFyZWEuYXBwZW5kKGhlYWRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRBcmVhID0gZWxlbWVudC5maW5kKCcuY29udGVudC10ZW1wbGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRBcmVhLmFwcGVuZChjb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZS5oYXNGb290ZXIgPSAoZm9vdGVyLmxlbmd0aCA+IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5oYXNGb290ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvb3RlckFyZWEgPSBlbGVtZW50LmZpbmQoJy5mb290ZXItdGVtcGxhdGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyQXJlYS5hcHBlbmQoZm9vdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuc2ltcGxlQ2FyZCA9IHNpbXBsZUNhcmQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsZUNhcmQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3NpbXBsZUNhcmRMaXN0L3NpbXBsZUNhcmQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JzZXJ2YWJsZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYnNlcnZhYmxlO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxTaW1wbGVDYXJkTGlzdCc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnU2ltcGxlQ2FyZExpc3RDb250cm9sbGVyJztcclxudmFyIFNpbXBsZUNhcmRMaXN0Q29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTaW1wbGVDYXJkTGlzdENvbnRyb2xsZXIoJHNjb3BlLCAkYXR0cnMsICRwYXJzZSwgb2JzZXJ2YWJsZUZhY3RvcnkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGVGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiAkcGFyc2UoJGF0dHJzLmFsd2F5c09wZW4pKCRzY29wZSk7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5hbHdheXNPcGVuID0gdmFsdWU7XHJcbiAgICAgICAgICAgIF90aGlzLm9ic2VydmFibGUuZmlyZSgnYWx3YXlzT3BlbicsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFNpbXBsZUNhcmRMaXN0Q29udHJvbGxlci5wcm90b3R5cGUucmVnaXN0ZXJDYXJkID0gZnVuY3Rpb24gKGJlaGF2aW9yKSB7XHJcbiAgICAgICAgYmVoYXZpb3Iuc2V0QWx3YXlzT3Blbih0aGlzLmFsd2F5c09wZW4pO1xyXG4gICAgICAgIHZhciB1bnJlZ2lzdGVyRnVuY3Rpb25zID0gW107XHJcbiAgICAgICAgdW5yZWdpc3RlckZ1bmN0aW9ucy5wdXNoKHRoaXMub2JzZXJ2YWJsZS5yZWdpc3RlcihiZWhhdmlvci5jbG9zZSwgJ2Nsb3NlJykpO1xyXG4gICAgICAgIHVucmVnaXN0ZXJGdW5jdGlvbnMucHVzaCh0aGlzLm9ic2VydmFibGUucmVnaXN0ZXIoYmVoYXZpb3Iuc2V0QWx3YXlzT3BlbiwgJ2Fsd2F5c09wZW4nKSk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgXy5lYWNoKHVucmVnaXN0ZXJGdW5jdGlvbnMsIGZ1bmN0aW9uICh1bnJlZ2lzdGVyKSB7XHJcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgU2ltcGxlQ2FyZExpc3RDb250cm9sbGVyLnByb3RvdHlwZS5vcGVuQ2FyZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXy5hbGwodGhpcy5vYnNlcnZhYmxlLmZpcmUoJ2Nsb3NlJykpO1xyXG4gICAgfTtcclxuICAgIFNpbXBsZUNhcmRMaXN0Q29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCAnJGF0dHJzJywgJyRwYXJzZScsIF9fb2JzZXJ2YWJsZS5mYWN0b3J5TmFtZV07XHJcbiAgICByZXR1cm4gU2ltcGxlQ2FyZExpc3RDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlNpbXBsZUNhcmRMaXN0Q29udHJvbGxlciA9IFNpbXBsZUNhcmRMaXN0Q29udHJvbGxlcjtcclxuZnVuY3Rpb24gc2ltcGxlQ2FyZExpc3QoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnQUUnLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuc2ltcGxlQ2FyZExpc3QgPSBzaW1wbGVDYXJkTGlzdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2ltcGxlQ2FyZExpc3QuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3NpbXBsZUNhcmRMaXN0L3NpbXBsZUNhcmRMaXN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2Jvb3RzdHJhcC10b3VjaHNwaW4vYm9vdHN0cmFwLXRvdWNoc3Bpbi5kLnRzJyAvPlxyXG4vLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2pxdWVyeS9qcXVlcnkuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG5yZXF1aXJlKCcuLi8uLi8uLi9saWJyYXJpZXMvYm9vdHN0cmFwLXRvdWNoc3Bpbi9pbmRleCcpO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fc3RyaW5nID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnN0cmluZztcclxudmFyIF9fbnVtYmVyID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm51bWJlcjtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuc3Bpbm5lcic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFNwaW5uZXInO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1NwaW5uZXJDb250cm9sbGVyJztcclxuc3Bpbm5lci4kaW5qZWN0ID0gWyckdGltZW91dCcsIF9fc3RyaW5nLnNlcnZpY2VOYW1lLCBfX251bWJlci5zZXJ2aWNlTmFtZV07XHJcbmZ1bmN0aW9uIHNwaW5uZXIoJHRpbWVvdXQsIHN0cmluZ1V0aWxpdHksIG51bWJlclV0aWxpdHkpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8cmwtZ2VuZXJpYy1jb250YWluZXIgc2VsZWN0b3I9XFxcIm5nRGlzYWJsZWRcXFwiPlxcblxcdFxcdFxcdFxcdDx0ZW1wbGF0ZSBkZWZhdWx0PlxcblxcdFxcdFxcdFxcdFxcdDxpbnB1dCBuYW1lPVxcXCJ7e25hbWV9fVxcXCIgY2xhc3M9XFxcInNwaW5uZXJcXFwiIGlkPVxcXCJ7e3NwaW5uZXJJZH19XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiAvPlxcblxcdFxcdFxcdFxcdDwvdGVtcGxhdGU+XFxuXFx0XFx0XFx0XFx0PHRlbXBsYXRlIHdoZW4tc2VsZWN0b3I9XFxcInRydWVcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIiBuZy1zaG93PVxcXCJwcmVmaXggIT0gbnVsbCAmJiBwb3N0Zml4ICE9IG51bGxcXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1hZGRvblxcXCI+e3twcmVmaXh9fTwvc3Bhbj5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8aW5wdXQgbmctZGlzYWJsZWQ9XFxcIm5nRGlzYWJsZWRcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCJuZ01vZGVsXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiAvPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1hZGRvblxcXCI+e3twb3N0Zml4fX08L3NwYW4+XFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXBcXFwiIG5nLXNob3c9XFxcInByZWZpeCAhPSBudWxsICYmIHBvc3RmaXggPT0gbnVsbFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWFkZG9uXFxcIj57e3ByZWZpeH19PC9zcGFuPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxpbnB1dCBuZy1kaXNhYmxlZD1cXFwibmdEaXNhYmxlZFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmctbW9kZWw9XFxcIm5nTW9kZWxcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIC8+XFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXBcXFwiIG5nLXNob3c9XFxcInByZWZpeCA9PSBudWxsICYmIHBvc3RmaXggIT0gbnVsbFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGlucHV0IG5nLWRpc2FibGVkPVxcXCJuZ0Rpc2FibGVkXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwibmdNb2RlbFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgLz5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYWRkb25cXFwiPnt7cG9zdGZpeH19PC9zcGFuPlxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdDxkaXYgbmctc2hvdz1cXFwicHJlZml4ID09IG51bGwgJiYgcG9zdGZpeCA9PSBudWxsXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8aW5wdXQgbmctZGlzYWJsZWQ9XFxcIm5nRGlzYWJsZWRcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCJuZ01vZGVsXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiAvPlxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdDwvdGVtcGxhdGU+XFxuXFx0XFx0XFx0PC9ybC1nZW5lcmljLWNvbnRhaW5lcj5cXG5cXHRcXHRcIixcclxuICAgICAgICByZXF1aXJlOiAnP15uZ01vZGVsJyxcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICBtaW46ICc9JyxcclxuICAgICAgICAgICAgbWF4OiAnPScsXHJcbiAgICAgICAgICAgIHN0ZXA6ICc9JyxcclxuICAgICAgICAgICAgZGVjaW1hbHM6ICc9JyxcclxuICAgICAgICAgICAgcHJlZml4OiAnQCcsXHJcbiAgICAgICAgICAgIHBvc3RmaXg6ICdAJyxcclxuICAgICAgICAgICAgcm91bmRUb1N0ZXA6ICc9JyxcclxuICAgICAgICAgICAgbmdEaXNhYmxlZDogJz0nLFxyXG4gICAgICAgICAgICBuZ01vZGVsOiAnPScsXHJcbiAgICAgICAgICAgIHNwaW5uZXJJZDogJ0AnLFxyXG4gICAgICAgICAgICBuYW1lOiAnQCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciB1bmJpbmRXYXRjaGVzO1xyXG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goJ25nRGlzYWJsZWQnLCBmdW5jdGlvbiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24odW5iaW5kV2F0Y2hlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5iaW5kV2F0Y2hlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHNwaW5uZXIgYWZ0ZXIgJHRpbWVvdXQgdG8gZ2l2ZSBhbmd1bGFyIGEgY2hhbmNlIGluaXRpYWxpemUgbmdNb2RlbFxyXG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdWNoc3BpbiA9IGVsZW1lbnQuZmluZCgnaW5wdXQuc3Bpbm5lcicpLlRvdWNoU3Bpbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW46IChzY29wZS5taW4gIT0gbnVsbCA/IHNjb3BlLm1pbiA6IE51bWJlci5NSU5fVkFMVUUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiAoc2NvcGUubWF4ICE9IG51bGwgPyBzY29wZS5tYXggOiBOdW1iZXIuTUFYX1ZBTFVFKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IHNjb3BlLnN0ZXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHNjb3BlLnByZWZpeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RmaXg6IHNjb3BlLnBvc3RmaXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogc2NvcGUuZGVjaW1hbHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0dmFsOiBuZ01vZGVsLiR2aWV3VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZXN0ZXBkaXZpc2liaWxpdHk6IHNjb3BlLnJvdW5kVG9TdGVwID8gJ3JvdW5kJyA6ICdub25lJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoc3Bpbi5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BpblZhbHVlID0gdG91Y2hzcGluLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZShzdHJpbmdVdGlsaXR5LnRvTnVtYmVyKHNwaW5WYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5iaW5kVmlld1dhdGNoID0gc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZ01vZGVsLiR2aWV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hzcGluLnZhbChuZXdWYWx1ZSAhPSBudWxsID8gbmV3VmFsdWUudG9TdHJpbmcoKSA6ICcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmJpbmRNb2RlbFdhdGNoID0gc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZ01vZGVsLiRtb2RlbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAobmV3TW9kZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLm5nTW9kZWwgPSByb3VuZChuZXdNb2RlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmJpbmRXYXRjaGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5iaW5kVmlld1dhdGNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmJpbmRNb2RlbFdhdGNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiByb3VuZChudW0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChudW0gIT0gbnVsbCAmJiBzY29wZS5yb3VuZFRvU3RlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IG51bWJlclV0aWxpdHkucm91bmRUb1N0ZXAobnVtLCBzY29wZS5zdGVwKTtcclxuICAgICAgICAgICAgICAgICAgICBudW0gPSBudW1iZXJVdGlsaXR5LnByZWNpc2VSb3VuZChudW0sIHNjb3BlLmRlY2ltYWxzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fc3RyaW5nLm1vZHVsZU5hbWVdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIHNwaW5uZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGlubmVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9zcGlubmVyL3NwaW5uZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG5cclxucmVxdWlyZSgnLi9qcXVlcnkuYm9vdHN0cmFwLXRvdWNoc3Bpbi5jc3MnKTtcclxucmVxdWlyZSgnLi9qcXVlcnkuYm9vdHN0cmFwLXRvdWNoc3BpbicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWJyYXJpZXMvYm9vdHN0cmFwLXRvdWNoc3Bpbi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9qcXVlcnkuYm9vdHN0cmFwLXRvdWNoc3Bpbi5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vanF1ZXJ5LmJvb3RzdHJhcC10b3VjaHNwaW4uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vanF1ZXJ5LmJvb3RzdHJhcC10b3VjaHNwaW4uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGlicmFyaWVzL2Jvb3RzdHJhcC10b3VjaHNwaW4vanF1ZXJ5LmJvb3RzdHJhcC10b3VjaHNwaW4uY3NzXG4gKiogbW9kdWxlIGlkID0gMTE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qXFxyXFxuICogIEJvb3RzdHJhcCBUb3VjaFNwaW4gLSB2My4wLjFcXHJcXG4gKiAgQSBtb2JpbGUgYW5kIHRvdWNoIGZyaWVuZGx5IGlucHV0IHNwaW5uZXIgY29tcG9uZW50IGZvciBCb290c3RyYXAgMy5cXHJcXG4gKiAgaHR0cDovL3d3dy52aXJ0dW9zb2Z0LmV1L2NvZGUvYm9vdHN0cmFwLXRvdWNoc3Bpbi9cXHJcXG4gKlxcclxcbiAqICBNYWRlIGJ5IElzdHbDoW4gVWpqLU3DqXN6w6Fyb3NcXHJcXG4gKiAgVW5kZXIgQXBhY2hlIExpY2Vuc2UgdjIuMCBMaWNlbnNlXFxyXFxuICovXFxyXFxuXFxyXFxuLmJvb3RzdHJhcC10b3VjaHNwaW4gLmlucHV0LWdyb3VwLWJ0bi12ZXJ0aWNhbCB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcclxcbiAgd2lkdGg6IDElO1xcclxcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXHJcXG4gIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxyXFxufVxcclxcblxcclxcbi5ib290c3RyYXAtdG91Y2hzcGluIC5pbnB1dC1ncm91cC1idG4tdmVydGljYWwgPiAuYnRuIHtcXHJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgZmxvYXQ6IG5vbmU7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIG1heC13aWR0aDogMTAwJTtcXHJcXG4gIHBhZGRpbmc6IDhweCAxMHB4O1xcclxcbiAgbWFyZ2luLWxlZnQ6IC0xcHg7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxufVxcclxcblxcclxcbi5ib290c3RyYXAtdG91Y2hzcGluIC5pbnB1dC1ncm91cC1idG4tdmVydGljYWwgLmJvb3RzdHJhcC10b3VjaHNwaW4tdXAge1xcclxcbiAgYm9yZGVyLXJhZGl1czogMDtcXHJcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxyXFxufVxcclxcblxcclxcbi5ib290c3RyYXAtdG91Y2hzcGluIC5pbnB1dC1ncm91cC1idG4tdmVydGljYWwgLmJvb3RzdHJhcC10b3VjaHNwaW4tZG93biB7XFxyXFxuICBtYXJnaW4tdG9wOiAtMnB4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogMDtcXHJcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA0cHg7XFxyXFxufVxcclxcblxcclxcbi5ib290c3RyYXAtdG91Y2hzcGluIC5pbnB1dC1ncm91cC1idG4tdmVydGljYWwgaSB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICB0b3A6IDNweDtcXHJcXG4gIGxlZnQ6IDVweDtcXHJcXG4gIGZvbnQtc2l6ZTogOXB4O1xcclxcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXHJcXG59XFxyXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL2xpYnJhcmllcy9ib290c3RyYXAtdG91Y2hzcGluL2pxdWVyeS5ib290c3RyYXAtdG91Y2hzcGluLmNzc1xuICoqIG1vZHVsZSBpZCA9IDExNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuICogIEJvb3RzdHJhcCBUb3VjaFNwaW4gLSB2My4wLjFcclxuICogIEEgbW9iaWxlIGFuZCB0b3VjaCBmcmllbmRseSBpbnB1dCBzcGlubmVyIGNvbXBvbmVudCBmb3IgQm9vdHN0cmFwIDMuXHJcbiAqICBodHRwOi8vd3d3LnZpcnR1b3NvZnQuZXUvY29kZS9ib290c3RyYXAtdG91Y2hzcGluL1xyXG4gKlxyXG4gKiAgTWFkZSBieSBJc3R2w6FuIFVqai1Nw6lzesOhcm9zXHJcbiAqICBVbmRlciBBcGFjaGUgTGljZW5zZSB2Mi4wIExpY2Vuc2VcclxuICovXHJcbihmdW5jdGlvbigkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgX2N1cnJlbnRTcGlubmVySWQgPSAwO1xyXG5cclxuICBmdW5jdGlvbiBfc2NvcGVkRXZlbnROYW1lKG5hbWUsIGlkKSB7XHJcbiAgICByZXR1cm4gbmFtZSArICcudG91Y2hzcGluXycgKyBpZDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9zY29wZUV2ZW50TmFtZXMobmFtZXMsIGlkKSB7XHJcbiAgICByZXR1cm4gJC5tYXAobmFtZXMsIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgcmV0dXJuIF9zY29wZWRFdmVudE5hbWUobmFtZSwgaWQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAkLmZuLlRvdWNoU3BpbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHJcbiAgICBpZiAob3B0aW9ucyA9PT0gJ2Rlc3Ryb3knKSB7XHJcbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgb3JpZ2luYWxpbnB1dCA9ICQodGhpcyksXHJcbiAgICAgICAgICAgIG9yaWdpbmFsaW5wdXRfZGF0YSA9IG9yaWdpbmFsaW5wdXQuZGF0YSgpO1xyXG4gICAgICAgICQoZG9jdW1lbnQpLm9mZihfc2NvcGVFdmVudE5hbWVzKFtcclxuICAgICAgICAgICdtb3VzZXVwJyxcclxuICAgICAgICAgICd0b3VjaGVuZCcsXHJcbiAgICAgICAgICAndG91Y2hjYW5jZWwnLFxyXG4gICAgICAgICAgJ21vdXNlbW92ZScsXHJcbiAgICAgICAgICAndG91Y2htb3ZlJyxcclxuICAgICAgICAgICdzY3JvbGwnLFxyXG4gICAgICAgICAgJ3Njcm9sbHN0YXJ0J10sIG9yaWdpbmFsaW5wdXRfZGF0YS5zcGlubmVyaWQpLmpvaW4oJyAnKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRlZmF1bHRzID0ge1xyXG4gICAgICBtaW46IDAsXHJcbiAgICAgIG1heDogMTAwLFxyXG4gICAgICBpbml0dmFsOiAnJyxcclxuICAgICAgc3RlcDogMSxcclxuICAgICAgZGVjaW1hbHM6IDAsXHJcbiAgICAgIHN0ZXBpbnRlcnZhbDogMTAwLFxyXG4gICAgICBmb3JjZXN0ZXBkaXZpc2liaWxpdHk6ICdyb3VuZCcsIC8vIG5vbmUgfCBmbG9vciB8IHJvdW5kIHwgY2VpbFxyXG4gICAgICBzdGVwaW50ZXJ2YWxkZWxheTogNTAwLFxyXG4gICAgICB2ZXJ0aWNhbGJ1dHRvbnM6IGZhbHNlLFxyXG4gICAgICB2ZXJ0aWNhbHVwY2xhc3M6ICdnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tdXAnLFxyXG4gICAgICB2ZXJ0aWNhbGRvd25jbGFzczogJ2dseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1kb3duJyxcclxuICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgcG9zdGZpeDogJycsXHJcbiAgICAgIHByZWZpeF9leHRyYWNsYXNzOiAnJyxcclxuICAgICAgcG9zdGZpeF9leHRyYWNsYXNzOiAnJyxcclxuICAgICAgYm9vc3RlcjogdHJ1ZSxcclxuICAgICAgYm9vc3RhdDogMTAsXHJcbiAgICAgIG1heGJvb3N0ZWRzdGVwOiBmYWxzZSxcclxuICAgICAgbW91c2V3aGVlbDogdHJ1ZSxcclxuICAgICAgYnV0dG9uZG93bl9jbGFzczogJ2J0biBidG4tZGVmYXVsdCcsXHJcbiAgICAgIGJ1dHRvbnVwX2NsYXNzOiAnYnRuIGJ0bi1kZWZhdWx0JyxcclxuXHQgIGJ1dHRvbmRvd25fdHh0OiAnLScsXHJcblx0ICBidXR0b251cF90eHQ6ICcrJ1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgYXR0cmlidXRlTWFwID0ge1xyXG4gICAgICBtaW46ICdtaW4nLFxyXG4gICAgICBtYXg6ICdtYXgnLFxyXG4gICAgICBpbml0dmFsOiAnaW5pdC12YWwnLFxyXG4gICAgICBzdGVwOiAnc3RlcCcsXHJcbiAgICAgIGRlY2ltYWxzOiAnZGVjaW1hbHMnLFxyXG4gICAgICBzdGVwaW50ZXJ2YWw6ICdzdGVwLWludGVydmFsJyxcclxuICAgICAgdmVydGljYWxidXR0b25zOiAndmVydGljYWwtYnV0dG9ucycsXHJcbiAgICAgIHZlcnRpY2FsdXBjbGFzczogJ3ZlcnRpY2FsLXVwLWNsYXNzJyxcclxuICAgICAgdmVydGljYWxkb3duY2xhc3M6ICd2ZXJ0aWNhbC1kb3duLWNsYXNzJyxcclxuICAgICAgZm9yY2VzdGVwZGl2aXNpYmlsaXR5OiAnZm9yY2Utc3RlcC1kaXZpc2liaWxpdHknLFxyXG4gICAgICBzdGVwaW50ZXJ2YWxkZWxheTogJ3N0ZXAtaW50ZXJ2YWwtZGVsYXknLFxyXG4gICAgICBwcmVmaXg6ICdwcmVmaXgnLFxyXG4gICAgICBwb3N0Zml4OiAncG9zdGZpeCcsXHJcbiAgICAgIHByZWZpeF9leHRyYWNsYXNzOiAncHJlZml4LWV4dHJhLWNsYXNzJyxcclxuICAgICAgcG9zdGZpeF9leHRyYWNsYXNzOiAncG9zdGZpeC1leHRyYS1jbGFzcycsXHJcbiAgICAgIGJvb3N0ZXI6ICdib29zdGVyJyxcclxuICAgICAgYm9vc3RhdDogJ2Jvb3N0YXQnLFxyXG4gICAgICBtYXhib29zdGVkc3RlcDogJ21heC1ib29zdGVkLXN0ZXAnLFxyXG4gICAgICBtb3VzZXdoZWVsOiAnbW91c2Utd2hlZWwnLFxyXG4gICAgICBidXR0b25kb3duX2NsYXNzOiAnYnV0dG9uLWRvd24tY2xhc3MnLFxyXG4gICAgICBidXR0b251cF9jbGFzczogJ2J1dHRvbi11cC1jbGFzcycsXHJcblx0ICBidXR0b25kb3duX3R4dDogJ2J1dHRvbi1kb3duLXR4dCcsXHJcblx0ICBidXR0b251cF90eHQ6ICdidXR0b24tdXAtdHh0J1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdmFyIHNldHRpbmdzLFxyXG4gICAgICAgICAgb3JpZ2luYWxpbnB1dCA9ICQodGhpcyksXHJcbiAgICAgICAgICBvcmlnaW5hbGlucHV0X2RhdGEgPSBvcmlnaW5hbGlucHV0LmRhdGEoKSxcclxuICAgICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICAgIGVsZW1lbnRzLFxyXG4gICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICBkb3duU3BpblRpbWVyLFxyXG4gICAgICAgICAgdXBTcGluVGltZXIsXHJcbiAgICAgICAgICBkb3duRGVsYXlUaW1lb3V0LFxyXG4gICAgICAgICAgdXBEZWxheVRpbWVvdXQsXHJcbiAgICAgICAgICBzcGluY291bnQgPSAwLFxyXG4gICAgICAgICAgc3Bpbm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgIGluaXQoKTtcclxuXHJcblxyXG4gICAgICBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgICAgIGlmIChvcmlnaW5hbGlucHV0LmRhdGEoJ2FscmVhZHlpbml0aWFsaXplZCcpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvcmlnaW5hbGlucHV0LmRhdGEoJ2FscmVhZHlpbml0aWFsaXplZCcsIHRydWUpO1xyXG4gICAgICAgIF9jdXJyZW50U3Bpbm5lcklkICs9IDE7XHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5kYXRhKCdzcGlubmVyaWQnLCBfY3VycmVudFNwaW5uZXJJZCk7XHJcblxyXG5cclxuICAgICAgICBpZiAoIW9yaWdpbmFsaW5wdXQuaXMoJ2lucHV0JykpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdNdXN0IGJlIGFuIGlucHV0LicpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2luaXRTZXR0aW5ncygpO1xyXG4gICAgICAgIF9zZXRJbml0dmFsKCk7XHJcbiAgICAgICAgX2NoZWNrVmFsdWUoKTtcclxuICAgICAgICBfYnVpbGRIdG1sKCk7XHJcbiAgICAgICAgX2luaXRFbGVtZW50cygpO1xyXG4gICAgICAgIF9oaWRlRW1wdHlQcmVmaXhQb3N0Zml4KCk7XHJcbiAgICAgICAgX2JpbmRFdmVudHMoKTtcclxuICAgICAgICBfYmluZEV2ZW50c0ludGVyZmFjZSgpO1xyXG4gICAgICAgIGVsZW1lbnRzLmlucHV0LmNzcygnZGlzcGxheScsICdibG9jaycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfc2V0SW5pdHZhbCgpIHtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuaW5pdHZhbCAhPT0gJycgJiYgb3JpZ2luYWxpbnB1dC52YWwoKSA9PT0gJycpIHtcclxuICAgICAgICAgIG9yaWdpbmFsaW5wdXQudmFsKHNldHRpbmdzLmluaXR2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY2hhbmdlU2V0dGluZ3MobmV3c2V0dGluZ3MpIHtcclxuICAgICAgICBfdXBkYXRlU2V0dGluZ3MobmV3c2V0dGluZ3MpO1xyXG4gICAgICAgIF9jaGVja1ZhbHVlKCk7XHJcblxyXG4gICAgICAgIHZhciB2YWx1ZSA9IGVsZW1lbnRzLmlucHV0LnZhbCgpO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IE51bWJlcihlbGVtZW50cy5pbnB1dC52YWwoKSk7XHJcbiAgICAgICAgICBlbGVtZW50cy5pbnB1dC52YWwodmFsdWUudG9GaXhlZChzZXR0aW5ncy5kZWNpbWFscykpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX2luaXRTZXR0aW5ncygpIHtcclxuICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3JpZ2luYWxpbnB1dF9kYXRhLCBfcGFyc2VBdHRyaWJ1dGVzKCksIG9wdGlvbnMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfcGFyc2VBdHRyaWJ1dGVzKCkge1xyXG4gICAgICAgIHZhciBkYXRhID0ge307XHJcbiAgICAgICAgJC5lYWNoKGF0dHJpYnV0ZU1hcCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIGF0dHJOYW1lID0gJ2J0cy0nICsgdmFsdWUgKyAnJztcclxuICAgICAgICAgIGlmIChvcmlnaW5hbGlucHV0LmlzKCdbZGF0YS0nICsgYXR0ck5hbWUgKyAnXScpKSB7XHJcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IG9yaWdpbmFsaW5wdXQuZGF0YShhdHRyTmFtZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF91cGRhdGVTZXR0aW5ncyhuZXdzZXR0aW5ncykge1xyXG4gICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sIHNldHRpbmdzLCBuZXdzZXR0aW5ncyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9idWlsZEh0bWwoKSB7XHJcbiAgICAgICAgdmFyIGluaXR2YWwgPSBvcmlnaW5hbGlucHV0LnZhbCgpLFxyXG4gICAgICAgICAgICBwYXJlbnRlbGVtZW50ID0gb3JpZ2luYWxpbnB1dC5wYXJlbnQoKTtcclxuXHJcbiAgICAgICAgaWYgKGluaXR2YWwgIT09ICcnKSB7XHJcbiAgICAgICAgICBpbml0dmFsID0gTnVtYmVyKGluaXR2YWwpLnRvRml4ZWQoc2V0dGluZ3MuZGVjaW1hbHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5kYXRhKCdpbml0dmFsdWUnLCBpbml0dmFsKS52YWwoaW5pdHZhbCk7XHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5hZGRDbGFzcygnZm9ybS1jb250cm9sJyk7XHJcblxyXG4gICAgICAgIGlmIChwYXJlbnRlbGVtZW50Lmhhc0NsYXNzKCdpbnB1dC1ncm91cCcpKSB7XHJcbiAgICAgICAgICBfYWR2YW5jZUlucHV0R3JvdXAocGFyZW50ZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgX2J1aWxkSW5wdXRHcm91cCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX2FkdmFuY2VJbnB1dEdyb3VwKHBhcmVudGVsZW1lbnQpIHtcclxuICAgICAgICBwYXJlbnRlbGVtZW50LmFkZENsYXNzKCdib290c3RyYXAtdG91Y2hzcGluJyk7XHJcblxyXG4gICAgICAgIHZhciBwcmV2ID0gb3JpZ2luYWxpbnB1dC5wcmV2KCksXHJcbiAgICAgICAgICAgIG5leHQgPSBvcmlnaW5hbGlucHV0Lm5leHQoKTtcclxuXHJcbiAgICAgICAgdmFyIGRvd25odG1sLFxyXG4gICAgICAgICAgICB1cGh0bWwsXHJcbiAgICAgICAgICAgIHByZWZpeGh0bWwgPSAnPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvbiBib290c3RyYXAtdG91Y2hzcGluLXByZWZpeFwiPicgKyBzZXR0aW5ncy5wcmVmaXggKyAnPC9zcGFuPicsXHJcbiAgICAgICAgICAgIHBvc3RmaXhodG1sID0gJzxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb24gYm9vdHN0cmFwLXRvdWNoc3Bpbi1wb3N0Zml4XCI+JyArIHNldHRpbmdzLnBvc3RmaXggKyAnPC9zcGFuPic7XHJcblxyXG4gICAgICAgIGlmIChwcmV2Lmhhc0NsYXNzKCdpbnB1dC1ncm91cC1idG4nKSkge1xyXG4gICAgICAgICAgZG93bmh0bWwgPSAnPGJ1dHRvbiBjbGFzcz1cIicgKyBzZXR0aW5ncy5idXR0b25kb3duX2NsYXNzICsgJyBib290c3RyYXAtdG91Y2hzcGluLWRvd25cIiB0eXBlPVwiYnV0dG9uXCI+JyArIHNldHRpbmdzLmJ1dHRvbmRvd25fdHh0ICsgJzwvYnV0dG9uPic7XHJcbiAgICAgICAgICBwcmV2LmFwcGVuZChkb3duaHRtbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgZG93bmh0bWwgPSAnPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1idG5cIj48YnV0dG9uIGNsYXNzPVwiJyArIHNldHRpbmdzLmJ1dHRvbmRvd25fY2xhc3MgKyAnIGJvb3RzdHJhcC10b3VjaHNwaW4tZG93blwiIHR5cGU9XCJidXR0b25cIj4nICsgc2V0dGluZ3MuYnV0dG9uZG93bl90eHQgKyAnPC9idXR0b24+PC9zcGFuPic7XHJcbiAgICAgICAgICAkKGRvd25odG1sKS5pbnNlcnRCZWZvcmUob3JpZ2luYWxpbnB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmV4dC5oYXNDbGFzcygnaW5wdXQtZ3JvdXAtYnRuJykpIHtcclxuICAgICAgICAgIHVwaHRtbCA9ICc8YnV0dG9uIGNsYXNzPVwiJyArIHNldHRpbmdzLmJ1dHRvbnVwX2NsYXNzICsgJyBib290c3RyYXAtdG91Y2hzcGluLXVwXCIgdHlwZT1cImJ1dHRvblwiPicgKyBzZXR0aW5ncy5idXR0b251cF90eHQgKyAnPC9idXR0b24+JztcclxuICAgICAgICAgIG5leHQucHJlcGVuZCh1cGh0bWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHVwaHRtbCA9ICc8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWJ0blwiPjxidXR0b24gY2xhc3M9XCInICsgc2V0dGluZ3MuYnV0dG9udXBfY2xhc3MgKyAnIGJvb3RzdHJhcC10b3VjaHNwaW4tdXBcIiB0eXBlPVwiYnV0dG9uXCI+JyArIHNldHRpbmdzLmJ1dHRvbnVwX3R4dCArICc8L2J1dHRvbj48L3NwYW4+JztcclxuICAgICAgICAgICQodXBodG1sKS5pbnNlcnRBZnRlcihvcmlnaW5hbGlucHV0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICQocHJlZml4aHRtbCkuaW5zZXJ0QmVmb3JlKG9yaWdpbmFsaW5wdXQpO1xyXG4gICAgICAgICQocG9zdGZpeGh0bWwpLmluc2VydEFmdGVyKG9yaWdpbmFsaW5wdXQpO1xyXG5cclxuICAgICAgICBjb250YWluZXIgPSBwYXJlbnRlbGVtZW50O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfYnVpbGRJbnB1dEdyb3VwKCkge1xyXG4gICAgICAgIHZhciBodG1sO1xyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MudmVydGljYWxidXR0b25zKSB7XHJcbiAgICAgICAgICBodG1sID0gJzxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBib290c3RyYXAtdG91Y2hzcGluXCI+PHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvbiBib290c3RyYXAtdG91Y2hzcGluLXByZWZpeFwiPicgKyBzZXR0aW5ncy5wcmVmaXggKyAnPC9zcGFuPjxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb24gYm9vdHN0cmFwLXRvdWNoc3Bpbi1wb3N0Zml4XCI+JyArIHNldHRpbmdzLnBvc3RmaXggKyAnPC9zcGFuPjxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYnRuLXZlcnRpY2FsXCI+PGJ1dHRvbiBjbGFzcz1cIicgKyBzZXR0aW5ncy5idXR0b25kb3duX2NsYXNzICsgJyBib290c3RyYXAtdG91Y2hzcGluLXVwXCIgdHlwZT1cImJ1dHRvblwiPjxpIGNsYXNzPVwiJyArIHNldHRpbmdzLnZlcnRpY2FsdXBjbGFzcyArICdcIj48L2k+PC9idXR0b24+PGJ1dHRvbiBjbGFzcz1cIicgKyBzZXR0aW5ncy5idXR0b251cF9jbGFzcyArICcgYm9vdHN0cmFwLXRvdWNoc3Bpbi1kb3duXCIgdHlwZT1cImJ1dHRvblwiPjxpIGNsYXNzPVwiJyArIHNldHRpbmdzLnZlcnRpY2FsZG93bmNsYXNzICsgJ1wiPjwvaT48L2J1dHRvbj48L3NwYW4+PC9kaXY+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBodG1sID0gJzxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBib290c3RyYXAtdG91Y2hzcGluXCI+PHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1idG5cIj48YnV0dG9uIGNsYXNzPVwiJyArIHNldHRpbmdzLmJ1dHRvbmRvd25fY2xhc3MgKyAnIGJvb3RzdHJhcC10b3VjaHNwaW4tZG93blwiIHR5cGU9XCJidXR0b25cIj4nICsgc2V0dGluZ3MuYnV0dG9uZG93bl90eHQgKyAnPC9idXR0b24+PC9zcGFuPjxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb24gYm9vdHN0cmFwLXRvdWNoc3Bpbi1wcmVmaXhcIj4nICsgc2V0dGluZ3MucHJlZml4ICsgJzwvc3Bhbj48c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uIGJvb3RzdHJhcC10b3VjaHNwaW4tcG9zdGZpeFwiPicgKyBzZXR0aW5ncy5wb3N0Zml4ICsgJzwvc3Bhbj48c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWJ0blwiPjxidXR0b24gY2xhc3M9XCInICsgc2V0dGluZ3MuYnV0dG9udXBfY2xhc3MgKyAnIGJvb3RzdHJhcC10b3VjaHNwaW4tdXBcIiB0eXBlPVwiYnV0dG9uXCI+JyArIHNldHRpbmdzLmJ1dHRvbnVwX3R4dCArICc8L2J1dHRvbj48L3NwYW4+PC9kaXY+JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRhaW5lciA9ICQoaHRtbCkuaW5zZXJ0QmVmb3JlKG9yaWdpbmFsaW5wdXQpO1xyXG5cclxuICAgICAgICAkKCcuYm9vdHN0cmFwLXRvdWNoc3Bpbi1wcmVmaXgnLCBjb250YWluZXIpLmFmdGVyKG9yaWdpbmFsaW5wdXQpO1xyXG5cclxuICAgICAgICBpZiAob3JpZ2luYWxpbnB1dC5oYXNDbGFzcygnaW5wdXQtc20nKSkge1xyXG4gICAgICAgICAgY29udGFpbmVyLmFkZENsYXNzKCdpbnB1dC1ncm91cC1zbScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcmlnaW5hbGlucHV0Lmhhc0NsYXNzKCdpbnB1dC1sZycpKSB7XHJcbiAgICAgICAgICBjb250YWluZXIuYWRkQ2xhc3MoJ2lucHV0LWdyb3VwLWxnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfaW5pdEVsZW1lbnRzKCkge1xyXG4gICAgICAgIGVsZW1lbnRzID0ge1xyXG4gICAgICAgICAgZG93bjogJCgnLmJvb3RzdHJhcC10b3VjaHNwaW4tZG93bicsIGNvbnRhaW5lciksXHJcbiAgICAgICAgICB1cDogJCgnLmJvb3RzdHJhcC10b3VjaHNwaW4tdXAnLCBjb250YWluZXIpLFxyXG4gICAgICAgICAgaW5wdXQ6ICQoJ2lucHV0JywgY29udGFpbmVyKSxcclxuICAgICAgICAgIHByZWZpeDogJCgnLmJvb3RzdHJhcC10b3VjaHNwaW4tcHJlZml4JywgY29udGFpbmVyKS5hZGRDbGFzcyhzZXR0aW5ncy5wcmVmaXhfZXh0cmFjbGFzcyksXHJcbiAgICAgICAgICBwb3N0Zml4OiAkKCcuYm9vdHN0cmFwLXRvdWNoc3Bpbi1wb3N0Zml4JywgY29udGFpbmVyKS5hZGRDbGFzcyhzZXR0aW5ncy5wb3N0Zml4X2V4dHJhY2xhc3MpXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX2hpZGVFbXB0eVByZWZpeFBvc3RmaXgoKSB7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnByZWZpeCA9PT0gJycpIHtcclxuICAgICAgICAgIGVsZW1lbnRzLnByZWZpeC5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MucG9zdGZpeCA9PT0gJycpIHtcclxuICAgICAgICAgIGVsZW1lbnRzLnBvc3RmaXguaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX2JpbmRFdmVudHMoKSB7XHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICB2YXIgY29kZSA9IGV2LmtleUNvZGUgfHwgZXYud2hpY2g7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZGUgPT09IDM4KSB7XHJcbiAgICAgICAgICAgIGlmIChzcGlubmluZyAhPT0gJ3VwJykge1xyXG4gICAgICAgICAgICAgIHVwT25jZSgpO1xyXG4gICAgICAgICAgICAgIHN0YXJ0VXBTcGluKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPT09IDQwKSB7XHJcbiAgICAgICAgICAgIGlmIChzcGlubmluZyAhPT0gJ2Rvd24nKSB7XHJcbiAgICAgICAgICAgICAgZG93bk9uY2UoKTtcclxuICAgICAgICAgICAgICBzdGFydERvd25TcGluKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbigna2V5dXAnLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgdmFyIGNvZGUgPSBldi5rZXlDb2RlIHx8IGV2LndoaWNoO1xyXG5cclxuICAgICAgICAgIGlmIChjb2RlID09PSAzOCkge1xyXG4gICAgICAgICAgICBzdG9wU3BpbigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAoY29kZSA9PT0gNDApIHtcclxuICAgICAgICAgICAgc3RvcFNwaW4oKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbignYmx1cicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgX2NoZWNrVmFsdWUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWxlbWVudHMuZG93bi5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICB2YXIgY29kZSA9IGV2LmtleUNvZGUgfHwgZXYud2hpY2g7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZGUgPT09IDMyIHx8IGNvZGUgPT09IDEzKSB7XHJcbiAgICAgICAgICAgIGlmIChzcGlubmluZyAhPT0gJ2Rvd24nKSB7XHJcbiAgICAgICAgICAgICAgZG93bk9uY2UoKTtcclxuICAgICAgICAgICAgICBzdGFydERvd25TcGluKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWxlbWVudHMuZG93bi5vbigna2V5dXAnLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgdmFyIGNvZGUgPSBldi5rZXlDb2RlIHx8IGV2LndoaWNoO1xyXG5cclxuICAgICAgICAgIGlmIChjb2RlID09PSAzMiB8fCBjb2RlID09PSAxMykge1xyXG4gICAgICAgICAgICBzdG9wU3BpbigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlbGVtZW50cy51cC5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICB2YXIgY29kZSA9IGV2LmtleUNvZGUgfHwgZXYud2hpY2g7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZGUgPT09IDMyIHx8IGNvZGUgPT09IDEzKSB7XHJcbiAgICAgICAgICAgIGlmIChzcGlubmluZyAhPT0gJ3VwJykge1xyXG4gICAgICAgICAgICAgIHVwT25jZSgpO1xyXG4gICAgICAgICAgICAgIHN0YXJ0VXBTcGluKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWxlbWVudHMudXAub24oJ2tleXVwJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIHZhciBjb2RlID0gZXYua2V5Q29kZSB8fCBldi53aGljaDtcclxuXHJcbiAgICAgICAgICBpZiAoY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gMTMpIHtcclxuICAgICAgICAgICAgc3RvcFNwaW4oKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWxlbWVudHMuZG93bi5vbignbW91c2Vkb3duLnRvdWNoc3BpbicsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICBlbGVtZW50cy5kb3duLm9mZigndG91Y2hzdGFydC50b3VjaHNwaW4nKTsgIC8vIGFuZHJvaWQgNCB3b3JrYXJvdW5kXHJcblxyXG4gICAgICAgICAgaWYgKG9yaWdpbmFsaW5wdXQuaXMoJzpkaXNhYmxlZCcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBkb3duT25jZSgpO1xyXG4gICAgICAgICAgc3RhcnREb3duU3BpbigpO1xyXG5cclxuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWxlbWVudHMuZG93bi5vbigndG91Y2hzdGFydC50b3VjaHNwaW4nLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgZWxlbWVudHMuZG93bi5vZmYoJ21vdXNlZG93bi50b3VjaHNwaW4nKTsgIC8vIGFuZHJvaWQgNCB3b3JrYXJvdW5kXHJcblxyXG4gICAgICAgICAgaWYgKG9yaWdpbmFsaW5wdXQuaXMoJzpkaXNhYmxlZCcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBkb3duT25jZSgpO1xyXG4gICAgICAgICAgc3RhcnREb3duU3BpbigpO1xyXG5cclxuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWxlbWVudHMudXAub24oJ21vdXNlZG93bi50b3VjaHNwaW4nLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgZWxlbWVudHMudXAub2ZmKCd0b3VjaHN0YXJ0LnRvdWNoc3BpbicpOyAgLy8gYW5kcm9pZCA0IHdvcmthcm91bmRcclxuXHJcbiAgICAgICAgICBpZiAob3JpZ2luYWxpbnB1dC5pcygnOmRpc2FibGVkJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHVwT25jZSgpO1xyXG4gICAgICAgICAgc3RhcnRVcFNwaW4oKTtcclxuXHJcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLnVwLm9uKCd0b3VjaHN0YXJ0LnRvdWNoc3BpbicsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICBlbGVtZW50cy51cC5vZmYoJ21vdXNlZG93bi50b3VjaHNwaW4nKTsgIC8vIGFuZHJvaWQgNCB3b3JrYXJvdW5kXHJcblxyXG4gICAgICAgICAgaWYgKG9yaWdpbmFsaW5wdXQuaXMoJzpkaXNhYmxlZCcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB1cE9uY2UoKTtcclxuICAgICAgICAgIHN0YXJ0VXBTcGluKCk7XHJcblxyXG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlbGVtZW50cy51cC5vbignbW91c2VvdXQgdG91Y2hsZWF2ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICBpZiAoIXNwaW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgIHN0b3BTcGluKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLmRvd24ub24oJ21vdXNlb3V0IHRvdWNobGVhdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgaWYgKCFzcGlubmluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICBzdG9wU3BpbigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlbGVtZW50cy5kb3duLm9uKCdtb3VzZW1vdmUgdG91Y2htb3ZlJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIGlmICghc3Bpbm5pbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWxlbWVudHMudXAub24oJ21vdXNlbW92ZSB0b3VjaG1vdmUnLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgaWYgKCFzcGlubmluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAkKGRvY3VtZW50KS5vbihfc2NvcGVFdmVudE5hbWVzKFsnbW91c2V1cCcsICd0b3VjaGVuZCcsICd0b3VjaGNhbmNlbCddLCBfY3VycmVudFNwaW5uZXJJZCkuam9pbignICcpLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgaWYgKCFzcGlubmluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIHN0b3BTcGluKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKF9zY29wZUV2ZW50TmFtZXMoWydtb3VzZW1vdmUnLCAndG91Y2htb3ZlJywgJ3Njcm9sbCcsICdzY3JvbGxzdGFydCddLCBfY3VycmVudFNwaW5uZXJJZCkuam9pbignICcpLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgaWYgKCFzcGlubmluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIHN0b3BTcGluKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ21vdXNld2hlZWwgRE9NTW91c2VTY3JvbGwnLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgaWYgKCFzZXR0aW5ncy5tb3VzZXdoZWVsIHx8ICFvcmlnaW5hbGlucHV0LmlzKCc6Zm9jdXMnKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIGRlbHRhID0gZXYub3JpZ2luYWxFdmVudC53aGVlbERlbHRhIHx8IC1ldi5vcmlnaW5hbEV2ZW50LmRlbHRhWSB8fCAtZXYub3JpZ2luYWxFdmVudC5kZXRhaWw7XHJcblxyXG4gICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgIGlmIChkZWx0YSA8IDApIHtcclxuICAgICAgICAgICAgZG93bk9uY2UoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1cE9uY2UoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX2JpbmRFdmVudHNJbnRlcmZhY2UoKSB7XHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbigndG91Y2hzcGluLnVwb25jZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc3RvcFNwaW4oKTtcclxuICAgICAgICAgIHVwT25jZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBvcmlnaW5hbGlucHV0Lm9uKCd0b3VjaHNwaW4uZG93bm9uY2UnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHN0b3BTcGluKCk7XHJcbiAgICAgICAgICBkb3duT25jZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBvcmlnaW5hbGlucHV0Lm9uKCd0b3VjaHNwaW4uc3RhcnR1cHNwaW4nLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHN0YXJ0VXBTcGluKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ3RvdWNoc3Bpbi5zdGFydGRvd25zcGluJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBzdGFydERvd25TcGluKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ3RvdWNoc3Bpbi5zdG9wc3BpbicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc3RvcFNwaW4oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbigndG91Y2hzcGluLnVwZGF0ZXNldHRpbmdzJywgZnVuY3Rpb24oZSwgbmV3c2V0dGluZ3MpIHtcclxuICAgICAgICAgIGNoYW5nZVNldHRpbmdzKG5ld3NldHRpbmdzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX2ZvcmNlc3RlcGRpdmlzaWJpbGl0eSh2YWx1ZSkge1xyXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuZm9yY2VzdGVwZGl2aXNpYmlsaXR5KSB7XHJcbiAgICAgICAgICBjYXNlICdyb3VuZCc6XHJcbiAgICAgICAgICAgIHJldHVybiAoTWF0aC5yb3VuZCh2YWx1ZSAvIHNldHRpbmdzLnN0ZXApICogc2V0dGluZ3Muc3RlcCkudG9GaXhlZChzZXR0aW5ncy5kZWNpbWFscyk7XHJcbiAgICAgICAgICBjYXNlICdmbG9vcic6XHJcbiAgICAgICAgICAgIHJldHVybiAoTWF0aC5mbG9vcih2YWx1ZSAvIHNldHRpbmdzLnN0ZXApICogc2V0dGluZ3Muc3RlcCkudG9GaXhlZChzZXR0aW5ncy5kZWNpbWFscyk7XHJcbiAgICAgICAgICBjYXNlICdjZWlsJzpcclxuICAgICAgICAgICAgcmV0dXJuIChNYXRoLmNlaWwodmFsdWUgLyBzZXR0aW5ncy5zdGVwKSAqIHNldHRpbmdzLnN0ZXApLnRvRml4ZWQoc2V0dGluZ3MuZGVjaW1hbHMpO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX2NoZWNrVmFsdWUoKSB7XHJcbiAgICAgICAgdmFyIHZhbCwgcGFyc2VkdmFsLCByZXR1cm52YWw7XHJcblxyXG4gICAgICAgIHZhbCA9IG9yaWdpbmFsaW5wdXQudmFsKCk7XHJcblxyXG4gICAgICAgIGlmICh2YWwgPT09ICcnKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbHMgPiAwICYmIHZhbCA9PT0gJy4nKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXJzZWR2YWwgPSBwYXJzZUZsb2F0KHZhbCk7XHJcblxyXG4gICAgICAgIGlmIChpc05hTihwYXJzZWR2YWwpKSB7XHJcbiAgICAgICAgICBwYXJzZWR2YWwgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJudmFsID0gcGFyc2VkdmFsO1xyXG5cclxuICAgICAgICBpZiAocGFyc2VkdmFsLnRvU3RyaW5nKCkgIT09IHZhbCkge1xyXG4gICAgICAgICAgcmV0dXJudmFsID0gcGFyc2VkdmFsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZHZhbCA8IHNldHRpbmdzLm1pbikge1xyXG4gICAgICAgICAgcmV0dXJudmFsID0gc2V0dGluZ3MubWluO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZHZhbCA+IHNldHRpbmdzLm1heCkge1xyXG4gICAgICAgICAgcmV0dXJudmFsID0gc2V0dGluZ3MubWF4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJudmFsID0gX2ZvcmNlc3RlcGRpdmlzaWJpbGl0eShyZXR1cm52YWwpO1xyXG5cclxuICAgICAgICBpZiAoTnVtYmVyKHZhbCkudG9TdHJpbmcoKSAhPT0gcmV0dXJudmFsLnRvU3RyaW5nKCkpIHtcclxuICAgICAgICAgIG9yaWdpbmFsaW5wdXQudmFsKHJldHVybnZhbCk7XHJcbiAgICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX2dldEJvb3N0ZWRTdGVwKCkge1xyXG4gICAgICAgIGlmICghc2V0dGluZ3MuYm9vc3Rlcikge1xyXG4gICAgICAgICAgcmV0dXJuIHNldHRpbmdzLnN0ZXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgdmFyIGJvb3N0ZWQgPSBNYXRoLnBvdygyLCBNYXRoLmZsb29yKHNwaW5jb3VudCAvIHNldHRpbmdzLmJvb3N0YXQpKSAqIHNldHRpbmdzLnN0ZXA7XHJcblxyXG4gICAgICAgICAgaWYgKHNldHRpbmdzLm1heGJvb3N0ZWRzdGVwKSB7XHJcbiAgICAgICAgICAgIGlmIChib29zdGVkID4gc2V0dGluZ3MubWF4Ym9vc3RlZHN0ZXApIHtcclxuICAgICAgICAgICAgICBib29zdGVkID0gc2V0dGluZ3MubWF4Ym9vc3RlZHN0ZXA7XHJcbiAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKCh2YWx1ZSAvIGJvb3N0ZWQpKSAqIGJvb3N0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoc2V0dGluZ3Muc3RlcCwgYm9vc3RlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiB1cE9uY2UoKSB7XHJcbiAgICAgICAgX2NoZWNrVmFsdWUoKTtcclxuXHJcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KGVsZW1lbnRzLmlucHV0LnZhbCgpKTtcclxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW5pdHZhbHVlID0gdmFsdWUsXHJcbiAgICAgICAgICAgIGJvb3N0ZWRzdGVwID0gX2dldEJvb3N0ZWRTdGVwKCk7XHJcblxyXG4gICAgICAgIHZhbHVlID0gdmFsdWUgKyBib29zdGVkc3RlcDtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlID4gc2V0dGluZ3MubWF4KSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLm1heDtcclxuICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLm1heCcpO1xyXG4gICAgICAgICAgc3RvcFNwaW4oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLmlucHV0LnZhbChOdW1iZXIodmFsdWUpLnRvRml4ZWQoc2V0dGluZ3MuZGVjaW1hbHMpKTtcclxuXHJcbiAgICAgICAgaWYgKGluaXR2YWx1ZSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBkb3duT25jZSgpIHtcclxuICAgICAgICBfY2hlY2tWYWx1ZSgpO1xyXG5cclxuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQoZWxlbWVudHMuaW5wdXQudmFsKCkpO1xyXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgIHZhbHVlID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbml0dmFsdWUgPSB2YWx1ZSxcclxuICAgICAgICAgICAgYm9vc3RlZHN0ZXAgPSBfZ2V0Qm9vc3RlZFN0ZXAoKTtcclxuXHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSAtIGJvb3N0ZWRzdGVwO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUgPCBzZXR0aW5ncy5taW4pIHtcclxuICAgICAgICAgIHZhbHVlID0gc2V0dGluZ3MubWluO1xyXG4gICAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCd0b3VjaHNwaW4ub24ubWluJyk7XHJcbiAgICAgICAgICBzdG9wU3BpbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxlbWVudHMuaW5wdXQudmFsKHZhbHVlLnRvRml4ZWQoc2V0dGluZ3MuZGVjaW1hbHMpKTtcclxuXHJcbiAgICAgICAgaWYgKGluaXR2YWx1ZSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdGFydERvd25TcGluKCkge1xyXG4gICAgICAgIHN0b3BTcGluKCk7XHJcblxyXG4gICAgICAgIHNwaW5jb3VudCA9IDA7XHJcbiAgICAgICAgc3Bpbm5pbmcgPSAnZG93bic7XHJcblxyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLnN0YXJ0c3BpbicpO1xyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLnN0YXJ0ZG93bnNwaW4nKTtcclxuXHJcbiAgICAgICAgZG93bkRlbGF5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBkb3duU3BpblRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHNwaW5jb3VudCsrO1xyXG4gICAgICAgICAgICBkb3duT25jZSgpO1xyXG4gICAgICAgICAgfSwgc2V0dGluZ3Muc3RlcGludGVydmFsKTtcclxuICAgICAgICB9LCBzZXR0aW5ncy5zdGVwaW50ZXJ2YWxkZWxheSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN0YXJ0VXBTcGluKCkge1xyXG4gICAgICAgIHN0b3BTcGluKCk7XHJcblxyXG4gICAgICAgIHNwaW5jb3VudCA9IDA7XHJcbiAgICAgICAgc3Bpbm5pbmcgPSAndXAnO1xyXG5cclxuICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ3RvdWNoc3Bpbi5vbi5zdGFydHNwaW4nKTtcclxuICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ3RvdWNoc3Bpbi5vbi5zdGFydHVwc3BpbicpO1xyXG5cclxuICAgICAgICB1cERlbGF5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB1cFNwaW5UaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBzcGluY291bnQrKztcclxuICAgICAgICAgICAgdXBPbmNlKCk7XHJcbiAgICAgICAgICB9LCBzZXR0aW5ncy5zdGVwaW50ZXJ2YWwpO1xyXG4gICAgICAgIH0sIHNldHRpbmdzLnN0ZXBpbnRlcnZhbGRlbGF5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gc3RvcFNwaW4oKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KGRvd25EZWxheVRpbWVvdXQpO1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh1cERlbGF5VGltZW91dCk7XHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbChkb3duU3BpblRpbWVyKTtcclxuICAgICAgICBjbGVhckludGVydmFsKHVwU3BpblRpbWVyKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChzcGlubmluZykge1xyXG4gICAgICAgICAgY2FzZSAndXAnOlxyXG4gICAgICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ3RvdWNoc3Bpbi5vbi5zdG9wdXBzcGluJyk7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLnN0b3BzcGluJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnZG93bic6XHJcbiAgICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLnN0b3Bkb3duc3BpbicpO1xyXG4gICAgICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ3RvdWNoc3Bpbi5vbi5zdG9wc3BpbicpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNwaW5jb3VudCA9IDA7XHJcbiAgICAgICAgc3Bpbm5pbmcgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgIH0pO1xyXG5cclxuICB9O1xyXG5cclxufSkoalF1ZXJ5KTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYnJhcmllcy9ib290c3RyYXAtdG91Y2hzcGluL2pxdWVyeS5ib290c3RyYXAtdG91Y2hzcGluLmpzXG4gKiogbW9kdWxlIGlkID0gMTE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5zdHJpbmdXaXRoV2F0ZXJtYXJrJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsU3RyaW5nV2l0aFdhdGVybWFyayc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnU3RyaW5nV2l0aFdhdGVybWFya0NvbnRyb2xsZXInO1xyXG52YXIgU3RyaW5nV2l0aFdhdGVybWFya0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3RyaW5nV2l0aFdhdGVybWFya0NvbnRyb2xsZXIoJHNjb3BlLCBvYmplY3RVdGlsaXR5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnN0cmluZzsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhhc1N0cmluZyA9IG9iamVjdFV0aWxpdHkuaXNOdWxsT3JFbXB0eSh2YWx1ZSkgPT09IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgU3RyaW5nV2l0aFdhdGVybWFya0NvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgX19vYmplY3Quc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIFN0cmluZ1dpdGhXYXRlcm1hcmtDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlN0cmluZ1dpdGhXYXRlcm1hcmtDb250cm9sbGVyID0gU3RyaW5nV2l0aFdhdGVybWFya0NvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHN0cmluZ1dpdGhXYXRlcm1hcmsoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuXFx0XFx0XFx0PHNwYW4+XFxuXFx0XFx0XFx0XFx0PHNwYW4gbmctc2hvdz1cXFwiY29udHJvbGxlci5oYXNTdHJpbmdcXFwiPnt7Y29udHJvbGxlci5zdHJpbmd9fTwvc3Bhbj5cXG5cXHRcXHRcXHRcXHQ8c3BhbiBuZy1oaWRlPVxcXCJjb250cm9sbGVyLmhhc1N0cmluZ1xcXCIgY2xhc3M9XFxcIndhdGVybWFya1xcXCI+e3tjb250cm9sbGVyLndhdGVybWFya319PC9zcGFuPlxcblxcdFxcdFxcdDwvc3Bhbj5cXG5cXHRcXHRcIixcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2NvbnRyb2xsZXInLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIHN0cmluZzogJ0AnLFxyXG4gICAgICAgICAgICB3YXRlcm1hcms6ICdAJyxcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuc3RyaW5nV2l0aFdhdGVybWFyayA9IHN0cmluZ1dpdGhXYXRlcm1hcms7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JqZWN0Lm1vZHVsZU5hbWVdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIHN0cmluZ1dpdGhXYXRlcm1hcmspXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBTdHJpbmdXaXRoV2F0ZXJtYXJrQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ1dpdGhXYXRlcm1hcmsuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3N0cmluZ1dpdGhXYXRlcm1hcmsvc3RyaW5nV2l0aFdhdGVybWFyay5qc1xuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fcGFyZW50Q2hpbGQgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucGFyZW50Q2hpbGRCZWhhdmlvcjtcclxudmFyIF9fZ2VuZXJpY1NlYXJjaCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5nZW5lcmljU2VhcmNoRmlsdGVyO1xyXG52YXIgX19vYmplY3RVdGlsaXR5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIF9fYXJyYXlVdGlsaXR5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmFycmF5O1xyXG52YXIgX19wcm9taXNlVXRpbGl0eSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wcm9taXNlO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy50eXBlYWhlYWQnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxUeXBlYWhlYWQnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1R5cGVhaGVhZENvbnRyb2xsZXInO1xyXG52YXIgVHlwZWFoZWFkQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUeXBlYWhlYWRDb250cm9sbGVyKCRzY29wZSwgJGF0dHJzLCAkcSwgcGFyZW50Q2hpbGQsIGdlbmVyaWNTZWFyY2hGYWN0b3J5LCBvYmplY3QsIGFycmF5LCBwcm9taXNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB0aGlzLiRxID0gJHE7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRDaGlsZCA9IHBhcmVudENoaWxkO1xyXG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xyXG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWRkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5jYWNoZWRJdGVtcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jYWNoZWRJdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuY2FjaGVkSXRlbXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYXJyYXkucmVtb3ZlKF90aGlzLmNhY2hlZEl0ZW1zLCBpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5zZWFyY2hGaWx0ZXIgPSBnZW5lcmljU2VhcmNoRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMubG9hZERlbGF5ID0gdGhpcy51c2VDbGllbnRTZWFyY2hpbmcgPyAxMDAgOiA1MDA7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbkJpbmRpbmc7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzU2VsZWN0aW9uID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5oYXNTZWxlY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGxhY2Vob2xkZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gJ1NlYXJjaCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNob3dTZWFyY2ggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dTZWFyY2ggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVzZVNjb3BlU2VsZWN0aW9uID0gb2JqZWN0LmlzTnVsbE9yRW1wdHkoJGF0dHJzLnNlbGVjdGlvbikgPT09IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaGFzVHJhbnNmb3JtID0gb2JqZWN0LmlzTnVsbE9yRW1wdHkoJGF0dHJzLnRyYW5zZm9ybSkgPT09IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudXNlQXBwbHkgPSBvYmplY3QuaXNOdWxsT3JFbXB0eSgkYXR0cnMuYXBwbHkpID09PSBmYWxzZTtcclxuICAgICAgICB0aGlzLnBhcmVudENoaWxkLnJlZ2lzdGVyQ2hpbGRCZWhhdmlvcih0aGlzLmNoaWxkTGluaywge1xyXG4gICAgICAgICAgICBhZGQ6IHRoaXMuYWRkSXRlbSxcclxuICAgICAgICAgICAgcmVtb3ZlOiB0aGlzLnJlbW92ZUl0ZW0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZWxlY3Rpb247IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5oYXNTZWxlY3Rpb24gPSBfLmlzT2JqZWN0KHZhbHVlKTtcclxuICAgICAgICAgICAgX3RoaXMuc2V0U2VsZWN0aW9uKHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNlbGVjdGlvbkJpbmRpbmc7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgVHlwZWFoZWFkQ29udHJvbGxlci5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKG9iamVjdCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1NlbGVjdGlvbiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzU2VsZWN0aW9uID0gdGhpcy5oYXNTZWxlY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnVzZVNjb3BlU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gb2JqZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHRoaXMuc2VsZWN0KSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh7IHZhbHVlOiBvYmplY3QsIGhhc1NlbGVjdGlvbjogdGhpcy5oYXNTZWxlY3Rpb24gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFR5cGVhaGVhZENvbnRyb2xsZXIucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXNUcmFuc2Zvcm0gJiYgb2JqZWN0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtSW5QYXJlbnQoe1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9iamVjdCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICB9O1xyXG4gICAgVHlwZWFoZWFkQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0SXRlbXMgPSBmdW5jdGlvbiAoc2VhcmNoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXMudXNlQ2xpZW50U2VhcmNoaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEl0ZW1zSW5QYXJlbnQoe1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBzZWFyY2gsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zZWFyY2hGaWx0ZXIuc2VhcmNoVGV4dCA9IHNlYXJjaDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVkSXRlbXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEud2hlbih0aGlzLmZpbHRlcih0aGlzLmNhY2hlZEl0ZW1zKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcS53aGVuKHRoaXMuZ2V0SXRlbXNJblBhcmVudCgpKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FjaGVkSXRlbXMgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5maWx0ZXIoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUeXBlYWhlYWRDb250cm9sbGVyLnByb3RvdHlwZS5hcHBseUl0ZW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy51c2VBcHBseSAmJiB0aGlzLmhhc1NlbGVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMuYXBwbHkoeyB2YWx1ZTogdGhpcy5zZWxlY3Rpb24gfSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb21pc2UuaXNQcm9taXNlKHJlcXVlc3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVJdGVtKF90aGlzLnNlbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKHJlcXVlc3QpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUl0ZW0odGhpcy5zZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLiRxLndoZW4oKTtcclxuICAgIH07XHJcbiAgICBUeXBlYWhlYWRDb250cm9sbGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAobGlzdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIF8uZmlsdGVyKGxpc3QsIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBfdGhpcy5zZWFyY2hGaWx0ZXIuZmlsdGVyKGl0ZW0pOyB9KTtcclxuICAgIH07XHJcbiAgICBUeXBlYWhlYWRDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsXHJcbiAgICAgICAgJyRhdHRycycsXHJcbiAgICAgICAgJyRxJyxcclxuICAgICAgICBfX3BhcmVudENoaWxkLnNlcnZpY2VOYW1lLFxyXG4gICAgICAgIF9fZ2VuZXJpY1NlYXJjaC5mYWN0b3J5TmFtZSxcclxuICAgICAgICBfX29iamVjdFV0aWxpdHkuc2VydmljZU5hbWUsXHJcbiAgICAgICAgX19hcnJheVV0aWxpdHkuc2VydmljZU5hbWUsXHJcbiAgICAgICAgX19wcm9taXNlVXRpbGl0eS5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gVHlwZWFoZWFkQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5UeXBlYWhlYWRDb250cm9sbGVyID0gVHlwZWFoZWFkQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gdHlwZWFoZWFkKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3R5cGVhaGVhZC5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICd0eXBlYWhlYWQnLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIGNoaWxkTGluazogJz0nLFxyXG4gICAgICAgICAgICBzZWxlY3Rpb25CaW5kaW5nOiAnPXNlbGVjdGlvbicsXHJcbiAgICAgICAgICAgIGhhc1NlbGVjdGlvbjogJz0nLFxyXG4gICAgICAgICAgICBzZWxlY3Q6ICcmJyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtSW5QYXJlbnQ6ICcmdHJhbnNmb3JtJyxcclxuICAgICAgICAgICAgZ2V0SXRlbXNJblBhcmVudDogJyZnZXRJdGVtcycsXHJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnQCcsXHJcbiAgICAgICAgICAgIHVzZUNsaWVudFNlYXJjaGluZzogJz0nLFxyXG4gICAgICAgICAgICBoYXNFcnJvcjogJz0nLFxyXG4gICAgICAgICAgICBzaG93U2VhcmNoOiAnPScsXHJcbiAgICAgICAgICAgIGFwcGx5OiAnJicsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy50eXBlYWhlYWQgPSB0eXBlYWhlYWQ7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW1xyXG4gICAgX19wYXJlbnRDaGlsZC5tb2R1bGVOYW1lLFxyXG4gICAgX19nZW5lcmljU2VhcmNoLm1vZHVsZU5hbWUsXHJcbiAgICBfX29iamVjdFV0aWxpdHkubW9kdWxlTmFtZSxcclxuICAgIF9fYXJyYXlVdGlsaXR5Lm1vZHVsZU5hbWUsXHJcbiAgICBfX3Byb21pc2VVdGlsaXR5Lm1vZHVsZU5hbWVdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIHR5cGVhaGVhZClcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIFR5cGVhaGVhZENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlYWhlYWQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3R5cGVhaGVhZC90eXBlYWhlYWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cFxcXCIgbmctY2xhc3M9XFxcInsgJ2hhcy1lcnJvcic6IHR5cGVhaGVhZC5oYXNFcnJvciB9XFxcIj5cXHJcXG5cXHQ8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgbmctbW9kZWw9XFxcInR5cGVhaGVhZC5zZWxlY3Rpb25cXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiXFxyXFxuXFx0XFx0cGxhY2Vob2xkZXI9XFxcInt7dHlwZWFoZWFkLnBsYWNlaG9sZGVyfX1cXFwiIHR5cGVhaGVhZD1cXFwib2JqZWN0IGFzIHR5cGVhaGVhZC50cmFuc2Zvcm0ob2JqZWN0KSBmb3Igb2JqZWN0IGluIHR5cGVhaGVhZC5nZXRJdGVtcygkdmlld1ZhbHVlKVxcXCJcXHJcXG5cXHRcXHR0eXBlYWhlYWQtbG9hZGluZz1cXFwidHlwZWFoZWFkLmxvYWRpbmdcXFwiIHR5cGVhaGVhZC13YWl0LW1zPVxcXCJ0eXBlYWhlYWQubG9hZERlbGF5XFxcIiAvPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwLWFkZG9uXFxcIiBuZy1pZj1cXFwidHlwZWFoZWFkLnNob3dTZWFyY2hcXFwiPlxcclxcblxcdFxcdDxybC1idXN5IGxvYWRpbmc9XFxcInR5cGVhaGVhZC5sb2FkaW5nXFxcIj48L3JsLWJ1c3k+XFxyXFxuXFx0XFx0PHNwYW4gbmctaGlkZT1cXFwidHlwZWFoZWFkLmxvYWRpbmdcXFwiPlxcclxcblxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1zZWFyY2hcXFwiIG5nLWhpZGU9XFxcInR5cGVhaGVhZC5oYXNTZWxlY3Rpb25cXFwiPjwvaT5cXHJcXG5cXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtY2hlY2tcXFwiIG5nLXNob3c9XFxcInR5cGVhaGVhZC5oYXNTZWxlY3Rpb25cXFwiPjwvaT5cXHJcXG5cXHRcXHQ8L3NwYW4+XFxyXFxuXFx0PC9kaXY+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYnRuXFxcIiBuZy1pZj1cXFwidHlwZWFoZWFkLnVzZUFwcGx5XFxcIj5cXHJcXG5cXHRcXHQ8cmwtYnV0dG9uLWFzeW5jIHR5cGU9XFxcImRlZmF1bHRcXFwiIGFjdGlvbj1cXFwidHlwZWFoZWFkLmFwcGx5SXRlbSgpXFxcIiByaWdodC1hbGlnbmVkPVxcXCJ0cnVlXFxcIiBuZy1kaXNhYmxlZD1cXFwiIXR5cGVhaGVhZC5oYXNTZWxlY3Rpb25cXFwiPlxcclxcblxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1wbHVzIG5ld1xcXCI+PC9pPlxcclxcblxcdFxcdDwvcmwtYnV0dG9uLWFzeW5jPlxcclxcblxcdDwvZGl2PlxcclxcbjwvZGl2PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3R5cGVhaGVhZC90eXBlYWhlYWQuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDExOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLmNvbXBvbmVudHMudXNlclJhdGluZyc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFVzZXJSYXRpbmcnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1VzZXJSYXRpbmdDb250cm9sbGVyJztcclxudmFyIFVzZXJSYXRpbmdDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFVzZXJSYXRpbmdDb250cm9sbGVyKCRzY29wZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy5zdGFycyA9IFtdO1xyXG4gICAgICAgIHZhciByYW5nZVNpemUgPSB0aGlzLiRzY29wZS5yYW5nZSAhPSBudWxsID8gdGhpcy4kc2NvcGUucmFuZ2UgOiA1O1xyXG4gICAgICAgIC8vIGNzcyBzdHlsZSByZXF1aXJlcyB0aGUgc3RhcnMgdG8gc2hvdyByaWdodCB0byBsZWZ0LiBSZXZlcnNlIHRoZSBsaXN0IHNvIHRoZSBoaWdoZXN0IHZhbHVlIGlzIGZpcnN0XHJcbiAgICAgICAgdmFyIHJhbmdlID0gXy5yYW5nZSgxLCByYW5nZVNpemUgKyAxKS5yZXZlcnNlKCk7XHJcbiAgICAgICAgXy5lYWNoKHJhbmdlLCBmdW5jdGlvbiAocmF0aW5nKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YXJzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJhdGluZyxcclxuICAgICAgICAgICAgICAgIGZpbGxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciB1bmJpbmQgPSB0aGlzLiRzY29wZS4kd2F0Y2goJ25nTW9kZWwnLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlU3RhclZpZXcoX3RoaXMuJHNjb3BlLm5nTW9kZWwuJHZpZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIHVuYmluZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgVXNlclJhdGluZ0NvbnRyb2xsZXIucHJvdG90eXBlLnNldFJhdGluZyA9IGZ1bmN0aW9uIChyYXRpbmcpIHtcclxuICAgICAgICB0aGlzLiRzY29wZS5uZ01vZGVsLiRzZXRWaWV3VmFsdWUocmF0aW5nKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXJWaWV3KHJhdGluZyk7XHJcbiAgICB9O1xyXG4gICAgVXNlclJhdGluZ0NvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZVN0YXJWaWV3ID0gZnVuY3Rpb24gKHJhdGluZykge1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLnN0YXJzLCBmdW5jdGlvbiAoc3Rhcikge1xyXG4gICAgICAgICAgICBpZiAoc3Rhci52YWx1ZSA8PSByYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHN0YXIuZmlsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXIuZmlsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBVc2VyUmF0aW5nQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnXTtcclxuICAgIHJldHVybiBVc2VyUmF0aW5nQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5Vc2VyUmF0aW5nQ29udHJvbGxlciA9IFVzZXJSYXRpbmdDb250cm9sbGVyO1xyXG5mdW5jdGlvbiB1c2VyUmF0aW5nKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8c3BhbiBjbGFzcz1cXFwicmF0aW5nXFxcIj5cXG5cXHRcXHRcXHRcXHQ8c3BhbiBjbGFzcz1cXFwic3RhclxcXCIgbmctcmVwZWF0PVxcXCJzdGFyIGluIHVzZXJSYXRpbmcuc3RhcnNcXFwiIG5nLWNsYXNzPVxcXCJ7ICdmaWxsZWQnOiBzdGFyLmZpbGxlZCB9XFxcIiBuZy1jbGljaz1cXFwidXNlclJhdGluZy5zZXRSYXRpbmcoc3Rhci52YWx1ZSlcXFwiPjwvc3Bhbj5cXG5cXHRcXHRcXHQ8L3NwYW4+XFxuXFx0XFx0XCIsXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICd1c2VyUmF0aW5nJyxcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICByYW5nZTogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbmdNb2RlbCkge1xyXG4gICAgICAgICAgICBzY29wZS5uZ01vZGVsID0gbmdNb2RlbDtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnVzZXJSYXRpbmcgPSB1c2VyUmF0aW5nO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIHVzZXJSYXRpbmcpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBVc2VyUmF0aW5nQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZXJSYXRpbmcuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3VzZXJSYXRpbmcvdXNlclJhdGluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIGF1dG9zYXZlRGlhbG9nID0gcmVxdWlyZSgnLi9hdXRvc2F2ZURpYWxvZy9hdXRvc2F2ZURpYWxvZy5tb2R1bGUnKTtcclxuZXhwb3J0cy5hdXRvc2F2ZURpYWxvZyA9IGF1dG9zYXZlRGlhbG9nO1xyXG52YXIgYnJlYWtwb2ludHMgPSByZXF1aXJlKCcuL2JyZWFrcG9pbnRzL2JyZWFrcG9pbnRzLm1vZHVsZScpO1xyXG5leHBvcnRzLmJyZWFrcG9pbnRzID0gYnJlYWtwb2ludHM7XHJcbnZhciBjb250ZW50UHJvdmlkZXIgPSByZXF1aXJlKCcuL2NvbnRlbnRQcm92aWRlci9jb250ZW50UHJvdmlkZXIuc2VydmljZScpO1xyXG5leHBvcnRzLmNvbnRlbnRQcm92aWRlciA9IGNvbnRlbnRQcm92aWRlcjtcclxudmFyIGRpYWxvZyA9IHJlcXVpcmUoJy4vZGlhbG9nL2RpYWxvZy5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuZGlhbG9nID0gZGlhbG9nO1xyXG52YXIganF1ZXJ5ID0gcmVxdWlyZSgnLi9qcXVlcnkvanF1ZXJ5LnNlcnZpY2UnKTtcclxuZXhwb3J0cy5qcXVlcnkgPSBqcXVlcnk7XHJcbnZhciB3aW5kb3dXcmFwcGVyID0gcmVxdWlyZSgnLi93aW5kb3dXcmFwcGVyL3dpbmRvd1dyYXBwZXIuc2VydmljZScpO1xyXG5leHBvcnRzLndpbmRvd1dyYXBwZXIgPSB3aW5kb3dXcmFwcGVyO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuc2VydmljZXMnO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIGF1dG9zYXZlRGlhbG9nLm1vZHVsZU5hbWUsXHJcbiAgICBicmVha3BvaW50cy5tb2R1bGVOYW1lLFxyXG4gICAgY29udGVudFByb3ZpZGVyLm1vZHVsZU5hbWUsXHJcbiAgICBkaWFsb2cubW9kdWxlTmFtZSxcclxuICAgIGpxdWVyeS5tb2R1bGVOYW1lLFxyXG4gICAgd2luZG93V3JhcHBlci5tb2R1bGVOYW1lLFxyXG5dKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZXMubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvc2VydmljZXMubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fcHJvbWlzZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wcm9taXNlO1xyXG52YXIgYXV0b3NhdmVEaWFsb2dfc2VydmljZV8xID0gcmVxdWlyZSgnLi9hdXRvc2F2ZURpYWxvZy5zZXJ2aWNlJyk7XHJcbnZhciBhdXRvc2F2ZURpYWxvZ19jb250cm9sbGVyXzEgPSByZXF1aXJlKCcuL2F1dG9zYXZlRGlhbG9nLmNvbnRyb2xsZXInKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9hdXRvc2F2ZURpYWxvZy5zZXJ2aWNlJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2F1dG9zYXZlRGlhbG9nLmNvbnRyb2xsZXInKSk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5zZXJ2aWNlcy5hdXRvc2F2ZURpYWxvZyc7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fcHJvbWlzZS5tb2R1bGVOYW1lXSlcclxuICAgIC5zZXJ2aWNlKGF1dG9zYXZlRGlhbG9nX3NlcnZpY2VfMS5zZXJ2aWNlTmFtZSwgYXV0b3NhdmVEaWFsb2dfc2VydmljZV8xLkF1dG9zYXZlRGlhbG9nU2VydmljZSlcclxuICAgIC5jb250cm9sbGVyKGF1dG9zYXZlRGlhbG9nX2NvbnRyb2xsZXJfMS5jb250cm9sbGVyTmFtZSwgYXV0b3NhdmVEaWFsb2dfY29udHJvbGxlcl8xLkF1dG9zYXZlRGlhbG9nQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG9zYXZlRGlhbG9nLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2F1dG9zYXZlRGlhbG9nL2F1dG9zYXZlRGlhbG9nLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgZGlhbG9nX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL2RpYWxvZy9kaWFsb2cuc2VydmljZScpO1xyXG52YXIgYXV0b3NhdmVEaWFsb2dfY29udHJvbGxlcl8xID0gcmVxdWlyZSgnLi9hdXRvc2F2ZURpYWxvZy5jb250cm9sbGVyJyk7XHJcbmV4cG9ydHMuc2VydmljZU5hbWUgPSAnYXV0b3NhdmVEaWFsb2cnO1xyXG52YXIgX19hdXRvc2F2ZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5hdXRvc2F2ZTtcclxudmFyIF9fcHJvbWlzZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wcm9taXNlO1xyXG52YXIgQXV0b3NhdmVEaWFsb2dTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF1dG9zYXZlRGlhbG9nU2VydmljZSgkcm9vdFNjb3BlLCBkaWFsb2csIGF1dG9zYXZlRmFjdG9yeSwgcHJvbWlzZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kcm9vdFNjb3BlID0gJHJvb3RTY29wZTtcclxuICAgICAgICB0aGlzLmRpYWxvZyA9IGRpYWxvZztcclxuICAgICAgICB0aGlzLmF1dG9zYXZlRmFjdG9yeSA9IGF1dG9zYXZlRmFjdG9yeTtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xyXG4gICAgICAgIHRoaXMuYXV0b3NhdmVDbG9zZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXhwbGljaXQpIHtcclxuICAgICAgICAgICAgaWYgKGV4cGxpY2l0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXV0b3NhdmUuYXV0b3NhdmUoX3RoaXMuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNldEZvcm0gPSBmdW5jdGlvbiAoZm9ybSkge1xyXG4gICAgICAgICAgICBfdGhpcy5hdXRvc2F2ZS5jb250ZW50Rm9ybSA9IGZvcm07XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIEF1dG9zYXZlRGlhbG9nU2VydmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnByb21pc2UucmVzb2x2ZVByb21pc2VzKG9wdGlvbnMucmVzb2x2ZSkudGhlbihmdW5jdGlvbiAocmVzb2x2ZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHNjb3BlID0gb3B0aW9ucy5zY29wZTtcclxuICAgICAgICAgICAgaWYgKHNjb3BlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlID0gX3RoaXMuJHJvb3RTY29wZS4kbmV3KCk7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNjb3BlID0gc2NvcGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5hdXRvc2F2ZSA9IF90aGlzLmF1dG9zYXZlRmFjdG9yeS5nZXRJbnN0YW5jZSh7XHJcbiAgICAgICAgICAgICAgICBzYXZlOiBvcHRpb25zLnNhdmUsXHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZTogb3B0aW9ucy52YWxpZGF0ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNjb3BlLmZvcm0gPSBvcHRpb25zLmZvcm07XHJcbiAgICAgICAgICAgIHNjb3BlLmZvcm1HZXR0ZXIgPSBvcHRpb25zLmZvcm1HZXR0ZXI7XHJcbiAgICAgICAgICAgIHNjb3BlLnNldEZvcm0gPSBfdGhpcy5zZXRGb3JtO1xyXG4gICAgICAgICAgICBfdGhpcy5kYXRhID0gXy5leHRlbmQob3B0aW9ucy5kYXRhLCByZXNvbHZlRGF0YSk7XHJcbiAgICAgICAgICAgIHNjb3BlLmRpYWxvZyA9IF90aGlzLmRhdGE7XHJcbiAgICAgICAgICAgIHZhciBkaWFsb2dPcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICAgICAgZGlhbG9nT3B0aW9ucy5jb250cm9sbGVyID0gYXV0b3NhdmVEaWFsb2dfY29udHJvbGxlcl8xLmNvbnRyb2xsZXJOYW1lO1xyXG4gICAgICAgICAgICBkaWFsb2dPcHRpb25zLmNvbnRyb2xsZXJBcyA9ICdjb250cm9sbGVyJztcclxuICAgICAgICAgICAgX3RoaXMuZGlhbG9nLm9wZW4ob3B0aW9ucywgX3RoaXMuYXV0b3NhdmVDbG9zZUhhbmRsZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEF1dG9zYXZlRGlhbG9nU2VydmljZS4kaW5qZWN0ID0gWyckcm9vdFNjb3BlJywgZGlhbG9nX3NlcnZpY2VfMS5zZXJ2aWNlTmFtZSwgX19hdXRvc2F2ZS5mYWN0b3J5TmFtZSwgX19wcm9taXNlLnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBBdXRvc2F2ZURpYWxvZ1NlcnZpY2U7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXV0b3NhdmVEaWFsb2dTZXJ2aWNlID0gQXV0b3NhdmVEaWFsb2dTZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvc2F2ZURpYWxvZy5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvYXV0b3NhdmVEaWFsb2cvYXV0b3NhdmVEaWFsb2cuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgbmcgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBiYXNlRGlhbG9nID0gcmVxdWlyZSgnLi9iYXNlRGlhbG9nL2Jhc2VEaWFsb2cubW9kdWxlJyk7XHJcbmV4cG9ydHMuYmFzZURpYWxvZyA9IGJhc2VEaWFsb2c7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5zZXJ2aWNlcy5kaWFsb2cnO1xyXG5leHBvcnRzLnNlcnZpY2VOYW1lID0gJ2RpYWxvZyc7XHJcbnZhciBEaWFsb2dTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERpYWxvZ1NlcnZpY2UoZGlhbG9nKSB7XHJcbiAgICAgICAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XHJcbiAgICB9XHJcbiAgICBEaWFsb2dTZXJ2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNsb3NlSGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpYWxvZy5vcGVuKG9wdGlvbnMsIGNsb3NlSGFuZGxlcik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERpYWxvZ1NlcnZpY2U7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRGlhbG9nU2VydmljZSA9IERpYWxvZ1NlcnZpY2U7XHJcbmZ1bmN0aW9uIGRpYWxvZ1NlcnZpY2VQcm92aWRlcigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICB2YXIgcHJvdmlkZXIgPSB7XHJcbiAgICAgICAgc2V0SW1wbGVtZW50YXRpb246IGZ1bmN0aW9uIChkaWFsb2dJbXBsZW1lbnRhdGlvbikge1xyXG4gICAgICAgICAgICBfdGhpcy5kaWFsb2dJbXBsZW1lbnRhdGlvbiA9IGRpYWxvZ0ltcGxlbWVudGF0aW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJGdldDogZnVuY3Rpb24gKGJhc2VEaWFsb2cpIHtcclxuICAgICAgICAgICAgdmFyIGRpYWxvZ0ltcGxlbWVudGF0aW9uID0gX3RoaXMuZGlhbG9nSW1wbGVtZW50YXRpb24gIT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgPyBfdGhpcy5kaWFsb2dJbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICAgICAgOiBiYXNlRGlhbG9nO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpYWxvZ1NlcnZpY2UoZGlhbG9nSW1wbGVtZW50YXRpb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgcHJvdmlkZXIuJGdldC4kaW5qZWN0ID0gW2Jhc2VEaWFsb2cuc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIHByb3ZpZGVyO1xyXG59XHJcbmV4cG9ydHMuZGlhbG9nU2VydmljZVByb3ZpZGVyID0gZGlhbG9nU2VydmljZVByb3ZpZGVyO1xyXG5uZy5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbYmFzZURpYWxvZy5tb2R1bGVOYW1lXSlcclxuICAgIC5wcm92aWRlcihleHBvcnRzLnNlcnZpY2VOYW1lLCBkaWFsb2dTZXJ2aWNlUHJvdmlkZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaWFsb2cuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2RpYWxvZy9kaWFsb2cuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3Byb21pc2UgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucHJvbWlzZTtcclxudmFyIGJhc2VEaWFsb2dfY29udHJvbGxlcl8xID0gcmVxdWlyZSgnLi9iYXNlRGlhbG9nLmNvbnRyb2xsZXInKTtcclxudmFyIGJhc2VEaWFsb2dfc2VydmljZV8xID0gcmVxdWlyZSgnLi9iYXNlRGlhbG9nLnNlcnZpY2UnKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9iYXNlRGlhbG9nLmNvbnRyb2xsZXInKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vYmFzZURpYWxvZy5zZXJ2aWNlJykpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuc2VydmljZXMuZGlhbG9nLmJhc2VEaWFsb2cnO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX3Byb21pc2UubW9kdWxlTmFtZV0pXHJcbiAgICAuY29udHJvbGxlcihiYXNlRGlhbG9nX2NvbnRyb2xsZXJfMS5jb250cm9sbGVyTmFtZSwgYmFzZURpYWxvZ19jb250cm9sbGVyXzEuQmFzZURpYWxvZ0NvbnRyb2xsZXIpXHJcbiAgICAuc2VydmljZShiYXNlRGlhbG9nX3NlcnZpY2VfMS5zZXJ2aWNlTmFtZSwgYmFzZURpYWxvZ19zZXJ2aWNlXzEuQmFzZURpYWxvZ1NlcnZpY2UpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlRGlhbG9nLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2RpYWxvZy9iYXNlRGlhbG9nL2Jhc2VEaWFsb2cubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBiYXNlRGlhbG9nX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vYmFzZURpYWxvZy5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnQmFzZURpYWxvZ0NvbnRyb2xsZXInO1xyXG52YXIgQmFzZURpYWxvZ0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmFzZURpYWxvZ0NvbnRyb2xsZXIoJHNjb3BlLCAkY29udHJvbGxlciwgYmFzZURpYWxvZykge1xyXG4gICAgICAgIHZhciBjb250cm9sbGVyO1xyXG4gICAgICAgIGlmICgkc2NvcGUubW9kYWxDb250cm9sbGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIGxvY2FscyA9ICRzY29wZS5yZXNvbHZlRGF0YSB8fCB7fTtcclxuICAgICAgICAgICAgJHNjb3BlLnJlc29sdmVEYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgbG9jYWxzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICAgICAgY29udHJvbGxlciA9ICRjb250cm9sbGVyKCRzY29wZS5tb2RhbENvbnRyb2xsZXIsIGxvY2Fscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICRzY29wZS4kb24oJ21vZGFsLmNsb3NpbmcnLCBiYXNlRGlhbG9nLm1vZGFsQ2xvc2luZyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XHJcbiAgICB9XHJcbiAgICBCYXNlRGlhbG9nQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCAnJGNvbnRyb2xsZXInLCBiYXNlRGlhbG9nX3NlcnZpY2VfMS5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gQmFzZURpYWxvZ0NvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQmFzZURpYWxvZ0NvbnRyb2xsZXIgPSBCYXNlRGlhbG9nQ29udHJvbGxlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZURpYWxvZy5jb250cm9sbGVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvZGlhbG9nL2Jhc2VEaWFsb2cvYmFzZURpYWxvZy5jb250cm9sbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3Byb21pc2UgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucHJvbWlzZTtcclxudmFyIGJhc2VEaWFsb2dfY29udHJvbGxlcl8xID0gcmVxdWlyZSgnLi9iYXNlRGlhbG9nLmNvbnRyb2xsZXInKTtcclxuZXhwb3J0cy5zZXJ2aWNlTmFtZSA9ICdiYXNlRGlhbG9nJztcclxudmFyIEJhc2VEaWFsb2dTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJhc2VEaWFsb2dTZXJ2aWNlKCRtb2RhbCwgJHJvb3RTY29wZSwgcHJvbWlzZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kbW9kYWwgPSAkbW9kYWw7XHJcbiAgICAgICAgdGhpcy4kcm9vdFNjb3BlID0gJHJvb3RTY29wZTtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xyXG4gICAgICAgIHRoaXMubW9kYWxDbG9zaW5nID0gZnVuY3Rpb24gKGV2ZW50LCByZWFzb24sIGV4cGxpY2l0bHlDbG9zZWQpIHtcclxuICAgICAgICAgICAgdmFyIGNhbkNsb3NlID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihfdGhpcy5jbG9zZUhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBjYW5DbG9zZSA9IF90aGlzLmNsb3NlSGFuZGxlcihleHBsaWNpdGx5Q2xvc2VkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNhbkNsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIEJhc2VEaWFsb2dTZXJ2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNsb3NlSGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkaWFsb2dJbnN0YW5jZSA9IHtcclxuICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHsgfSxcclxuICAgICAgICAgICAgZGlzbWlzczogZnVuY3Rpb24gKCkgeyB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wcm9taXNlLnJlc29sdmVQcm9taXNlcyhvcHRpb25zLnJlc29sdmUpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2xvc2VIYW5kbGVyID0gY2xvc2VIYW5kbGVyO1xyXG4gICAgICAgICAgICBvcHRpb25zID0gX3RoaXMuY29uZmlndXJlTW9kYWxTZXR0aW5ncyhvcHRpb25zLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgdmFyIG1vZGFsSW5zdGFuY2UgPSBfdGhpcy4kbW9kYWwub3BlbihvcHRpb25zKTtcclxuICAgICAgICAgICAgZGlhbG9nSW5zdGFuY2UuY2xvc2UgPSBtb2RhbEluc3RhbmNlLmNsb3NlO1xyXG4gICAgICAgICAgICBkaWFsb2dJbnN0YW5jZS5kaXNtaXNzID0gbW9kYWxJbnN0YW5jZS5kaXNtaXNzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkaWFsb2dJbnN0YW5jZTtcclxuICAgIH07XHJcbiAgICBCYXNlRGlhbG9nU2VydmljZS5wcm90b3R5cGUuY29uZmlndXJlTW9kYWxTZXR0aW5ncyA9IGZ1bmN0aW9uIChvcHRpb25zLCByZXNvbHZlRGF0YSkge1xyXG4gICAgICAgIHZhciBtb2RhbFNjb3BlID0gb3B0aW9ucy5zY29wZTtcclxuICAgICAgICBpZiAobW9kYWxTY29wZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1vZGFsU2NvcGUgPSB0aGlzLiRyb290U2NvcGUuJG5ldygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5yZXNvbHZlVG9EaWFsb2cpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlhbG9nQXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbW9kYWxTY29wZVtvcHRpb25zLmRpYWxvZ0FzXSA9IHJlc29sdmVEYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW9kYWxTY29wZSA9IF8uZXh0ZW5kKG1vZGFsU2NvcGUsIHJlc29sdmVEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbW9kYWxTY29wZS5yZXNvbHZlRGF0YSA9IHJlc29sdmVEYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtb2RhbFNjb3BlLm1vZGFsQ29udHJvbGxlciA9IG9wdGlvbnMuY29udHJvbGxlcjtcclxuICAgICAgICBvcHRpb25zLnJlc29sdmUgPSBudWxsO1xyXG4gICAgICAgIG9wdGlvbnMuY29udHJvbGxlciA9IGJhc2VEaWFsb2dfY29udHJvbGxlcl8xLmNvbnRyb2xsZXJOYW1lO1xyXG4gICAgICAgIG9wdGlvbnMuc2NvcGUgPSBtb2RhbFNjb3BlO1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfTtcclxuICAgIEJhc2VEaWFsb2dTZXJ2aWNlLiRpbmplY3QgPSBbJyRtb2RhbCcsICckcm9vdFNjb3BlJywgX19wcm9taXNlLnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBCYXNlRGlhbG9nU2VydmljZTtcclxufSkoKTtcclxuZXhwb3J0cy5CYXNlRGlhbG9nU2VydmljZSA9IEJhc2VEaWFsb2dTZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlRGlhbG9nLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy9kaWFsb2cvYmFzZURpYWxvZy9iYXNlRGlhbG9nLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdBdXRvc2F2ZURpYWxvZ0NvbnRyb2xsZXInO1xyXG52YXIgQXV0b3NhdmVEaWFsb2dDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF1dG9zYXZlRGlhbG9nQ29udHJvbGxlcigkc2NvcGUpIHtcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICBpZiAoJHNjb3BlLmZvcm0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgdW5iaW5kID0gJHNjb3BlLiR3YXRjaCgkc2NvcGUuZm9ybSwgZnVuY3Rpb24gKGZvcm0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb3JtICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2V0Rm9ybShmb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICB1bmJpbmQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCRzY29wZS5mb3JtR2V0dGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIHVuYmluZCA9ICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gJHNjb3BlLmZvcm1HZXR0ZXIoJHNjb3BlKTsgfSwgZnVuY3Rpb24gKGZvcm0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb3JtICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2V0Rm9ybShmb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICB1bmJpbmQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgQXV0b3NhdmVEaWFsb2dDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZSddO1xyXG4gICAgcmV0dXJuIEF1dG9zYXZlRGlhbG9nQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5BdXRvc2F2ZURpYWxvZ0NvbnRyb2xsZXIgPSBBdXRvc2F2ZURpYWxvZ0NvbnRyb2xsZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG9zYXZlRGlhbG9nLmNvbnRyb2xsZXIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy9hdXRvc2F2ZURpYWxvZy9hdXRvc2F2ZURpYWxvZy5jb250cm9sbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vdHlwaW5ncy9qcXVlcnkvanF1ZXJ5LmQudHNcIiAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBuZyA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JzZXJ2YWJsZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYnNlcnZhYmxlO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudXRpbGl0aWVzLnNlcnZpY2VzLmNvbnRlbnRQcm92aWRlcic7XHJcbmV4cG9ydHMuc2VydmljZU5hbWUgPSAnY29udGVudFByb3ZpZGVyRmFjdG9yeSc7XHJcbnZhciBDb250ZW50UHJvdmlkZXJTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbnRlbnRQcm92aWRlclNlcnZpY2Uob2JzZXJ2YWJsZUZhY3RvcnkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc2V0VHJhbnNjbHVkZUNvbnRlbnQgPSBmdW5jdGlvbiAodHJhbnNjbHVkZUZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24odHJhbnNjbHVkZUZ1bmN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNjbHVkZUZ1bmN0aW9uKGZ1bmN0aW9uIChjbG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldENvbnRlbnQoY2xvbmUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRDb250ZW50KG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgfVxyXG4gICAgQ29udGVudFByb3ZpZGVyU2VydmljZS5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcclxuICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZSgnY29udGVudENoYW5nZWQnKTtcclxuICAgIH07XHJcbiAgICBDb250ZW50UHJvdmlkZXJTZXJ2aWNlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChhY3Rpb24sIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5jb250ZW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgYWN0aW9uKHRoaXMuZ2V0Q29udGVudChzZWxlY3RvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZhYmxlLnJlZ2lzdGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgYWN0aW9uKF90aGlzLmdldENvbnRlbnQoc2VsZWN0b3IpKTtcclxuICAgICAgICB9LCAnY29udGVudENoYW5nZWQnKTtcclxuICAgIH07XHJcbiAgICBDb250ZW50UHJvdmlkZXJTZXJ2aWNlLnByb3RvdHlwZS5nZXRDb250ZW50ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgaWYgKHNlbGVjdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoc2VsZWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb250ZW50UHJvdmlkZXJTZXJ2aWNlO1xyXG59KSgpO1xyXG5jb250ZW50UHJvdmlkZXJTZXJ2aWNlRmFjdG9yeS4kaW5qZWN0ID0gW19fb2JzZXJ2YWJsZS5mYWN0b3J5TmFtZV07XHJcbmZ1bmN0aW9uIGNvbnRlbnRQcm92aWRlclNlcnZpY2VGYWN0b3J5KG9ic2VydmFibGVGYWN0b3J5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29udGVudFByb3ZpZGVyU2VydmljZShvYnNlcnZhYmxlRmFjdG9yeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5uZy5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19vYnNlcnZhYmxlLm1vZHVsZU5hbWVdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5zZXJ2aWNlTmFtZSwgY29udGVudFByb3ZpZGVyU2VydmljZUZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZW50UHJvdmlkZXIuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2NvbnRlbnRQcm92aWRlci9jb250ZW50UHJvdmlkZXIuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==